import type { IGeometry, GeometryType, IAttachmentInfo, IExtent } from '@esri/arcgis-rest-feature-service'
import type { IItem } from '@esri/arcgis-rest-portal'

import { type DataSourceManager, type IMDataSourceJson, type IMDataSourceSchema, type IMReversedDataSourceSchema, type IntlShape, type IMDataSourceInfo, type ServiceDefinition, type ImmutableObject, type ImmutableArray, type SqlExpression, type IMDataViewJson } from 'jimu-core'

/**
 * All data source status is here, including data source instance status and data status (for QueriableDataSource).
 * * Instance status includes: NotCreated, Created, CreateError. <br/>
 *    When a data source is requested to be created, it is set to `NotCreated` at first.
 *    If a data source has never been used, there is no data source status.
 * * Data status includes: NotReady, Unloaded, Loading, Loaded, LoadError. <br/>
 *    When a QueriableDataSource is created, it is set as `NotReady` or `Unloaded` at first.
 *    If the data source is generated by widgets, the initial status will be `NotReady`, otherwise the initial status will be `Unloaded`.
 *    When widgets are ready to generate data, that is to say, the data source is ready to do query, widgets will change the status from `NotReady` to `Unloaded`.
 *    When widgets are not ready to generate data, widgets will change the status back to `NotReady`,
 *    then framework will help to clear source records, records and cache in data source instance.
 *    If `load()` is invoked, it will be set as `Loading`. If data is returned, it will be set as `Loaded`.
 *    If an error occurs, it will be set as `LoadError`.
 */
export enum DataSourceStatus {
  // Instance status.
  NotCreated = 'NOT_CREATED',
  Created = 'CREATED',
  CreateError = 'CREATE_ERROR',

  // Data status.
  /**
   * NotReady is for widget output data source only.
   * When output data source instance is created, the data is not ready for use.
   * Widget should dispatch an action (DataSourceStatusChanged) to make the data source ready for use.
   * If a data source status is not ready, the query should return an empty result.
   */
  NotReady = 'NOT_READY',
  Unloaded = 'UNLOADED',
  Loading = 'LOADING',
  Loaded = 'LOADED',
  LoadError = 'LOAD_ERROR',

  // Save status.
  /** @ignore */
  Saving = 'SAVING',
  /** @ignore */
  Saved = 'SAVED',
  /** @ignore */
  SaveError = 'SAVE_ERROR',

  // For remote push(stream) data sources.
  /** @ignore */
  Closed = 'CLOSED',
  /** @ignore */
  Connecting = 'CONNECTING',
  /** @ignore */
  Connected = 'CONNECTED',
  /** @ignore */
  Closing = 'CLOSING',

  // For client DS, we don't define status.
}

/**
 * The data source types that `jimu-core` supports.
 */
export enum DataSourceTypes {
  Error = 'ERROR',
  /** @ignore */
  SimpleLocal = 'SIMPLE_LOCAL',
  /**
   * CSV data source is from a CSV file (.csv, .txt).
   * @ignore
   */
  CSV = 'CSV',

  /**
   * FeatureLayer data source is a `QueriableDataSource`, which is used to query ArcGIS feature service.
   * See {@link FeatureLayerDataSource}
   */
  FeatureLayer = 'FEATURE_LAYER',
  /**
   * See {@link SceneLayerDataSource}
   */
  SceneLayer = 'SCENE_LAYER',
  /**
   * SubtypeGroupLayer data source is a `QueriableDataSource`, which is used to query ArcGIS feature service.
   * It is a data source set that may have child data sources. The child data sources are SubtypeSubLayer data sources.
   */
  SubtypeGroupLayer = 'SUBTYPE_GROUP_LAYER',
  /**
   * SubtypeSublayer data source is a `QueriableDataSource`, which is used to query ArcGIS feature service.
   */
  SubtypeSublayer = 'SUBTYPE_SUBLAYER',
  /**
   * GroupLayer data source is a data source set that may have child data sources. It is from group layer in a map service or a webmap/webscene.
   */
  GroupLayer = 'GROUP_LAYER',
  /**
   * FeatureService data source is a data source set that may have child data sources. It is from the feature service.
   */
  FeatureService = 'FEATURE_SERVICE',
  /**
   * MapService data source is a data source set that may have child data sources. It is from the map service.
   */
  MapService = 'MAP_SERVICE',
  /**
   * SceneService data source is a data source set that may have child data sources. It is from the scene service.
   */
  SceneService = 'SCENE_SERVICE',
  /**
   * VectorTileService data source is from the vector tile service.
   * @ignore
   */
  VectorTileService = 'VECTOR_TILE_SERVICE',
  /**
   * GeoJSONLayer data source is from a [GeoJSON](https://geojson.org/) file.
   * @ignore
   */
  GeoJSON = 'GEO_JSON',
  /**
   * KMLLayer data source is from a KML file (.kml, .kmz).
   * @ignore
   */
  KML = 'KML',
  /**
   * WFSLayer data source is from an OGC Web Feature Service (WFS).
   * @ignore
   */
  WFS = 'WFS',
  /**
   * WMSLayer data source is from an OGC Web Map Services (WMS).
   * @ignore
   */
  WMS = 'WMS',
  /**
   * @ignore
   * WMTSLayer data source is from an OGC Web Map Tile Services (WMTS).
   */
  WMTS = 'WMTS',
  BuildingSceneLayer = 'building-scene',
  BuildingGroupSubLayer = 'building-group',
  BuildingComponentSubLayer = 'building-component',
  /**
   * OrientedImageryLayer is a child of Feature Service.
   */
  OrientedImageryLayer = 'ORIENTED_IMAGERY_LAYER',
  /**
   * ImageServer includes three types: ImageryLayer (dynamic), ImageryTileLayer, ElevationLayer.
   */
  ImageryLayer = 'IMAGERY_LAYER',
  ImageryTileLayer = 'IMAGERY_TILE_LAYER',
  ElevationLayer = 'ELEVATION_LAYER'
}

/**
 * @ignore
 */
export enum ArcGISDataSourceTypes {
  Map = 'MAP',
  WebMap = 'WEB_MAP',
  WebScene = 'WEB_SCENE',
}

/**
 * @ignore
 * All data source types, including types from jimu-core and jimu-arcgis.
 * The variable is only used as `value`, e.g. const types = [AllDataSourceTypes.WebMap].
 */
export const AllDataSourceTypes = { ...DataSourceTypes, ...ArcGISDataSourceTypes }

/**
* All data source types, including types from jimu-core and jimu-arcgis.
* The variable is only used as `type`, e.g. let types: AllDataSourceTypes[].
*/
// eslint-disable-next-line
 export type AllDataSourceTypes = DataSourceTypes | ArcGISDataSourceTypes

/**
 * For now, we only support some layer service types.
 * This type is used by adding the data source by URL.
 */
export enum SupportedLayerServiceTypes {
  // single layer service under map service or feature service
  FeatureLayer = 'Feature Layer',
  Table = 'Table',
  GroupLayer = 'Group Layer',
  OrientedImageryLayer = 'Oriented Imagery Layer', //FeatureServer/GroupLayer/OrientedImageryLayer

  // single layer service under scene service
  SceneLayerPoint = 'Point',
  SceneLayer3DObject = '3DObject',

  BuildingSceneLayer = 'Building',
  BuildingGroupSubLayer = 'building-group',
  BuildingComponentSubLayer = 'building-component'
}

/**
 * For now, we only support some service types.
 * This type is used by adding data source by URL.
 */
export enum SupportedServerTypes {
  // [Feature Service](https://developers.arcgis.com/rest/services-reference/feature-service.htm)
  FeatureService = 'FeatureServer',
  // [Map Service](https://developers.arcgis.com/rest/services-reference/hosted-map-service.htm)
  MapService = 'MapServer',
  // [Scene Service](https://developers.arcgis.com/rest/services-reference/scene-service.htm)
  SceneService = 'SceneServer',
  // [Image Service](https://developers.arcgis.com/rest/services-reference/image-service.htm)
  ImageService = 'ImageServer', // from rest service, two types: dynamic, tilled, distinct by layer.tileInfo
  // [Vector Tile Service](https://developers.arcgis.com/rest/services-reference/vector-tile-service.htm)
  VectorTileService = 'VectorTileServer'
}

/**
 * For now, we only support some portal item types.
 * This type is used by adding data source by items.
 * Please see [Items and item types](https://developers.arcgis.com/rest/users-groups-and-items/items-and-item-types.htm).
 */
export enum SupportedItemTypes {
  WebMap = 'Web Map',
  WebScene = 'Web Scene',
  FeatureService = 'Feature Service',
  MapService = 'Map Service',
  SceneService = 'Scene Service',
  ImageService = 'Image Service',
  VectorTileService = 'Vector Tile Service',
  FeatureCollection = 'Feature Collection',
  GroupLayer = 'Group Layer',
  CSV = 'CSV',
  GeoJSON = 'GeoJson',
  KML = 'KML',
  WFS = 'WFS',
  WMS = 'WMS',
  WMTS = 'WMTS',
  GeometryService = 'Geometry Service',
  GeocodingService = 'Geocoding Service',
  GeoprocessingService = 'Geoprocessing Service',
  NetworkAnalysisService = 'Network Analysis Service',
  GeoenrichmentService = 'Geoenrichment service'
}

/**
 * For now, we only support some types of ArcGIS Maps SDK for JavaScript layer.
 * This type is used by adding the data source with the ArcGIS Maps SDK for JavaScript layer.
 * Please see [Layer](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-Layer.html).
 */
export enum SupportedJSAPILayerTypes {
  FeatureLayer = 'feature',
  MapImageLayer = 'map-image',
  TileLayer = 'tile',
  GroupLayer = 'group',
  SceneLayer = 'scene',
  ImageryLayer = 'imagery',
  ImageryTileLayer = 'imagery-tile',
  ElevationLayer = 'elevation',
  OrientedImageryLayer = 'oriented-imagery',
  SubtypeGroupLayer = 'subtype-group',
  SubtypeSublayer = 'subtype-sublayer',
  VectorTileLayer = 'vector-tile',
  KMLLayer = 'kml',
  CSVLayer = 'csv',
  GeoJSONLayer = 'geojson',
  WFSLayer = 'wfs',
  WMSLayer = 'wms',
  WMTSLayer = 'wmts',
  BuildingSceneLayer = 'building-scene',
  BuildingComponentSubLayer = 'building-component',
  BuildingGroupSubLayer = 'building-group'
}

/**
 * For now, we only support some types of layers.
 * This type is used by adding a data source from item data. For example, to add data from a group layer item, to create the child data sources, we need to parse the group layer item data.
 * Please see https://developers.arcgis.com/web-map-specification/objects/operationalLayers/ and https://developers.arcgis.com/web-scene-specification/objects/operationalLayers/.
 */
export enum SupportedLayerTypesInWebMapSpec {
  FeatureLayer = 'ArcGISFeatureLayer',
  SceneLayer = 'ArcGISSceneServiceLayer',
  GroupLayer = 'GroupLayer',
  MapService = 'ArcGISMapServiceLayer',
  TiledMapService = 'ArcGISTiledMapServiceLayer',
  VectorTileService = 'VectorTileLayer',
  ImageService = 'ArcGISImageServiceLayer',
  TiledImageService = 'ArcGISTiledImageServiceLayer',
  CSV = 'CSV',
  GeoJSON = 'GeoJSON',
  KML = 'KML',
  WFS = 'WFS',
  WMS = 'WMS',
  SubtypeGroupLayer = 'SubtypeGroupLayer'
}

/**
 * Data source factory is used to create data source.
 */
export interface DataSourceFactory {
  createDataSource: (options: DataSourceConstructorOptions) => DataSource
}

/** @ignore */
export interface AttachmentInfo extends IAttachmentInfo {
  url?: string
}

/** @ignore */
export interface AttachmentQueryOptions {
  attachmentTypes: string[]
  url: string
  featureId: number | string
}

/**
 * Parameters of `DataSource`'s constructor.
 */
export interface DataSourceConstructorOptions {
  /** The data source ID. */
  id: string

  /**
   * dataSourceJson or belongToDataSource is either-or option.
   * Pass dataSourceJson will create a main data source.
   * Pass belongToDataSource will create data view or local data source.
   */
  dataSourceJson?: IMDataSourceJson

  /** Data source that the to-be-created data source belongs to. */
  belongToDataSource?: DataSource

  /**
   * If dataViewId exists, a data view will be created.
   */
  dataViewId?: string

  /**
   * if localId exists, a local data source will be created.
   */
  localId?: string

  dataSourceManager?: DataSourceManager
  parentDataSource?: DataSource
  /**
   * jimuChildId is the id to distinguish between different child data sources in a parent data source.
   * Besides jimuChildId, every child data source has a data source id, which consists of parent data source id and jimuChildId.
   */
  jimuChildId?: string
  /**
  * If all of the data is saved in the data source instance, put the data in the source records.
  * For others, the data may come from AGOL/portal item or a remote database.
  *
  * Only main data source or selection view will save source records,
  * if current data source is a view of selection view, will use selection view's source records, else,
  * will use main data source's source records.
  */
  sourceRecords?: DataRecord[]
  /**
   * Order in the parent data source.
   */
  order?: number
}

/**
 * @ignore
 */
export class DataSourceError extends Error {
  dataSourceId: string
  constructor (id, message) {
    super(`data source id: ${id}, ${message}`)
    this.dataSourceId = id
  }
}

// #region Data records

/**
 * A data record represents a record in a data source.
 */
export interface DataRecord {
  /** A reference of the data source object that has this record. */
  dataSource: DataSource

  /**
   * The data is a plain object. The format is {key: value}, and the key is "jimuFieldName".
   *
   * The data before mapping use this schema: {fieldName: value}. We need to return this schema: {jimuFieldName: value}.
   */
  getData: () => any
  setData: (data) => void
  /**
   * Create a clone of the data record object.
   * Use shallow clone by default. If `deep` is `true`, will use deep clone.
   */
  clone: (deep?: boolean) => DataRecord

  /** @ignore */
  getDataBeforeMapping: () => any
  /**
   * Return formatted record.
   */
  getFormattedData: (intl: IntlShape) => any
  /**
   * Return the value of a specific field.
   */
  getFieldValue: (jimuFieldName: string) => any
  /** @ignore */
  getDateFieldValue: (jimuFieldName: string) => any
  /**
   * Return the formatted value of a specific field.
   */
  getFormattedFieldValue: (jimuFieldName: string, intl: IntlShape) => string
  /** @ignore */
  convertBeforeMappingDataToData: (beforeMappingData: any) => any
  /**
   * Return the data in JSON format, which is used to serialize data, and the key is "jimuFieldName".
   */
  toJson: () => any
  /**
   * Return ID of the record.
   */
  getId: () => string
  /**
   * Set ID of the record.
   */
  setId: (id: string) => void
  /**
   * Return geometry of the record.
   */
  getGeometry: () => IGeometry
  /**
   * Return the original geometry of the record.
   * @ignore
   */
  getRawGeometry: () => any
  setGeometry: (geo: IGeometry) => void
}

/**
 * A DataRecordSet has a collection of data records. Similar to [FeatureSet](https://developers.arcgis.com/javascript/latest/api-reference/esri-tasks-support-FeatureSet.html)
 */
export interface DataRecordSet {
  /** The name of the DataRecordSet */
  name: string

  /** The display label of the DataRecordSet **/
  label?: string

  /** The type of the DataRecordSet. Currently, this is used in data action. */
  type?: 'selected' | 'loaded' | 'current'

  /** The data source where the data record set comes from. */
  dataSource: DataSource

  /** The records of the set */
  records: DataRecord[]

  /**
   * The fields names.
   *
   * If set, actions should use the fields instead of the fields in the schema.
   * If not set, actions should use the fields in the schema.
   * However, actions still can decide how to use this property. For example, the `view in table` action will always display all fields.
   * */
  fields?: string[]
}

// #endregion Data records

// #region Data queries

/**
 * The result of data source's query method.
 */
export interface QueryResult {
  /**
   * The query parameters that generate the result.
   */
  queryParams: IMQueryParams
  /**
   * Records of the query result.
   */
  records?: DataRecord[]
  /**
   * The jimuFieldName.
   */
  fields?: string[]
  /**
   * The number of result records.
   */
  count?: number
  /**
   * The IDs of the result records.
   */
  ids?: string[]
  /**
   * The extent of the result records.
   */
  extent?: IExtent | __esri.Extent
  /**
   * Whether the query process is aborted. `isAborted` is `undefined` or `false` means the query process is done.
   */
  isAborted?: boolean
  /**
   * Source version of data source.
   * @ignore
   */
  sourceVersion?: number
  /**
   * When exceededTransferLimit is true, it indicates there are more query results and you can continue to page through the results.
   */
  exceededTransferLimit?: boolean
}

export type QueryProgressCallback = (progress: number, result: QueryResult) => void

/**
 * Query scope defines which data is returned when the query is executed in addition to the query parameters.
 */
export enum QueryScope {
  /** Use the query parameters directly to query. */
  InAllData = 'IN_ALL_DATA',

  /** Use the query parameters and the filters configured in exb to query. */
  InRemoteConfigView = 'IN_REMOTE_CONFIG_VIEW',

  /** Use the query parameters and the configured filters in data source and filters configured in exb to query. */
  InConfigView = 'IN_CONFIG_VIEW',

  /** Use all of the applied query parameters to query. */
  InRuntimeView = 'IN_RUNTIME_VIEW'
}

/**
 * Options when calling data source's load method.
 */
export interface QueryOptions {
  scope?: QueryScope

  /** For load only.
   *  For local data source, you can use local ID as widget ID.
   */
  widgetId?: string

  /** Force the query even if  the query parameters have not changed. */
  refresh?: boolean

  /**
   * When executing query, the matched query is excluded.
   * Valid in runtime scope only.
   */
  excludeQuery?: WidgetDataSourcePair | WidgetDataSourcePair[]

  dataSourceToFormatSql?: QueriableDataSource
}

export interface GetCurrentQueryParamsOptions {
  exclude?: WidgetDataSourcePair | WidgetDataSourcePair[]
  dataSourceToFormatSql?: QueriableDataSource
}

export interface WidgetDataSourcePair {
  dataSourceId: string
  widgetId: string
}

/**
 * Select records options.
 * If provide `records`, will ignore `ids`.
 */
export interface SelectOptions {
  widgetId: string
  ids?: string[]
  records?: DataRecord[]
}

/**
 * If provide `records`, will ignore `ids` and `queryParams`.
 * If no `records` and provide `ids`, will ignore `queryParams`.
 */
export interface QueriableSelectOptions extends SelectOptions {
  queryParams?: Pick<QueryParams, null>
}

export interface UsedFieldsOptions {
  /**
   * Default value is false.
   * Exclude widgets which do not use data source to do query. Actually, data source does not need to load records for these widgets.
   */
  excludeWidgetsDoNotUseDsToQuery?: boolean
  // Default is none.
  logLevel?: 'debug' | 'none'
}

export interface QueriableUsedFieldsOptions extends UsedFieldsOptions {
  queryParams?: QueryParams
}

/** The base query parameter interface. */
export interface QueryParams {
  /**
   * Page number starts from 1, not 0.
   */
  page?: number
  /**
   * Page size.
   */
  pageSize?: number
}
export type IMQueryParams = ImmutableObject<QueryParams>

/**
 * Query parameter which supports SQL.
 */
export interface SqlQueryParams extends QueryParams {
  /**
   * A where clause for the query.
   */
  where?: string
  /**
   * @ignore
   * If the where clause is from SqlExpressionRuntime component or createSQLExpression util, the query params should contain this property.
   * The property can be used to generate new where clause based on different data views since data views' `isCaseSensitive` can be different (e.g. main data source is hosted AGOL service and its selection view).
   *
   * When merging one data view's query params and main data source's query params, will check whether their `isCaseSensitive` are the same.
   * If not, will use main data source's `sqlExpression` and the current data view to generate a new where clause, to make it matching the current data view's `isCaseSensitive` capability.
   */
  sqlExpression?: SqlExpression
  /**
   * The list of fields to be included in the returned result set.
   */
  outFields?: string[]
  /**
   * Since widgets share the loaded data when using the load method, the data source will concatenate all the fields used by the widgets as the final outField when sending the request.
   * If set to true, the data source will use the outFields provided directly. This can improve performance, but please ensure that you pass in sufficient fields to avoid errors in the widgets.
   */
  honorOutFields?: boolean
  /**
   * One or more `jimuFieldName` by which the features/records will be ordered.
   * Use ASC for ascending and DESC for descending. The following fields are used to control the ordering.
   * orderByFields is set to ASC (ascending order) by default if <ORDER> is unspecified.
   */
  orderByFields?: string[]
}

export type IMSqlQueryParams = ImmutableObject<SqlQueryParams>

/**
 * The definitions for one or more field-based statistics to be calculated.
 */
export interface StatisticDefinition {
  /**
   * Statistic type.
   */
  statisticType: 'count' | 'sum' | 'min' | 'max' | 'avg' | 'stddev' | 'var' | 'percentile_cont' | 'percentile_disc'
  /**
   * Field to execute statistic query.
   */
  onStatisticField: string
  /**
   * Name of statistic query result.
   */
  outStatisticFieldName: string
  /**
   * The parameters is for percentile statistics.
   */
  statisticParameters?: StatisticParameters
}

export interface StatisticParameters {
  /**
   * `value` should be a decimal value between 0 and 1.
   */
  value: number
  // `orderBy` in chart series query is lower case.
  orderBy?: 'ASC' | 'DESC' | 'asc' | 'desc'
}

/** @ignore */
export interface CodedValue {
  value: string | number
  label: string
  render?: (item: CodedValue) => any
}

export type TimeExtent = number | [number, number]

export interface TimeInfo {
  timeExtent: [number, number]
  startTimeField?: string
  endTimeField?: string
  trackIdField?: string
  timeReference?: TimeReference
  timeInterval?: number
  timeIntervalUnits?: 'esriTimeUnitsCenturies' | 'esriTimeUnitsDays' | 'esriTimeUnitsDecades' | 'esriTimeUnitsHours' | 'esriTimeUnitsMilliseconds' | 'esriTimeUnitsMinutes' | 'esriTimeUnitsMonths' | 'esriTimeUnitsSeconds' | 'esriTimeUnitsWeeks' | 'esriTimeUnitsYears' | 'esriTimeUnitsUnknown'
}

export interface TimeReference {
  respectsDaylightSaving?: boolean
  timeZone?: string
}

// #endregion Data queries

// #region Data sources

/**
 * The interface for all data sources.
 *
 * Conceptually, we have four types of data sources but all of them are created as data source object:
 * * Main data source: the data source user added in data panel.
 * * Data view: the data view user created in data panel.
 * * Local data source: when multiple widgets connect to a main data source or a data view, they'll share the same data records. If you need to
 *    use a local data copy, you can create a local data source from a main data source by using `DataSourceManager.getInstance().createLocalDataSource()`.
 * * Local data view: a local data source created from a data view.
 *
 * Data view, local data source or local data view derived from the same main data source will share the same schema, same selection records, but may have different data records.
 * The schema is in main data source only.
 *
 * To share the selection between data source and view, we create a selection data view when creating the data source. The selection data source view ID is: `${dataSourceId}-selection`.
 * When selecting records, the selected records are copied to the selection data view.
 *
 */
export interface DataSource {

  // #region Basic interface

  /** The data source ID. */
  id: string
  /** The type of the data source. */
  type: string
  /** The data source manager, which is used to manage the data source, including create/get/destroy the data source instance. */
  dataSourceManager: DataSourceManager
  /**
   * Whether a data source contains child data sources.
   * A set data source won't create all its child data sources when `ready` is resolved.
   * To make sure all child data sources are created, please use `childDataSourcesReady`.
   */
  isDataSourceSet: () => this is DataSource & SetDataSourceMixin
  /** The total records count depends on the current query */
  count?: number

  /** Return data source label. */
  getLabel: () => string

  /**
   * The data source JSON object in app config.
   */
  getDataSourceJson: () => IMDataSourceJson
  /** Update data source JSON in data source instance */
  setDataSourceJson: (dsJson: IMDataSourceJson) => void
  /** Return the data source ID field. */
  getIdField: () => string
  /**
   * The schema returned here is the merged result of the configured schema and the fetched schema.
   * The configured schema is the user's changes, such as a new data source name.
   * The fetched schema is the original schema from AGOL/portal item or a remote database, such as the service name, the fields and the filters.
   */
  getSchema: () => IMDataSourceSchema
  setSchema: (schema: IMDataSourceSchema) => void
  /**
   * The data schema is in "dataSourceJson",
   *    * For data source, use "jimuName" as key, and save the actual field name in the object.
   *    * For data source set, use "jimuChildId" as key, and save the actual child ID in the object.
   * In many cases, we need to use the actual "childId" or "fieldName" to access info, so we can use this method to get a reverse schema for ease of use.
   * @ignore
   */
  getReversedConfigSchema: () => IMReversedDataSourceSchema
  /**
   * Fetch the data schema from an actual data source. If it's a statistic data source, the schema will not be fetched.
   */
  fetchSchema: () => Promise<IMDataSourceSchema>

  getFetchedSchema: () => IMDataSourceSchema
  setFetchedSchema: (schema: IMDataSourceSchema) => void
  /**
   * @ignore
   * The schema contains all fields defined in the actual service. You can select some of the fields and only allow widgets to use these fields.
   * Framework provide two ways to select fields, one is to change the app config in builder, the other is to call `dataSource.setSelectedFields` in app.
   *
   * The method will return the intersection of configured selected fields and runtime selected fields.
   * The fields of used data source in widget json should be a sub set of the returned selected fields.
   * For example, widgets can call `setSelectedFields` to limit the selectable fields of its output data source.
   */
  getSelectedFields: () => string[] // jimuName
  setSelectedFields: (jimuNames: string[]) => void
  /**
   * Return used fields both saved in config and load on demand.
   * @ignore
   */
  getAllUsedFields: (options?: UsedFieldsOptions) => string[] | '*'
  /**
   * Return used fields load on demand. For example, out fields in query params.
   * @ignore
   */
  getLoadOnDemandUsedFields: (options?: UsedFieldsOptions) => string[] | '*'
  /**
   * Return used fields saved in config. For example, fields saved in use data sources of widget config.
   * @ignore
   */
  getConfigUsedFields: (options?: UsedFieldsOptions) => string[] | '*'

  /**
   * When current data source is created from an array of records, will save it in `sourceRecords`.
   * These two methods are used to update or get the source data.
   */
  setSourceRecords: (records: DataRecord[]) => void
  /** Return the source records */
  getSourceRecords: () => DataRecord[]
  /**
    * If selected records are not loaded in the current data source, they will be concatenated to the end of records array.
    * For example, record 1 is selected in data view 1 and it is not loaded in data view 2 (record 1 actually matches query params of data view 2),
    * dataView2.getRecordsWithSelection() will return all loaded records in data view 2 and record 1.
    */
  getRecordsWithSelection: () => DataRecord[]
  /**
   * Return whether current data source can save source records to itself.
   * A data view / local data source doesn't save source records, instead, will use source records in main data source.
   * Selection view is a special data view which will save selected records.
   * @ignore
   */
  canSaveSourceRecords: () => boolean
  /**
   * Builds a data record only -- does not add the record into data source.
   */
  buildRecord: (data: any) => DataRecord

  /** Get record by index */
  getRecord: (index: number) => DataRecord

  /** Get record by ID */
  getRecordById: (id: string) => DataRecord
  /** Get records */
  getRecords: () => DataRecord[]
  /**
   * Update the records in the data source object only, does not update the source data.
   */
  setRecords: (records: DataRecord[]) => void
  /** @ignore */
  nextRecord?: () => DataRecord
  /** @ignore */
  prevRecord?: () => DataRecord
  /**
   * This function will clear the loaded records and won't clear the sourceRecords. Once the loaded records are cleared, the version in the data source info will be updated.
   */
  clearRecords?: () => void
  /**
   * @ignore
   * Clear records but don't add version in data source info.
   */
  clearRecordsNotAddVersion?: () => void
  /**
   * @ignore
   * Clear the count but don't add version in data source info.
   */
  clearCountNotAddVersion?: () => void
  /**
   * @ignore
   * Clear the query by id promise but don't add version in data source info.
   */
  clearQueryByIdNotAddVersion?: () => void
  /**
   * Clear both sourceRecords and loaded records. Both source version and version in data source info will be updated.
   */
  clearSourceRecords: () => void
  /**
   * @ignore
   * Clear source records and records, neither source version nor version will be added.
   */
  clearSourceRecordsNotAddVersion: () => void

  /** Return data source status. */
  getStatus: () => DataSourceStatus
  /** Update data source status. */
  setStatus?: (status: DataSourceStatus) => void
  /** Return data source count status. */
  getCountStatus: () => DataSourceStatus
  /** Update data source count status. */
  setCountStatus?: (status: DataSourceStatus) => void
  /** Return data source version. */
  getVersion: () => number
  /** Update data source version. */
  addVersion?: () => void
  /**
   * When current data source is created from an array of records, it will be saved in `sourceRecords`.
   * Return the version of `sourceRecords`.
   */
  getSourceVersion: () => number
  /**
   * When current data source is created from an array of records, it will be saved in `sourceRecords`.
   * Add the version of `sourceRecords`.
   * `setSourceRecords` will add the version by default.
   */
  addSourceVersion: () => void

  /**
   * Destroy the data source.
   */
  destroy: () => void
  /**
   * Ready is resolved means the data source instance is ready for use.
   * Please note that can not make sure all child data sources are created if a set data source is ready.
   * To make sure all child data sources are created, please use `childDataSourcesReady`.
   */
  ready: () => Promise<void | any>

  /** Return the data source info in redux store. */
  getInfo: () => IMDataSourceInfo

  /**
   * Return null means the data source is a non-spatial data source.
   * @ignore
   */
  getGeometryType: () => GeometryType

  /**
   * For most of the widget output data source, it has an original data source from which it's generated.
   * For the configured data source, return null.
   * @ignore
   */
  getOriginDataSources?: () => DataSource[]

  /**
   * Return the derived data views and local data sources.
   */
  getAllDerivedDataSources: () => DataSource[]

  /**
   * Return whether the data source is added in builder and is saved in app config.
   */
  isInAppConfig: () => boolean

  // #endregion

  // #region interface for child data source
  /**
   * The parent data source of this data source, mull means it's a root data source.
   */
  parentDataSource: DataSource & SetDataSourceMixin

  jimuChildId: string
  /**
   * Order in the parent data source.
   */
  order?: number
  /** Return the root data source. */
  getRootDataSource: () => DataSource
  // #endregion

  // #region interface for data view or local data source
  /** The data source which this data source derives from. */
  belongToDataSource?: DataSource
  /** The data view ID configured in JSON. */
  dataViewId?: string
  /**
   * True means the data source is a data view.
   * For local data source, this is false even the local data source is created from a data view.
   */
  isDataView: boolean
  /**
   * True means the data source is a local data source.
   */
  isLocal: boolean
  /** The local ID of the data source. */
  localId?: string
  /** Return the main data source. */
  getMainDataSource: () => DataSource
  /** Return all data views created from a main data source. */
  getDataViews: () => DataSource[]
  /** Get data view by data view ID. */
  getDataView: (dataViewId: string) => DataSource
  /** Get selection data view */
  getSelectionDataView: () => DataSource
  /** Return the config of the current data source. */
  getDataViewConfig: () => IMDataViewJson

  /** Return all local data sources created from a main data source or data view. */
  getLocalDataSources: () => DataSource[]
  /** Get local data source by local ID. */
  getLocalDataSource: (localId: string) => DataSource
  /**
   * @ignore
   * Get whether a data source should use records of no_selection view as its own source records.
   */
  useNoSelectionView: (dataSource?: DataSource) => boolean
  // #endregion

  // #region interface for data source edit operations
  /**
   * @ignore
   * These methods will update the source data of data source.
   *
   * The data source object provides an interface interact with its source,
   * the source 1. may come from AGOL/portal item or a remote database, 2. may come from an array directly.
   * If the source comes from AGOL/portal item or a remote database, these operations will use ArcGIS Maps SDK for JavaScript or ArcGIS REST APIs to apply edits to it.
   * If the source comes from an array directly, will save it in `sourceRecords` and these operations will edit the `sourceRecords`.
   *
   * The data source object also contains a subset of its source, the subset is saved in `records` and loaded from source.
   * To update the subset, please use `setRecords()`, to update the source, please use these operations.
   * To get the subset, please use `getRecords()`, to get the source:
   *   - for data source which comes from an array directly, please use `getSourceRecords()`,
   *   - for data source which comes from AGOL/portal item or a remote database:
   *     - for queriable data source, please use `query()` or `load()`,
   *     - for stream data source, please use `onData` (TBD).
   */
  updateRecords: (records: DataRecord[]) => Promise<boolean>
  addRecord: (record: DataRecord) => Promise<DataRecord>
  updateRecord: (record: DataRecord) => Promise<boolean>
  deleteRecord: (index: number) => Promise<boolean>
  deleteRecordById: (id: string) => Promise<boolean>
  // #endregion

  // #region interface after editing source data of data source (**the edit operation isn't done by data source**, e.g. via ArcGIS ArcGIS REST APIs directly)
  /**
   * @ignore
   * These methods are used to update records in data source after editing data out of data source (**the edit operation isn't done by data source**).

   * No need to use these methods if the edit operation is done by data source.
   */
  afterUpdateRecords: (records: DataRecord[]) => void
  afterAddRecord: (record: DataRecord) => void
  afterUpdateRecord: (record: DataRecord) => void
  afterDeleteRecordById: (id: string) => void
  afterDeleteRecordsByIds: (ids: string[]) => void
  // #endregion

  // #region interface for data source selection
  /**
   * Data source may have selected data, use selection view to handle it.
   *
   *  - All user selected records will be saved in `sourceRecords` of selection view,
   *  - `records` of selection view are updated automatically whenever `sourceRecords` or filter of selection view changes,
   *  - `selectedIds` of data source info is the real highlighted records of the data source,
   *    both of main data source and data views have their own info, `selectedIds` of data view info is subset of `selectedIds` of main data source info since some selected records of main data source may do not match filter of data view,
   *
   *  - If widget add a filter to selection view,
   *     - `sourceRecords` of selection view will still be the same,
   *     - `records` of selection view and `selectedIds` of main data source and all derived data sources will be the filtered result,
   *  - If widget add a filter to main data source/data view,
   *     - if load data, `sourceRecords` and `records` will be added missing ones, if don't load data, they will keep the same,
   *     - `selectedIds` of the filtered data source and data sources which are derived from it will be the filtered result,
   *
   *  - If query or load selection view, the view will load ArcGIS Maps SDK for JavaScript and then will create a client-side feature layer to do query,
   *  - If open no_selection view and `sourceRecords` of selection view is empty, will use `records` of no_selection view as `sourceRecords` of selection view,
   *  - `records` of no_selection view are updated automatically, too.
   *  - No_selection view only loads one page, won't use all records of no_selection view as default value of selection view.
   */
  /**
   * @ignore
   * @deprecated
   * Select record by index.
   */
  selectRecord: (index: number) => void
  /**
   * Select records.
   */
  selectRecords: (options: SelectOptions) => Promise<Pick<QueryResult, 'records'>>
  /**
   * Select a record by ID.
   * When select record by ID, we can pass in the record. So when the selected record is not loaded, we can add it in.
   *
   * @param id The ID to be selected. The selection will be cleared if the ID is null.
   */
  selectRecordById: (id: string, record?: DataRecord) => void
  /**
   * Select records by IDs.
   * When select records by IDs, we can pass in the records. So when the selected records are not loaded, we can add them in.
   *
   * @param ids The IDs to be selected. The selection will be cleared if the IDs are null.
   */
  selectRecordsByIds: (ids: string[], records?: DataRecord[]) => void
  /** Get selected records */
  getSelectedRecords: () => DataRecord[]
  /** Get selected record indexes*/
  getSelectedRecordIndexes: () => number[]
  /** Get selected record IDs*/
  getSelectedRecordIds: () => string[]
  getSelectedRecordIdsFromInfo: () => ImmutableArray<string>
  getSelectOptionsFromInfo: () => ImmutableObject<SelectOptions>
  /**
   * Update selected records in data source info if the current data source listens selection change (see `setListenSelection`) or the current data source is the trigger data source (that is to say, select via it).
   *
   * Before update info, will check whether these selected records match filters of the current data source firstly, and then only set the matched selected records to info.
   * Will skip the check in some cases to improve performance if the `forceCheck` is not passed in or is false. For example, if the current data source is main data source (we suppose that main data source contains all records, no need to check).
   * But if the `forceCheck` is true, won't skip the check.
   */
  updateSelectionInfo: (options: SelectOptions, triggerDataSource: DataSource, forceCheck?: boolean) => void
  clearSelection: () => void
  /**
    * Whether listen selected records from other data sources which are derived from the same main data source.
    * If true, will update selected record IDs of current data source info when selecting records via other derived data sources. Will also update selected record IDs when selecting records via current data source itself.
    * If false, won't change selected record IDs when selecting records via other derived data sources. Will update selected record IDs only when selecting records via current data source itself.
    *
    * Main data source and its data views will listen selected records by default, local data source does not listen selected records by default.
    */
  setListenSelection: (listen: boolean) => void
  /** Return whether listen selection. */
  getListenSelection: () => boolean
  // #endregion
}

/**
 * `QueriableDataSource` extends `DataSource` and add query capability. A queriable data source must
 * have an `URL` to execute the query.
 *
 * The current default query implementation supports pagination. It allows multiple widgets to apply queries on the same data source,
 * all of which are merged by using the `AND` logic operator.
 *
 * When execute a query, in addition to the passed in query parameters, all configured queries and
 * all other widgets applied queries are merged by using the `AND` logic operator.
 *
 * When a query is executed against a data view, the query from its main data source is used as well.
 */
export interface QueriableDataSource extends DataSource {
  /** The data source URL */
  url?: string
  lastUpdateTime: Date
  /**
   * Whether the data source is case-sensitive when doing query by SQL clauses.
   */
  isSqlCaseSensitive: boolean

  /**
   * @ignore
   * The method check whether there are more pages. E.g. the function `haveMorePages(3, 10)` returns `true`, indicating that there are more than 30 records available.
   * It depends on the loaded pages. Please do the load first and then call the method to check if there are more pages besides the loaded ones.
   */
  haveMorePages: (page: number, pageSize: number) => boolean | 'unknown'

  /**
   * Execute the query against the service and update the internal data records, pagination is supported.
   * When call this method, the real query is returned by `getRealQueryParams`.
   *
   * Pagination:
   * The pagination properties in the passed in query parameter may be not the same as the real query pagination that is sent to the service.
   * The real query pagination is defined in the data source setting.
   */
  load: (query: QueryParams, options?: QueryOptions) => Promise<DataRecord[]>

  /**
   * Load record by ID, do not consider other queries.
   */
  loadById: (id: string, refresh?: boolean) => Promise<DataRecord>

  /** Load the records count. */
  loadCount: (query: QueryParams, options?: QueryOptions) => Promise<number>

  /**
   * Update the data source query without executing the actual query.
   */
  updateQueryParams: (query: QueryParams, widgetId: string) => void

  /**
   * Get the current query parameters. The current query parameters contain all applied queries.
   */
  getCurrentQueryParams: (options?: GetCurrentQueryParamsOptions) => QueryParams

  /**
   * Get the current loaded record id, which is used in `loadById` method.
   */
  getCurrentQueryId: () => string

  /** Get the queries applied in runtime. If the excludeWidgetId is passed in, the queries of this widget will be excluded. */
  getRuntimeQueryParams: (excludeWidgetId?: string) => QueryParams
  /**
   * Get the user config query parameters.
   */
  getConfigQueryParams: () => QueryParams

  /** Get the query parameters configured in remote (not in exb). */
  getRemoteQueryParams: () => QueryParams

  /**
   * Merge queries by using `AND`, and return the merged result.
   * If any query is undefined/null, it will be ignored.
   */
  mergeQueryParams: (...queries: QueryParams[]) => QueryParams

  /**
   * When do query/load, we do not fire the query request directly. Instead, we'll consider the data source's config/current query parameter.
   *  * For load: we'll merge the configured query parameter if it has, and all widget applied queries.
   *  * For query, we'll merge the current query parameter and the configured query parameter it has.
   */
  getRealQueryParams: (query: QueryParams, flag: 'query' | 'load', options?: QueryOptions) => QueryParams

  /**
   * Execute query against the service only, do NOT update the internal data records.
   * The actual query parameters are generated by `getRealQueryParams`.
   *
   * To query count, please use `queryCount`.
   */
  query: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>

  /**
   * Query record by ID.
   * Will return all fields if not pass in the `fields`.
  */
  queryById: (id: string, fields?: string[]) => Promise<DataRecord>

  /** Query count */
  queryCount: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>

  /** Query record IDs, there is no limit to the number of the IDs returned in the `ids` array response. */
  queryIds: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>

  /**
   * Query all records, there is no limit to the number of the records returned in the `records` array response.
   * You can abort the progress by a abort `signal` and can use `progressCallback` to get the progress and the current results.
   */
  queryAll: (query: QueryParams, signal?: AbortSignal, progressCallback?: QueryProgressCallback, options?: QueryOptions) => Promise<QueryResult>

  selectRecords: (options: QueriableSelectOptions, signal?: AbortSignal, progressCallback?: QueryProgressCallback) => Promise<QueryResult>

  /**
   * The page size here defines the records this method returns, which are not the actual query pageSize. Will use a fixed pageSize to query and cache data.
   */
  getRecordsByPage: (page: number, pageSize: number) => DataRecord[]

  /**
   * Get records of the loaded continuous pages.
   * If the loaded pages are 1, 2, and 10, will only return records on the page 1 and 2.
   *
   * Widgets can use different page sizes to query the data source, but the data source has a specific page size to query the service.
   * The data source will save the loaded records by its own page size and split them when widgets doing queries (with different page and page sizes).
   * The method returns continuous page records to make sure the order of the records is correct.
   */
  getRecords: () => DataRecord[]
  /**
   * Get records of all the loaded pages.
   */
  getAllLoadedRecords: () => DataRecord[]

  getPagesData: () => { [page: number]: DataRecord[] }
  setPagesData: (pages: { [page: number]: DataRecord[] }) => void

  /**
   * Get real query page depends on the widget's request page.
   */
  getRealQueryPages: (pageSize: number, page: number) => number[]

  getQueryPageSize: () => number

  /**
   * Null means there is no record count limit, and will return all records from the service.
   */
  getMaxRecordCount: () => number

  // TODO add/update/delete multiple records
  /** @ignore */
  getSaveStatus: () => DataSourceStatus
  /** @ignore */
  setSaveStatus?: (status: DataSourceStatus) => void

  /** Override parent interface to get correct type. */
  getDataViews: () => QueriableDataSource[]
  getDataView: (dataViewId: string) => QueriableDataSource
  getMainDataSource: () => QueriableDataSource

  /** If the return value > 0, auto refresh is enabled. */
  getAutoRefreshInterval: () => number
  getLastRefreshTime: () => Date
  startAutoRefresh: () => void
  stopAutoRefresh: () => void
  allowToExportData: () => Promise<boolean>

  /**
  * If selected records are not loaded in the current data source, will concat them to the end of records array.
  * See {@link getRecordsWithSelection} for details.
  */
  getRecordsByPageWithSelection: (page: number, pageSize: number) => DataRecord[]

  getCapabilities: () => Capabilities
  getAllUsedFields: (options?: QueriableUsedFieldsOptions) => string[] | '*'
}

export interface Capabilities {
  getQueryCapabilities: () => QueryCapabilities
}

export interface QueryCapabilities {
  maxPageSize: number
}

/** @ignore */
export interface LoadableDataSource extends DataSource {
  url?: string

  /**
   * Load all data records.
   */
  load: () => Promise<DataRecord[]>
}

export interface SimpleLocalDataSource extends DataSource {
  type: DataSourceTypes.SimpleLocal
}

export interface CSVDataSource extends LoadableDataSource, JSAPILayerMixin {
  type: DataSourceTypes.CSV
  doLoad: () => Promise<DataRecord[]>
  layer?: __esri.CSVLayer
}

/**
 * Layer from ArcGIS Maps SDK for JavaScript, which may contain sublayers.
 */
export type ArcGISFolderLayer = __esri.MapImageLayer | __esri.TileLayer | __esri.GroupLayer | __esri.Sublayer | __esri.BuildingSceneLayer

interface ArcGISBuildingGroupSublayer extends __esri.BuildingGroupSublayer {
  parent: __esri.BuildingSceneLayer | ArcGISBuildingGroupSublayer
}

interface ArcGISBuildingSublayer extends __esri.BuildingSublayer {
  parent: __esri.BuildingSceneLayer | ArcGISBuildingGroupSublayer
}

/**
 * Layer from ArcGIS Maps SDK for JavaScript, which is sublayer of __esri.Layer.
 */
export type ArcGISSubLayer = __esri.Sublayer | __esri.KMLSublayer | __esri.WMSSublayer | __esri.WMTSSublayer | ArcGISBuildingSublayer | __esri.SubtypeSublayer

/**
 * There is no actual ArcGIS "LayerFolder" service, this interface defines the common behavior of these services:
 *  MapService, FeatureService, SceneService, and GroupLayerService.
 */
export interface AbstractArcGISLayerFolderDataSource extends DataSource, JSAPILayerMixin, ItemMixin, SetDataSourceMixin {
  getServiceDefinition: () => ServiceDefinition

  /** Get the service GDB version. */
  getGDBVersion: () => string
  /** Change the GDB version for all layers in the service. */
  changeGDBVersion: (gdbVersion: string) => void
}

/**
 * `VectorTileServiceDataSource` is created from vector tile service or webmap/webscene.
 * @ignore
 */
export interface VectorTileServiceDataSource extends DataSource, JSAPILayerMixin, ItemMixin {
  type: DataSourceTypes.VectorTileService
  layer?: __esri.VectorTileLayer
}

/**
 * `GeoJsonDataSource` is created from a [GeoJSON](https://geojson.org/) file or webmap/webscene.
 * @ignore
 */
export interface GeoJSONDataSource extends DataSource, JSAPILayerMixin, ItemMixin {
  type: DataSourceTypes.GeoJSON
  layer?: __esri.GeoJSONLayer
}

/**
 * `KMLDataSource` is created from a KML file (.kml, .kmz) or webmap/webscene.
 * @ignore
 */
export interface KMLDataSource extends DataSource, JSAPILayerMixin, ItemMixin {
  type: DataSourceTypes.KML
  layer?: __esri.KMLLayer
}

/**
 * `WFSDataSource` is created from an OGC Web Feature Service (WFS) or webmap/webscene.
 * @ignore
 */
export interface WFSDataSource extends DataSource, JSAPILayerMixin, ItemMixin {
  type: DataSourceTypes.WFS
  layer?: __esri.WFSLayer
}

/**
 * `WMSDataSource` is created from an OGC Web Map Services (WMS) or webmap/webscene.
 * @ignore
 */
export interface WMSDataSource extends DataSource, JSAPILayerMixin, ItemMixin {
  type: DataSourceTypes.WMS
  layer?: __esri.WMSLayer
}

/**
 * `WMTSDataSource` is created from an OGC Web Map Tile Services (WMTS) or webmap/webscene.
 * @ignore
 */
export interface WMTSDataSource extends DataSource, JSAPILayerMixin, ItemMixin {
  type: DataSourceTypes.WMTS
  layer?: __esri.WMTSLayer
}

/**
 * `ElevationLayerDataSource`
 * @ignore
 */
export interface ElevationLayerDataSource extends DataSource, JSAPILayerMixin, ItemMixin {
  type: DataSourceTypes.ElevationLayer
  layer?: __esri.ElevationLayer
}

// #endregion Data sources

// #region Data source mixins

export interface ItemMixin {
  itemId?: string
  portalUrl?: string
  getItemInfo: () => IItem
  getItemData: () => any
  fetchItemInfo: () => Promise<IItem>
  fetchItemData: () => Promise<any>
}

export interface JSAPILayerMixin {
  /**
   * 1 How to use ArcGIS Maps SDK for JavaScript layer
   *   1.1 a data source may have a layer, the layer is the source of the data source (`isDataInDataSourceInstance` should be false) and is used to save source data and communicate with Maps SDK for JavaScript (get popupTemplate, symbol and so on), if want to query features, should use data source instance, not the layer.
   *   1.2 main data source and all other data views/local data source share the same layer.
   *   1.3 selection view create a new layer when do query, but doesn't save the layer.
   *   1.4 if widget needs an ArcGIS Maps SDK for JavaScript layer, call `dataSource.createJSAPILayerByDataSource()` to create a new layer, do not use the layer in data source instance directly, to listen data source changes and apply the changes to the new layer, see 2.2.
   *
   * 2 How to listen data source changes via DataSourceComponent
   *   2.1 if widget loads records, use `onDataSourceInfoChange` to listen selected records change, query params change and loaded records change.
   *   2.2 if widget doesn't  load records (use a Maps SDK for JavaScript widget and needs an ArcGIS Maps SDK for JavaScript layer), use `onQueryRequired` to listen query params change, use `onSelectionChange` to listen selected records change.
   *
   * 3 Relation between output data source and origin data source
   *   3.1 if schema is not changed (e.g. query output) and only has one origin data source, will use origin data source's `layerDefinition`, `popupInfo` and Maps SDK for JavaScript `layer`.
   *   3.2 if schema is changed (e.g. chart output), need widget to set `layerDefinition`, `popupInfo` and Maps SDK for JavaScript `layer` to data source instance.
   */
  layer?: __esri.Layer | ArcGISSubLayer
  jimuLayerId?: string
  url?: string
  itemId?: string
  portalUrl?: string
  /**
   * Default `dataSource` is the current data source.
   * Default `useDataSourceQueryParams` is true, that is to say apply the data source's query params to the created ArcGIS Maps SDK for JavaScript layer by default.
   * Default `throwError` is false, that is to say the method won't throw error and will return `undefined` if the creation fail.
   */
  createJSAPILayerByDataSource: (dataSource?: DataSource, useDataSourceQueryParams?: boolean, throwError?: boolean) => Promise<__esri.Layer | ArcGISSubLayer>
  // Whether the layer has spatial information to draw the layer to a map, such as latitude and longitude.
  supportSpatialInfo: () => boolean
}

export interface SetDataSourceMixin {
  /** Return child data sources of a parent data source. */
  getChildDataSources?: () => DataSource[]

  /** Return all child data sources of a parent data source, includes the grandchildren */
  getAllChildDataSources?: () => DataSource[]

  /**
   * Get child data source by `jimuChildId`. You can get `jimuChildId` by `getJimuChildId()`.
   */
  getChildDataSource?: (jimuChildId: string) => DataSource

  /**
   * Get the actual data source ID by `jimuChildId`.
   * @ignore
   */
  getChildDataSourceId?: (jimuChildId: string) => string

  /**
   * Delete the promise which caches the process to create a child data source.
   * @ignore
   */
  clearChildDataSourcePromise?: (childDataSourceId: string) => void

  /**
   * @ignore
   * The jimu child ID is similar to the jimuFieldName, and widgets should use the jimuChildId instead of the childId to make data mapping work.
   */
  getJimuChildId?: (childId: string) => string[]
  /**
  * All child data sources (including descendant data sources) are ready for use.
  * Data source has this method only if it is data source set (`dataSource.isDataSourceSet()` is true).
  */
  childDataSourcesReady?: () => Promise<DataSource[]>
  /**
   * Return whether all child data sources (including descendant data sources) are created.
   * Data source has this method only if it is data source set (`dataSource.isDataSourceSet()` is true).
   */
  areChildDataSourcesCreated?: () => boolean
  /**
   * Whether there are some child data source pending.
   * @ignore
   */
  areSomeChildDataSourcesPending?: () => Promise<boolean>
  /**
   * Create a child or a descendant data source by id.
   * Data source has this method only if it is data source set (`dataSource.isDataSourceSet()` is true).
   *
   * Please note will only create the specific data source, won't create descendant data sources of it.
   */
  createDataSourceById?: (dataSourceId: string) => Promise<DataSource>
}

// #endregion Data source mixins

export enum DataSourceSelectionMode {
  New = 'New',
  AddToCurrent = 'AddToCurrent',
  RemoveFromCurrent = 'RemoveFromCurrent',
  SelectFromCurrent = 'SelectFromCurrent'
}

/**
 * @ignore
 * Timezone for runtime.
 * 'unknown': unknown timezone in service.
 * 'device':  user's device.
 * 'specific': IANA(Asia/Shanghai) from app settings of ExB & MV, or defined timezone/null from services.
*/
export type TimezoneRuntime = 'unknown' | 'device' | string

/**
 * @ignore
 * Timezone for API.
 * 'unknown': unknown timezone, or defined timezone/null in service.
 * 'device':  user's device.
 * 'specific': IANA(Asia/Shanghai).
 * https://next.sites.afd.arcgis.com/javascript/latest/api-reference/esri-views-MapView.html#timeZone
 * https://next.sites.afd.arcgis.com/javascript/latest/api-reference/esri-widgets-Feature.html#timeZone
 */
export type TimezoneAPI = 'unknown' | 'device' | string

type NonAbstractConstructor<T = object> = new (...args: any[]) => T
type AbstractConstructor<T = object> = abstract new (...args: any[]) => T
export type Constructor<T = object> = NonAbstractConstructor<T> | AbstractConstructor<T>
