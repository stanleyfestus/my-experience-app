(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.arcgisTelemetry = global.arcgisTelemetry || {}));
})(this, (function (exports) { 'use strict';

    function shouldDisableTracking(options = {}) {
        const { disabled, portal } = options;
        if (disabled || (portal === null || portal === void 0 ? void 0 : portal.eueiEnabled) === false) {
            return true;
        }
        if (!portal || hasEueiEnabledAndIsMemberOfOrg(portal) || isRegisteredUserWithoutOrgInUSA(portal) || isAnonymousUserInUSA(portal)) {
            return false;
        }
        return true;
    }
    function hasEueiEnabledAndIsMemberOfOrg(portal) {
        return portal.eueiEnabled && portal.user && portal.user.orgId === portal.id;
    }
    function isRegisteredUserWithoutOrgInUSA(portal) {
        return portal.user && !portal.user.orgId && portal.ipCntryCode === 'US';
    }
    function isAnonymousUserInUSA(portal) {
        return !portal.user && portal.ipCntryCode === 'US';
    }

    const storage = {
        storage: {},
        memory: true,
        get(key) {
            let stored;
            try {
                stored =
                    (window.localStorage && window.localStorage.getItem(key)) ||
                        this.storage[key];
            }
            catch (e) {
                stored = this.storage[key];
            }
            if (stored) {
                try {
                    return JSON.parse(stored);
                }
                catch (e) {
                    return undefined;
                }
            }
            else {
                return undefined;
            }
        },
        set(key, value) {
            // handle Safari private mode (setItem is not allowed)
            const valueToString = JSON.stringify(value);
            try {
                window.localStorage.setItem(key, valueToString);
            }
            catch (e) {
                if (!this.memory) {
                    console.error('setting local storage failed, falling back to in-memory storage');
                    this.memory = true;
                }
                this.storage[key] = value;
            }
        },
        delete(key) {
            try {
                window.localStorage.removeItem(key);
            }
            catch (e) {
                if (!this.memory) {
                    console.error('setting local storage failed, falling back to in-memory storage');
                    this.memory = true;
                }
                delete this.storage[key];
            }
        },
    };

    const ESRI_TELEMETRY_DATA_ATTRIBUTE = 'esri-telemetry';
    function injectScriptElementAsync(attributes) {
        const onloadPromise = new Promise((resolve, reject) => {
            attributes.onload = resolve;
            attributes.onerror = reject;
            const script = injectScriptElement(attributes);
            if (!script || attributes.body) {
                // this is for the case where the script is already loaded or it has a body instead of a src
                resolve();
            }
        });
        return onloadPromise;
    }
    function scriptExists(attributes) {
        const { id, dataAttribute } = attributes;
        return !!document.getElementById(id) || !!document.querySelector(`[data-${ESRI_TELEMETRY_DATA_ATTRIBUTE}="${dataAttribute}"]`);
    }
    function injectScriptElement(attributes) {
        const { body, src, id, dataAttribute, section = 'body', type = 'text/javascript', async = false, defer = false, onload, onerror } = attributes;
        if (typeof window === 'undefined') {
            throw new WindowUndefinedError('Window is undefined: Cannot add script element.');
        }
        if (scriptExists(attributes)) {
            console.log(`script (${id || dataAttribute}) is already present, skipping`);
            return;
        }
        const scriptElement = createScriptElementWithAttributes({
            id,
            dataAttribute,
            type,
            async,
            defer,
            body,
            src,
            onload,
            onerror
        });
        return section === 'body'
            ? document.body.appendChild(scriptElement)
            : document.head.appendChild(scriptElement);
    }
    class WindowUndefinedError extends Error {
    }
    function createScriptElementWithAttributes({ id, dataAttribute, type, async, defer, body, src, onload, onerror }) {
        const scriptElement = document.createElement('script');
        if (id) {
            scriptElement.id = id;
        }
        if (dataAttribute) {
            scriptElement.setAttribute(`data-${ESRI_TELEMETRY_DATA_ATTRIBUTE}`, dataAttribute);
        }
        src && (scriptElement.src = src);
        body && (scriptElement.innerText = body);
        scriptElement.type = type;
        scriptElement.async = async;
        scriptElement.defer = defer;
        onload && (scriptElement.onload = onload);
        onerror && (scriptElement.onerror = onerror);
        return scriptElement;
    }

    function createScriptTags(scripts) {
        return scripts.map(scriptObj => {
            const attrs = [];
            ['src', 'id', 'dataAttribute', 'type'].forEach(attr => {
                let attrName = attr;
                if (attr === 'dataAttribute') {
                    attrName = 'data-esri-telemetry';
                }
                if (scriptObj[attr]) {
                    attrs.push(`${attrName}="${scriptObj[attr]}"`);
                }
            });
            ['async', 'defer'].forEach(attr => {
                if (scriptObj[attr]) {
                    attrs.push(`${attr}`);
                }
            });
            return `<script ${attrs.join(' ')}>${scriptObj.body ? scriptObj.body : ''}</script>`;
        }).join('');
    }

    const INTERNAL_ORGS = [
        'esri.com',
        'esriuk.com',
        'esri.de',
        'esri.ca',
        'esrifrance.fr',
        'esri.nl',
        'esri-portugal.pt',
        'esribulgaria.com',
        'esri.fi',
        'esri.kr',
        'esrimalaysia.com.my',
        'esri.es',
        'esriaustralia.com.au',
        'esri-southafrica.com',
        'esri.cl',
        'esrichina.com.cn',
        'esri.co',
        'esriturkey.com.tr',
        'geodata.no',
        'esriitalia.it',
        'esri.pl',
    ];
    /**
     * Telemetry class
     */
    class Telemetry {
        constructor(options) {
            var _a, _b, _c;
            this.trackers = [];
            this.options = options;
            this.debug = options.debug;
            this.suppressDisabledWarnings = options.suppressDisabledWarnings;
            this.disabled = shouldDisableTracking(options);
            this.logger = options.logger || console;
            if (this.disabled && !this.suppressDisabledWarnings) {
                this.logger.info('Telemetry Disabled');
            }
            const user = ((_a = options.portal) === null || _a === void 0 ? void 0 : _a.user) || options.user;
            if (user) {
                this.setUser(user, (_c = (_b = options.portal) === null || _b === void 0 ? void 0 : _b.subscriptionInfo) === null || _c === void 0 ? void 0 : _c.type);
            }
            if (!this.disabled) {
                this.initializeTrackers();
            }
        }
        initializeTrackers() {
            if (this.options.plugins) {
                this.trackers.push(...this.options.plugins);
            }
            if (!this.trackers.length) {
                this.logger.error(new Error('No trackers configured'));
            }
        }
        getScriptTags() {
            return this.trackers
                .map((tracker) => {
                return tracker.getScriptTags && tracker.getScriptTags();
            })
                .join('');
        }
        async init() {
            const promises = this.trackers.map((tracker) => {
                return tracker.init();
            });
            await Promise.all(promises);
        }
        setUser(user = {}, orgType = 'Public') {
            user = typeof user === 'string' ? { username: user } : user;
            this.user = user;
            this.user.accountType = orgType;
            let internalDomain;
            if (user.email && user.email.split) {
                const domain = user.email.split('@')[1];
                internalDomain =
                    INTERNAL_ORGS.filter((org) => {
                        return domain === org;
                    }).length > 0;
            }
            if (internalDomain ||
                ['In House', 'Demo and Marketing'].indexOf(orgType) > -1) {
                this.user.internalUser = true;
            }
        }
        logPageView(page, event = {}, options = {}) {
            if (this.disabled && !this.suppressDisabledWarnings) {
                this.logger.info('Page view was not logged because telemetry is disabled.');
                return false;
            }
            const enabledTrackers = this.trackers.filter(({ disabled, hasError }) => !disabled && !hasError);
            if (!enabledTrackers.length) {
                this.logger.warn('Page view was not logged because no enabled telemetry-plugins are registered.');
                return false;
            }
            const attributes = this.preProcess(event, options);
            if (this.debug) {
                this.logger.info('Tracking page view', JSON.stringify(attributes));
            }
            const promises = enabledTrackers.map((tracker) => {
                return tracker.logPageView(page, attributes);
            });
            Promise.all(promises).then();
            return true;
        }
        logEvent(event, options = {}) {
            if (this.disabled && !this.suppressDisabledWarnings) {
                this.logger.info('Event was not logged because telemetry is disabled.');
                return false;
            }
            const enabledTrackers = this.trackers.filter(({ disabled, hasError }) => !disabled && !hasError);
            if (!enabledTrackers.length) {
                this.logger.warn('Event was not logged because no enabled telemetry-plugins are registered.');
                return false;
            }
            const eventAttributes = this.preProcess(event, options);
            if (this.debug) {
                this.logger.info('Tracking event', JSON.stringify(eventAttributes));
            }
            const promises = enabledTrackers.map((tracker) => {
                return tracker.logEvent(eventAttributes);
            });
            Promise.all(promises).then();
            return true;
        }
        logError(event = {}) {
            event = Object.assign({ eventType: 'error' }, event);
            this.logEvent(event);
        }
        startWorkflow(name, attributes = {}) {
            const workflow = {
                name,
                start: Date.now(),
                steps: [],
                workflowId: Math.floor((1 + Math.random()) * 0x100000000000).toString(16),
            };
            this.saveWorkflow(workflow);
            const workflowObj = Object.assign({ name, step: 'start' }, attributes);
            this.logWorkflow(workflowObj);
            return workflow;
        }
        stepWorkflow(name, step, attributes = {}) {
            //TODO: check if the check for attributes being a string is useful or can be removed
            const details = typeof attributes === 'string' ? attributes : attributes.details;
            const workflowObj = Object.assign({ name, step, details }, attributes);
            this.logWorkflow(workflowObj);
        }
        endWorkflow(name, attributes = {}) {
            const workflowObj = Object.assign({ name, step: 'finish' }, attributes);
            this.logWorkflow(workflowObj);
        }
        cancelWorkflow(name, attributes = {}) {
            const workflowObj = Object.assign({ name, step: 'cancel' }, attributes);
            this.logWorkflow(workflowObj);
        }
        getWorkflow(name) {
            const workflow = storage.get(`TELEMETRY-WORKFLOW:${name}`);
            // do not let old workflows be returned
            if (workflow) {
                const workflowAge = Date.now() - workflow.start;
                const timeout = 30 * 60 * 1000;
                if (workflowAge < timeout) {
                    return workflow;
                }
                else {
                    this.deleteWorkflow(workflow);
                }
            }
        }
        saveWorkflow(workflow) {
            storage.set(`TELEMETRY-WORKFLOW:${workflow.name}`, workflow);
        }
        deleteWorkflow(workflow) {
            storage.delete(`TELEMETRY-WORKFLOW:${workflow.name}`);
        }
        logWorkflow(options = {}) {
            /*
            const workflow = {
              name: 'add layer to map',
              step: 'start',
              details: 'some details about the step'
            }
            */
            options = this.preProcess(options);
            let workflow = this.getWorkflow(options.name);
            if (!workflow) {
                this.startWorkflow(options.name);
                workflow = this.getWorkflow(options.name);
            }
            workflow.steps.push(options.step);
            workflow.duration = (Date.now() - workflow.start) / 1000;
            if (['cancel', 'finish'].indexOf(options.step) > -1) {
                this.deleteWorkflow(workflow);
            }
            else {
                this.saveWorkflow(workflow);
            }
            const track = Object.assign(options, {
                eventType: 'workflow',
                category: options.name,
                action: options.step,
                label: options.details,
                duration: workflow.duration,
                workflowId: workflow.workflowId,
            });
            this.logEvent(track);
        }
        preProcess(event = {}, options = {}) {
            let userMetadata = {};
            if (this.user) {
                userMetadata = {
                    user: 'unknown',
                    org: 'unknown',
                    lastLogin: this.user.lastLogin,
                    userSince: this.user.created,
                    internalUser: this.user.internalUser || false,
                    accountType: this.user.accountType,
                };
            }
            return Object.entries(Object.assign(Object.assign({}, event), userMetadata)).reduce(makeEventPayload(options.omitComplexData, this.logger), {});
        }
        disableTracker(trackerName) {
            var _a;
            const tracker = this.trackers.find(({ name }) => name === trackerName);
            if (tracker && !tracker.hasError) {
                tracker.disabled = true;
                (_a = tracker.disable) === null || _a === void 0 ? void 0 : _a.call(tracker);
            }
        }
        enableTracker(trackerName) {
            var _a;
            const tracker = this.trackers.find(({ name }) => name === trackerName);
            if (tracker && !tracker.hasError) {
                tracker.disabled = false;
                (_a = tracker.enable) === null || _a === void 0 ? void 0 : _a.call(tracker);
            }
        }
    }
    function makeEventPayload(omitComplexData, logger) {
        return function (acc, [key, val]) {
            if (isPrimitive(val)) {
                acc[key] = val;
            }
            else if (!omitComplexData) {
                logger.warn(`You are trying to log a non-primitive value, ${key}:${JSON.stringify(val)}. This will get logged as [object Object]`);
                acc[key] = val;
            }
            return acc;
        };
    }
    function isPrimitive(val) {
        const primitives = ['string', 'number', 'boolean', 'undefined'];
        return (primitives.includes(typeof val) ||
            (val && typeof val.valueOf() === 'string'));
    }

    exports.Telemetry = Telemetry;
    exports.WindowUndefinedError = WindowUndefinedError;
    exports.createScriptTags = createScriptTags;
    exports.injectScriptElement = injectScriptElement;
    exports.injectScriptElementAsync = injectScriptElementAsync;
    exports.storage = storage;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=telemetry.min.js.map
