import { shouldDisableTracking } from './should-disable-tracking';
import { storage } from './utils/storage';
export * from './utils';
const INTERNAL_ORGS = [
    'esri.com',
    'esriuk.com',
    'esri.de',
    'esri.ca',
    'esrifrance.fr',
    'esri.nl',
    'esri-portugal.pt',
    'esribulgaria.com',
    'esri.fi',
    'esri.kr',
    'esrimalaysia.com.my',
    'esri.es',
    'esriaustralia.com.au',
    'esri-southafrica.com',
    'esri.cl',
    'esrichina.com.cn',
    'esri.co',
    'esriturkey.com.tr',
    'geodata.no',
    'esriitalia.it',
    'esri.pl',
];
/**
 * Telemetry class
 */
export class Telemetry {
    constructor(options) {
        var _a, _b, _c;
        this.trackers = [];
        this.options = options;
        this.debug = options.debug;
        this.suppressDisabledWarnings = options.suppressDisabledWarnings;
        this.disabled = shouldDisableTracking(options);
        this.logger = options.logger || console;
        if (this.disabled && !this.suppressDisabledWarnings) {
            this.logger.info('Telemetry Disabled');
        }
        const user = ((_a = options.portal) === null || _a === void 0 ? void 0 : _a.user) || options.user;
        if (user) {
            this.setUser(user, (_c = (_b = options.portal) === null || _b === void 0 ? void 0 : _b.subscriptionInfo) === null || _c === void 0 ? void 0 : _c.type);
        }
        if (!this.disabled) {
            this.initializeTrackers();
        }
    }
    initializeTrackers() {
        if (this.options.plugins) {
            this.trackers.push(...this.options.plugins);
        }
        if (!this.trackers.length) {
            this.logger.error(new Error('No trackers configured'));
        }
    }
    getScriptTags() {
        return this.trackers
            .map((tracker) => {
            return tracker.getScriptTags && tracker.getScriptTags();
        })
            .join('');
    }
    async init() {
        const promises = this.trackers.map((tracker) => {
            return tracker.init();
        });
        await Promise.all(promises);
    }
    setUser(user = {}, orgType = 'Public') {
        user = typeof user === 'string' ? { username: user } : user;
        this.user = user;
        this.user.accountType = orgType;
        let internalDomain;
        if (user.email && user.email.split) {
            const domain = user.email.split('@')[1];
            internalDomain =
                INTERNAL_ORGS.filter((org) => {
                    return domain === org;
                }).length > 0;
        }
        if (internalDomain ||
            ['In House', 'Demo and Marketing'].indexOf(orgType) > -1) {
            this.user.internalUser = true;
        }
    }
    logPageView(page, event = {}, options = {}) {
        if (this.disabled && !this.suppressDisabledWarnings) {
            this.logger.info('Page view was not logged because telemetry is disabled.');
            return false;
        }
        const enabledTrackers = this.trackers.filter(({ disabled, hasError }) => !disabled && !hasError);
        if (!enabledTrackers.length) {
            this.logger.warn('Page view was not logged because no enabled telemetry-plugins are registered.');
            return false;
        }
        const attributes = this.preProcess(event, options);
        if (this.debug) {
            this.logger.info('Tracking page view', JSON.stringify(attributes));
        }
        const promises = enabledTrackers.map((tracker) => {
            return tracker.logPageView(page, attributes);
        });
        Promise.all(promises).then();
        return true;
    }
    logEvent(event, options = {}) {
        if (this.disabled && !this.suppressDisabledWarnings) {
            this.logger.info('Event was not logged because telemetry is disabled.');
            return false;
        }
        const enabledTrackers = this.trackers.filter(({ disabled, hasError }) => !disabled && !hasError);
        if (!enabledTrackers.length) {
            this.logger.warn('Event was not logged because no enabled telemetry-plugins are registered.');
            return false;
        }
        const eventAttributes = this.preProcess(event, options);
        if (this.debug) {
            this.logger.info('Tracking event', JSON.stringify(eventAttributes));
        }
        const promises = enabledTrackers.map((tracker) => {
            return tracker.logEvent(eventAttributes);
        });
        Promise.all(promises).then();
        return true;
    }
    logError(event = {}) {
        event = Object.assign({ eventType: 'error' }, event);
        this.logEvent(event);
    }
    startWorkflow(name, attributes = {}) {
        const workflow = {
            name,
            start: Date.now(),
            steps: [],
            workflowId: Math.floor((1 + Math.random()) * 0x100000000000).toString(16),
        };
        this.saveWorkflow(workflow);
        const workflowObj = Object.assign({ name, step: 'start' }, attributes);
        this.logWorkflow(workflowObj);
        return workflow;
    }
    stepWorkflow(name, step, attributes = {}) {
        //TODO: check if the check for attributes being a string is useful or can be removed
        const details = typeof attributes === 'string' ? attributes : attributes.details;
        const workflowObj = Object.assign({ name, step, details }, attributes);
        this.logWorkflow(workflowObj);
    }
    endWorkflow(name, attributes = {}) {
        const workflowObj = Object.assign({ name, step: 'finish' }, attributes);
        this.logWorkflow(workflowObj);
    }
    cancelWorkflow(name, attributes = {}) {
        const workflowObj = Object.assign({ name, step: 'cancel' }, attributes);
        this.logWorkflow(workflowObj);
    }
    getWorkflow(name) {
        const workflow = storage.get(`TELEMETRY-WORKFLOW:${name}`);
        // do not let old workflows be returned
        if (workflow) {
            const workflowAge = Date.now() - workflow.start;
            const timeout = 30 * 60 * 1000;
            if (workflowAge < timeout) {
                return workflow;
            }
            else {
                this.deleteWorkflow(workflow);
            }
        }
    }
    saveWorkflow(workflow) {
        storage.set(`TELEMETRY-WORKFLOW:${workflow.name}`, workflow);
    }
    deleteWorkflow(workflow) {
        storage.delete(`TELEMETRY-WORKFLOW:${workflow.name}`);
    }
    logWorkflow(options = {}) {
        /*
        const workflow = {
          name: 'add layer to map',
          step: 'start',
          details: 'some details about the step'
        }
        */
        options = this.preProcess(options);
        let workflow = this.getWorkflow(options.name);
        if (!workflow) {
            this.startWorkflow(options.name);
            workflow = this.getWorkflow(options.name);
        }
        workflow.steps.push(options.step);
        workflow.duration = (Date.now() - workflow.start) / 1000;
        if (['cancel', 'finish'].indexOf(options.step) > -1) {
            this.deleteWorkflow(workflow);
        }
        else {
            this.saveWorkflow(workflow);
        }
        const track = Object.assign(options, {
            eventType: 'workflow',
            category: options.name,
            action: options.step,
            label: options.details,
            duration: workflow.duration,
            workflowId: workflow.workflowId,
        });
        this.logEvent(track);
    }
    preProcess(event = {}, options = {}) {
        let userMetadata = {};
        if (this.user) {
            userMetadata = {
                user: 'unknown',
                org: 'unknown',
                lastLogin: this.user.lastLogin,
                userSince: this.user.created,
                internalUser: this.user.internalUser || false,
                accountType: this.user.accountType,
            };
        }
        return Object.entries(Object.assign(Object.assign({}, event), userMetadata)).reduce(makeEventPayload(options.omitComplexData, this.logger), {});
    }
    disableTracker(trackerName) {
        var _a;
        const tracker = this.trackers.find(({ name }) => name === trackerName);
        if (tracker && !tracker.hasError) {
            tracker.disabled = true;
            (_a = tracker.disable) === null || _a === void 0 ? void 0 : _a.call(tracker);
        }
    }
    enableTracker(trackerName) {
        var _a;
        const tracker = this.trackers.find(({ name }) => name === trackerName);
        if (tracker && !tracker.hasError) {
            tracker.disabled = false;
            (_a = tracker.enable) === null || _a === void 0 ? void 0 : _a.call(tracker);
        }
    }
}
function makeEventPayload(omitComplexData, logger) {
    return function (acc, [key, val]) {
        if (isPrimitive(val)) {
            acc[key] = val;
        }
        else if (!omitComplexData) {
            logger.warn(`You are trying to log a non-primitive value, ${key}:${JSON.stringify(val)}. This will get logged as [object Object]`);
            acc[key] = val;
        }
        return acc;
    };
}
function isPrimitive(val) {
    const primitives = ['string', 'number', 'boolean', 'undefined'];
    return (primitives.includes(typeof val) ||
        (val && typeof val.valueOf() === 'string'));
}
//# sourceMappingURL=index.js.map