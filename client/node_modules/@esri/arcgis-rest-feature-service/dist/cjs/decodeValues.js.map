{"version":3,"file":"decodeValues.js","sourceRoot":"","sources":["../../src/decodeValues.ts"],"names":[],"mappings":";AAAA;gBACgB;;;AAKhB,+CAAyC;AAkCzC;;;;;;;;;;;;;;;;;;GAkBG;AACH,SAAgB,YAAY,CAC1B,cAAoC;IAEpC,IAAI,IAAI,CAAC;IACT,IAAI,cAAc,CAAC,MAAM,EAAE;QACzB,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;KAC/C;SAAM;QACL,IAAI,GAAG,IAAA,sBAAQ,EAAC,EAAE,GAAG,EAAE,cAAc,CAAC,GAAG,EAAE,CAAC,CAAC,IAAI,CAC/C,CAAC,QAA0B,EAAE,EAAE;YAC7B,OAAO,QAAQ,CAAC,MAAM,CAAC;QACzB,CAAC,CACF,CAAC;KACH;IACD,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;QAC1B,8BAA8B;QAC9B,MAAM,OAAO,GAAG,wBAAwB,CAAC,MAAM,CAAC,CAAC;QACjD,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;YACnC,sBAAsB;YACtB,OAAO,cAAc,CAAC,aAAa,CAAC;SACrC;QAED,iCAAiC;QACjC,MAAM,eAAe,GAAG,cAAc,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,CAC/D,CAAC,OAAiB,EAAE,EAAE;YACpB,MAAM,iBAAiB,GAA6B,EAAE,CAAC;YACvD,KAAK,MAAM,GAAG,IAAI,OAAO,CAAC,UAAU,EAAE;gBACpC,0BAA0B;gBAC1B,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,GAAG,CAAC;oBAChE,SAAS;gBACX,MAAM,KAAK,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;gBACtC,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;gBAC5B,iBAAiB,CAAC,GAAG,CAAC;oBACpB,KAAK,KAAK,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,WAAW,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;aACjE;YACD,4CAA4C;YAC5C,uCAAY,OAAO,GAAK,EAAE,UAAU,EAAE,iBAAiB,EAAE,EAAG;QAC9D,CAAC,CACF,CAAC;QACF,2CAA2C;QAC3C,uCACK,cAAc,CAAC,aAAa,GAC5B,EAAE,QAAQ,EAAE,eAAe,EAAE,EAChC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AA5CD,oCA4CC;AAED,SAAS,wBAAwB,CAAC,MAAgB;IAChD,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE;QACtC,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC5B,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,YAAY,EAAE;YAC1C,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;SAC9B;QACD,OAAO,OAAO,CAAC;IACjB,CAAC,EAAE,EAA8B,CAAC,CAAC;AACrC,CAAC;AAED,6BAA6B;AAC7B,SAAS,WAAW,CAAC,KAAU,EAAE,MAAW;IAC1C,MAAM,UAAU,GAAG,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAM,EAAE,EAAE;QACpD,OAAO,KAAK,KAAK,CAAC,CAAC,IAAI,CAAC;IAC1B,CAAC,CAAC,CAAC;IACH,OAAO,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;AAC9C,CAAC","sourcesContent":["/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { IRequestOptions, IField, IFeature } from \"@esri/arcgis-rest-request\";\n\nimport { IQueryFeaturesResponse } from \"./query.js\";\nimport { getLayer } from \"./getLayer.js\";\nimport { ILayerDefinition } from \"./helpers.js\";\n\n/**\n * Request options to fetch a feature by id.\n */\nexport interface IDecodeValuesOptions extends IRequestOptions {\n  /**\n   * Layer service url.\n   */\n  url?: string;\n  /**\n   * Unique identifier of the feature.\n   */\n  queryResponse: IQueryFeaturesResponse;\n  /**\n   * * If a fieldset is provided, no internal metadata check will be issued to gather info about coded value domains.\n   *\n   * getFeatureService(url)\n   *   .then(metadata => {\n   *     queryFeatures({ url })\n   *       .then(response => {\n   *         decodeValues({\n   *           url,\n   *           queryResponse,\n   *           fields: metadata.fields\n   *         })\n   *           .then(decodedResponse)\n   *       })\n   *   })\n   */\n  fields?: IField[];\n}\n\n/**\n * ```js\n * import { queryFeatures, decodeValues } from '@esri/arcgis-rest-feature-service';\n * //\n * const url = `https://sampleserver6.arcgisonline.com/arcgis/rest/services/ServiceRequest/FeatureServer/0`\n * queryFeatures({ url })\n *   .then(queryResponse => {\n *     decodeValues({\n *       url,\n *       queryResponse\n *     })\n *       .then(decodedResponse)\n *   })\n * ```\n * Replaces the raw coded domain values in a query response with descriptions (for legibility).\n *\n * @param requestOptions - Options for the request.\n * @returns A Promise that will resolve with the addFeatures response.\n */\nexport function decodeValues(\n  requestOptions: IDecodeValuesOptions\n): Promise<IQueryFeaturesResponse> {\n  let prms;\n  if (requestOptions.fields) {\n    prms = Promise.resolve(requestOptions.fields);\n  } else {\n    prms = getLayer({ url: requestOptions.url }).then(\n      (metadata: ILayerDefinition) => {\n        return metadata.fields;\n      }\n    );\n  }\n  return prms.then((fields) => {\n    // extract coded value domains\n    const domains = extractCodedValueDomains(fields);\n    if (Object.keys(domains).length < 1) {\n      // no values to decode\n      return requestOptions.queryResponse;\n    }\n\n    // don't mutate original features\n    const decodedFeatures = requestOptions.queryResponse.features.map(\n      (feature: IFeature) => {\n        const decodedAttributes: { [index: string]: any } = {};\n        for (const key in feature.attributes) {\n          /* istanbul ignore next */\n          if (!Object.prototype.hasOwnProperty.call(feature.attributes, key))\n            continue;\n          const value = feature.attributes[key];\n          const domain = domains[key];\n          decodedAttributes[key] =\n            value !== null && domain ? decodeValue(value, domain) : value;\n        }\n        // merge decoded attributes into the feature\n        return { ...feature, ...{ attributes: decodedAttributes } };\n      }\n    );\n    // merge decoded features into the response\n    return {\n      ...requestOptions.queryResponse,\n      ...{ features: decodedFeatures }\n    };\n  });\n}\n\nfunction extractCodedValueDomains(fields: IField[]) {\n  return fields.reduce((domains, field) => {\n    const domain = field.domain;\n    if (domain && domain.type === \"codedValue\") {\n      domains[field.name] = domain;\n    }\n    return domains;\n  }, {} as { [index: string]: any });\n}\n\n// TODO: add type for domain?\nfunction decodeValue(value: any, domain: any) {\n  const codedValue = domain.codedValues.find((d: any) => {\n    return value === d.code;\n  });\n  return codedValue ? codedValue.name : value;\n}\n"]}