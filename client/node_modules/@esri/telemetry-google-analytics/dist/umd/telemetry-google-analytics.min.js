(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.arcgisTelemetry = global.arcgisTelemetry || {}));
})(this, (function (exports) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    const ESRI_TELEMETRY_DATA_ATTRIBUTE = 'esri-telemetry';
    function injectScriptElementAsync(attributes) {
        const onloadPromise = new Promise((resolve, reject) => {
            attributes.onload = resolve;
            attributes.onerror = reject;
            const script = injectScriptElement(attributes);
            if (!script || attributes.body) {
                // this is for the case where the script is already loaded or it has a body instead of a src
                resolve();
            }
        });
        return onloadPromise;
    }
    function scriptExists(attributes) {
        const { id, dataAttribute } = attributes;
        return !!document.getElementById(id) || !!document.querySelector(`[data-${ESRI_TELEMETRY_DATA_ATTRIBUTE}="${dataAttribute}"]`);
    }
    function injectScriptElement(attributes) {
        const { body, src, id, dataAttribute, section = 'body', type = 'text/javascript', async = false, defer = false, onload, onerror } = attributes;
        if (typeof window === 'undefined') {
            throw new WindowUndefinedError('Window is undefined: Cannot add script element.');
        }
        if (scriptExists(attributes)) {
            console.log(`script (${id || dataAttribute}) is already present, skipping`);
            return;
        }
        const scriptElement = createScriptElementWithAttributes({
            id,
            dataAttribute,
            type,
            async,
            defer,
            body,
            src,
            onload,
            onerror
        });
        return section === 'body'
            ? document.body.appendChild(scriptElement)
            : document.head.appendChild(scriptElement);
    }
    class WindowUndefinedError extends Error {
    }
    function createScriptElementWithAttributes({ id, dataAttribute, type, async, defer, body, src, onload, onerror }) {
        const scriptElement = document.createElement('script');
        if (id) {
            scriptElement.id = id;
        }
        if (dataAttribute) {
            scriptElement.setAttribute(`data-${ESRI_TELEMETRY_DATA_ATTRIBUTE}`, dataAttribute);
        }
        src && (scriptElement.src = src);
        body && (scriptElement.innerText = body);
        scriptElement.type = type;
        scriptElement.async = async;
        scriptElement.defer = defer;
        onload && (scriptElement.onload = onload);
        onerror && (scriptElement.onerror = onerror);
        return scriptElement;
    }

    function createScriptTags(scripts) {
        return scripts.map(scriptObj => {
            const attrs = [];
            ['src', 'id', 'dataAttribute', 'type'].forEach(attr => {
                let attrName = attr;
                if (attr === 'dataAttribute') {
                    attrName = 'data-esri-telemetry';
                }
                if (scriptObj[attr]) {
                    attrs.push(`${attrName}="${scriptObj[attr]}"`);
                }
            });
            ['async', 'defer'].forEach(attr => {
                if (scriptObj[attr]) {
                    attrs.push(`${attr}`);
                }
            });
            return `<script ${attrs.join(' ')}>${scriptObj.body ? scriptObj.body : ''}</script>`;
        }).join('');
    }

    /**
     * Class supporting Google Analytics 4
     */
    class GoogleAnalytics {
        constructor(options) {
            var _a;
            this.name = 'googleAnalytics';
            this.dimensions = {};
            this.metrics = {};
            if (typeof window !== 'undefined' && !((_a = options === null || options === void 0 ? void 0 : options.measurementIds) === null || _a === void 0 ? void 0 : _a.length)) {
                // browser environment
                throw new Error('at least one measurementId needs to be provided in your configuration');
            }
            Object.assign(this, options);
        }
        _getScripts() {
            const measurementId = this.measurementIds ? this.measurementIds[0] : '';
            return [
                {
                    dataAttribute: 'google-analytics',
                    async: true,
                    src: `https://www.googletagmanager.com/gtag/js?id=${measurementId}`
                },
            ];
        }
        getScriptTags() {
            return createScriptTags(this._getScripts());
        }
        async init() {
            // for use in a broswer environment
            if (typeof window === 'undefined') {
                throw new WindowUndefinedError('Window is undefined: Cannot add script element.');
            }
            // calls _getScripts() and then iterates over the array and adds dom nodes for each and resolves once all have loaded.
            // injectScriptElementAsync will check if a script with the specified id already exists and, if so, do nothing
            await Promise.all(this._getScripts().map(scriptObj => {
                return injectScriptElementAsync(scriptObj);
            }));
            // runs second script
            this.injectConfig();
        }
        // we log page views manually, even though ga4 can do so automatically for pages now
        logPageView(page, options = {}) {
            const cleanedOptions = this.buildCustomParams(options);
            const pageViewOptionsObject = Object.assign({ page_title: page || window.location.pathname }, cleanedOptions);
            window.gtag('event', 'page_view', pageViewOptionsObject);
            return true;
        }
        logEvent(event) {
            // eventType is name of our event
            let { action } = event, customParams = __rest(event, ["action"]);
            const eventType = action || 'other';
            // if using telemetry wrapper, custom metrics/dimensions in customParams; if not, in options
            const eventParams = this.buildCustomParams(customParams);
            // should have custom metric & dimension data that looks like
            // metric_name: metric_value
            // dimension_name: dimension_value
            window.gtag('event', eventType, eventParams);
            return true;
        }
        disable() {
            if (this.measurementIds) {
                this.measurementIds.forEach(id => {
                    window[`ga-disable-${id}`] = true;
                });
            }
        }
        enable() {
            if (this.measurementIds) {
                this.measurementIds.forEach(id => {
                    window[`ga-disable-${id}`] = undefined;
                });
            }
        }
        // injects configs for each measurement id 
        injectConfig() {
            window.dataLayer = window.dataLayer || [];
            window.gtag = function () { window.dataLayer.push(arguments); };
            window.gtag('js', new Date());
            const configOptions = {
                'custom_map': this.createDimensionsAndMetricsCustomMap(this.dimensions, this.metrics),
                'send_page_view': false,
                'anonymize_ip': true // anonymize ip for each event/page view tracked
            };
            this.measurementIds.forEach(measurementId => {
                window.gtag('config', measurementId, configOptions);
            });
        }
        buildCustomParams(eventParams) {
            let cleanedEventParams;
            let { category, label } = eventParams;
            // verify that all are valid custom metrics/dimensions
            cleanedEventParams = this.verifyCustomDimensionAndMetrics(eventParams);
            // ga3 syntax uses category/action/label, which have been changed
            // to event_category, event_action, and event_label in ga4
            if (category) {
                cleanedEventParams = Object.assign(Object.assign({}, cleanedEventParams), { event_category: category });
            }
            if (label) {
                cleanedEventParams = Object.assign(Object.assign({}, cleanedEventParams), { event_label: label });
            }
            return cleanedEventParams;
        }
        verifyCustomDimensionAndMetrics(eventParams) {
            // all valid metric names and dimension names
            // since we store metrics/dimensions as dimension<index>: dimension_name, we want values
            const metricAndDimensionsMap = this.createDimensionsAndMetricsCustomMap(this.dimensions, this.metrics);
            const metricAndDimensionNames = Object.values(metricAndDimensionsMap);
            // get all keys (name of metric/dimension), 
            // filter out any keys not in valid names, 
            // and then recreate new object with filtered keys and values only
            const cleanedEventParams = Object.keys(eventParams)
                .filter(key => metricAndDimensionNames.includes(key))
                .reduce((cur, key) => { return Object.assign(cur, { [key]: eventParams[key] }); }, {});
            return cleanedEventParams;
        }
        createDimensionsAndMetricsCustomMap(dimensions = {}, metrics = {}) {
            const metricsMap = this.createMetricCustomMap(metrics);
            const dimensionsMap = this.createDimensionCustomMap(dimensions);
            return Object.assign(Object.assign({}, metricsMap), dimensionsMap);
        }
        // under the assumption that our metrics come like { timeMetric: 1, otherMetric: 3} where metric_name: index
        createMetricCustomMap(metrics = {}) {
            return Object.keys(metrics)
                .map(function (key) {
                return {
                    // format of metric<Index>: metric_name
                    key: `metric${metrics[key]}`,
                    value: key
                };
            })
                .filter((val) => val)
                .reduce((acc, { key, value }) => {
                acc[key] = value;
                return acc;
            }, {});
        }
        // under the assumption that our dimensions come like { someAttribute: 7, datasetId: 6} where dimension_name: index
        createDimensionCustomMap(dimensions = {}) {
            return Object.keys(dimensions)
                .map(function (key) {
                return {
                    // format of dimension<Index>: dimension_name
                    key: `dimension${dimensions[key]}`,
                    value: key
                };
            })
                .filter((val) => val)
                .reduce((acc, { key, value }) => {
                acc[key] = value;
                return acc;
            }, {});
        }
    }

    exports.GoogleAnalytics = GoogleAnalytics;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=telemetry-google-analytics.min.js.map
