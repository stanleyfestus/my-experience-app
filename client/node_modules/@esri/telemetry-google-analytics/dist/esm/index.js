import { __rest } from "tslib";
import { createScriptTags, WindowUndefinedError, injectScriptElementAsync } from '@esri/telemetry';
/**
 * Class supporting Google Analytics 4
 */
export class GoogleAnalytics {
    constructor(options) {
        var _a;
        this.name = 'googleAnalytics';
        this.dimensions = {};
        this.metrics = {};
        if (typeof window !== 'undefined' && !((_a = options === null || options === void 0 ? void 0 : options.measurementIds) === null || _a === void 0 ? void 0 : _a.length)) {
            // browser environment
            throw new Error('at least one measurementId needs to be provided in your configuration');
        }
        Object.assign(this, options);
    }
    _getScripts() {
        const measurementId = this.measurementIds ? this.measurementIds[0] : '';
        return [
            {
                dataAttribute: 'google-analytics',
                async: true,
                src: `https://www.googletagmanager.com/gtag/js?id=${measurementId}`
            },
        ];
    }
    getScriptTags() {
        return createScriptTags(this._getScripts());
    }
    async init() {
        // for use in a broswer environment
        if (typeof window === 'undefined') {
            throw new WindowUndefinedError('Window is undefined: Cannot add script element.');
        }
        // calls _getScripts() and then iterates over the array and adds dom nodes for each and resolves once all have loaded.
        // injectScriptElementAsync will check if a script with the specified id already exists and, if so, do nothing
        await Promise.all(this._getScripts().map(scriptObj => {
            return injectScriptElementAsync(scriptObj);
        }));
        // runs second script
        this.injectConfig();
    }
    // we log page views manually, even though ga4 can do so automatically for pages now
    logPageView(page, options = {}) {
        const cleanedOptions = this.buildCustomParams(options);
        const pageViewOptionsObject = Object.assign({ page_title: page || window.location.pathname }, cleanedOptions);
        window.gtag('event', 'page_view', pageViewOptionsObject);
        return true;
    }
    logEvent(event) {
        // eventType is name of our event
        let { action } = event, customParams = __rest(event, ["action"]);
        const eventType = action || 'other';
        // if using telemetry wrapper, custom metrics/dimensions in customParams; if not, in options
        const eventParams = this.buildCustomParams(customParams);
        // should have custom metric & dimension data that looks like
        // metric_name: metric_value
        // dimension_name: dimension_value
        window.gtag('event', eventType, eventParams);
        return true;
    }
    disable() {
        if (this.measurementIds) {
            this.measurementIds.forEach(id => {
                window[`ga-disable-${id}`] = true;
            });
        }
    }
    enable() {
        if (this.measurementIds) {
            this.measurementIds.forEach(id => {
                window[`ga-disable-${id}`] = undefined;
            });
        }
    }
    // injects configs for each measurement id 
    injectConfig() {
        window.dataLayer = window.dataLayer || [];
        window.gtag = function () { window.dataLayer.push(arguments); };
        window.gtag('js', new Date());
        const configOptions = {
            'custom_map': this.createDimensionsAndMetricsCustomMap(this.dimensions, this.metrics),
            'send_page_view': false,
            'anonymize_ip': true // anonymize ip for each event/page view tracked
        };
        this.measurementIds.forEach(measurementId => {
            window.gtag('config', measurementId, configOptions);
        });
    }
    buildCustomParams(eventParams) {
        let cleanedEventParams;
        let { category, label } = eventParams;
        // verify that all are valid custom metrics/dimensions
        cleanedEventParams = this.verifyCustomDimensionAndMetrics(eventParams);
        // ga3 syntax uses category/action/label, which have been changed
        // to event_category, event_action, and event_label in ga4
        if (category) {
            cleanedEventParams = Object.assign(Object.assign({}, cleanedEventParams), { event_category: category });
        }
        if (label) {
            cleanedEventParams = Object.assign(Object.assign({}, cleanedEventParams), { event_label: label });
        }
        return cleanedEventParams;
    }
    verifyCustomDimensionAndMetrics(eventParams) {
        // all valid metric names and dimension names
        // since we store metrics/dimensions as dimension<index>: dimension_name, we want values
        const metricAndDimensionsMap = this.createDimensionsAndMetricsCustomMap(this.dimensions, this.metrics);
        const metricAndDimensionNames = Object.values(metricAndDimensionsMap);
        // get all keys (name of metric/dimension), 
        // filter out any keys not in valid names, 
        // and then recreate new object with filtered keys and values only
        const cleanedEventParams = Object.keys(eventParams)
            .filter(key => metricAndDimensionNames.includes(key))
            .reduce((cur, key) => { return Object.assign(cur, { [key]: eventParams[key] }); }, {});
        return cleanedEventParams;
    }
    createDimensionsAndMetricsCustomMap(dimensions = {}, metrics = {}) {
        const metricsMap = this.createMetricCustomMap(metrics);
        const dimensionsMap = this.createDimensionCustomMap(dimensions);
        return Object.assign(Object.assign({}, metricsMap), dimensionsMap);
    }
    // under the assumption that our metrics come like { timeMetric: 1, otherMetric: 3} where metric_name: index
    createMetricCustomMap(metrics = {}) {
        return Object.keys(metrics)
            .map(function (key) {
            return {
                // format of metric<Index>: metric_name
                key: `metric${metrics[key]}`,
                value: key
            };
        })
            .filter((val) => val)
            .reduce((acc, { key, value }) => {
            acc[key] = value;
            return acc;
        }, {});
    }
    // under the assumption that our dimensions come like { someAttribute: 7, datasetId: 6} where dimension_name: index
    createDimensionCustomMap(dimensions = {}) {
        return Object.keys(dimensions)
            .map(function (key) {
            return {
                // format of dimension<Index>: dimension_name
                key: `dimension${dimensions[key]}`,
                value: key
            };
        })
            .filter((val) => val)
            .reduce((acc, { key, value }) => {
            acc[key] = value;
            return acc;
        }, {});
    }
}
//# sourceMappingURL=index.js.map