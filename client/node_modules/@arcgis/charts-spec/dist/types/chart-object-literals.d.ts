export declare const WebChartTypes: {
    readonly Chart: "chart";
    readonly Text: "chartText";
    readonly Overlay: "chartOverlay";
    readonly Overlays: "chartOverlays";
    readonly Legend: "chartLegend";
    readonly CursorCrosshair: "cursorCrosshair";
    readonly Axis: "chartAxis";
    readonly GaugeAxisTick: "gaugeAxisTick";
    readonly GaugeNeedle: "gaugeNeedle";
    readonly CategoryAxisFormat: "category";
    readonly NumberAxisFormat: "number";
    readonly DateAxisFormat: "date";
    readonly Guide: "chartGuide";
    readonly ScatterSeries: "scatterSeries";
    readonly PieSeries: "pieSeries";
    readonly PieTick: "pieTick";
    readonly GaugeSeries: "gaugeSeries";
    readonly LineSeries: "lineSeries";
    readonly BarSeries: "barSeries";
    readonly HistogramSeries: "histogramSeries";
    readonly BoxPlotSeries: "boxPlotSeries";
    readonly RadarSeries: "radarSeries";
    readonly ProbabilityPlotSeries: "probabilityPlotSeries";
    readonly ProfileGraphSeries: "profileGraphSeries";
    readonly ComboLineAndBarSeries: "comboLineAndBarSeries";
    readonly Buffer: "buffer";
    readonly SizePolicy: "sizeScale";
};
export type WebChartTypes = (typeof WebChartTypes)[keyof typeof WebChartTypes];
export declare const WebChartDataTransformations: {
    readonly None: "none";
    readonly Log: "logarithmic";
    readonly Sqrt: "squareRoot";
};
export type WebChartDataTransformations = (typeof WebChartDataTransformations)[keyof typeof WebChartDataTransformations];
export declare const WebChartColoringPatterns: {
    readonly Single: "singleColor";
    readonly Match: "colorMatch";
};
export type WebChartColoringPatterns = (typeof WebChartColoringPatterns)[keyof typeof WebChartColoringPatterns];
export declare const WebChartLegendPositions: {
    readonly Left: "left";
    readonly Right: "right";
    readonly Top: "top";
    readonly Bottom: "bottom";
};
export type WebChartLegendPositions = (typeof WebChartLegendPositions)[keyof typeof WebChartLegendPositions];
export declare const WebChartStackedKinds: {
    readonly Side: "sideBySide";
    readonly Stacked: "stacked";
    readonly Stacked100: "stacked100";
};
export type WebChartStackedKinds = (typeof WebChartStackedKinds)[keyof typeof WebChartStackedKinds];
export declare const WebChartBoxPlotMultipleSeriesKinds: {
    readonly Side: "sideBySide";
    readonly MeanLines: "meanLines";
};
export type WebChartBoxPlotMultipleSeriesKinds = (typeof WebChartBoxPlotMultipleSeriesKinds)[keyof typeof WebChartBoxPlotMultipleSeriesKinds];
export declare const WebChartProbabilityPlotKinds: {
    readonly General: "qqPlot";
    readonly Normalized: "normalQQPlot";
};
export type WebChartProbabilityPlotKinds = (typeof WebChartProbabilityPlotKinds)[keyof typeof WebChartProbabilityPlotKinds];
export declare const WebChartSortOrderKinds: {
    readonly Ascending: "ASC";
    readonly Descending: "DESC";
};
export type WebChartSortOrderKinds = (typeof WebChartSortOrderKinds)[keyof typeof WebChartSortOrderKinds];
export declare const StatisticsDefaults: {
    readonly statisticType: "count";
    readonly sortingOrder: "ASC";
};
/**
 * Represents the different types of smoothing that can be applied to a line chart when the `lineSmoothed` property is set to `true`.
 */
export declare const WebChartLineSmoothedKinds: {
    readonly Bezier: "bezier";
    readonly MonotoneX: "monotoneX";
    readonly MonotoneY: "monotoneY";
};
export type WebChartLineSmoothedKinds = (typeof WebChartLineSmoothedKinds)[keyof typeof WebChartLineSmoothedKinds];
/**
 * Represents the different types of time intervals that can be applied to a chart using the time binning feature.
 */
export declare const WebChartTimeIntervalUnits: {
    readonly Seconds: "esriTimeUnitsSeconds";
    readonly Minutes: "esriTimeUnitsMinutes";
    readonly Hours: "esriTimeUnitsHours";
    readonly Days: "esriTimeUnitsDays";
    readonly Weeks: "esriTimeUnitsWeeks";
    readonly Months: "esriTimeUnitsMonths";
    readonly Years: "esriTimeUnitsYears";
};
export type WebChartTimeIntervalUnits = (typeof WebChartTimeIntervalUnits)[keyof typeof WebChartTimeIntervalUnits];
/**
 * Represents the different types of null policy that can be applied to a chart using the time binning feature.
 */
export declare const WebChartNullPolicyTypes: {
    readonly Null: "null";
    readonly Zero: "zero";
    readonly Interpolate: "interpolate";
};
export type WebChartNullPolicyTypes = (typeof WebChartNullPolicyTypes)[keyof typeof WebChartNullPolicyTypes];
/**
 * Represents the different types of time aggregation that can be applied to a chart using the time binning feature.
 */
export declare const WebChartTimeAggregationTypes: {
    readonly Start: "equalIntervalsFromStartTime";
    readonly End: "equalIntervalsFromEndTime";
};
export type WebChartTimeAggregationTypes = (typeof WebChartTimeAggregationTypes)[keyof typeof WebChartTimeAggregationTypes];
/**
 * Represents the different types of behaviors that can applied to a chart axis.
 */
export declare const WebChartLabelBehavior: {
    readonly Hide: "hide";
    readonly Rotate: "rotate";
    readonly Stagger: "stagger";
    readonly Wrap: "wrap";
};
export type WebChartLabelBehavior = (typeof WebChartLabelBehavior)[keyof typeof WebChartLabelBehavior];
export declare const WebChartVersionStatus: {
    readonly Same: "same";
    readonly Newer: "newer";
    readonly Older: "older";
    readonly Unrecognized: "unrecognized";
};
export type WebChartVersionStatus = (typeof WebChartVersionStatus)[keyof typeof WebChartVersionStatus];
/**
 * Represents the different types of axes that can be used in a chart.
 */
export declare const WebChartAxisTypes: {
    readonly Value: "value";
    readonly Date: "date";
    readonly Category: "category";
};
export type WebChartAxisTypes = (typeof WebChartAxisTypes)[keyof typeof WebChartAxisTypes];
/**
 * Represents the different types of gauge charts.
 */
export declare const GaugeChartSubTypes: {
    readonly FeatureGauge: "featureGauge";
    readonly StatisticGauge: "statisticGauge";
};
export type GaugeChartSubTypes = (typeof GaugeChartSubTypes)[keyof typeof GaugeChartSubTypes];
/**
 * Represents the types of scales that can be applied to the size policy. Use by bubble charts (scatterplot).
 */
export declare const SizePolicyScaleTypes: {
    readonly Linear: "linear";
    readonly Logarithmic: "logarithmic";
};
export type SizePolicyScaleTypes = (typeof SizePolicyScaleTypes)[keyof typeof SizePolicyScaleTypes];
/**
 * Labels orientation for radar chart axes.
 */
export declare const WebChartRadarChartAxisLabelsOrientation: {
    readonly Radial: "radial";
    readonly Circular: "circular";
    readonly Horizontal: "horizontal";
};
export type WebChartRadarChartAxisLabelsOrientation = (typeof WebChartRadarChartAxisLabelsOrientation)[keyof typeof WebChartRadarChartAxisLabelsOrientation];
/**
 * The types of order assocated with chart data.
 */
export declare const WebChartOrderDataByTypes: {
    readonly YValue: "arcgis-charts-y-value";
    readonly Mean: "arcgis-charts-mean";
    readonly Median: "arcgis-charts-median";
    readonly Category: "arcgis-charts-category";
};
export type WebChartOrderDataByTypes = (typeof WebChartOrderDataByTypes)[keyof typeof WebChartOrderDataByTypes];
/**
 * A data order option that the items are to be ordered either ascending or descending.
 * It can be used for any type of order, like by category, by mean, by median, etc.
 */
export interface WebChartDirectionalDataOrder {
    /**
     * The type of order, eg by category, by mean, by median, or by y value.
     */
    orderType: WebChartOrderDataByTypes;
    /**
     * The direction of the order, either ascending or descending.
     */
    orderBy: WebChartSortOrderKinds;
    /**
     * Indicates whether to order data by the label or the value.
     *
     * For example, when a field has domain coded values or supbtypes, setting this property to `false` will order the data by the field value.
     * Otherwise the domain description, subtypes description, or the alias of the field will be used to sort the data.
     *
     * @default true
     */
    preferLabel?: boolean;
}
/**
 * A data order option for the items to be ordered by `category` based on a predefined list of labels.
 */
export interface WebChartPredefinedLabelsDataOrder {
    /**
     * The type of order, which is by category.
     */
    orderType: "arcgis-charts-category";
    /**
     * The predefined list of labels to order the data by.
     *
     * When the value of the `preferLabel` property is set to `false`, the `orderBy` list should be a list of
     * coded domain values or field names; otherwise, it should be a list of domain descriptions, subtypes descriptions, or field aliases.
     *
     */
    orderBy: string[];
    /**
     * Indicates whether to order data by the label or the value.
     *
     * For example, when a field has domain coded values or supbtypes, setting this property to `false` will order the data by the field value.
     * Otherwise the domain description, subtypes description, or the alias of the field will be used to sort the data.
     *
     * When the value is set to `true` or undefined, the `orderBy` property should contain a list of labels like domain descriptions, subtypes descriptions, or field aliases.
     * When the value is set to `false`, the `orderBy` property should contain a list of coded domain values or field names, in order for the data to be sorted correctly.
     *
     *
     * @default true
     */
    preferLabel?: boolean;
}
/**
 * Order options for split-by series.
 */
export interface WebChartOrderSeriesBy {
    /**
     * When the value is set to true, we want to order the split-by series based on the series' names (alias, custom label, or description).
     *
     * When the value is set to false, we want to order the split-by series based on the series' split-by values.
     *
     * @default true
     */
    preferLabel?: boolean;
    /**
     * The direction of the order.
     *
     * @default WebChartSortOrderKinds.Ascending
     */
    orderBy?: WebChartSortOrderKinds;
}
