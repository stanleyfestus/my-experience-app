/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.31.0-next.103
 */
'use strict';

const index = require('./index-ba28e81f.js');
const index$1 = require('./index-1a3dc635.js');
const actionBarUtils = require('./action-bar-utils-4eba529f.js');
const configUpdate = require('./config-update-440b5828.js');

const chartsBarChartBetaCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.barSeries{flex-grow:1;overflow-y:hidden}.barSeries>div{justify-content:center;align-items:center}.barSeries .arcgis-charts-modal-inside{padding:1em;padding-left:0}.barSeries .arcgis-charts-modal-inside ol{padding-left:2em}.barSeries .arcgis-charts-modal-curtain{width:100%;height:100%;position:absolute;top:0px;left:0px;z-index:2001;background-color:rgb(255, 255, 255);opacity:0.5;opacity:1}.barSeries .arcgis-charts-modal-content{background:rgba(255, 255, 255, 0.8);color:rgb(0, 0, 0);display:inline-block;position:absolute;top:0px;left:0px;max-width:90%;max-height:90%;overflow:visible;z-index:2002;position:absolute;max-width:90%;max-height:90%;width:auto !important;height:auto !important;margin:auto !important;inset:auto !important;left:auto !important;top:auto !important}.barSeries .arcgis-charts-modal-header{display:block;width:100%;min-height:1.8em;background:rgba(0, 0, 0, 0.05)}.barSeries .arcgis-charts-modal-close{display:block;position:absolute;top:0.3em;right:0.3em;background:url(\"data:image/svg+xml;charset=utf-8;base64,PHN2ZyBoZWlnaHQ9IjUxMiIgdmVyc2lvbj0iMSIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ0NS4yIDEwOS4ybC00Mi40LTQyLjRMMjU2IDIxMy42IDEwOS4yIDY2LjhsLTQyLjQgNDIuNEwyMTMuNiAyNTYgNjYuOCA0MDIuOGw0Mi40IDQyLjRMMjU2IDI5OC40bDE0Ni44IDE0Ni44IDQyLjQtNDIuNEwyOTguNCAyNTYiLz48L3N2Zz4=\") center center/80% no-repeat rgba(100, 100, 100, 0.1);width:1.2em;height:1.2em;cursor:pointer}.barSeries .arcgis-charts-modal-title{font-weight:bold;font-size:110%;padding:0.5em 1.2em 0.5em 1em}:host{width:var(--charts-bar-chart-width, var(--arcgis-charts-default-width));height:var(--charts-bar-chart-height, var(--arcgis-charts-default-height));display:flex;flex-direction:row}";
const ArcgisChartsBarChartBetaStyle0 = chartsBarChartBetaCss;

const ArcGISChartsBarChartBeta = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisRuntimeError = index.createEvent(this, "arcgisRuntimeError", 7);
        this.arcgisDataProcessError = index.createEvent(this, "arcgisDataProcessError", 7);
        this.arcgisDataProcessComplete = index.createEvent(this, "arcgisDataProcessComplete", 7);
        this.arcgisLegendItemVisibilityChange = index.createEvent(this, "arcgisLegendItemVisibilityChange", 7);
        this.arcgisUpdateComplete = index.createEvent(this, "arcgisUpdateComplete", 7);
        this.arcgisBadDataWarningRaise = index.createEvent(this, "arcgisBadDataWarningRaise", 7);
        this.arcgisSeriesColorChange = index.createEvent(this, "arcgisSeriesColorChange", 7);
        this.arcgisAxesMinMaxChange = index.createEvent(this, "arcgisAxesMinMaxChange", 7);
        this.arcgisSelectionComplete = index.createEvent(this, "arcgisSelectionComplete", 7);
        this.arcgisNoRenderPropChange = index.createEvent(this, "arcgisNoRenderPropChange", 7);
        this.arcgisSeriesOrder = index.createEvent(this, "arcgisSeriesOrder", 7);
        /**
         * When `true`, the next round of update will be skipped.
         * @type {boolean}
         * @category Private
         * @default false
         */
        this.skipNextUpdate = false;
        /**
         * List of props which should not trigger a render when changed
         * @type {string[]}
         * @category Private
         */
        this.noRenderProps = [
            "disableInteractions",
            "rotation",
            "legendPosition",
            "legendVisibility",
            "view",
        ];
        /**
         * List of props which should trigger a data update
         * @type {string[]}
         * @category Private
         */
        this.dataUpdateNeededProps = [
            "forceDataUpdate",
            "runtimeDataFilters",
            "returnFeaturesExtent",
        ];
        /**
         * List of all the properties updated since the last update. Useful when multiple properties are updated
         * within the same time frame, while some of them require some extra logic to be applied.
         * @type {Set<string>}
         * @category Private
         */
        this.updatedProps = new Set();
        this.config = undefined;
        this.rotation = undefined;
        this.actionMode = undefined;
        this.cursorRange = undefined;
        this.legendPosition = undefined;
        this.legendVisibility = undefined;
        this.hideEmptySeries = undefined;
        this.timeZone = undefined;
        this.view = undefined;
        this.layer = undefined;
        this.selectionData = undefined;
        this.returnSelectionOIDs = undefined;
        this.returnSelectionIndexes = undefined;
        this.returnFeaturesExtent = undefined;
        this.filterBySelection = undefined;
        this.disableInteractions = undefined;
        this.queueChartCreation = undefined;
        this.useAnimatedCharts = undefined;
        this.hideLicenceWatermark = undefined;
        this.enableResponsiveFeatures = undefined;
        this.autoDisposeChart = undefined;
        this.placeholder = undefined;
        this.selectionTheme = undefined;
        this.setTimeBinningInfoWhenNotProvided = undefined;
        this.chartLimits = undefined;
        this.guideTooltipFormatter = undefined;
        this.xAxisLabelFormatter = undefined;
        this.yAxisLabelFormatter = undefined;
        this.messageOptions = undefined;
        this.errorPolicy = actionBarUtils.km.Throw;
        this.disableTogglingLegendItems = undefined;
        this.hideLoaderAnimation = undefined;
        this.runtimeDataFilters = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.layerFilterChangePolicy = actionBarUtils.$m.Refresh;
        this.layerRendererChangePolicy = actionBarUtils.Om.Refresh;
        this.ignoreViewExtent = undefined;
        this.updateSplitBySeries = undefined;
        this.showNotifyPanel = false;
    }
    /**
     * Listener on event coming from the chart container indicating the chart data has been processed
     * emitting an event carrying the data
     * @param {CustomEvent<WebChartGenericDataItem>} event The event carrying the chart data processed by the core
     * @category Custom-event handler
     */
    handleChartOutputDataChange(event) {
        this.arcgisDataProcessComplete.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating a legend item visibility has been changed
     * emitting an event carrying the item id and its new visibility
     * @param {CustomEvent} event The event carrying the item id and its new visibility
     * @category Custom-event handler
     */
    handleLegendItemVisibilityChanged(event) {
        this.arcgisLegendItemVisibilityChange.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating a chart is updated
     * @param {CustomEvent} event The event carrying the ValidationStatus
     * @category Custom-event handler
     */
    handleUpdateCompleted(event) {
        this.arcgisUpdateComplete.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating an error in the data set
     * @param {CustomEvent} event The event carrying details about the error
     * @category Custom-event handler
     */
    handleBadDataWarningRaise(event) {
        this.arcgisBadDataWarningRaise.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating the chart series color
     * have been assigned
     * @param {CustomEvent} event The event carrying the series colors
     * @category Custom-event handler
     */
    handleSeriesColorsChange(event) {
        this.arcgisSeriesColorChange.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container
     * on selection of one or multiple columns
     * @param {CustomEvent<SelectionData>} event The event carrying the selected elements
     * @category Custom-event handler
     */
    handleSelection(event) {
        this.arcgisSelectionComplete.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container
     * when more elements than the authorized limit have been selected.
     * @category Custom-event handler
     */
    handleTooManySelectedElements() {
        if (this.errorPolicy === actionBarUtils.km.Throw) {
            this.notifyHeading = this.errorStrings.tooManySelectedElements.title;
            this.notifyMessage = this.errorStrings.tooManySelectedElements.message;
            this.notifyOptions = {
                kind: "warning",
                autoClose: true,
                duration: "fast",
                active: true,
            };
            this.showNotifyPanel = true;
        }
    }
    /**
     * Listener on event coming from the closure of a calcite-alert.
     * The handler helps keeping in sync the boolean `showNotifyPanel` with the panel's state.
     * @param {CustomEvent} event
     * @category Custom-event handler
     */
    handleAlertClosed(event) {
        // If the calcite-alert (notify panel) from this component is getting closed, we flag it
        if (event.target === this.el) {
            // we don't want the component to re-render so we skip the next update
            this.skipNextUpdate = true;
            this.showNotifyPanel = false;
        }
    }
    /**
     * Listener on event coming from the chart container indicating the chart axes
     * min and max values have been computed
     * @param {CustomEvent} event The event carrying the axes min and max
     * @category Custom-event handler
     */
    handleAxesMinMaxChange(event) {
        this.arcgisAxesMinMaxChange.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating a the series order changed on the chart.
     * @param event The event carrying a list of series id as they are visually ordered on the chart
     * @category Custom-event handler
     */
    handleSeriesOrder(event) {
        this.arcgisSeriesOrder.emit(event.detail);
    }
    /**
     * Called every time the view prop is updated.
     * Add a listener to it to keep the chart in sync.
     * @param {__esri.MapView | __esri.SceneView} newView The new view
     * @param {__esri.MapView | __esri.SceneView} oldView The old view
     * @category Watch handler
     */
    async viewChange(newView, oldView) {
        await this.setExtentChangeListener();
        // The "view" property is flagged as a non-render prop to avoid an unnecessary update when the
        // view is assigned to the component (the update will happen through the view listeners), so we
        // only need to explicitly ask for a refresh when the view is removed from the component
        if (oldView !== undefined && newView === undefined) {
            await this.refresh();
        }
    }
    /**
     * Called every time the layer prop is updated.
     * Adds listeners to it to keep the chart in sync.
     * @category Watch handler
     */
    async layerChange() {
        await this.addLayerListeners();
    }
    /**
     * Called every time the `runtimeDataFilters` prop is updated.
     * The property name is added to the `updatedProps` list in order to trigger later a data update.
     * The mechanism is also done by `componentShouldUpdate` but doesn't always work when multiple properties are
     * updated at the same time (e.g. only 1 `componentShouldUpdate` is called while 2 properties were changed).
     * For that reason all the properties implying a data update (see this.dataUpdateNeededProps) need a @Watch
     * to ensure the chart update to consider them properly.
     * Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6095
     * @category Watch handler
     */
    async runtimeDataFiltersChange() {
        this.updatedProps.add("runtimeDataFilters");
    }
    /**
     * Called every time the `returnFeaturesExtent` prop is updated.
     * The property name is added to the `updatedProps` list in order to trigger later a data update.
     * The mechanism is also done by `componentShouldUpdate` but doesn't always work when multiple properties are
     * updated at the same time (e.g. only 1 `componentShouldUpdate` is called while 2 properties were changed).
     * For that reason all the properties implying a data update (see this.dataUpdateNeededProps) need a @Watch
     * to ensure the chart update to consider them properly.
     * Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6095
     * @category Watch handler
     */
    async returnFeaturesExtentChange() {
        this.updatedProps.add("returnFeaturesExtent");
    }
    /**
     * Called every time the disableInteractions prop is updated.
     * Helps setting a css class on the chart to either enable or disable the chart interactions.
     * @param {boolean} newValue The new value for the disableInteractions property
     */
    async disableInteractionsChange(newValue) {
        // Toggling the interactions only for Firefox. (see issue #2466 for more details)
        if (navigator.userAgent.search("Firefox") !== -1) {
            if (newValue) {
                this.chartRef?.classList.add(configUpdate.HTMLClasses.DisableInteractions);
            }
            else {
                this.chartRef?.classList.remove(configUpdate.HTMLClasses.DisableInteractions);
            }
        }
    }
    /**
     * Called every time the rotation property is updated
     * @param {boolean} newRotation The new rotation value for the chart
     * @category Watch handler
     */
    rotationChange(newRotation) {
        this.config = actionBarUtils.Ln(newRotation, this.config);
    }
    /**
     * Called every time the position of the legend is updated
     * @param {WebChartLegendPositions} newLegendPosition The new position of the legend
     * @category Watch handler
     */
    legendPositionChange(newLegendPosition) {
        this.config = configUpdate.updateLegendPosition(newLegendPosition, this.config);
    }
    /**
     * Called every time the visibility of the legend is updated
     * @param {boolean} newLegendVisibility The new visibility of the legend
     * @category Watch handler
     */
    legendVisibilityChange(newLegendVisibility) {
        this.config = configUpdate.updateLegendVisibility(newLegendVisibility, this.config);
    }
    /**
     * Called every time the time zone is updated
     * @category Watch handler
     */
    timeZoneChange() {
        this.updateConfigTimeZone();
    }
    /**
     * Called every time the filter by selection is updated.
     * Resets the axes min/max.
     * @category Watch handler
     */
    filterBySelectionChanged() {
        this.config = configUpdate.resetAxesBounds(this.config);
    }
    /**
     * Called every time when the property `layerFilterChangePolicy` changes
     * Adds a listener on the layer's filter when the property is `true`, removes it otherwise.
     * @param {LayerFilterChangePolicy | undefined} newRefreshOnLayerFilter The new value of refresh on layer filter
     * @category Watch handler
     */
    layerFilterChangePolicyCallBack(newRefreshOnLayerFilter) {
        if (newRefreshOnLayerFilter !== actionBarUtils.$m.Ignore) {
            this.setLayerFilterListener();
        }
        else {
            this.removeLayerFilterListener();
        }
    }
    /**
     * Called every time when the property `layerRendererChangePolicy` changes
     * Adds a listener on the layer's renderer when the property is `true`, removes it otherwise.
     * @param {LayerFilterChangePolicy | undefined} newRefreshOnLayerRenderer The new value of refresh on layer renderer
     * @category Watch handler
     */
    layerRendererChangePolicyCallBack(newRefreshOnLayerRenderer) {
        if (newRefreshOnLayerRenderer !== actionBarUtils.Om.Ignore) {
            this.setLayerRendererListener();
        }
        else {
            this.removeLayerRendererListener();
        }
    }
    /**
     * Notify method allows passing external messages to the chart component.
     * It can be used to pass validation or information messages.
     * In a situation where a config update is overriding your notification modal,
     * consider waiting for the `arcgisUpdateComplete` event.
     * @param {string} [message] The message to display
     * @param {string} [heading] The heading of the message
     * @param {NotifyOptions} [options] The options to apply to the notification
     * @category Public
     */
    async notify(message, heading, options) {
        if (this.chart !== undefined) {
            this.chart.notify(message, heading, options);
        }
    }
    /**
     * Triggers an alert to display an error message.
     * @category Public
     * @param {string | undefined} [errorMessage]
     */
    async errorAlert(errorMessage) {
        if (this.errorPolicy === actionBarUtils.km.Throw) {
            this.notifyHeading = this.errorStrings.errorHeading;
            this.notifyMessage = errorMessage;
            this.notifyOptions = {
                kind: "danger",
                autoClose: true,
                active: true,
            };
            this.showNotifyPanel = true;
        }
    }
    /**
     * Resets the chart zoom to bring it back to full extent
     * @category Public
     */
    async resetZoom() {
        if (this.chart !== undefined) {
            this.chart.resetZoom();
        }
    }
    /**
     * Switches the selection on the chart.
     * @category Public
     */
    async switchSelection() {
        // for now we don't allow the switch selection when the filter by selection is on
        if (this.chart !== undefined && this.filterBySelection !== true) {
            await this.chart.switchSelection();
        }
    }
    /**
     * Clears all selection on the chart.
     * @category Public
     */
    async clearSelection() {
        if (this.chart !== undefined) {
            this.chart.clearSelection();
            // to handle the full data reset we call the componentDidUpdate to trigger a chart update
            if (this.filterBySelection === true) {
                await this.refresh();
            }
        }
    }
    /**
     * Re-render the chart.
     * @param {boolean} [props.updateData] Indicates whether to fetch new data. Default: true.
     * @param {boolean} [props.updateExtent] Indicates whether the view's extent is to update. Default: false.
     * @param {boolean} [props.resetAxesBounds] Option to reset the axes bounds along with the refresh. Default: false;
     * @category Public
     */
    async refresh(props) {
        const { updateData = true, resetAxesBounds = false, updateExtent = false, } = props ?? {};
        //  Adds a property into `updatedProps` so the debouncedChartUpdate triggers the update
        this.updatedProps.add(updateData ? "forceDataUpdate" : "forceSimpleUpdate");
        this.viewExtentUpdated = updateExtent;
        // Resetting the axes bounds
        if (resetAxesBounds) {
            delete this.config?.axes?.[0]?.minimum;
            delete this.config?.axes?.[0]?.maximum;
            delete this.config?.axes?.[1]?.minimum;
            delete this.config?.axes?.[1]?.maximum;
        }
        await this.componentDidUpdate();
        // reset the boolean for the next update
        this.viewExtentUpdated = false;
    }
    /**
     * Prevents render for noRenderProps
     * @category Lifecycle
     */
    componentShouldUpdate(...args) {
        const [value, , propName] = args;
        // Flagging the property. This list will be used when the chart update is actually called.
        this.updatedProps.add(propName);
        const isNoRenderProp = this.noRenderProps.includes(propName);
        if (isNoRenderProp) {
            this.arcgisNoRenderPropChange.emit({ propName, value });
        }
        const shouldUpdate = !this.skipNextUpdate && !isNoRenderProp;
        this.skipNextUpdate = false;
        return shouldUpdate;
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        this.errorStrings = await configUpdate.fetchErrorsStrings(this.el);
        this.commonStrings = await configUpdate.fetchCommonStrings(this.el);
        // We define the function that will be called to update the chart. We use the external library fastq to queue the updates
        // to make sure only one update is executed at a time
        this.debouncedChartUpdate = configUpdate.promise(async () => {
            if (this.chart !== undefined) {
                const updatedProps = Array.from(this.updatedProps);
                if (updatedProps.length > 0) {
                    // if one of the properties updated require a data update, we flag it
                    // multiple properties can be updated within the same time frame, which will trigger only one Stencil lifecycle
                    const dataUpdateNeeded = updatedProps.some((updatedProp) => this.dataUpdateNeededProps.includes(updatedProp));
                    // clearing the list for the next update
                    this.updatedProps.clear();
                    const updateOptions = configUpdate.gatherComponentOptions({
                        component: this,
                        dataUpdated: dataUpdateNeeded,
                        viewExtentUpdated: this.viewExtentUpdated,
                    });
                    // As long as `addMissingSeries` is true, we try to complete the config with missing series
                    if (this.updateSplitBySeries?.addMissingSeries === true) {
                        await configUpdate.addMissingSplitBySeries(this, updateOptions);
                    }
                    await this.chart.update({
                        newChartConfig: this.config,
                        updateOptions,
                        updateGlobalOptions: configUpdate.gatherComponentGlobalOptions(this),
                        t9nStrings: {
                            errorStrings: this.errorStrings,
                            commonStrings: this.commonStrings,
                        },
                    });
                }
            }
        }, configUpdate.maximumNumberOfSimultaneousUpdates);
    }
    /**
     * @category Lifecycle
     */
    async componentDidLoad() {
        if (this.chartRef !== undefined) {
            await this.createChartInstance();
        }
    }
    /**
     * @category Lifecycle
     */
    async componentDidUpdate() {
        // If this.chartCreationProcessing is still running we need to wait for it to be done before updating the chart
        if (this.chart === undefined &&
            this.chartCreationProcessing !== undefined) {
            await this.chartCreationProcessing;
            this.chartCreationProcessing = undefined;
        }
        // Controlling the series type to display a console error if the type is not the expected one
        // We still proceed to the update to let the config validator deal with the invalid config
        await actionBarUtils.zc([actionBarUtils.WebChartTypes.BarSeries], this.config);
        if (this.config !== undefined &&
            this.chart !== undefined &&
            !this.showNotifyPanel) {
            try {
                // Calling for the chart update if the data source is valid
                if (configUpdate.isValidDataSource(this.config, this.layer)) {
                    await this.debouncedChartUpdate.push();
                }
            }
            catch (e) {
                if (this.chartRef !== undefined) {
                    if (e.name === actionBarUtils.Ol.ChartDisposed) {
                        this.chart.dispose();
                        this.chart = undefined;
                        this.chartRef.innerHTML = "";
                        await this.createChartInstance(false);
                    }
                    else {
                        // sending an event when error occurs.
                        // We don't automatically recreate the chart in that scenario as it would lead to the same result.
                        if (e.name === actionBarUtils.Ol.QueryFeaturesError) {
                            this.arcgisDataProcessError.emit(e.details);
                        }
                        else {
                            this.arcgisRuntimeError.emit(e.details ?? e);
                        }
                        // displaying the error
                        this.errorAlert(e?.message);
                    }
                }
            }
        }
        else if (this.chart === undefined &&
            this.chartCreationProcessing === undefined &&
            !this.showNotifyPanel) {
            await this.createChartInstance();
        }
        else if (this.placeholder !== undefined) {
            this.notify(this.placeholder);
        }
    }
    /**
     * Called when the component is removed from the DOM.
     * @category Lifecycle
     */
    async disconnectedCallback() {
        this.removeLayerListeners();
        this.removeExtentChangeListeners();
        if (this.chart !== undefined) {
            this.chart.dispose();
        }
    }
    /**
     * @category Lifecycle
     */
    render() {
        const notifyPanel = this.showNotifyPanel ? (index.h(configUpdate.ArcgisChartsNotifyPanel, { heading: this.notifyHeading, message: this.notifyMessage, options: this.notifyOptions })) : null;
        // TODO: implement stronger way to know when to keep the chart visible
        const chartStyles = this.showNotifyPanel && this.notifyOptions?.kind === "danger"
            ? configUpdate.HTMLClasses.Hide
            : `${actionBarUtils.WebChartTypes.BarSeries} ${configUpdate.HTMLClasses.Show}`;
        const notifyStyles = this.showNotifyPanel
            ? `${configUpdate.HTMLClasses.Show} ${configUpdate.HTMLClasses.NotifyPanel}`
            : configUpdate.HTMLClasses.Hide;
        return (index.h(index.Host, { key: '6d65dfc5abe94e6fc6c8058882811d750305cecf' }, index.h("slot", { key: 'bc0548bd48426c26a2b7718f7321d84d17335d72', name: actionBarUtils.Slot.actionBar, onSlotchange: (e) => {
                actionBarUtils.onActionBarSlotChange(e, actionBarUtils.WebChartTypes.BarSeries, this.config);
            } }), index.h("div", { key: 'ddace17d4f919d28bfd343f9a600db78e6716945', class: chartStyles, ref: (el) => {
                this.chartRef = el;
            } }), index.h("div", { key: '9c2756f4e61c8a9f28c279044cda5a93b8999f0d', class: notifyStyles }, notifyPanel)));
    }
    /**
     * Adds the listener to listen to the layer definitionExpression and renderer changes
     * @category Private
     */
    async addLayerListeners() {
        // removing existing listeners before adding new ones
        this.removeLayerListeners();
        this.layerFilterListener = await configUpdate.addLayerFilterListener({
            layer: this.layer,
            component: this,
        });
        this.layerRendererListener = await configUpdate.addLayerRendererListener({
            layer: this.layer,
            component: this,
        });
    }
    /**
     * Adds the listener to listen to the layer definitionExpression changes
     * @category Private
     */
    async setLayerFilterListener() {
        this.removeLayerFilterListener();
        this.layerFilterListener = await configUpdate.addLayerFilterListener({
            layer: this.layer,
            component: this,
        });
    }
    /**
     * Adds a listener to listen to the layer's renderer changes when color match is enabled for a layer data source
     * @category Private
     */
    async setLayerRendererListener() {
        this.removeLayerRendererListener();
        this.layerRendererListener = await configUpdate.addLayerRendererListener({
            layer: this.layer,
            component: this,
        });
    }
    /**
     * Adds a listener to listen to the view's extent change
     * @category Private
     */
    async setExtentChangeListener() {
        // removing existing listeners before adding new ones
        this.removeExtentChangeListeners();
        this.extentChangeListeners = await configUpdate.addExtentChangeListener({
            view: this.view,
            layer: this.layer,
            component: this,
        });
    }
    /**
     * Removes the listeners added to listen to the layer definitionExpression and renderer changes
     * @category Private
     */
    removeLayerListeners() {
        this.removeLayerFilterListener();
        this.removeLayerRendererListener();
    }
    /**
     * Removes the layer filter listener when layer definitionExpression changes
     * @category Private
     */
    removeLayerFilterListener() {
        if (this.layerFilterListener !== undefined) {
            this.layerFilterListener.remove();
        }
    }
    /**
     * Removes the layer renderer listener when layer renderer changes
     * @category Private
     */
    removeLayerRendererListener() {
        if (this.layerRendererListener !== undefined) {
            this.layerRendererListener.remove();
        }
    }
    /**
     * Removes the listeners added to listen to the view's extent change
     * @category Private
     */
    removeExtentChangeListeners() {
        if (this.extentChangeListeners !== undefined) {
            this.extentChangeListeners.forEach((listener) => listener.remove());
            this.extentChangeListeners = [];
        }
    }
    /**
     * If the chart config version is newer than the current one, display a message in a popup.
     * @category Private
     */
    checkForIncompatibleChartVersion() {
        const chartVersion = this.config?.version;
        if (this.errorPolicy === actionBarUtils.km.Throw &&
            actionBarUtils.Pc(chartVersion).versionStatus ===
                actionBarUtils.WebChartVersionStatus.Newer) {
            this.notifyHeading = this.errorStrings.incompatibleChartVersion.title;
            this.notifyMessage = actionBarUtils.Kr(this.errorStrings.incompatibleChartVersion.message, {
                chartVersion: chartVersion ?? "",
            });
            this.notifyOptions = {
                kind: "warning",
                autoClose: true,
                active: true,
            };
            this.showNotifyPanel = true;
        }
    }
    /**
     * Updates the config's time zone if needed.
     * @category Private
     */
    updateConfigTimeZone() {
        if (this.config?.axes?.[0]?.valueFormat.type === actionBarUtils.WebChartTypes.DateAxisFormat) {
            this.config.axes[0].valueFormat.intlOptions.timeZone = actionBarUtils.ta(this.timeZone);
        }
    }
    /**
     * creates arcgis chart instance
     * @param {boolean} firstCreation Indicates whether it's the first time the component is created
     * @category Private
     */
    async createChartInstance(firstCreation = true) {
        // If a chart creation is already running (rare case) we wait for it to be done before continuing
        if (this.chartCreationProcessing !== undefined) {
            await this.chartCreationProcessing;
            this.chartCreationProcessing = undefined;
        }
        // Controlling the series type to display a console error if the type is not the expected one
        // We still proceed to the creation to let the config validator deal with the invalid config
        await actionBarUtils.zc([actionBarUtils.WebChartTypes.BarSeries], this.config);
        this.updateConfigTimeZone();
        this.checkForIncompatibleChartVersion();
        this.updatedProps.clear();
        try {
            if (configUpdate.isValidDataSource(this.config, this.layer)) {
                const options = configUpdate.gatherComponentOptions({ component: this });
                await configUpdate.addMissingSplitBySeries(this, options);
                this.chartCreationProcessing = index$1.IV({
                    chartContainer: this.chartRef,
                    chartConfig: this.config,
                    options,
                    globalOptions: configUpdate.gatherComponentGlobalOptions(this),
                    t9nStrings: {
                        errorStrings: this.errorStrings,
                        commonStrings: this.commonStrings,
                    },
                });
            }
            this.chart = await this.chartCreationProcessing;
            this.chartCreationProcessing = undefined;
            // after creating the chart we add listeners on the feature layer and view
            // only adding them if it's the first component creation. `createChartInstance()` can be called
            // when an update failed, and in that case we don't need to add again the listeners given the view
            // or layer didn't change
            if (firstCreation) {
                await this.addLayerListeners();
                await this.setExtentChangeListener();
            }
        }
        catch (e) {
            // sending an event if an error occurs
            if (e.name === actionBarUtils.Ol.QueryFeaturesError) {
                this.arcgisDataProcessError.emit(e.details);
            }
            else {
                this.arcgisRuntimeError.emit(e.details ?? e);
            }
            // displaying the error
            this.errorAlert(e?.message);
            // disposing the chart
            this.chart?.dispose();
            this.chartCreationProcessing = undefined;
            this.chart = undefined;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "view": ["viewChange"],
        "layer": ["layerChange"],
        "runtimeDataFilters": ["runtimeDataFiltersChange"],
        "returnFeaturesExtent": ["returnFeaturesExtentChange"],
        "disableInteractions": ["disableInteractionsChange"],
        "rotation": ["rotationChange"],
        "legendPosition": ["legendPositionChange"],
        "legendVisibility": ["legendVisibilityChange"],
        "timeZone": ["timeZoneChange"],
        "filterBySelection": ["filterBySelectionChanged"],
        "layerFilterChangePolicy": ["layerFilterChangePolicyCallBack"],
        "layerRendererChangePolicy": ["layerRendererChangePolicyCallBack"]
    }; }
};
ArcGISChartsBarChartBeta.style = ArcgisChartsBarChartBetaStyle0;

exports.ArcGISChartsBarChartBeta = ArcGISChartsBarChartBeta;
