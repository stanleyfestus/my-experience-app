/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.31.0-next.103
 */
import { r as registerInstance, c as createEvent, h, H as Host, a as getElement } from './index-81addfc3.js';
import { H as HTMLClasses, u as updateLegendPosition, b as updateLegendVisibility, r as resetAxesBounds, f as fetchErrorsStrings, c as fetchCommonStrings, p as promise, g as gatherComponentOptions, d as gatherComponentGlobalOptions, m as maximumNumberOfSimultaneousUpdates, i as isValidDataSource, e as addLayerFilterListener, h as addLayerRendererListener, j as addExtentChangeListener, W as WY, k as ArcgisChartsNotifyPanel } from './config-update-8321df6d.js';
import { k as km, $ as $m, O as Om, z as zc, W as WebChartTypes, b as Ol, S as Slot, o as onActionBarSlotChange, P as Pc, e as WebChartVersionStatus, K as Kr } from './action-bar-utils-96b03bef.js';

const chartsHistogramCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.histogramSeries{flex-grow:1;overflow-y:hidden}.histogramSeries>div{justify-content:center;align-items:center}.histogramSeries .arcgis-charts-modal-inside{padding:1em;padding-left:0}.histogramSeries .arcgis-charts-modal-inside ol{padding-left:2em}.histogramSeries .arcgis-charts-modal-curtain{width:100%;height:100%;position:absolute;top:0px;left:0px;z-index:2001;background-color:rgb(255, 255, 255);opacity:0.5;opacity:1}.histogramSeries .arcgis-charts-modal-content{background:rgba(255, 255, 255, 0.8);color:rgb(0, 0, 0);display:inline-block;position:absolute;top:0px;left:0px;max-width:90%;max-height:90%;overflow:visible;z-index:2002;position:absolute;max-width:90%;max-height:90%;width:auto !important;height:auto !important;margin:auto !important;inset:auto !important;left:auto !important;top:auto !important}.histogramSeries .arcgis-charts-modal-header{display:block;width:100%;min-height:1.8em;background:rgba(0, 0, 0, 0.05)}.histogramSeries .arcgis-charts-modal-close{display:block;position:absolute;top:0.3em;right:0.3em;background:url(\"data:image/svg+xml;charset=utf-8;base64,PHN2ZyBoZWlnaHQ9IjUxMiIgdmVyc2lvbj0iMSIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ0NS4yIDEwOS4ybC00Mi40LTQyLjRMMjU2IDIxMy42IDEwOS4yIDY2LjhsLTQyLjQgNDIuNEwyMTMuNiAyNTYgNjYuOCA0MDIuOGw0Mi40IDQyLjRMMjU2IDI5OC40bDE0Ni44IDE0Ni44IDQyLjQtNDIuNEwyOTguNCAyNTYiLz48L3N2Zz4=\") center center/80% no-repeat rgba(100, 100, 100, 0.1);width:1.2em;height:1.2em;cursor:pointer}.histogramSeries .arcgis-charts-modal-title{font-weight:bold;font-size:110%;padding:0.5em 1.2em 0.5em 1em}:host{width:var(--charts-histogram-width, var(--arcgis-charts-default-width));height:var(--charts-histogram-height, var(--arcgis-charts-default-height));display:flex;flex-direction:row}";
const ArcgisChartsHistogramStyle0 = chartsHistogramCss;

const ArcGISChartsHistogram = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisRuntimeError = createEvent(this, "arcgisRuntimeError", 7);
        this.arcgisDataProcessError = createEvent(this, "arcgisDataProcessError", 7);
        this.arcgisDataProcessComplete = createEvent(this, "arcgisDataProcessComplete", 7);
        this.arcgisLegendItemVisibilityChange = createEvent(this, "arcgisLegendItemVisibilityChange", 7);
        this.arcgisUpdateComplete = createEvent(this, "arcgisUpdateComplete", 7);
        this.arcgisBadDataWarningRaise = createEvent(this, "arcgisBadDataWarningRaise", 7);
        this.arcgisSeriesColorChange = createEvent(this, "arcgisSeriesColorChange", 7);
        this.arcgisAxesMinMaxChange = createEvent(this, "arcgisAxesMinMaxChange", 7);
        this.arcgisSelectionComplete = createEvent(this, "arcgisSelectionComplete", 7);
        /**
         * When `true`, the next round of update will be skipped.
         * @type {boolean}
         * @category Private
         * @default false
         */
        this.skipNextUpdate = false;
        /**
         * List of props which should not trigger a render when changed
         * @type {string[]}
         * @category Private
         */
        this.noRenderProps = [
            "disableInteractions",
            "legendPosition",
            "legendVisibility",
            "view",
        ];
        /**
         * List of props which should trigger a data update
         * @type {string[]}
         * @category Private
         */
        this.dataUpdateNeededProps = [
            "forceDataUpdate",
            "runtimeDataFilters",
        ];
        /**
         * List of all the properties updated since the last update. Useful when multiple properties are updated
         * within the same time frame, while some of them require some extra logic to be applied.
         * @type {Set<string>}
         * @category Private
         */
        this.updatedProps = new Set();
        this.config = undefined;
        this.actionMode = undefined;
        this.cursorRange = undefined;
        this.legendPosition = undefined;
        this.legendVisibility = undefined;
        this.view = undefined;
        this.layer = undefined;
        this.selectionData = undefined;
        this.returnSelectionOIDs = undefined;
        this.returnSelectionIndexes = undefined;
        this.filterBySelection = undefined;
        this.messageOptions = undefined;
        this.errorPolicy = km.Throw;
        this.disableInteractions = undefined;
        this.queueChartCreation = undefined;
        this.useAnimatedCharts = undefined;
        this.hideLicenceWatermark = undefined;
        this.enableResponsiveFeatures = undefined;
        this.autoDisposeChart = undefined;
        this.placeholder = undefined;
        this.selectionTheme = undefined;
        this.tooltipFormatter = undefined;
        this.dataLabelFormatter = undefined;
        this.guideTooltipFormatter = undefined;
        this.xAxisLabelFormatter = undefined;
        this.yAxisLabelFormatter = undefined;
        this.disableTogglingLegendItems = undefined;
        this.hideLoaderAnimation = undefined;
        this.runtimeDataFilters = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.layerFilterChangePolicy = $m.Refresh;
        this.layerRendererChangePolicy = Om.Refresh;
        this.ignoreViewExtent = undefined;
        this.showNotifyPanel = false;
    }
    /**
     * Listener on event coming from the chart container indicating the chart data has been processed
     * emitting an event carrying the data
     * @param {CustomEvent<WebChartHistogramDataItem>} event The event carrying the chart data processed by the core
     * @category Custom-event handler
     */
    handleChartOutputDataChange(event) {
        this.arcgisDataProcessComplete.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating a legend item visibility has been changed
     * Emitting an event carrying the item id and its new visibility
     * @param {CustomEvent} event The event carrying the item id and its new visibility
     * @category Custom-event handler
     */
    handleLegendItemVisibilityChanged(event) {
        this.arcgisLegendItemVisibilityChange.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating a chart is updated
     * @param {CustomEvent} event The event carrying the ValidationStatus
     * @category Custom-event handler
     */
    handleUpdateCompleted(event) {
        this.arcgisUpdateComplete.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating an error in the data set
     * @param {CustomEvent} event The event carrying details about the error
     * @category Custom-event handler
     */
    handleBadDataWarningRaise(event) {
        this.arcgisBadDataWarningRaise.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating the chart series color
     * have been assigned
     * @param {CustomEvent<SeriesSymbolsMap>} event The event carrying the series colors
     * @category Custom-event handler
     */
    handleSeriesColorsChange(event) {
        this.arcgisSeriesColorChange.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container indicating the chart axes
     * min and max values have been computed
     * @param {CustomEvent} event The event carrying the axes min and max
     * @category Custom-event handler
     */
    handleAxesMinMaxChange(event) {
        this.arcgisAxesMinMaxChange.emit(event.detail);
    }
    /**
     * Listener on event coming from the chart container
     * on selection of one or multiple columns
     * @param {CustomEvent<SelectionData>} event The event carrying the selected elements
     * @category Custom-event handler
     */
    handleSelection(event) {
        this.arcgisSelectionComplete.emit(event.detail);
    }
    /**
     * Listener on event coming from the closure of a calcite-alert.
     * The handler helps keeping in sync the boolean `showNotifyPanel` with the panel's state.
     * @param {CustomEvent} event The event carrying the alert's details
     * @category Custom-event handler
     */
    handleAlertClosed(event) {
        // If the calcite-alert (notify panel) from this component is getting closed, we flag it
        if (event.target === this.el) {
            // we don't want the component to re-render so we skip the next update
            this.skipNextUpdate = true;
            this.showNotifyPanel = false;
        }
    }
    /**
     * Called every time the view prop is updated.
     * Add a listener to it to keep the chart in sync.
     * @param {MapView | SceneView | undefined} newView The new view
     * @param {MapView | SceneView | undefined} oldView The old view
     * @category Watch handler
     */
    async viewChange(newView, oldView) {
        await this.setExtentChangeListener();
        // The "view" property is flagged as a non-render prop to avoid an unnecessary update when the
        // view is assigned to the component (the update will happen through the view listeners), so we
        // only need to explicitly ask for a refresh when the view is removed from the component
        if (oldView !== undefined && newView === undefined) {
            await this.refresh();
        }
    }
    /**
     * Called every time the layer prop is updated.
     * Adds listeners to it to keep the chart in sync.
     * @category Watch handler
     */
    async layerChange() {
        await this.addLayerListeners();
    }
    /**
     * Called every time the `runtimeDataFilters` prop is updated.
     * The property name is added to the `updatedProps` list in order to trigger later a data update.
     * The mechanism is also done by `componentShouldUpdate` but doesn't always work when multiple properties are
     * updated at the same time (e.g. only 1 `componentShouldUpdate` is called while 2 properties were changed).
     * For that reason all the properties implying a data update (see this.dataUpdateNeededProps) need a @Watch
     * to ensure the chart update to consider them properly.
     * Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6095
     * @category Watch handler
     */
    async runtimeDataFiltersChange() {
        this.updatedProps.add("runtimeDataFilters");
    }
    /**
     * Called every time the disableInteractions prop is updated.
     * Helps setting a css class on the chart to either enable or disable the chart interactions.
     * @param {boolean} newValue The new value of the disableInteractions prop
     */
    async disableInteractionsChange(newValue) {
        // Toggling the interactions only for Firefox. (see issue #2466 for more details)
        if (navigator.userAgent.search("Firefox") !== -1) {
            if (newValue) {
                this.chartRef?.classList.add(HTMLClasses.DisableInteractions);
            }
            else {
                this.chartRef?.classList.remove(HTMLClasses.DisableInteractions);
            }
        }
    }
    /**
     * Called every time the position of the legend is updated
     * @param {WebChartLegendPositions} newLegendPosition The new position of the legend
     * @category Watch handler
     */
    legendPositionChange(newLegendPosition) {
        this.config = updateLegendPosition(newLegendPosition, this.config);
    }
    /**
     * Called every time the visibility of the legend is updated
     * @param {boolean} newLegendVisibility The new visibility of the legend
     * @category Watch handler
     */
    legendVisibilityChange(newLegendVisibility) {
        this.config = updateLegendVisibility(newLegendVisibility, this.config);
    }
    /**
     * Called every time the filter by selection is updated.
     * Resets the axes min/max.
     * @category Watch handler
     */
    filterBySelectionChanged() {
        this.config = resetAxesBounds(this.config);
    }
    /**
     * Called every time when the property `layerFilterChangePolicy` changes
     * Adds a listener on the layer's filter when the property is `true`, removes it otherwise.
     * @param newRefreshOnLayerFilter The new value of refresh on layer filter
     * @category Watch handler
     */
    layerFilterChangePolicyCallBack(newRefreshOnLayerFilter) {
        if (newRefreshOnLayerFilter !== $m.Ignore) {
            this.setLayerFilterListener();
        }
        else {
            this.removeLayerFilterListener();
        }
    }
    /**
     * Called every time when the property `layerRendererChangePolicy` changes
     * Adds a listener on the layer's renderer when the property is `true`, removes it otherwise.
     * @param {LayerRendererChangePolicy | undefined} newRefreshOnLayerRenderer The new value of refresh on layer renderer
     * @category Watch handler
     */
    layerRendererChangePolicyCallBack(newRefreshOnLayerRenderer) {
        if (newRefreshOnLayerRenderer !== Om.Ignore) {
            this.setLayerRendererListener();
        }
        else {
            this.removeLayerRendererListener();
        }
    }
    /**
     * Notify method allows passing external messages to the chart component.
     * It can be used to pass validation or information messages.
     * In a situation where a config update is overriding your notification modal,
     * consider waiting for the `arcgisUpdateComplete` event.
     * @param {string} [message] The message to display
     * @param {string} [heading] The heading of the message
     * @param {NotifyOptions} [options] The options to apply to the notification
     * @category Public
     */
    async notify(message, heading, options) {
        if (this.chart !== undefined) {
            this.chart.notify(message, heading, options);
        }
        await Promise.resolve(undefined);
    }
    /**
     * Triggers an alert to display an error message.
     * @category Public
     * @param {string | undefined} [errorMessage] The error message to display
     */
    async errorAlert(errorMessage) {
        if (this.errorPolicy === km.Throw) {
            this.notifyHeading = this.errorStrings.errorHeading;
            this.notifyMessage = errorMessage;
            this.notifyOptions = {
                kind: "danger",
                autoClose: true,
                active: true,
            };
            this.showNotifyPanel = true;
        }
    }
    /**
     * Resets the chart zoom to bring it back to full extent
     * @category Public
     */
    async resetZoom() {
        if (this.chart !== undefined) {
            this.chart.resetZoom();
        }
        await Promise.resolve(undefined);
    }
    /**
     * Switches the selection on the chart.
     * @category Public
     */
    async switchSelection() {
        // for now we don't allow the switch selection when the filter by selection is on
        if (this.chart !== undefined && this.filterBySelection !== true) {
            await this.chart.switchSelection();
        }
    }
    /**
     * Clears all selection on the chart.
     * @category Public
     */
    async clearSelection() {
        if (this.chart !== undefined) {
            this.chart.clearSelection();
            // to handle the full data reset we call the componentDidUpdate to trigger a chart update
            if (this.filterBySelection === true) {
                await this.refresh();
            }
        }
    }
    /**
     * Re-render the chart.
     * @param {boolean | undefined} [props.updateData] Indicates whether to fetch new data. Default: true.
     * @param {boolean | undefined} [props.updateExtent] Indicates whether the view's extent is to update. Default: false.
     * @param {boolean | undefined} [props.resetAxesBounds] Option to reset the axes bounds along with the refresh.
     * @category Public
     */
    async refresh(props) {
        const { updateData = true, resetAxesBounds = false, updateExtent = false, } = props ?? {};
        this.viewExtentUpdated = updateExtent;
        //  Adds a property into `updatedProps` so the debouncedChartUpdate triggers the update
        this.updatedProps.add(updateData ? "forceDataUpdate" : "forceSimpleUpdate");
        // Resetting the axes bounds
        if (resetAxesBounds) {
            delete this.config?.axes?.[1]?.minimum;
            delete this.config?.axes?.[1]?.maximum;
        }
        await this.componentDidUpdate();
        // reset the boolean for the next update
        this.viewExtentUpdated = false;
    }
    /**
     * Prevents render for noRenderProps
     * @category Lifecycle
     */
    componentShouldUpdate(...args) {
        const [, , propName] = args;
        // Flagging the property. This list will be used when the chart update is actually called.
        this.updatedProps.add(propName);
        const shouldUpdate = !this.skipNextUpdate && !this.noRenderProps.includes(propName);
        this.skipNextUpdate = false;
        return shouldUpdate;
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        this.errorStrings = await fetchErrorsStrings(this.el);
        this.commonStrings = await fetchCommonStrings(this.el);
        // We define the function that will be called to update the chart. We use the external library fastq to queue the updates
        // to make sure only one update is executed at a time
        this.debouncedChartUpdate = promise(async () => {
            if (this.chart !== undefined) {
                const updatedProps = Array.from(this.updatedProps);
                if (updatedProps.length > 0) {
                    // if one of the properties updated require a data update, we flag it
                    // multiple properties can be updated within the same time frame, which will trigger only one Stencil lifecycle
                    const dataUpdateNeeded = updatedProps.some((updatedProp) => this.dataUpdateNeededProps.includes(updatedProp));
                    // clearing the list for the next update
                    this.updatedProps.clear();
                    await this.chart.update({
                        newChartConfig: this.config,
                        updateOptions: gatherComponentOptions({
                            component: this,
                            dataUpdated: dataUpdateNeeded,
                            viewExtentUpdated: this.viewExtentUpdated,
                        }),
                        updateGlobalOptions: gatherComponentGlobalOptions(this),
                        t9nStrings: {
                            errorStrings: this.errorStrings,
                            commonStrings: this.commonStrings,
                        },
                    });
                }
                await Promise.resolve(undefined);
            }
        }, maximumNumberOfSimultaneousUpdates);
    }
    /**
     * @category Lifecycle
     */
    async componentDidLoad() {
        if (this.chartRef !== undefined) {
            await this.createChartInstance();
        }
    }
    /**
     * @category Lifecycle
     */
    async componentDidUpdate() {
        // If this.chartCreationProcessing is still running we need to wait for it to be done before updating the chart
        if (this.chart === undefined &&
            this.chartCreationProcessing !== undefined) {
            await this.chartCreationProcessing;
            this.chartCreationProcessing = undefined;
        }
        // Controlling the series type to display a console error if the type is not the expected one
        // We still proceed to the update to let the config validator deal with the invalid config
        await zc([WebChartTypes.HistogramSeries], this.config);
        if (this.config !== undefined &&
            this.chart !== undefined &&
            !this.showNotifyPanel) {
            try {
                // Calling for the chart update if the data source is valid
                if (isValidDataSource(this.config, this.layer)) {
                    await this.debouncedChartUpdate.push();
                }
            }
            catch (e) {
                if (this.chartRef !== undefined) {
                    if (e.name === Ol.ChartDisposed) {
                        this.chart.dispose();
                        this.chart = undefined;
                        this.chartRef.innerHTML = "";
                        await this.createChartInstance(false);
                    }
                    else {
                        // sending an event when error occurs.
                        // We don't automatically recreate the chart in that scenario as it would lead to the same result.
                        if (e.name === Ol.QueryFeaturesError) {
                            this.arcgisDataProcessError.emit(e.details);
                        }
                        else {
                            this.arcgisRuntimeError.emit(e.details ?? e);
                        }
                        // displaying the error
                        this.errorAlert(e?.message);
                    }
                }
            }
        }
        else if (this.chart === undefined &&
            this.chartCreationProcessing === undefined &&
            !this.showNotifyPanel) {
            await this.createChartInstance();
        }
        else if (this.placeholder !== undefined) {
            this.notify(this.placeholder);
        }
    }
    /**
     * Called when the component is removed from the DOM.
     * @category Lifecycle
     */
    async disconnectedCallback() {
        this.removeLayerListeners();
        this.removeExtentChangeListeners();
        if (this.chart !== undefined) {
            this.chart.dispose();
        }
    }
    /**
     * @category Lifecycle
     */
    render() {
        const notifyPanel = this.showNotifyPanel ? (h(ArcgisChartsNotifyPanel, { heading: this.notifyHeading, message: this.notifyMessage, options: this.notifyOptions })) : null;
        // TODO: implement stronger way to know when to keep the chart visible
        const chartStyles = this.showNotifyPanel && this.notifyOptions?.kind === "danger"
            ? HTMLClasses.Hide
            : `${WebChartTypes.HistogramSeries} ${HTMLClasses.Show}`;
        const notifyStyles = this.showNotifyPanel
            ? `${HTMLClasses.Show} ${HTMLClasses.NotifyPanel}`
            : HTMLClasses.Hide;
        return (h(Host, { key: '5c99e18e631d6fac241e7153de80f61cc791fab0' }, h("slot", { key: 'c6d3cf0737fbbf887f9c66480926f992e5a5ccbc', name: Slot.actionBar, onSlotchange: (e) => {
                onActionBarSlotChange(e, WebChartTypes.HistogramSeries, this.config);
            } }), h("div", { key: '8931fd6dc0753f005a9dbdad894da63ffdbe7e08', class: chartStyles, ref: (el) => {
                this.chartRef = el;
            } }), h("div", { key: 'fa4528b76ae6b4a7cdfa026cf11f67199ffd8fae', class: notifyStyles }, notifyPanel)));
    }
    /**
     * Adds the listener to listen to the layer definitionExpression and renderer changes
     * @category Private
     */
    async addLayerListeners() {
        // removing existing listeners before adding new ones
        this.removeLayerListeners();
        this.layerFilterListener = await addLayerFilterListener({
            layer: this.layer,
            component: this,
        });
        this.layerRendererListener = await addLayerRendererListener({
            layer: this.layer,
            component: this,
        });
    }
    /**
     * Adds the listener to listen to the layer definitionExpression changes
     * @category Private
     */
    async setLayerFilterListener() {
        this.removeLayerFilterListener();
        this.layerFilterListener = await addLayerFilterListener({
            layer: this.layer,
            component: this,
        });
    }
    /**
     * Adds a listener to listen to the layer's renderer changes when color match is enabled for a layer data source
     * @category Private
     */
    async setLayerRendererListener() {
        this.removeLayerRendererListener();
        this.layerRendererListener = await addLayerRendererListener({
            layer: this.layer,
            component: this,
        });
    }
    /**
     * Adds a listener to listen to the view's extent change
     * @category Private
     */
    async setExtentChangeListener() {
        // removing existing listeners before adding new ones
        this.removeExtentChangeListeners();
        this.extentChangeListeners = await addExtentChangeListener({
            view: this.view,
            layer: this.layer,
            component: this,
        });
    }
    /**
     * Removes the listeners added to listen to the layer definitionExpression and renderer changes
     * @category Private
     */
    removeLayerListeners() {
        this.removeLayerFilterListener();
        this.removeLayerRendererListener();
    }
    /**
     * Removes the layer filter listener when layer definitionExpression changes
     * @category Private
     */
    removeLayerFilterListener() {
        if (this.layerFilterListener !== undefined) {
            this.layerFilterListener.remove();
        }
    }
    /**
     * Removes the layer renderer listener when layer renderer changes
     * @category Private
     */
    removeLayerRendererListener() {
        if (this.layerRendererListener !== undefined) {
            this.layerRendererListener.remove();
        }
    }
    /**
     * Removes the listeners added to listen to the view's extent change
     * @category Private
     */
    removeExtentChangeListeners() {
        if (this.extentChangeListeners !== undefined) {
            this.extentChangeListeners.forEach((listener) => listener.remove());
            this.extentChangeListeners = [];
        }
    }
    /**
     * If the chart config version is newer than the current one, display a message in a popup.
     * @category Private
     */
    checkForIncompatibleChartVersion() {
        const chartVersion = this.config?.version;
        if (this.errorPolicy === km.Throw &&
            Pc(chartVersion).versionStatus ===
                WebChartVersionStatus.Newer) {
            this.notifyHeading = this.errorStrings.incompatibleChartVersion.title;
            this.notifyMessage = Kr(this.errorStrings.incompatibleChartVersion.message, {
                chartVersion: chartVersion ?? "",
            });
            this.notifyOptions = {
                kind: "warning",
                autoClose: true,
                active: true,
            };
            this.showNotifyPanel = true;
        }
    }
    /**
     * creates arcgis chart instance
     * @param {boolean} [firstCreation] Indicates whether it's the first time the component is created
     * @category Private
     */
    async createChartInstance(firstCreation = true) {
        // If a chart creation is already running (rare case) we wait for it to be done before continuing
        if (this.chartCreationProcessing !== undefined) {
            await this.chartCreationProcessing;
            this.chartCreationProcessing = undefined;
        }
        // Controlling the series type to display a console error if the type is not the expected one
        // We still proceed to the creation to let the config validator deal with the invalid config
        await zc([WebChartTypes.HistogramSeries], this.config);
        this.checkForIncompatibleChartVersion();
        this.updatedProps.clear();
        try {
            if (isValidDataSource(this.config, this.layer)) {
                this.chartCreationProcessing = WY({
                    chartContainer: this.chartRef,
                    chartConfig: this.config,
                    options: gatherComponentOptions({ component: this }),
                    globalOptions: gatherComponentGlobalOptions(this),
                    t9nStrings: {
                        errorStrings: this.errorStrings,
                        commonStrings: this.commonStrings,
                    },
                });
            }
            this.chart = await this.chartCreationProcessing;
            this.chartCreationProcessing = undefined;
            // after creating the chart we add listeners on the feature layer and view
            // only adding them if it's the first component creation. `createChartInstance()` can be called
            // when an update failed, and in that case we don't need to add again the listeners given the view
            // or layer didn't change
            if (firstCreation) {
                await this.addLayerListeners();
                await this.setExtentChangeListener();
            }
        }
        catch (e) {
            // sending an event if a query failed
            if (e.name === Ol.QueryFeaturesError) {
                this.arcgisDataProcessError.emit(e.details);
            }
            else {
                this.arcgisRuntimeError.emit(e.details ?? e);
            }
            // displaying the error
            this.errorAlert(e?.message);
            // disposing the chart
            this.chart?.dispose();
            this.chartCreationProcessing = undefined;
            this.chart = undefined;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return getElement(this); }
    static get watchers() { return {
        "view": ["viewChange"],
        "layer": ["layerChange"],
        "runtimeDataFilters": ["runtimeDataFiltersChange"],
        "disableInteractions": ["disableInteractionsChange"],
        "legendPosition": ["legendPositionChange"],
        "legendVisibility": ["legendVisibilityChange"],
        "filterBySelection": ["filterBySelectionChanged"],
        "layerFilterChangePolicy": ["layerFilterChangePolicyCallBack"],
        "layerRendererChangePolicy": ["layerRendererChangePolicyCallBack"]
    }; }
};
ArcGISChartsHistogram.style = ArcgisChartsHistogramStyle0;

export { ArcGISChartsHistogram as A };
