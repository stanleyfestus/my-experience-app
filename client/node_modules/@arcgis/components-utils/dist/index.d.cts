type Nil = null | undefined;
type IHandle = {
    remove: () => void;
};
/**
 * Identity function - returns back the first parameter
 *
 * Useful when providing a "mapping function" is required, but you have no need
 * to change the value
 */
declare const identity: <T>(value: T) => T;
/**
 * Get back a type whose keys are all marked as mutable (no longer "readonly")
 *
 * It's a best practice to mark all keys as readonly by default in all the
 * interfaces and types you create. Benefits:
 * - Explicitly documents that a given key won't be modified/should not be
 *   modified
 * - Favors more declarative and functional style programming
 * - Helps prevent bugs related to mutation unexpectedly affecting other places
 *   that held a reference to the same object
 *
 * Your function could return a type like "ResolvedConfig", that has all keys
 * marked as readonly. But inside the function you may wish to modify some of
 * the keys while creating the object - casting the object to
 * `Writable<ResolvedConfig>` helps with that
 */
type Writable<T> = {
    -readonly [k in keyof T]: T[k];
};

/**
 * Find a value in an array, and return it's mapped variant.
 */
declare function mappedFind<Item, ReturnType>(array: readonly Item[], callback: (item: Item, index: number) => Nil | ReturnType): ReturnType | undefined;

/**
 * This code contains imperative syntax (like for loops and mutation) as it is
 * in the hot path - performance optimizations are critical here.
 * See https://devtopia.esri.com/WebGIS/arcgis-js-api/commit/2565cedd87b
 *
 * Stencil has native support for passing-in class prop as an object or string,
 * but it does not support arrays or booleans, thus this utility is used
 * instead.
 *
 * @remarks
 * This function is not necessary in a Lit package as Lit's `classMap` directive
 * accepts an object
 */
declare function classes(...classes: (Nil | Record<string, boolean> | string[] | string | false)[]): string;

/**
 * A deferred promise.
 * Useful for when you want to return a promise but don't have the value yet.
 * Example:
 * ```
 * const deferred = new Deferred<string>();
 * setTimeout(() => deferred.resolve("Hello World"), 1000);
 * return deferred.promise;
 * ```
 * @template T The type of the promise.
 */
declare class Deferred<T> {
    /**
     * The promise that can be awaited.
     */
    promise: Promise<T>;
    /**
     * Resolves the promise.
     * @param value The value to resolve the promise with.
     */
    resolve(_value: PromiseLike<T> | T): void;
    /**
     * Rejects the promise.
     */
    reject(_error: unknown): void;
    /**
     * Creates a new deferred promise.
     */
    constructor();
}

/**
 * Observe the element and its ancestors for attribute mutations.
 * If the attributes have been changed in the ancestor tree then the callback will be invoked.
 * Example: `observeAncestorsMutation(element, ["dir", "lang"], () => console.log("dir or lang changed"));`
 * @param element The element on which to observe the attribute mutations.
 * @param attributeFilter The list of attributes to observe.
 * @param callback The callback to invoke when the attributes have been changed.
 * @returns The mutation observer
 */
declare function observeAncestorsMutation(element: Node, attributeFilter: string[], callback: () => void): IHandle;
/**
 * Use the Calcite mode to determine the theme of the element.
 * It will traverse the element's ancestors to find the theme.
 * Shadow DOM boundaries are also taken into account.
 * @param base The element to start the search from.
 * @returns The theme of the element, either "light" or "dark", "light" is the default.
 */
declare function getElementTheme(base: Element): "dark" | "light";
/**
 * Get direction property of closest element.
 * @param el The element to start the search from.
 * @returns The direction of the element, either "ltr" | "rtl", "ltr" is the default.
 */
declare function getElementDir(el: HTMLElement): "ltr" | "rtl";
/**
 * Get the attribute value from the element.
 * It will traverse the element's ancestors to find the attribute.
 * Shadow DOM boundaries are also taken into account.
 * If the attribute is not found then the fallback value is returned.
 * Example: `getElementAttribute(element, "dir", "ltr");`
 * @param base The element to start the search from.
 * @param prop The attribute name.
 * @param fallbackValue The fallback value if the attribute is not found.
 * @returns The attribute value or the fallback value if the attribute is not found.
 */
declare function getElementAttribute(el: Element, prop: string, fallbackValue: string): string;
/**
 * Set the focus on the element that matches the selector.
 * It will traverse the element's ancestors to find the target element.
 * Shadow DOM boundaries are also taken into account.
 * If the element is not found then the focus is not set.
 * Example: `setFocusOnElement(element, "[role='menuitem']");`
 * @param ref The element to start the search from.
 * @param selector The selector to match.
 * @returns Returns true if the focus is set on the element.
 */
declare function setFocusOnElement(ref: Element | null | undefined, selector: string): void;

/**
 * Calls a sync method and catch any errors. Returns undefined if error occurred.
 *
 * Can also provide a thisContext and rest arguments
 */
declare function safeCall<Callback extends (...args: any) => any>(callback?: Callback, thisContext?: ThisParameterType<Callback>, ...rest: Parameters<Callback>): ReturnType<Callback> | void;
/**
 * Calls an async method and catch any errors. Returns undefined if error occurred.
 *
 * Can also provide a thisContext and rest arguments
 */
declare function safeAsyncCall<Callback extends (...args: any) => any>(callback?: Callback, thisContext?: ThisParameterType<Callback>, ...rest: Parameters<Callback>): Promise<Awaited<ReturnType<Callback>> | void>;

/**
 * Generates a GUID string.
 * @returns A GUID string with the pattern 00000000-0000-0000-0000-000000000000.
 */
declare function generateGuid(): string;

/**
 * The interface for translated strings.
 */
interface GenericT9nStrings {
    [key: string]: GenericT9nStrings | string;
}
declare const supportedLocalesArray: readonly ["ar", "bg", "bs", "ca", "cs", "da", "de", "el", "en", "es", "et", "fi", "fr", "he", "hr", "hu", "id", "it", "ja", "ko", "lt", "lv", "nl", "nb", "pl", "pt-BR", "pt-PT", "ro", "ru", "sk", "sl", "sr", "sv", "th", "tr", "uk", "vi", "zh-CN", "zh-HK", "zh-TW"];
/**
 * The list of supported locales for ArcGIS Maps SDK for JavaScript components.
 */
declare const supportedLocales: Set<"hr" | "th" | "tr" | "ar" | "bg" | "bs" | "ca" | "cs" | "da" | "de" | "el" | "en" | "es" | "et" | "fi" | "fr" | "he" | "hu" | "id" | "it" | "ja" | "ko" | "lt" | "lv" | "nl" | "nb" | "pl" | "pt-BR" | "pt-PT" | "ro" | "ru" | "sk" | "sl" | "sr" | "sv" | "uk" | "vi" | "zh-CN" | "zh-HK" | "zh-TW">;
type SupportedLocale = (typeof supportedLocalesArray)[number];
declare const defaultLocale = "en";
/**
 * Fetch the T9N strings bundle for the given locale, assets path and prefix.
 * The locale must be one of the supported locales.
 * If the locale is not supported, it will default to 'en'.
 * If the T9N strings bundle cannot be found, it will default to 'en'.
 *
 * @remarks
 * Rather than using this function directly, prefer the `useT9n()` controller.
 *
 * @example
 * ```ts
 * const t9nStrings = await fetchT9nStringsBundle("en", getAssetPath("./assets/coding-editor/t9n"), "coding-editor.t9n.");
 * ```
 */
declare function fetchT9nStringsBundle<Strings extends GenericT9nStrings>(
/** The locale for which to fetch the T9N strings  */
locale: string, 
/** The path to the assets folder where the T9N strings are located */
assetsPath: string, 
/** The prefix to use for the T9N strings file name. */
prefix?: string): Promise<Strings>;
/**
 * Get the locale of the given element.
 * It will look for the lang attribute on the element and its ancestors.
 * If not lang is found, it will default to 'en'.
 */
declare function getElementLocales(element: HTMLElement): {
    readonly lang: string;
    readonly t9nLocale: SupportedLocale;
};
type LocaleObserver<Strings extends GenericT9nStrings = GenericT9nStrings> = {
    /** The T9N strings of the component */
    t9nStrings: Strings;
    /**
     * The locale of the component set by the `lang` attribute on the component host element or one of its ancestors.
     */
    lang: string;
    /**
     * The locale used by the component to load the T9N strings.
     * It may be different than the locale of the component host element that was set by the `lang` attribute.
     */
    t9nLocale: SupportedLocale;
};
/**
 * Start the locale observer for the given component.
 * The callback will be called when the locale changes for the component.
 * It will observe the lang attribute on the component and its ancestors.
 * The callback is called once at the beginning.
 *
 * @remarks
 * Rather than using this function directly, prefer the `useT9n()` controller.
 */
declare function startLocaleObserver<Strings extends GenericT9nStrings = GenericT9nStrings>(
/** The Web component HTML element that is doing the fetching */
element: HTMLElement, 
/** The path to the assets folder where the T9N strings are located */
assetsPath: string, 
/** The callback to call when the locale changes  */
onUpdated: (payload: LocaleObserver<Strings>) => void, 
/**
 * Optionally override the asset file name.
 * Default file name is the component tag name without the part before the
 * first dash (e.g. `arcgis-map` becomes `map`).
 */
assetName?: string): IHandle;

declare const extractMinorVersion: (version: string) => string;
/**
 * Creates preamble text from a version number. The preamble text is used in stencil.config.ts and inserts a comment at the top of the generated bundles.
 * The preamble text contains the version number and a link to the license.
 * The version number is typically extracted from the package.json file.
 * @example
 * ```ts
 * const preamble = getPreamble("4.18.2-beta.1");
 * console.log(preamble);
 * // All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * // See https://js.arcgis.com/4.18/esri/copyright.txt for details.
 * // v4.18.2-beta.1
 * ```
 * @param version the version number, typically coming from package.json.
 * @returns a string containing the preamble text.
 */
declare const getPreamble: (version: string) => string;

/**
 * Add quotes to a string for display purposes.
 * If the string contains a double quote, then single quotes will be used.
 * If the string contains a single quote, then double quotes will be used.
 * If the string contains both, then double quotes will be used and the single quotes will be escaped.
 * @param value The string to quote
 * @returns The quoted string
 */
declare function quoteString(value: string): string;
/**
 * Create a filter expression from a filter word.
 * @param filterWord The filter word to create the expression from.
 * @returns The filter expression.
 */
declare function createFilterExpression(filterWord: string): RegExp;
/**
 * Replace values in a string using the format {valueName} with the value from the values object.
 * If the value is not found in the values object, then the value is not replaced.
 * @param message The string to replace values in.
 * @param values The values to replace in the string.
 * @returns The string with the values replaced.
 */
declare function setValuesInString(message: string | null | undefined, values?: Record<string, string>): string;
/**
 * Add LTR marks to a string to ensure it is displayed as LTR.
 * @param value The string to add LTR marks to.
 * @returns The string with LTR marks.
 */
declare function addLTRMark(value: string | undefined): string;

/** Convert kebab-case string to PascalCase */
declare const kebabToPascal: (string: string) => string;
/** Convert camelCase string to kebab-case */
declare const camelToKebab: (string: string) => string;
declare const capitalize: <T extends string>(string: T) => Capitalize<T>;
declare const uncapitalize: <T extends string>(string: T) => Uncapitalize<T>;
declare const camelToHuman: (string: string) => string;

/**
 * Like setTimeout(), but does not advance the clock if the program is
 * stopped on a debugger breakpoint.
 *
 * @see https://devtopia.esri.com/WebGIS/arcgis-js-api/discussions/60405
 */
declare function devToolsAwareTimeout(callback: () => void, timeout: number): ReturnType<typeof setInterval>;

/**
 * Safeguard to ensure that an item is not null.
 * @param item The item to check.
 * @returns Returns true if the item is not null.
 */
declare function isNotNull<T>(item: T | null): item is T;
/**
 * Safe guard to ensure that an item is not undefined.
 * @param item The item to check.
 * @returns Returns true if the item is not undefined.
 */
declare function isNotUndefined<T>(item: T | undefined): item is T;

/**
 * Allows to debounce a function.
 * @template F Function type that should extend a function with any parameters and a return type.
 * @param func Function to be debounced
 * @param waitFor Debounce time in milliseconds
 * @returns Returns a function that can be called to debounce the given function.
 */
declare function debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(func: F, waitFor?: number): (...args: Parameters<F>) => void;

/**
 * Compares two url strings for their origin and returns true if they have the same origin.
 * @param url1 First url string
 * @param url2 Second url string
 * @param ignoreProtocol Indicates if protocol comparison should be ignored
 * @returns True if the two url strings have the same origin
 */
declare function hasSameOrigin(url1: string | null | undefined, url2: string | null | undefined, ignoreProtocol?: boolean): boolean;
/**
 * Tests if a url string is a URL or not.
 * @param url The url string to test
 * @returns True if the string is a URL.
 */
declare function isURL(url: string): boolean;

export { Deferred, type GenericT9nStrings, type IHandle, type LocaleObserver, type Nil, type SupportedLocale, type Writable, addLTRMark, camelToHuman, camelToKebab, capitalize, classes, createFilterExpression, debounce, defaultLocale, devToolsAwareTimeout, extractMinorVersion, fetchT9nStringsBundle, generateGuid, getElementAttribute, getElementDir, getElementLocales, getElementTheme, getPreamble, hasSameOrigin, identity, isNotNull, isNotUndefined, isURL, kebabToPascal, mappedFind, observeAncestorsMutation, quoteString, safeAsyncCall, safeCall, setFocusOnElement, setValuesInString, startLocaleObserver, supportedLocales, uncapitalize };
