/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{cyclical2PI as e}from"../../../core/Cyclical.js";import{createAngle as t,valueInUnit as r}from"../../../core/quantityUtils.js";import{subtract as i,dot as n,squaredLength as s,scaleAndAdd as o}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{create as a}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{b as c,d as p,i as g}from"../../../chunks/vec32.js";import{create as h}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{absoluteHeightElevationInfo as l}from"../../../support/elevationInfoUtils.js";import{VerticalHalfPlaneConstraint as d}from"../sketch/constraints.js";import{fromAnyMapPoint as f,asVec2 as m,markAsTarget as u,fromValues as x,fromVec3 as V}from"../sketch/normalizedPoint.js";import{SnappingAlgorithm as E}from"./SnappingAlgorithm.js";import{squaredScreenDistance as j}from"./snappingUtils.js";import{SelfSnappingRightAngleType as v,RightAngleSnappingCandidate as S,OtherVertexType as k}from"./candidates/RightAngleSnappingCandidate.js";import{vectorToScreenPoint as C}from"../support/viewUtils.js";import{radiansGeographicBetweenVec as w,pointFromDistanceAlongAzimuth as y}from"../../support/angularMeasurementUtils.js";import{geodesicDistance as F}from"../../support/geodesicLengthMeasurementUtils.js";class R extends E{snapNewVertex(e,t){const r=t.editGeometryOperations.data.components[0],i=[];if(r.vertices.length<2)return i;const{view:n}=this,s=C(e,t.spatialReference,l,n),o=r.vertices.at(-1);this._checkForSnappingCandidate(v.LastVertex,i,o.leftEdge,o,o.leftEdge.leftVertex,e,s,t);const a=r.vertices[0];return this._checkForSnappingCandidate(v.FirstVertex,i,a.rightEdge,a,a.rightEdge.rightVertex,e,s,t),i}snapExistingVertex(e,t){const r=[],i=t.vertexHandle;if(i.component.vertices.length<3)return r;const{view:n}=this,s=C(e,t.spatialReference,l,n),o=i.leftEdge,a=i.rightEdge;if(o?.leftVertex.leftEdge){const i=o.leftVertex.leftEdge;this._checkForSnappingCandidate(v.ExistingEdge,r,i,i.rightVertex,i.leftVertex,e,s,t)}if(a?.rightVertex.rightEdge){const i=a.rightVertex.rightEdge;this._checkForSnappingCandidate(v.ExistingEdge,r,i,i.leftVertex,i.rightVertex,e,s,t)}return r}_checkForSnappingCandidate(e,t,r,i,n,s,o,a){if(!this.edgeExceedsShortLineThreshold(r,a))return;const c=this.view,p=f(i.pos,c,a),g=f(n.pos,c,a);_(T,g,p,s,a),this._checkForSnappingCandidateAlongProjectedRay(e,t,g,p,T,s,o,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,r,a,p,g,f,E){const{spatialReference:v,pointer:w}=E,y=i(M,m(g),m(a)),F=n(p,y)/s(p),R=o(M,m(a),p,F),_=u(x(R[0],R[1],g[2]));if(j(f,C(_,v,l,this.view))>this.squaredProximityThreshold(w)||this.isVertical(_,a,E)||this.isVertical(a,r,E))return;const P=c(h(),a,p,Math.sign(F));t.push(new S({targetPoint:_,constraint:new d(a,V(P)),previousVertex:r,otherVertex:a,otherVertexType:k.CENTER,selfSnappingType:e,isDraped:"on-the-ground"===E.elevationInfo?.mode}))}}function _(e,t,r,i,n){P(e,t,r,i,n)||U(e,t,r)}function P(i,n,s,o,{spatialReference:a}){const c=w(n,s,a,a);if(null==c)return!1;const g=w(s,o,a,a);if(null==g)return!1;const l=Math.sign(e.shortestSignedDiff(c,g))*Math.PI*.5,d=t(c+l,"radians","geographic"),f=h(),m=F(s,o,a);return null!=m&&(y(f,s,a,r(m,"meters"),d,"geodesic"),p(i,f,s),!0)}function U(e,t,r){const n=i(M,m(r),m(t));g(e,n[1],-n[0],0)}const M=a(),T=h();export{R as RightAngleSnapper};
