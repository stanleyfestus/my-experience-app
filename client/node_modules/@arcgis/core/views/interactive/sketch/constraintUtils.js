/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{valueInUnit as e,createLength as n,createAngle as t}from"../../../core/quantityUtils.js";import{verticalLengthUnitFromSpatialReference as r,lengthUnitFromSpatialReference as o}from"../../../core/unitUtils.js";import{d as i,c as l,g as u}from"../../../chunks/vec32.js";import{projectVectorToVector as s}from"../../../geometry/projection/projectVectorToVector.js";import{geodesicCompatibleSpatialReference as c}from"../../../geometry/support/geodesicUtils.js";import{makeDehydratedPoint as a}from"../../../layers/graphics/dehydratedPoint.js";import{getConvertedElevationFromXYZ as f}from"../../../support/elevationInfoUtils.js";import{CoordinateConstraint as m,constraintOrSet as d,VerticalCylinderConstraint as p,HorizontalPlaneConstraint as v,GeodesicConstraint as g,PointConstraint as R,VerticalHalfPlaneConstraint as j}from"./constraints.js";import{fromPoint as w,createWritable as y,toElevationAlignedDehydratedPoint as h}from"./normalizedPoint.js";import{getDegreesGeographic as x,DirectionMode as S,directionBetweenPoints as I,pointFromDistanceAlongAzimuth as U}from"../../support/angularMeasurementUtils.js";import M from"../../../geometry/SpatialReference.js";function Z(e,n,t,r,o,i){let l="geodesic",u=c(t);const a=y();return w(e,n,r,a),a[2]=0,u&&s(a,t,a,u)||(l="euclidean",u=t),{mode:l,view:n,elevationInfo:r,hasZ:o,directionMode:i,spatialReference:e.spatialReference,measurementSR:u,origin:a}}function b(n,t,r){if(null==t||null==n)return;const i=o(r.measurementSR);if(null==i)return;const l=G(n,r);if(null==l)return;const u=e(t,i);return new p(l,u)}function A(e,n,r,o){if(null==r||null==e)return;const i=G(e,o);if(null==i)return;const l=x(r),u=10,s=e=>{if(null==e)return;const n=y(),r=t(e,"degrees","geographic");return U(n,i,o.measurementSR,u,r,o.mode)?new j(i,n):void 0},c=()=>{if(null!=n&&null!=e)return x(I(n,e))};switch(o.directionMode){case S.Absolute:return s(l);case S.Relative:{const e=c();if(null==e)return;return s(e+l)}case S.RelativeBilateral:{const e=c();if(null==e)return;return d([s(e+l),s(e-l)])}}}function B(e,n){const t=C(e,n);return null!=t?new v(t):void 0}function P(e,n,t){const{context:r,longitude:o,latitude:i,direction:l,distance:u,elevation:s}=t;if(null!=o||null!=i||null!=u||null!=s||null!=l){if(null!=o||null!=i){const e=x(o),n=x(i),t=C(s,r);return new m(e,n,t)}return T(e,n,t)}}function T(n,t,{context:r,direction:o,distance:i,elevation:l}){if(null==t)return B(l,r);const{view:u,elevationInfo:c,measurementSR:a}=r,f=w(t,u,c);if(!a||!s(f,t.spatialReference,E,a))return;const[m,p]=E,v=null!=i?e(i,"meters"):void 0,j=x(o),y=C(l,r),h=e=>{const n=new g([m,p],a,v,y,e);return null==v||null==e||null==y&&r.hasZ?n:new R(n.closestTo(f))};if(null==j)return h(void 0);const U=()=>{if(null!=n&&null!=t)return x(I(n,t))};switch(r.directionMode){case S.Absolute:return h(j);case S.Relative:{const e=U();if(null==e)return;return h(e+j)}case S.RelativeBilateral:{const e=U();if(null==e)return;return d([h(e+j),h(e-j)])}}}function V(e){return"geodesic"===e.context.mode?P(null,null,e):q(e)}function k(e,n,t){const{context:r,x:o,y:i,distance:l,direction:u,elevation:s}=t;return"geodesic"===r.mode?P(n,e,t):null!=o||null!=i?q(t):z([b(e,l,r),A(e,n,u,r),B(s,r)])}function q({x:e,y:n,elevation:t,context:r}){J.x=e?.value??0,J.y=n?.value??0,J.spatialReference=r.spatialReference;const o=G(J,r,F);return new m(null!=e&&null!=o?o[0]:void 0,null!=n&&null!=o?o[1]:void 0,C(t,r))}function z(e){let n;for(const t of e)t&&(n=n?.intersect(t)??t);return n}function G(e,n,t=y()){const{view:r,elevationInfo:o,measurementSR:l,origin:u,mode:c}=n;if(w(e,r,o,t),s(t,e.spatialReference,t,l))return"geodesic"!==c&&i(t,t,u),t}function W(e,n,t,r){const{view:o,measurementSR:i,spatialReference:c,origin:a,mode:f}=t;if("geodesic"===f?l(H,e):u(H,e,a),s(H,i,H,c))return h(H,o,n,t,r)}function C(e,n){return D(e,n)?.value??void 0}function D(t,{view:o,origin:i,elevationInfo:l,hasZ:u,measurementSR:s}){if(null==t||!u)return;const c=r(s);if(null==c)return;const[a,m]=i,d=e(t,c),p="3d"===o?.type?f(o,a,m,d,s,l):d;return null!=p?n(p,c):void 0}const E=y(),F=y(),H=y(),J=a(0,0,0,M.WGS84);export{W as constraintSpaceToPoint,Z as getConstraintContext,P as getGeodesicConstraint,V as getPointConstraint,k as getPolylineOrPolygonConstraint,z as intersectAll,G as pointToConstraintSpace};
