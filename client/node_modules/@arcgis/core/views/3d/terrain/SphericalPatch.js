/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{n as e,i,g as s,h as o,G as n,e as r,f as a,F as l,a as h}from"../../../chunks/vec32.js";import{create as u}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{lonLatToSphericalPCPF as d}from"../../../geometry/projection/lonLatToSphericalPCPF.js";import{newDoubleArray as c}from"../../../geometry/support/DoubleArray.js";import{intersectsSphere as p,numPlanes as f,PlaneIndex as m}from"../../../geometry/support/frustum.js";import{c as g,a as x}from"../../../chunks/sphere.js";import{PatchType as $}from"./interfaces.js";import{createSphericalGlobePatch as _,updateCornerSpherical as v,updateEdgesAndCornersSpherical as M,updateEdgeElevationsAndResolutionsSpherical as S}from"./PatchGeometryFactory.js";import{enableTerrainInternalChecks as b,internalAssert as j,almostEquals as T}from"./terrainUtils.js";import{Tile as E,CenterPosition as B}from"./Tile.js";import{TileFrustumVisibility as H}from"./TileFrustumVisibility.js";import{compareTilesByLij as I}from"./tileUtils.js";class y extends E{constructor(t,e,i,s,o){super(),this._convexHull=new Array(24),this._boundingSphere=g(),this._baseUsedMemory=1816,this.init(t,e,i,s,o)}init(i,s,o,n,r){super.init(i,s,o,n,r);const a=this.ellipsoid.radius,l=this.extentInRadians[0],h=this.extentInRadians[1],u=this.extentInRadians[2],c=this.extentInRadians[3],p=t(h,c,.5),f=t(l,u,.5),m=0===i?0:Math.min(Math.abs(h),Math.abs(c));this._edgeLen=(u-l)*Math.cos(m)*a,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=a-Math.sqrt(a*a-this._edgeLen2/4),d(this.centerAtSeaLevel,f,p,this.ellipsoid.radius),e(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const t=this._center;if(0===this.lij[0])i(x(t[B.MIDDLE]),0,0,0),i(t[B.TOP],0,0,0),i(t[B.BOTTOM],0,0,0),t[B.MIDDLE][3]=this.ellipsoid.radius+this.elevationBoundsMax;else{this._updateCenter();const e=t[B.MIDDLE],i=this.convexHull;let s=0;for(let t=0;t<8;++t)s=Math.max(s,D(x(e),i,3*t));t[B.MIDDLE][3]=Math.sqrt(s)}}_calculateFrustumVisibilityStatus(t){if(!p(t,this._boundingSphere))return H.OUTSIDE;if(this.lij[0]<10)return H.INTERSECTS;const e=this.convexHull,i=this.surface.view.state.camera.near;let s=!0;for(let o=0;o<f;o++){const n=o===m.NEAR,r=t[o],a=r[0],l=r[1],h=r[2],u=r[3]-(n?i:0);let d=!1;for(let t=0;t<8;++t){const i=3*t;if(a*e[i]+l*e[i+1]+h*e[i+2]+u<0){if(d=!0,!s)break}else s=!1}if(!d)return H.OUTSIDE}return s?H.INSIDE:H.INTERSECTS}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){_(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),b&&this._checkBVs()}_updateBoundingSphere(){const t=this._boundingSphere,e=x(t),r=this.elevationBoundsMin,a=this.elevationBoundsMax,l=this.ellipsoid.radius,h=a;if(0===this.level)i(e,0,0,0),t[3]=l+h;else{const i=this.extentInRadians,h=.5*(i[0]+i[2]),u=i[1],d=i[3];O(V,h,u,l),O(A,h,d,l),s(e,V,A);o(e,e,(l+.5*(r+a))/n(e));const c=this.convexHull;let p=0;const f=(t,e)=>{const i=t[0]-c[3*e],s=t[1]-c[3*e+1],o=t[2]-c[3*e+2];return Math.sqrt(i*i+s*s+o*o)};for(let t=0;t<8;++t){const i=f(e,t);p=Math.max(p,i)}const m=p;t[3]=m+2}}_updateConvexHull(){const t=this.extentInRadians,i=this.ellipsoid.radius;if(0===this.level)return;const l=this.elevationBoundsMin,d=this.elevationBoundsMax,c=this._getPatchType(),p=this.surface.isWebMercator,f=p&&c===$.HAS_NORTH_POLE,m=p&&c===$.HAS_SOUTH_POLE,g=m||f,x=Math.PI/2,_=t[0],v=t[2],M=m?-x:t[1],S=f?x:t[3],b=.5*(_+v),E=l,B=i+(g?Math.min(0,E-1):E),H=(t,e,i)=>O(t,e,i,B),I=u(),y=u(),L=u(),D=u();H(I,_,M),H(y,_,S),H(L,v,S),H(D,v,M);const R=(t,e)=>{for(let i=0;i<3;++i)this._convexHull[3*e+i]=t[i]};R(I,0),R(y,1),R(L,2),R(D,3);const V=d,A=i+(g?Math.max(0,V+1):V),C=u(),F=u(),N=u();O(F,b,S,B),O(N,b,M,B),s(C,F,N),e(C,C);const U=u(),k=u(),w=(t,i)=>{h(k,t,i),e(k,k);const n=-a(t,U)/a(k,U);j(n>=0),o(k,k,n),s(t,t,k)};if(2**this.lij[0]>2*this.lij[1]){const t=N,i=u();r(i,P,t),e(i,i),r(U,t,i),e(U,U),j(T(a(U,t)/n(t),0)),w(I,y),w(D,L),R(I,0),R(D,3)}else if(2**this.lij[0]!==2*this.lij[1]){const t=F,i=u();r(i,P,t),e(i,i),r(U,i,t),e(U,U),w(y,I),w(L,D),R(y,1),R(L,2)}const q=(t,e)=>{const i=A/a(e,C);for(let s=0;s<3;++s)this._convexHull[3*t+s]=e[s]*i};q(4,I),q(5,y),q(6,L),q(7,D)}_getPatchType(){const t=this.lij[1],e=0===t,i=t===(1<<this.level)-1;return e?i?$.HAS_BOTH_POLES:$.HAS_NORTH_POLE:i?$.HAS_SOUTH_POLE:$.REGULAR}intersectsRay(t,e,i,s){const o=this._boundingSphere,n=o[3]+i,r=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],a=o[0]-t[0],l=o[1]-t[1],h=o[2]-t[2],u=(a*e[0]+l*e[1]+h*e[2])/r,d=e[0]*u-a,c=e[1]*u-l,p=e[2]*u-h;return d*d+c*c+p*p<n*n}get minimumVerticesPerSide(){return this.level<L.length?L[this.level]+1:2}updateCornerElevations(){v(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){M(this.renderData),this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){S(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!b)return;if(this.level<=2)return;const t=this._boundingSphere,i=t[3],o=x(t),d=u(),p=this.ellipsoid.radius,f=this.elevationBoundsMin,m=this.elevationBoundsMax,g=p+f,$=1,_=0,v=this._center[B.MIDDLE][3],M=this.convexHull,S=(t,e)=>{for(let i=0;i<3;++i)t[i]=M[3*e+i]};{const t=u(),i=u(),s=u(),o=u(),n=u(),l=(l,u,d,c)=>{S(i,l),S(s,u),S(o,d),h(i,i,s),h(o,o,s),r(t,i,o),e(t,t);const p=a(t,s);S(n,c);const f=a(t,n),m=Math.abs(f-p);j(T(m,0),`Non coplanar ${l},${u},${d},${c} diff = ${m}`)};l(0,1,2,3),l(4,5,6,7),l(0,1,4,5),l(1,2,5,6),l(2,3,6,7),l(3,0,7,4)}const E=c(24),H=(t,e,i)=>{const s=4*t;for(let o=0;o<3;++o)E[s+o]=e[o];E[s+3]=i},y=u(),L=u(),D=u(),P=u(),V=(t,i,s,o)=>{S(y,i),S(L,s),S(D,o),h(y,y,L),e(y,y),h(D,D,L),e(D,D),r(P,y,D),e(P,P);const n=a(P,L);H(t,P,n)};V(0,0,1,2),V(1,1,0,4),V(2,1,5,2),V(3,3,2,6),V(4,4,0,3),V(5,4,6,5);const A=1,C=(t,e,i,s)=>{const o=4*t;return E[o]*e+E[o+1]*i+E[o+2]*s-E[o+3]},F=(t,e,i,s)=>C(t,e,i,s)>=-A,N=(t,e)=>F(t,e[0],e[1],e[2]),U=2**this.lij[0]>2*this.lij[1],k=(t,e,s)=>Math.sqrt(R(t,e,s,o[0],o[1],o[2]))<i,w=t=>k(t[0],t[1],t[2]),q=(t,e)=>k(t[e],t[e+1],t[e+2]),G=this.extentInRadians,z=.5*(G[0]+G[2]),W=G[1],J=G[3],K=u(),Q=u();O(K,z,J,g),O(Q,z,W,g);const X=U?"Upper":"Lower";let Y=!0;for(let e=0;e<6;++e){for(let t=0;t<8;++t){const i=3*t,s=F(e,M[i],M[i+1],M[i+2]);Y&&=s,j(s,`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}j(N(e,Q),`Tile[${this.lij}] (${X}) bottom mid outside of plane ${e}`),j(N(e,K),`Tile[${this.lij}] (${X}) top mid outside of plane ${e}`)}j(Y,"Not all convex hull points are inside  convex hull polyhedron"),j(w(Q),`Tile[${this.lij}] (${X}) bottom mid outside of bounding sphere`),j(w(K),`Tile[${this.lij}] (${X}) top mid outside of bounding sphere`);for(let e=0;e<8;++e){const t=q(M,3*e);j(t,`Tile[${this.lij}] Convex hull point ${e} outside of bounding sphere`)}for(let e=0;e<6;++e)for(let t=0;t<8;++t){const i=3*t;F(e,M[i],M[i+1],M[i+2])||console.error(`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}const{extentInRadians:Z}=this,tt=Math.max(Z[2]-Z[0],Z[3]-Z[1]),et=Math.round(tt*p),{renderData:it}=this;if(!it)return;const{geometry:st,geometryState:ot,localOrigin:nt}=it,rt=st.vertexAttributes?.position;if(!rt)return;const at=u(),lt=st.numVerticesPerSide-2,{indices:ht,indexCount:ut,edgeVerticesStartIndex:dt,poleVerticesStartIndex:ct}=st;if(!ht)return;const pt=new Set;for(let e=0;e<ut;++e){const t=ht[e];if(pt.has(t))continue;pt.add(t);const r=t<ct,a=t>=dt;let h=!1,u=-1;if(a){let e=dt;for(let i=0;i<4;++i){const s=ot.edgeResolutions[i];if(t===e||t===e+s-1){h=!0;break}if(e+=s,t<e){u=i;break}}}const c=a?ot.edgePeerNeighbors[u]:null,g=a&&c&&I(this,c)>0;rt.getVec(t,d),s(at,d,nt);const x=n(at)-p;let M=0,S=!1;const b=f-x,j=x-m,T=b>$,E=j>$,B=T||E,H=()=>{const e=r?"internal":a&&!h?"edge":h?"corner":"pole";return`Tile[${this.lij}].vertex[${t}]:${e}`+(T?"(below)":E?"(above)":"")+(g?"(Neighbor)":"")},y=l(at,o);if(y>=i+_){const t=y-i;B||(console.error(`${H()} is out of the bounding sphere by ${t.toFixed(0)} / ${i.toFixed(0)}[tol=${_}] h=${x.toFixed(0)} / [${f.toFixed(0)}..${m.toFixed(0)}] (${(t/i).toFixed(0)})`),S=!0)}for(let e=0;e<6;++e)if(!F(e,at[0],at[1],at[2])){const s=C(e,at[0],at[1],at[2]),o=t%lt,n=(t-o)/lt;0===e&&b||5===e&&j||(console.error(`${H()} (${o},${n})|${lt}] is out of the bounding trapezoid plane ${e} h=${Math.round(x)} / [${Math.round(f)}..${Math.round(m)}] dist=${Math.round(s)} radii = ${Math.round(i)}/${Math.round(v)}} : maxL = ${et}`),++M)}if(S||M>0)break}}get convexHull(){return this._convexHull}}const L=[128,64,64,32,16,8,8,4];function D(t,e,i){return R(t[0],t[1],t[2],e[i],e[i+1],e[i+2])}function R(t,e,i,s,o,n){const r=s-t,a=o-e,l=n-i;return r*r+a*a+l*l}const O=(t,e,i,s)=>{const o=Math.cos(e),n=Math.sin(e),r=Math.cos(i),a=Math.sin(i);t[0]=s*r*o,t[1]=s*r*n,t[2]=s*a},P=[0,0,1],V=u(),A=u();export{y as SphericalPatch};
