/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{n as t,c as r,a as e,f as n,b as i,i as s,F as o,e as u,g as c,h as f,G as a}from"../../../../chunks/vec32.js";import{create as l,freeze as h,fromValues as m}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as p}from"../../../../geometry/ellipsoidUtils.js";import{getSphericalPCPF as d}from"../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectBuffer as _}from"../../../../geometry/projection/projectBuffer.js";import{projectVec3Array as g}from"../../../../geometry/projection/projectVec3Array.js";import{PlaneIndex as S}from"../../../../geometry/support/frustum.js";import{fromValues as b,signedDistance as F}from"../../../../geometry/support/plane.js";import{ViewingMode as G}from"../../../ViewingMode.js";import{Visibility as M}from"./FeatureTileDescriptor.js";import{Frustum as R}from"../../state/Frustum.js";class T{constructor(t,r){this._renderCoordsHelper=t,this._getIsGroundOpaque=r,this._isGroundOpaque=!1,this._cache=new Map,this._cameraForward=l(),this._cameraEye=l(),this._cameraFovY=55*Math.PI/180,this._frustumBoundingSphereCenter=l(),this._frustumBoundingSphereRadius=0,this._frustum=new R(t),this._renderSR=t.spatialReference;const e=d(this._renderSR);this._renderSREllipsoidRadius=p(e).radius}begin(e){this._aboveGround=e.aboveGround,this._isGroundOpaque=this._getIsGroundOpaque(),this._frustum.update(e),t(this._cameraForward,e.viewForward),r(this._cameraEye,e.eye),this._cameraFovY=e.fovY,this._updateFrustumBoundingSphere()}end(){this._cache.clear()}calculate(t){return this._getOrCalculateSingleTileVisibility(t)}_getOrCalculateSingleTileVisibility(t){const r=this._cache.get(t.id);if(null!=r)return r;const e=this._calculateSingleTileVisibility(t);return this._cache.set(t.id,e),e}_calculateSingleTileVisibility(t){return this._calculateSingleTileVisibilitySided(t)}_isTileVisibleInFrustum(t){return this._renderCoordsHelper.viewingMode===G.Local?this._isTileVisibleInFrustumLocal(t):this._isTileVisibleInFrustumGlobal(t)}_updateFrustumBoundingSphere(){const r=this._frustum,s=r.origin,o=D;t(o,r.direction);const u=r.points,c=N;e(c,u[4],s);const f=.5*n(c,c)/n(o,c),a=this._frustumBoundingSphereCenter;i(a,s,o,f);const l=1+f;this._frustumBoundingSphereRadius=l}_isTileVisibleInFrustumLocal(t){const r=t.tilingScheme.spatialReference,u=t.extent,c=this._renderSR,f=C;if(f[0]=u[0],f[1]=u[1],f[2]=0,f[3]=u[2],f[4]=u[3],f[5]=0,!_(f,r,0,f,c,0))return!1;const a=x;s(a[0],f[0],f[1],0),s(a[1],f[3],f[1],0),s(a[2],f[3],f[4],0),s(a[3],f[0],f[4],0);const l=L;s(l,.5*(f[0]+f[3]),.5*(f[1]+f[4]),.5*(f[2]+f[5]));const h=Rt,m=.5*o(a[0],a[2]),p=this._frustum,d=this._frustumBoundingSphereRadius,g=this._frustumBoundingSphereCenter,S=z;e(S,g,l);const b=n(h,S),F=W;i(F,l,h,b);if(o(F,g)>m+d)return!1;const G=this._cameraForward,M=n(G,Rt),R=this._cameraFovY,T=this._cameraEye;if(Math.abs(M)<Math.abs(Math.cos(.5*R))){let t=!0;const r=s(Tt,G[0],G[1],0),e=n(T,r);for(let i=0;i<4;++i){const s=a[i];if(n(s,r)-e>0){t=!1;break}}if(t)return!1}{const t=a[0],r=a[2];if(t[0]<=T[0]&&T[0]<=r[0]&&t[1]<=T[1]&&T[1]<=r[1])return!0}const j=E,y=this._isGroundOpaque&&this._aboveGround,V=this._isGroundOpaque&&!this._aboveGround,I=Math.min(V?bt:1/0,b+d),v=Math.max(y?-bt:-1/0,b-d);for(let e=0;e<4;++e)i(j[e],a[e],h,I),i(j[e+4],a[e],h,v);if(B(p.planes,j,8))return!1;if(O(p.planes,j,8))return!0;for(let e=0;e<4;++e){const t=j[e],r=j[e+4];if(jt(p.planes,t,r))return!0;const n=j[(e+1)%4];if(jt(p.planes,t,n))return!0;const i=j[4+(e+1)%4];if(jt(p.planes,r,i))return!0}if(It[0][3]=+a[0][0],It[1][3]=-a[2][0],It[2][3]=+a[0][1],It[3][3]=-a[2][1],It[4][3]=+v,It[5][3]=-I,O(It,p.points))return!0;if(O(It,p.points))return!0;for(let e=0;e<4;++e){const t=T,r=p.points[e+4];if(yt(It,t,r))return!0;const n=p.points[4+(e+1)%4];if(yt(It,r,n))return!0}return!1}_isTileVisibleInFrustumGlobal(r){if(r.lij[0]<q)return!0;const h=r.tilingScheme.spatialReference,p=r.extent,d=this._isGroundOpaque&&this._aboveGround,_=this._isGroundOpaque&&!this._aboveGround,S=x,b=.5*(p[0]+p[2]);if(s(S[0],p[0],p[1],0),s(S[1],p[2],p[1],0),s(S[2],p[2],p[3],0),s(S[3],p[0],p[3],0),s(S[4],b,p[1],0),s(S[5],b,p[3],0),!g(S,h,0,S,this._renderSR,0,6))return!1;const G=S[0][2]>0,M=S[3][2]<0,R=G||M,T=this._renderSREllipsoidRadius;if(R){const t=m(0,0,1),r=k;j(r,t,S[0]);const e=Y;if(j(e,t,S[1]),G){const n=P,i=S[4],s=H;j(s,i,t),j(n,s,i);const o=S[0];u(o,r,n),V(o,T);const c=S[1];u(c,e,n),V(c,T)}else if(M){const n=P,i=S[5],s=H;j(s,i,t),j(n,i,s);const o=S[3];u(o,n,r),V(o,T);const c=S[2];u(c,n,e),V(c,T)}}const I=L;{const r=e(Z,S[3],S[0]);t(r,r);const s=c($,S[0],S[3]);f(s,s,.5);const o=-n(s,r),u=c(tt,S[0],S[1]);f(u,u,.5);const a=c(rt,S[2],S[3]);f(a,a,.5);const l=e(et,a,u);t(l,l);const h=-(o+n(r,u))/n(r,l);i(I,u,l,h),V(I,T)}const v=this._frustumBoundingSphereRadius,O=this._frustumBoundingSphereCenter,E=this._frustum,C=E.planes,D=A;t(D,I);const N=n(S[0],D)/a(S[0]),W=E.origin,z=E.points;let ut=!1;if(d){{ut=!0;const r=t(l(),W);for(let i=0;i<4;++i){const s=z[4+i],o=e(l(),s,W);t(o,o);const c=u(l(),r,o);t(c,c);const f=u(l(),o,c);t(f,f);if(n(W,f)>T){ut=!1;break}}}if(ut){if(n(W,D)<T*N-bt)return!1}const r=t(Ft,E.origin);if(n(r,D)<0)return!1;{const r=t(Gt,E.direction);if(n(r,D)>Mt)return!1}}const dt=Math.sqrt(1-N*N);if(dt>.9)return!0;let _t=!1;{const t=n(D,O),r=a(O);if(r<=v&&!C.some((t=>F(t,J)>0))){if(!d)return!0;_t=!0}const e=t/r;if(!_t&&t<=0){if(-t>v)return!1}const i=v/r;if(Math.sqrt(1-e*e)*Math.sqrt(1-i*i)-i*e>dt)return!1}if(!ut){if(S.some((t=>E.intersectsPoint(t))))return!0;if(E.intersectsPoint(I))return!0}const gt=K;e(gt,O,J);const Rt=n(gt,D),Tt=U;f(Tt,D,Rt);const jt=o(Tt,O),yt=h.isWGS84,Vt=r.lij,It=yt&&Vt[2]===2**Vt[0]-1,vt=yt&&0===Vt[2],Bt=vt?ht:It?at:ct,Ot=vt?mt:It?lt:ft;if(!_t){const t=S,r=pt,e=nt,n=it,i=J;for(const s of Bt){const o=t[s];if(y(e,t[(s+1)%4],o),y(n,i,o),j(r,n,e),w(r,z,1))return!1}}let qt=null;if(!d&&Rt<1.01*v){const t=2.5*v;if(jt>N*t+v)return!1;const r=X,e=t/N;for(let n=0;n<4;++n)f(r[n],S[n],e/T);s(r[4],0,0,0),qt=r}else{const t=(_?T+bt:Rt+v)/N,r=d?T-bt:(Rt-v)/N,e=Q;for(let n=0;n<4;++n){const i=S[n];f(e[n],i,r/T),f(e[n+4],i,t/T)}qt=e}if(B(C,qt,qt.length))return!1;const wt=E.lines,Et=st,Ct=ot;for(const n of wt){t(Ct,n.direction);for(const r of Ot){const n=qt[r];if(t(Et,n),St(Ct,Et,qt,z))return!1;const i=(r+1)%4;if(d){const r=qt[i];if(e(Et,r,n),t(Et,Et),St(Ct,Et,qt,z))return!1}if(_){const n=qt[4+r],s=qt[4+i];if(e(Et,s,n),t(Et,Et),St(Ct,Et,qt,z))return!1}}}return!0}_calculateSingleTileVisibilitySided(t){return this._isTileVisibleInFrustum(t)?M.VISIBLE:M.INVISIBLE}}function j(r,e,n){return u(r,e,n),t(r,r),r}function y(r,n,i){return e(r,n,i),t(r,r),r}function V(t,r){return f(t,t,r/a(t)),t}const I=[S.LEFT,S.RIGHT,S.BOTTOM,S.TOP,S.FAR];function v(t,r,e){for(let n=0;n<e;++n)if(F(t,r[n])<=0)return!1;return!0}function B(t,r,e){for(const n of I)if(v(t[n],r,e))return!0;return!1}function O(t,r,e=r.length){for(let n=0;n<e;++n){const e=r[n];let i=!0;for(const r of t){if(F(r,e)>0){i=!1;break}}if(i)return!0}return!1}const q=2;function w(t,r,e){for(const i of r)if(n(i,t)<e)return!1;return!0}const E=[l(),l(),l(),l(),l(),l(),l(),l()],C=[0,0,0,0,0,0],x=[l(),l(),l(),l(),l(),l()],L=l(),P=l(),k=l(),Y=l(),H=l(),A=l(),U=l(),D=l(),N=l(),W=l(),z=l(),J=h(0,0,0),K=l(),Q=[l(),l(),l(),l(),l(),l(),l(),l()],X=[l(),l(),l(),l(),l()],Z=l(),$=l(),tt=l(),rt=l(),et=l(),nt=l(),it=l(),st=l(),ot=l(),ut=l(),ct=[0,1,2,3],ft=[0,1,2,3],at=[0,1,3],lt=[0,1,3],ht=[1,2,3],mt=[1,2,3],pt=l();function dt(t,r,e){let i=1/0,s=-1/0;for(const o of e){const t=n(r,o);i=Math.min(i,t),s=Math.max(s,t)}t[0]=i,t[1]=s}function _t(t,r,e,i){let s=1/0,o=-1/0;for(const u of i){const i=n(e,u);if(s=Math.min(s,i),o=Math.max(o,i),s<=r&&o>=t)return!1}return!0}const gt=[0,0];function St(t,r,e,n){if(0===e.length||0===n.length)return!0;const i=ut;j(i,t,r);const s=n[0]<e[0],o=s?e:n,u=gt;return dt(u,i,s?n:e),_t(u[0],u[1],i,o)}const bt=430,Ft=l(),Gt=l(),Mt=Math.cos(.25*Math.PI),Rt=m(0,0,1),Tt=l();function jt(t,r,e){const n={t0:0,t1:1};for(const i of I){if(!Vt(t[i],r,e,n))return!1}return n.t0<n.t1}function yt(t,r,e){const n={t0:0,t1:1};for(const i of t){if(!Vt(i,r,e,n))return!1}return n.t0<n.t1}function Vt(t,r,e,n){let{t0:i,t1:s}=n;const o=F(t,r),u=F(t,e);if(o>=0&&u>=0)return!1;if(o<0&&u>=0){const t=-o/(u-o);if(t<i)return!1;t<s&&(s=t)}else if(o>=0&&u<0){const t=o/(o-u);if(t>s)return!1;t>i&&(i=t)}return n.t0=i,n.t1=s,!0}const It=[b(-1,0,0,1),b(1,0,0,-1),b(0,-1,0,1),b(0,1,0,-1),b(0,0,-1,1),b(0,0,1,-1)];export{T as FeatureTileVisibility3D,q as globalTileLevelThreshold,O as isAnyVertexInPolyhedron,B as isConvexHullOutsideOfFrustum};
