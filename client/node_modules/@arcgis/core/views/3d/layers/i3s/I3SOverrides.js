/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../request.js";import r from"../../../../core/Accessor.js";import{splitIntoChunks as i}from"../../../../core/arrayUtils.js";import{createTask as s,resultOrAbort as o,result as n}from"../../../../core/asyncUtils.js";import{estimateStringByteSize as a,estimateNumberByteSize as d}from"../../../../core/byteSizeEstimations.js";import c from"../../../../core/Collection.js";import{makeHandle as h}from"../../../../core/handleUtils.js";import"../../../../core/has.js";import l from"../../../../core/Logger.js";import{abortMaybe as u,destroyMaybe as m}from"../../../../core/maybe.js";import{whenOrAbort as p,createResolver as g}from"../../../../core/promiseUtils.js";import y from"../../../../core/ReactiveSet.js";import{watch as f,sync as b}from"../../../../core/reactiveUtils.js";import{property as _}from"../../../../core/accessorSupport/decorators/property.js";import{subclass as v}from"../../../../core/accessorSupport/decorators/subclass.js";import{equals as O}from"../../../../geometry/support/spatialReferenceUtils.js";import{formatNumber as j}from"../../../../intl/number.js";import{getMaximumQuerySize as C,queryAllJSON as I}from"../../../../layers/support/featureQueryAll.js";import{assetMapFromAssetMapsJSON as w,extractMesh as A}from"../../../../rest/support/meshFeatureSet.js";import{isTimeoutError as F}from"../../../../support/requestUtils.js";import{ViewingMode as x}from"../../../ViewingMode.js";let G=class extends r{constructor(e){super(e),this._warnMaximumChangedObjectsExceeded=!1,this._maximumNumberOfEditOVerrides=E,this._definitionExpressionDirty=!0,this._interactiveEditingSessions=new c,this.geometryOverrides=new c,this._clientGeometryCache=new Map,this._attributeChangedObjectIds=new y,this._geometryChangedObjectIds=new y,this._pendingFetchChangedObjectIds=null,this._pendingFetchAbortController=new AbortController,this._applyGeometryOverridesTask=null,this._featureIdLocks=new Map}initialize(){this._memCache=this.memoryController.newCache(`i3s-attribute-overrides-${this.layer.uid}`),this.addHandles(f((()=>this.layer.definitionExpression),(async()=>{this._definitionExpressionDirty=!0,this._pendingFetchChangedObjectIds||(this._applyGeometryOverridesTask=u(this._applyGeometryOverridesTask),this._applyGeometryOverridesTask=s((e=>this._queryAndAddGeometryOverrides(e))),await this._applyGeometryOverridesTask.promise)}),b)),this._pendingFetchChangedObjectIds=this._fetchChangedObjectIds(this._pendingFetchAbortController?.signal),this._pendingFetchChangedObjectIds.finally((()=>{this._pendingFetchAbortController=null,this._pendingFetchChangedObjectIds=null}))}destroy(){this._set("layer",null),this._memCache=m(this._memCache),this._pendingFetchAbortController=u(this._pendingFetchAbortController),this._pendingFetchChangedObjectIds=null,this._featureIdLocks.clear()}get is3DOFL(){return null!=this._associatedLayer?.infoFor3D}get sortedGeometryChangedObjectIds(){return this.is3DOFL?[...this._geometryChangedObjectIds].sort(((e,t)=>e-t)):[]}get _associatedLayer(){return null==this.layer?null:this.layer.associatedLayer}get hasGeometryChanges(){return this._geometryChangedObjectIds.size>0}get updating(){return!!this.is3DOFL&&!!(this._pendingFetchChangedObjectIds||this._applyGeometryOverridesTask&&!this._applyGeometryOverridesTask.finished)}get isEmpty(){return null==this._pendingFetchChangedObjectIds&&0===this._attributeChangedObjectIds.size&&0===this._geometryChangedObjectIds.size}featureHasGeometryChanges(e){return this._geometryChangedObjectIds.has(e)}featureHasAttributeChanges(e){return this._attributeChangedObjectIds.has(e)}createInteractiveEditSession(e){this._attributeChangedObjectIds.add(e);const t=this._interactiveEditingSessions,r=new L(e,(()=>{t.remove(r)}));return t.unshift(r),r}async applyAttributeOverrides(e,t,r,i=[]){if(this._pendingFetchChangedObjectIds&&await p(this._pendingFetchChangedObjectIds,r),null==t)return;const{attributeData:s,loadedAttributes:o}=t;if(null==o||null==s||0===this._attributeChangedObjectIds.size)return;const n=new Set;for(const d of o)n.add(d.index);for(const d of i)n.has(d.index)||(o.push(d),s[d.name]=new Array(e.length));const a=await this._lockFeatureIds(e);try{const t={attributeData:s,loadedAttributes:o},i=this._getOverridesFromCache(e,t,this._attributeChangedObjectIds),{objectIds:n,fieldNames:a}=i;if(0===n.length||0===a.length)return;const d=await this._queryAttributeOverridesFromAssociatedLayer(n,a,r);if(null==d)return;this._processOverridesFromAssociatedLayer(e,d,a,t)}finally{a.remove()}}updateGeometry(e,t){this._geometryChangedObjectIds.add(e);const r=this._clientGeometryCache.get(e);if(null!=r&&(this.geometryOverrides.remove(r),this._clientGeometryCache.delete(e)),null!=t){const r={oid:e,mesh:t};this.geometryOverrides.add(r),this._clientGeometryCache.set(e,r)}}updateAttributeValue(e,t,r){this._attributeChangedObjectIds.add(e),this._cacheAttributeValue(e,t,r)}featureAdded(e){this.is3DOFL&&this._geometryChangedObjectIds.add(e),this._attributeChangedObjectIds.add(e)}_cacheAttributeValue(e,t,r){this._memCache.put(this._getAttributeCacheKey(e,t),r,this._memCacheAttributeValueSize(r))}_getOverridesFromCache(e,{loadedAttributes:t,attributeData:r},i){const s=new Set,o=new Array;for(const a of t)o[a.index]=r[a.name];const n=new Set;for(let a=0;a<e.length;a++){const r=e[a];if(i.has(r))for(const e of t){const t=this._attributeFromCache(r,e.index);void 0===t?(s.add(r),n.add(e.name)):o[e.index][a]=t}}return{objectIds:Array.from(s),fieldNames:Array.from(n)}}_attributeFromCache(e,t){const r=this._fromInteractiveEditingSession(e,t);if(void 0!==r)return r;const i=this._getAttributeCacheKey(e,t);return this._memCache.get(i)}_fromInteractiveEditingSession(e,t){if(null!=this._interactiveEditingSessions)for(const r of this._interactiveEditingSessions){if(r.objectId!==e)continue;const i=r.getAttribute(t);if(void 0!==i)return i}}_getAttributeCacheKey(e,t){return`${e}-${t}`}async _queryAttributeOverridesFromAssociatedLayer(e,t,r){if(0===e.length)return null;this._logWarningIfMaximumObjectsExceeded();const{associatedLayer:i}=this.layer;if(null==i)return null;const s=i.createQuery(),{objectIdField:o}=i,n=[o,...t];s.where=this.layer.definitionExpression||"1=1",s.returnGeometry=!1,s.outFields=n,s.cacheHint=!0;const a=await this._executeBatchQuery(i,e,s,r),d=[];for(const c of a)if(c.ok)for(const e of c.value.features)d.push(e);return d}async _queryGeometryOverridesFromAssociatedLayer(e,t){if(0===e.length||!this.is3DOFL)return null;const r=this.layer.associatedLayer,i=r.infoFor3D,{spatialReference:s}=r,{state:{viewingMode:o},spatialReference:n}=this.view,a=o===x.Global,d=s.isGeographic;if(a&&!d)return l.getLogger(this).warn("unsupported-pcs-edits-in-global-view",this.layer.title,k(s,n,this.view.viewingMode,M.Mode)),null;if(!a&&d)return l.getLogger(this).warn("unsupported-gcs-edits-in-local-view",this.layer.title,k(s,n,this.view.viewingMode,M.Mode)),null;if(!(O(s,n)||a&&n.isWebMercator&&s.isWGS84))return l.getLogger(this).warn("unsupported-mismatched-spatial-reference-edits",this.layer.title,k(s,n,this.view.viewingMode,M.SpatialReference)),null;this._logWarningIfMaximumObjectsExceeded();const{objectIdField:c,globalIdField:h}=r,u=[c,...null!=h?[h]:[]],m=r.createQuery();m.where=this.layer.definitionExpression||"1=1",m.returnGeometry=!0,m.outFields=u,m.cacheHint=!0,m.returnZ=r.hasZ,m.returnM=r.hasM;const p=await this._executeBatchQuery(r,e,m,t),g=[];for(const l of p){if(!l.ok)continue;const e=l.value,{assetMaps:t,features:r,globalIdFieldName:o}=e;if(null==t)continue;const n=w(i,t);for(const a of r){const e=A(a,o,s,i,n),t=a;null!=e?(t.geometry=e,g.push(t)):t.geometry=null}}return g}_logWarningIfMaximumObjectsExceeded(){if(!this._warnMaximumChangedObjectsExceeded)return;this._warnMaximumChangedObjectsExceeded=!1;let e=`The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${j(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;const t=this.layer.portalItem;e+=t?.loaded?` (${t.portal.url}/home/item.html?id=${t.id}#settings)`:` (${this.layer.parsedUrl.path})`,l.getLogger(this).warn("#queryOverrides()",this.layer.title,`${e}.`)}async _executeBatchQuery(e,t,r,s){if(0===t.length)return[];const n=C(e);t=[...t].sort(((e,t)=>e-t));const a=i(t,n).map((t=>{const i=r.clone();return i.objectIds=t,o(I(e,i,{signal:s}))}));return Promise.all(a)}_processOverridesFromAssociatedLayer(e,t,r,{loadedAttributes:i,attributeData:s}){const o=this._associatedLayer;if(null==o)return;const n=o.objectIdField,a=r.map((t=>(t in s||(s[t]=new Array(e.length)),s[t]))),d=new Map(i.map((e=>[e.name,e.index]))),c=r.map((e=>d.get(e))),h=new Map(Array.from(e,((e,t)=>[e,t])));for(const l of t){const e=l.attributes[n];for(let t=0;t<r.length;t++){const i=c[t],s=h.get(e),o=l.attributes[r[t]];a[t][s]=o,this._cacheAttributeValue(e,i,o)}}}_memCacheAttributeValueSize(e){return"string"==typeof e?a(e):d()}async _fetchChangedObjectIds(e){const r=this.layer;await r.load({signal:e}),this._geometryChangedObjectIds.clear(),this._attributeChangedObjectIds.clear();const{associatedLayer:i}=r;if(null==i||!i.capabilities?.operations?.supportsChangeTracking)return;const s=this._getFetchChangedObjectIdsServerGen();if(null==s)return;const o=i.layerId,a=this.is3DOFL,d={f:"json",returnIdsOnly:!0,layers:`[${o}]`,returnUpdates:!0,returnDeletes:a,returnInserts:a,layerServerGens:JSON.stringify([{id:o,serverGen:s}])};if(a){const e=i.infoFor3D;d.fieldsToCompare=JSON.stringify({fields:[...Object.values(e.transformFieldRoles),e.sourceHashField]})}const c=await n(t(`${i.url}/extractChanges`,{method:"post",query:d,timeout:S,signal:e}));if(!c.ok&&F(c.error)){const e=this.layer.title;l.getLogger(this).warn("extractChanges:timeout",e,`${e} could not obtain edited features that are not cached in the scene service. Display of features may not be up to date with the latest edits. Consider re-caching the scene service.`)}if(c.ok&&1===c.value.data?.edits?.length){const t=c.value.data.edits[0],r=t?.objectIds,i=t?.fieldUpdates,s=r?.adds??[],o=r?.updates??[],n=r?.deletes??[],d=[...s,...o,...n],h=a?[...s,...i??o,...n]:[],l=Math.min(this._maximumNumberOfEditOVerrides,d.length);l<d.length&&(this._warnMaximumChangedObjectsExceeded=!0);const u=d.sort(((e,t)=>e-t));for(let e=0;e<l;++e){const t=u[e];this._attributeChangedObjectIds.add(t)}for(const e of h)this._geometryChangedObjectIds.add(e);for(;this._definitionExpressionDirty;)await this._queryAndAddGeometryOverrides(e)}}async _queryAndAddGeometryOverrides(e){this._definitionExpressionDirty=!1;const t=this.layer,{associatedLayer:r}=t;if(null!=r&&r.capabilities?.operations?.supportsChangeTracking&&this.is3DOFL&&this._geometryChangedObjectIds.size>0){const t=await this._queryGeometryOverridesFromAssociatedLayer(Array.from(this._geometryChangedObjectIds),e);if(null!=t)for(const e of t)null!=e.geometry&&this.updateGeometry(e.attributes[r.objectIdField],e.geometry)}}_getFetchChangedObjectIdsServerGen(){const e=this.layer;if(null!=e.serviceUpdateTimeStamp?.lastUpdate)return e.serviceUpdateTimeStamp.lastUpdate;const t=e.associatedLayer;return null!=t?.serverGens?.minServerGen?t.serverGens.minServerGen:null}async _lockFeatureIds(e){const t=this._featureIdLocks;let r=!0;for(;r;){const i=new Array;for(const r of e){const e=t.get(r);e&&i.push(e)}0===i.length?r=!1:await Promise.all(i)}const i=g(),s=i.promise;for(const o of e)t.set(o,s);return h((()=>{for(const r of e)t.delete(r);i.resolve()}))}get test(){}};e([_({constructOnly:!0})],G.prototype,"view",void 0),e([_({constructOnly:!0})],G.prototype,"layer",void 0),e([_({readOnly:!0})],G.prototype,"is3DOFL",null),e([_()],G.prototype,"_interactiveEditingSessions",void 0),e([_({readOnly:!0})],G.prototype,"sortedGeometryChangedObjectIds",null),e([_({readOnly:!0})],G.prototype,"geometryOverrides",void 0),e([_()],G.prototype,"_clientGeometryCache",void 0),e([_()],G.prototype,"_associatedLayer",null),e([_({constructOnly:!0})],G.prototype,"memoryController",void 0),e([_()],G.prototype,"_attributeChangedObjectIds",void 0),e([_()],G.prototype,"_geometryChangedObjectIds",void 0),e([_()],G.prototype,"hasGeometryChanges",null),e([_()],G.prototype,"_pendingFetchChangedObjectIds",void 0),e([_()],G.prototype,"_pendingFetchAbortController",void 0),e([_()],G.prototype,"_applyGeometryOverridesTask",void 0),e([_()],G.prototype,"updating",null),e([_()],G.prototype,"isEmpty",null),G=e([v("esri.views.3d.layers.i3s.I3SOverrides")],G);class L{constructor(e,t){this.objectId=e,this._remove=t,this._updates=new Map,this._isActive=!0}getAttribute(e){return this._updates.get(e)}setAttribute(e,t){this.isActive&&this._updates.set(e,t)}remove(){this.isActive&&(this._isActive=!1,this._remove())}get isActive(){return this._isActive}}const S=1e4,E=5e4;var M;function k(e,t,r,i){return`Displaying the edits of a SceneLayer with a${i===M.Mode?e.isGeographic?" geographic ":" projected ":" "}spatial reference (wkid:${e.wkid}) in ${r} viewing mode${i===M.SpatialReference?` with spatial reference (wkid:${t.wkid}) `:" "}is not supported. No geometry edits will be displayed for this layer.\nPlease consider re-caching the scene service or changing the ${i===M.Mode?"viewing mode":"view spatial reference"} to display edits.`}!function(e){e[e.Mode=0]="Mode",e[e.SpatialReference=1]="SpatialReference"}(M||(M={}));export{G as I3SOverrides};
