/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{assertIsSome as t}from"../../../../core/maybe.js";import{MinPriority as r}from"../../../../core/MemCache.js";import{throwIfAborted as o}from"../../../../core/promiseUtils.js";import{generateUUID as n}from"../../../../core/uuid.js";import{normalFromMat4 as s}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as i}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{p as a}from"../../../../chunks/vec32.js";import{ONES as l}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectBoundingSphere as d}from"../../../../geometry/projection/projectBoundingSphere.js";import{isRelativeVertexSpace as u}from"../../../../geometry/support/meshVertexSpaceUtils.js";import{l as c}from"../../../../chunks/sphere.js";import{convertMeshMaterialToPBRMaterial as m}from"./I3SClientMaterialUtil.js";class h{constructor(e,t,r,o){this._uid=e,this._worker=o,this._id2Meta=new Map,this._oid2Meta=new Map,this._indexSR=t.indexSR,this._vertexSR=t.vertexSR,this._renderSR=t.renderSR,this._memCache=r.newCache(`sl-client-mesh-data-${this._uid}`)}get uid(){return this._uid}get worker(){return this._worker}get indexSR(){return this._indexSR}get renderSR(){return this._renderSR}createMeshNodeInfo(e,t){const r=`mesh${t}`,o=e.extent,n=o.spatialReference,s=this._indexSR,i=p(o,e.origin);d(i,n,i,s);return{type:"mesh",id:r,version:M(e),oid:t,mbs:i,componentNodeIds:[],unloadedMesh:e,nodeIndex:null,loadMeshPromise:null}}addMeshNode(t,r){if(null!=this.getMeshNodeIndex(r.oid))throw new e(`I3SClientNodeLoader: client side mesh for feature oid=${r.oid} already exists`);r.nodeIndex=t,this._id2Meta.set(r.id,r),this._oid2Meta.set(r.oid,r)}getMeshNodeIndex(e){const t=this._oid2Meta.get(e);return null==t||"mesh"!==t.type?null:t.nodeIndex}getMeshNodeInfo(e){const t=this._oid2Meta.values();for(const r of t)if("mesh"===r.type&&r.id===e)return r;return null}removeNode(e){const t=this._id2Meta.get(e);null!=t&&(this._id2Meta.delete(e),"mesh"===t.type&&this._oid2Meta.delete(t.oid))}async loadNodeJSON(t){const r=this._id2Meta.get(t);if(null==r)throw new e(`I3SClientNodeLoader::loadNodeJSON unable to find node ${t}`);switch(r.type){case"mesh":return this._loadMeshNodeJSON(r);case"mesh-component":return f(r);default:throw new e(`I3SClientNodeLoader::loadNodeJSON unable to handle node ${t}`)}}async _loadMeshNodeJSON(e){const t=e.id,r=(await this._getMeshData(e)).loadedMesh;if(null==r.components||0===r.components.length)return{id:t,version:null,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null};const o=[],n=r.components;for(let s=0;s<n.length;++s){const r=`${t}-component${s}`,n={type:"mesh-component",id:r,mbs:e.mbs,componentIndex:s,meshNodeInfo:e,textureData:new Map};this._id2Meta.set(n.id,n),e.componentNodeIds.push(r),o.push({id:n.id,href:null,mbs:n.mbs,obb:null})}return{id:t,version:null,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:o}}updateNodeIndex(e,t,r){const o=this._id2Meta.get(e);o&&"mesh"===o.type&&(o.nodeIndex=r)}async loadNodeData(r,n){const s=this._id2Meta.get(r);if(null==s||"mesh-component"!==s.type)throw new e(`Failed to load client node data for node ${r} (unexpected node info)`);const i=s.meshNodeInfo,a=await this._getMeshData(i),l=a.loadedMesh,d=i.oid;if(null==l.components)throw new e(`Failed to load client node data for node ${r} (unexpected null reference)`);const u=l.components[s.componentIndex],{material:c,requiredTextures:h,textureData:f}=await m(u.material);if(null!=f)for(const e of f)null!=e&&s.textureData.set(e.id,e);const p={params:{material:c},type:"ArrayBufferView"},{vertexSpace:g,origin:M,transform:S}=l,w=[M.x,M.y,M.z??0];a.projectionPromise||(t(this._worker,"SceneLayerWorker is needed to project mesh"),a.projectionPromise=this._worker.project({positions:l.vertexAttributes.position,localMatrix:S?.localMatrix,vertexSpace:g.toJSON(),origin:w,inSpatialReference:l.spatialReference.toJSON(),outSpatialReference:this._vertexSR.toJSON()},n));const{projected:b,original:_,projectedOrigin:N}=await a.projectionPromise;l.vertexAttributes.position=_;const{transformed:v,original:D}=await x(u,a,this._worker,n);l.vertexAttributes.normal=D,o(n);const{geometryBuffer:I,geometryDescriptor:R}=y(b,u.faces,v,l.vertexAttributes.uv,l.vertexAttributes.color,d);return{geometryData:{featureDataPosition:N,featureIds:[],geometries:[p]},attributeDataInfo:{attributeData:{},loadedAttributes:[]},geometryBuffer:I,geometryDescriptor:R,requiredTextures:h,textureData:f,normalReferenceFrame:this._vertexSR.isGeographic?"east-north-up":"vertex-reference-frame"}}async loadAttributes(e,t,r){const o=e.numFeatures,n={};for(const{field:{name:s}}of t)n[s]=new Array(o);return n}async loadTextures(e,t,r){const o=e.id,n=this._id2Meta.get(o);if(null==n||"mesh-component"!==n.type)throw new Error(`Failed to load textures for node ${e.id} (unexpected node info)`);const s=[];for(const i of t)s.push(n.textureData.get(i.id)||null);return s}async _getMeshData(e){const t=e.version,o=this._memCache.get(t);if(null==o){if(null!=e.loadMeshPromise)return e.loadMeshPromise;const o=async(o,n)=>{const s=e.unloadedMesh.clone();try{await s.load()}catch(l){n(l)}const i=s.memoryUsage,a={loadedMesh:s,projectionPromise:null,normalsTransformPromise:null,usedMemoryInBytes:i};this._memCache.put(t,a,i,r),e.loadMeshPromise=null,o(a)};return e.loadMeshPromise=new Promise(((e,t)=>o(e,t))),e.loadMeshPromise}return o}}async function f(e){return{id:e.id,version:e.meshNodeInfo.version,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null,isEmpty:!1}}function p(e,t){const{spatialReference:r}=e,o=[1,-1],n=[.5*e.width,.5*e.height,e.hasZ?.5*(e.zmax-e.zmin):0],s=r.isGeographic?r.metersPerUnit:1,i=e.center;let a=0;if(e.hasZ)for(let l=0;l<2;++l)for(let e=0;e<2;++e)for(let r=0;r<2;++r){const d=(i.x+o[l]*n[0]-t.x)*s,u=(i.y+o[e]*n[1]-t.y)*s,c=i.z+o[r]*n[2]-t.z;a=Math.max(d*d+u*u+c*c,a)}else for(let l=0;l<2;++l)for(let e=0;e<2;++e){const r=(i.x+o[l]*n[0]-t.x)*s,d=(i.y+o[e]*n[1]-t.y)*s;a=Math.max(r*r+d*d,a)}return c([t.x,t.y,t.z],Math.sqrt(a))}async function x(e,r,o,n){const{transform:d,vertexAttributes:u}=r.loadedMesh,c="source"===e.shading?u.normal:null;if(!(null!=c&&null!=d&&(0!==d.rotationAngle||!a(d.scale,l))))return{transformed:c,original:u.normal};if(!r.normalsTransformPromise){t(o,"SceneLayerWorker is needed to transform mesh normals");const e=i();s(e,d.localMatrix),r.normalsTransformPromise=o.transformNormals({normalMatrix:e,normals:c},n)}return r.normalsTransformPromise}function y(e,t,r,o,n,s){const i=1,a=t.length/3,l=3*a;let d=0,u=0,c=!1,m=0,h=!1,f=0,p=!1,x=0,y=0,M=0;d+=S,d+=S,u=d,d+=3*l*w,null!=r&&(c=!0,m=d,d+=3*l*w),null!=o&&(h=!0,f=d,d+=2*l*w),null!=n&&(p=!0,x=d,d+=4*l*b),y=d,d+=i*_,M=d,d+=2*i*S;const N=new ArrayBuffer(d),v=new Uint8Array(N);g(v,0,l),g(v,S,i);const D=new Float32Array(N,u),I=null!=r?new Float32Array(N,m):null,R=null!=o?new Float32Array(N,f):null,j=null!=n?new Uint8Array(N,x):null;for(let g=0;g<a;++g){const s=3*g;for(let i=0;i<3;++i){const a=t[s+i],l=3*a,d=9*g+3*i;if(D[d]=e[l],D[d+1]=e[l+1],D[d+2]=e[l+2],null!=I&&(I[d]=r[l],I[d+1]=r[l+1],I[d+2]=r[l+2]),null!=R){const e=2*a,t=6*g+2*i;R[t]=o[e],R[t+1]=o[e+1]}if(null!=j){const e=4*a,t=12*g+4*i;j[t]=n[e],j[t+1]=n[e+1],j[t+2]=n[e+2],j[t+3]=n[e+3]}}}g(v,y,s),g(v,y+S,s/2**32),g(v,M,0),g(v,M+S,a-1);return{geometryBuffer:N,geometryDescriptor:{isDraco:!1,isLegacy:!0,color:p,normal:c,uv0:h,uvRegion:!1,featureIndex:!0}}}function g(e,t,r){e[t]=255&r,e[t+1]=255&r>>8,e[t+2]=255&r>>16,e[t+3]=255&r>>24}function M(e){const t=e.metadata.displaySource?.source;if(null==t||!Array.isArray(t)||!t.length||t[0]instanceof File)return n();const r=t;let o="";for(const n of r)o+=n.makeHash();return o+JSON.stringify(e.transform?.toJSON()??"")+(u(e.vertexSpace)?JSON.stringify(e.vertexSpace.origin):"")+JSON.stringify(e.spatialReference)}const S=4,w=4,b=1,_=8;export{h as I3SClientNodeLoader,p as createSphereFromExtent,w as sizeOfFloat32,S as sizeOfInt32,_ as sizeOfUInt64,b as sizeOfUInt8,x as transformNormals};
