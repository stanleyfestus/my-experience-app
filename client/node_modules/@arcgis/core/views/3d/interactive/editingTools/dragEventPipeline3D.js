/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../../../geometry.js";import{screenPointObjectToArray as e,castScreenPointArray as r,createScreenPointArray as n}from"../../../../core/screenUtils.js";import{create as t}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{l as o,c as l,e as s,d as c,f as a,h as i,g as u}from"../../../../chunks/vec32.js";import{create as p}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectPoint as m}from"../../../../geometry/projection.js";import{intersectRay as d,create as f,getNormal as g,fromPositionAndNormal as E}from"../../../../geometry/support/plane.js";import{create as y,closestPoints as S}from"../../../../geometry/support/ray.js";import{projectPoint as j}from"../../../../geometry/support/vector.js";import{sv2d as v}from"../../../../geometry/support/vectorStacks.js";import{getZForElevationMode as R}from"../../../../support/elevationInfoUtils.js";import{fromScreen as x}from"../../support/geometryUtils/ray.js";import{newIntersector as b}from"../../webgl-engine/lib/Intersector.js";import{StoreResults as w,IntersectorType as I}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{terrainId as H}from"../../webgl-engine/lib/verticalOffsetUtils.js";import{EventPipeline as U}from"../../../interactive/dragEventPipeline.js";import O from"../../../../geometry/Point.js";function C(e,r){return T(e,(()=>r))}function P(e){return T(e,(e=>e.plane))}function T(n,t){const o=p(),l=p();let s=!1;return c=>{const a=t(c);if("start"===c.action){const t=e(c.screenStart,r(v.get())),l=x(n.state.camera,t,Q);null!=l&&(s=d(a,l,o))}if(!s)return null;const i=e(c.screenEnd,r(v.get())),u=x(n.state.camera,i,Q);return null==u?null:d(a,u,l)?{...c,renderStart:o,renderEnd:l,plane:a,ray:u}:null}}function D(e,r,t=0,o=null,l=null){let s=null;return c=>{if("start"===c.action&&(s=e.sceneIntersectionHelper.intersectElevationFromScreen(n(c.screenStart.x,c.screenStart.y),r,t,l),null!=s&&null!=o&&!m(s,s,o)))return null;if(null==s)return null;const a=e.sceneIntersectionHelper.intersectElevationFromScreen(n(c.screenEnd.x,c.screenEnd.y),r,t,l);return null!=a&&(null==o||m(a,a,o))?{...c,mapStart:s,mapEnd:a}:null}}function M(e,r,n,t=null,o=null){return D(e,n,R(r,e,n),t,o)}function N(e,r,n,t){const o=n.toMap(e.screenStart);return null!=o?M(r,o,n.elevationInfo,t):null}function h(e,r){const n=K,t=L,o=f();e.renderCoordsHelper.worldUpAtPosition(r,n);const l=s(g(o),n,c(t,r,e.state.camera.eye));return s(l,l,n),E(r,l,o)}function G(e,r,n){let t=null;const o=new U;return o.next(C(e,h(e,r))).next(k(e,r)).next(F(e,n)).next((e=>{e.mapEnd.x=e.mapStart.x,e.mapEnd.y=e.mapStart.y,t=e})),e=>(t=null,o.execute(e),t)}function k(e,r){const n=p(),t=o(r);e.renderCoordsHelper.worldUpAtPosition(r,n);const s=p(),m=p(),d=l=>{if(c(l,l,r),j(n,l,l),"global"===e.viewingMode){o(l)*Math.sign(a(n,l))<.001-t&&c(l,i(l,n,.001),r)}return u(l,l,r),l};return e=>(e.renderStart=d(l(s,e.renderStart)),e.renderEnd=d(l(m,e.renderEnd)),e)}function A(n,t){const o=o=>{const l=e(o,r(J)),s=x(n.state.camera,l,Q);if(null==s)return null;const c=S(t,s,K,L);return c?.[0]};return e=>{const r=o(e.screenStart);if(null==r)return null;const n=o(e.screenEnd);return null==n?null:{...e,renderStart:r,renderEnd:n}}}function F(e,r){const n=e.renderCoordsHelper;return e=>{const t=n.fromRenderCoords(e.renderStart,new O({spatialReference:r})),o=n.fromRenderCoords(e.renderEnd,new O({spatialReference:r}));return null!=t&&null!=o?{...e,mapStart:t,mapEnd:o}:null}}var q;function z(e){let r=null;return n=>{switch(n.action){case"start":r=e.disableDisplay();break;case"end":case"cancel":null!=r&&(r.remove(),r=null)}return n}}function B(r,t=null){const o=b(r.state.viewingMode);o.options.selectionMode=!0,o.options.store=w.MIN,o.options.hud=!1;const l=n(),s={requiresGroundFeedback:!0,enableDraped:!0,exclude:new Set},c=p(),a=t??r.spatialReference,i=n=>{r.map.ground&&r.map.ground.opacity<1?s.exclude.add(H):s.exclude.delete(H),r.sceneIntersectionHelper.intersectIntersectorScreen(e(n,l),o,s);const t=o.results.min;let i;if(t.getIntersectionPoint(c))i=t.intersector===I.TERRAIN?q.GROUND:q.OTHER;else{if(!o.results.ground.getIntersectionPoint(c))return null;i=q.GROUND}return{location:r.renderCoordsHelper.fromRenderCoords(c,new O({spatialReference:a})),surfaceType:i}};let u;return e=>{if("start"===e.action){const r=i(e.screenStart);u=null!=r?r.location:null}if(null==u)return null;const r=i(e.screenEnd);return null!=r?.location?{...e,mapStart:u,mapEnd:r.location,surfaceType:r.surfaceType}:null}}!function(e){e[e.GROUND=0]="GROUND",e[e.OTHER=1]="OTHER"}(q||(q={}));const J=t(),K=p(),L=p(),Q=y();export{q as SurfaceType,F as convertToMapCoordinates,z as hideManipulatorWhileDragging,k as projectToWorldUp,B as screenToMap3D,M as screenToMapXYAtLocation,N as screenToMapXYForManipulatedObject,C as screenToRenderPlane,P as screenToRenderPlaneFromEvent,A as screenToRenderRay,G as screenToZConstrained};
