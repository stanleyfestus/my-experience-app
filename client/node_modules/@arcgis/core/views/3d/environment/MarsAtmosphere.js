/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import{lerp as t,clamp as r}from"../../../core/mathUtils.js";import{disposeMaybe as s}from"../../../core/maybe.js";import{watch as i,initial as o}from"../../../core/reactiveUtils.js";import"../../../core/Logger.js";import"../../../core/has.js";import"../../../core/RandomLCG.js";import"../../../core/Error.js";import{subclass as a}from"../../../core/accessorSupport/decorators/subclass.js";import{lookAt as n}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{create as m}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{set as h}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{l as p,h as c,g as u,j as l,e as f,k as _}from"../../../chunks/vec32.js";import{create as d}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as g}from"../../../geometry/ellipsoidUtils.js";import{newFloatArray as b}from"../../../geometry/support/FloatArray.js";import{InternalRenderCategory as j}from"../webgl.js";import{computeInnerAltitudeFade as x,innerAtmosphereDepth as V}from"./atmosphereUtils.js";import{S as w}from"../../../chunks/SimpleAtmosphere.glsl.js";import{SimpleAtmosphereTechnique as v}from"./SimpleAtmosphereTechnique.js";import{SimpleAtmosphereTechniqueConfiguration as A,SimpleAtmosphereGeometry as P}from"./SimpleAtmosphereTechniqueConfiguration.js";import{marsAtmosphereTextureSimple as R}from"./resources/MarsAtmosphereTexture.js";import{makePiecewiseLinearFunction as y}from"../support/mathUtils.js";import{glLayout as S}from"../support/buffer/glUtil.js";import{newLayout as T}from"../support/buffer/InterleavedLayout.js";import{OpaqueEnvironment as q}from"../webgl-engine/effects/OpaqueEnvironment.js";import{RenderRequestType as M}from"../webgl-engine/lib/basicInterfaces.js";import{Default3D as U}from"../webgl-engine/lib/DefaultVertexAttributeLocations.js";import{createQuadVAO as F}from"../webgl-engine/lib/glUtil3D.js";import{project as C}from"../webgl-engine/lib/Util.js";import{VertexArrayObject as E}from"../webgl-engine/lib/VertexArrayObject.js";import{VertexAttribute as O}from"../webgl-engine/lib/VertexAttribute.js";import{BufferObject as I}from"../../webgl/BufferObject.js";import{TextureWrapMode as D,PrimitiveType as L,Usage as N}from"../../webgl/enums.js";import{Texture as W}from"../../webgl/Texture.js";import{TextureDescriptor as k}from"../../webgl/TextureDescriptor.js";import{vertexCount as G}from"../../webgl/Util.js";const B=128,z=-V,H=0,Q=50,J=()=>1-511/512,K=y([[50,.1015625],[500,.21875],[5e3,1-250/512],[5e4,.4140625]]);let X=class extends q{constructor(e){super(e),this._passParameters=new w,this._configuration=new A,this._vao=null,this._vaoCount=0,this._fadeVao=null,this._fadeVaoCount=0,this._texV1=1;const{view:t,techniques:r}=e,s=g(t.spatialReference),{outerAtmosphereRimWidth:i,radius:o}=s;this._planetRadius=o,this._innerRimFactor=1+z/o,this._middleRimFactor=1+H/o,this._outerRimFactor=1+i/o,this._texV0=H/i,this._texVScale=this._texV1-this._texV0,r.precompile(v,this._configuration),this._configuration.geometry=P.Underground,r.precompile(v,this._configuration)}initialize(){this.addHandles(i((()=>this.view.environment.atmosphereEnabled),(e=>e?this._enable():this._disable()),o))}destroy(){this._passParameters.texture=s(this._passParameters.texture),this._fadeVao=s(this._fadeVao),this._vao=s(this._vao)}render(e){const t=e.find((({name:e})=>e===j.OPAQUE_ENVIRONMENT));this._update();const r=this.renderingContext;if(!this._passParameters.texture){const e=new k;e.wrapMode=D.CLAMP_TO_EDGE,e.flipped=!0,e.width=1,e.height=512,this._passParameters.texture=new W(r,e,R)}if(this._passParameters.undergroundFadeAlpha<1){this._vao||(this._vao=this._createRibbon(r),this._vaoCount=G(this._vao,"geometry")),this._configuration.geometry=P.Cone;const e=this.techniques.acquire(v,this._configuration);if(!e.compiled)return e.release(),this.requestRender(M.UPDATE),t;r.bindTechnique(e,this.bindParameters,this._passParameters),r.bindVAO(this._vao),r.drawArrays(L.TRIANGLES,0,this._vaoCount),e.release()}if(this._passParameters.undergroundFadeAlpha>0){this._fadeVao||(this._fadeVao=F(r),this._fadeVaoCount=G(this._fadeVao,"geometry")),this._configuration.geometry=P.Underground;const e=this.techniques.acquire(v,this._configuration);if(!e.compiled)return e.release(),this.requestRender(M.UPDATE),t;r.bindTechnique(e,this.bindParameters,this._passParameters),r.bindVAO(this._fadeVao),r.drawArrays(L.TRIANGLE_STRIP,0,this._fadeVaoCount),e.release()}return t}_update(){const e=this.bindParameters.camera,s=d(),i=this._planetRadius,o=p(e.eye),a=o-i;if(a<0){const e=Math.min(-a/5e3,1);this._passParameters.undergroundFadeAlpha=e}else this._passParameters.undergroundFadeAlpha=0;const n=Math.max(Q,a),m=i+z;this._passParameters.innerScale=te(i+n,i,m)-1,this._passParameters.altitudeFade=x(a),c(s,e.eye,(i+Q)/o),Y(s,e.center,e.up,i,this._passParameters.silhouette);const u=this._computeScreenRimWidth(e,s,e.up,this._passParameters.silhouette),l=J(),f=K(a);let _=this._texV0+l*this._texVScale,g=this._texV0+u*f*this._texVScale;if(a>Q){Y(e.eye,e.center,e.up,i,this._passParameters.silhouette);const s=this._computeScreenRimWidth(e,e.eye,e.up,this._passParameters.silhouette),o=r((s-1.5)/(u-1.5),0,1);_=this._texV0+o*l*this._texVScale,g=this._texV0+t(this._texV1,u*f,o)*this._texVScale}h(this._passParameters.texV,_,g)}_createRibbon(e){const t=b(3+3*B*3),r=new Uint32Array(3*B*5);t[0]=0,t[1]=0,t[2]=-1;for(let o=0;o<B;o++){const e=9*o+3;t[e]=o,t[e+1]=this._innerRimFactor,t[e+2]=-1,t[e+3]=o,t[e+4]=this._middleRimFactor,t[e+5]=0,t[e+6]=o,t[e+7]=this._outerRimFactor,t[e+8]=1;const s=3*o+1,i=o===B-1?1:s+3,a=15*o;r[a]=s,r[a+1]=s+1,r[a+2]=i+1,r[a+3]=i+1,r[a+4]=i,r[a+5]=s,r[a+6]=s+1,r[a+7]=s+2,r[a+8]=i+2,r[a+9]=i+2,r[a+10]=i+1,r[a+11]=s+1,r[a+12]=s,r[a+13]=i,r[a+14]=0}const s=re.createBuffer(r.length),i=s.position;for(let o=0;o<r.length;++o){const e=3*r[o];i.set(o,0,t[e]),i.set(o,1,t[e+1]),i.set(o,2,t[e+2])}return new E(e,U,new Map([["geometry",S(re)]]),new Map([["geometry",I.createVertex(e,N.STATIC_DRAW,s.buffer)]]))}_computeScreenRimWidth(e,t,r,s){return u($,s.center,s.v2),c(ee,$,this._outerRimFactor),n(Z,t,$,r),C($,Z,e.projectionMatrix,e.viewport,$),C(ee,Z,e.projectionMatrix,e.viewport,ee),l($,ee)/e.height}};function Y(e,t,r,s,i){const o=p(e),a=s*Math.sqrt(o*o-s*s)/o,n=Math.sqrt(s*s-a*a),m=i.v1,h=i.v2;return c(i.center,e,n/o),f(m,e,t),_(m)<1&&f(m,e,r),c(m,m,a/p(m)),f(h,m,e),c(h,h,a/p(h)),a}X=e([a("esri.views.3d.environment.MarsAtmosphere")],X);const Z=m(),$=d(),ee=d();function te(e,t,r){return e*e/(Math.sqrt(e*e-t*t)*Math.sqrt(e*e-r*r)+t*r)}const re=T().vec3f(O.POSITION),se=X;export{se as default};
