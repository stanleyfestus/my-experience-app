/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import{Cyclical as t}from"../../../core/Cyclical.js";import n from"../../../core/Logger.js";import{deg2rad as r,rad2deg as o,asinClamped as i}from"../../../core/mathUtils.js";import{throwIfAborted as a}from"../../../core/promiseUtils.js";import{h as c,g as s,l,j as u,F as f,c as m}from"../../../chunks/vec32.js";import{clone as p,create as d}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as h}from"../../../geometry/ellipsoidUtils.js";import y from"../../../geometry/Point.js";import{projectWithZConversion as g,project as v}from"../../../geometry/projection.js";import w from"../../../geometry/SpatialReference.js";import{projectPointToVector as R,projectPointToVectorAsync as T}from"../../../geometry/projection/projectPointToVector.js";import{projectVectorToPoint as x,projectVectorToPointAsync as S}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToVector as M}from"../../../geometry/projection/projectVectorToVector.js";import{ViewingMode as j}from"../../ViewingMode.js";import{cameraOnContentAlongViewDirection as C}from"../camera/intersectionUtils.js";import{c as z}from"../../../chunks/cameraUtilsPlanar.js";import{c as A}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as b}from"./earthUtils.js";import{getElevationAtPoint as U}from"./ElevationProvider.js";import{isSpatialReferenceSupported as L}from"../../support/spatialReferenceSupport.js";const D=()=>n.getLogger("esri.views.3d.support.cameraUtils"),P=39.37,H=96,O=H*P,E=1,F=8,G=5,I=1,J={heading:0,tilt:0},q=d(),k=new t(-20037508.342788905,20037508.342788905),V=new t(-180,180);var X;function K(e){return e.spatialReference??w.WGS84}function W({state:e}){return e.isGlobal?A:z}function Y(e,t,n,r,o){return W(e).headingTiltToDirectionUp(t,n,r,o)}function N(e,t){if(null==t)return null;const n=e.renderSpatialReference,o=W(e).headingTiltToDirectionUp,i=d();if(!R(t.position,i,n))return null;const a=o(i,t.heading,t.tilt);c(a.direction,a.direction,e.state.camera.distance),s(a.direction,a.direction,i);const l=C(e,i,a.direction,a.up);return l.fov=r(t.fov),l.row=t.layout.row,l.rows=t.layout.rows,l.column=t.layout.column,l.columns=t.layout.columns,l}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(X||(X={}));const Z=d();function B(t,n,r){const i=t.renderSpatialReference,a=ue(t,n.eye,n.viewForward,n.up,J);let c=K(t);return M(n.eye,i,Z,c)||(c=w.WGS84,M(n.eye,i,Z,c)),null==r?r=new e(new y(Z,c),a.heading,a.tilt,o(n.fov)):(r.position.x=Z[0],r.position.y=Z[1],r.position.z=Z[2],r.position.spatialReference=c,r.heading=a.heading,r.tilt=a.tilt,r.fov=o(n.fov)),r.layout.row=n.row,r.layout.rows=n.rows,r.layout.column=n.column,r.layout.columns=n.columns,r}function Q(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper;return n.width/2/n.pixelRatio/(H*P/(t/=r))/Math.tan(n.fovX/2)}function $(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper,o=t*Math.tan(n.fovX/2),i=n.width/2/n.pixelRatio;return O/(i/o)*r}function _(e,t,n,r){const o=r.levelAtScale(t),i=te(ue(e,n.eye,n.viewForward,n.up).tilt),a=Math.max(o-i,0);return r.scaleAtLevel(a)}function ee(e,t,n){const r=n.levelAtScale(e),o=te(t);return n.scaleAtLevel(r+o)}function te(e){return 2*((e>90?180-e:e)/90)**2}function ne(e,t,n){const r=e.basemapTerrain?.tilingScheme;if(!r)return 0;if(null==n){const t=e.pointsOfInterest?.cameraOnSurface?.renderLocation;n=(t&&e.renderCoordsHelper?.getAltitude(t))??0}const o=h(e.spatialReference).radius,i=e.state.viewingMode===j.Local?t.eye[2]:l(t.eye)-o;return _(e,$(e,Math.abs(i-n)),t,r)}function re(e,t,n){const r=N(e,t);return r?ne(e,r,n):0}const oe=1,ie=100;function ae(e,t,n,a){if(0===t)return 0;const c=u(n.eye,a),s=e.basemapTerrain?.tilingScheme;if(!s)return D().error("#scaleToTargetDistance()","Cannot compute distance from scale without a tiling scheme"),c;const f=e.pointsOfInterest?.cameraOnSurface?.renderLocation,m=(f&&e.renderCoordsHelper?.getAltitude(f))??0;let p=c;if(e.state.viewingMode===j.Local){const o=ue(e,n.eye,n.viewForward,n.up).tilt,i=Q(e,ee(t,o,s))-Math.abs(n.eye[2]-m),a=n.eye[2]<m,c=i/Math.cos(r(o));p=a?p-c:p+c}else{let f=1/0,d=0;const y=ue(e,n.eye,n.viewForward,n.up);let g=he(e,y.heading,y.tilt,a,c,X.ADJUST);if(!g)return p;const v=h(e.spatialReference).radius,w=l(n.eye)<v+m;for(;f>oe&&d<ie;){const c=l(g.eye),h=w?180-g.tilt:g.tilt,R=r(h),T=Math.sin(R)*c,x=Math.cos(R)*c,S=Q(e,ee(t,g.tilt,s)),M=w?v+m-S:v+m+S,j=i(T/M),C=Math.cos(j)*M-x,z=u(g.eye,a);p=w?z-C:z+C,g=he(e,y.heading,y.tilt,a,p,X.ADJUST);const A=Ee(e,g,o(n.fov));if(!g||!A)return p;const b=re(e,A,m);f=Math.abs(t-b),++d}}return p}async function ce(e,t,n,r,o,i){const c=await le(e,t,e.state.camera.distance,r,o,i);a(i);const s=N(e,c);if(!s)return r;const l=d();e.renderCoordsHelper.toRenderCoords(t,l);return le(e,t,ae(e,n,s,l),r,o,i)}function se(e,t,n,r,o,i){return Ee(e,he(e,r.heading,r.tilt,t,n,o),r.fov,i)}async function le(e,t,n,r,o,i){const c=await ye(e,r.heading,r.tilt,t,n,o,i);return a(i),Fe(e,c,r.fov,i)}function ue(e,t,n,r,o){return W(e).directionToHeadingTilt(t,n,r,o)}function fe(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,q,e.spatialReference)&&e.elevationProvider&&(U(e.elevationProvider,q)??0)>q[2]-I)}async function me(e,t,n){if(fe(e,t))return!0;const{elevationProvider:r,spatialReference:o,renderCoordsHelper:i}=e;if(null==r||!i.fromRenderCoords(t,q,o))return!1;const[c,s,l]=q,u=await r.queryElevation(c,s,l,o,"ground",n)??0;return a(n),u>l-I}async function pe(e,t,n){const r=d();if(null==t)return m(r,e.state.camera.center);if(t instanceof y){const{renderSpatialReference:o,basemapTerrain:i,elevationProvider:c}=e,s=t.spatialReference;if(await T(t,r,o,0,{signal:n}),a(n),null==t.z&&null!=i&&null!=c){const o=await c.queryElevation(t.x,t.y,t.z??0,s,"ground",n);a(n),null!=o&&e.renderCoordsHelper.setAltitude(r,o)}return r}return m(r,t)}function de(e,t){const n=d();if(null==t)return m(n,e.state.camera.center);if(t instanceof y){if(!R(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:o}=e;if(null==t.z&&null!=r&&null!=o){const r=U(o,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return m(n,t)}function he(e,t,n,r,o,i){return ge(e,t,n,r instanceof y?r:null,de(e,r),o,i)}async function ye(e,t,n,r,o,i,c){const s=r instanceof y?r:null,l=await pe(e,r,c);return a(c),ve(e,t,n,s,l,o,i,c)}function ge(e,t,n,r,o,i,a){if(null==o)return null;if(!r&&(r=new y({spatialReference:K(e)}),!x(o,e.renderSpatialReference,r)))return null;const c=we(e,t,n,o,i,a);if(Re(e,n,a)&&fe(e,c.eye)){const{tilt:a,mode:c}=Te(e,n,o,i);return ge(e,t,a,r,o,i,c)}return xe(c,o)}async function ve(e,t,n,r,o,i,c,s){r||(r=new y({spatialReference:K(e)}),await S(o,e.renderSpatialReference,r,{signal:s})||(r=null)),a(s);const l=we(e,t,n,o,i,c);if(Re(e,n,c)&&await me(e,l.eye,s)){a(s);const{tilt:c,mode:l}=Te(e,n,o,i);return ve(e,t,c,r,o,i,l,s)}return xe(l,o)}function we(e,t,n,r,o,i){const a=Ue(e,t,n,r,o=Math.max(o,e.state.constraints.minimumPoiDistance),i);return(0,W(e).eyeForCenterWithHeadingTilt)(r,o,a.heading,a.tilt)}function Re(e,t,n){const r=e.map.ground.navigationConstraint;return n===X.ADJUST&&e.state.isGlobal&&t>0&&(null==r||"stay-above"===r.type)}function Te(e,t,n,r){const o=He(e,n,r,Pe(e,r,t,n));return{tilt:o,mode:t-o<1?X.LOCKED:X.ADJUST}}function xe(e,t){return{...e,center:p(t)}}function Se(e,t){const{state:n,spatialReference:r}=e,o=t.spatialReference;return n.isGlobal&&L(o,j.Global)||n.isLocal&&r.equals(o)}function Me(e,t){let n,r,o;if(e.state.isGlobal){const e=new y(t.xmin,t.ymin,t.spatialReference),i=new y(t.xmax,t.ymax,t.spatialReference),a=t.spatialReference.isGeographic?V:k;n=new y({x:a.center(e.x,i.x),y:(i.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const c=h(t.spatialReference),s=b(n,e,i);r=s.lon,o=s.lat,a.diff(e.x,i.x)>a.range/2&&(r+=c.halfCircumference),r=Math.min(r,c.halfCircumference),o=Math.min(o,c.halfCircumference)}else{const i=e.renderSpatialReference??t.spatialReference;i.equals(t.spatialReference)||(t=v(t,i)),r=t.xmax-t.xmin,o=t.ymax-t.ymin;const a=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new y({x:t.xmin+.5*r,y:t.ymin+.5*o,z:a,spatialReference:i})}const i=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,a=e.state.camera,c=1/Math.tan(a.fovX/2),s=1/Math.tan(a.fovY/2),l=1/Math.tan(a.fov/2);return{center:n,distance:Math.max(.5*r*c,.5*o*s,.5*i*l)/E}}async function je(e,t,n,r,o,i){const c=Se(e,t)?t:await g(t,e.spatialReference,{signal:i});a(i);const{center:s,distance:l}=Me(e,c),u=await ye(e,n,r,s,l,o,i);return a(i),Fe(e,u,e.camera.fov,i)}function Ce(e,t,n,r,o,i){let a;try{a=Se(e,t)?t:v(t,e.spatialReference)}catch(u){return null}const{center:c,distance:s}=Me(e,a),l=he(e,n,r,c,s,o);return null==l?null:Ee(e,l,e.camera.fov,i)}function ze(e,t,n){const r=e.renderSpatialReference,o=new y({spatialReference:K(e)});if(!x(n,r,o))return null;const i=Math.tan(t.fovX/2),a=Math.tan(t.fovY/2),c=f(t.eye,n),s=2*c*i*E,l=2*c*a*E;return W(e).toExtent(e,o,s,l)}function Ae(e,t){return W(e).toArea(e,t)}function be(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>F)return!0;const o=t,i=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return u(o,i)/(Math.tan(.5*e.state.camera.fov)*r)>G}function Ue(e,t,n,r,o,i){let a=0;return i===X.ADJUST&&be(e,r,o)?(t=0,a=De(e,o,n,r)):a=Oe(e,r,o,n),a=e.state.constraints.clampTilt(o,a),{heading:t,tilt:n=He(e,r,o,a)}}const Le=.7;function De(e,t,n,r){const o=Oe(e,r,t,n);if(!e.state.constraints.tilt)return o;const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const a=i.min*(1-Le)+i.max*Le;return Math.min(o,a)}function Pe(e,t,n,r){let o=Oe(e,r,t,n);if(!e.state.constraints.tilt)return o;const i=e.state.constraints.tilt(t);return o=Math.min(o,.5*Math.PI),i.min*(1-Le)+o*Le}function He(e,t,n,r){return W(e).lookAtTiltToEyeTilt(r,t,n)}function Oe(e,t,n,r){return W(e).eyeTiltToLookAtTilt(r,t,n)}function Ee(t,n,r,o){if(null==n)return null;const i=t.renderSpatialReference,a=new y({spatialReference:K(t)});return x(n.eye,i,a)?(o??=new e,o.position=a,o.heading=n.heading,o.tilt=n.tilt,o.fov=r,o):null}async function Fe(t,n,r,o){const i=t.renderSpatialReference,c=new y({spatialReference:K(t)});return await S(n.eye,i,c,{signal:o}),a(o),new e(c,n.heading,n.tilt,r)}function Ge(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);D().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Ie(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);D().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}export{X as OrientationMode,_ as applyTiltAdjustToScale,ue as directionToHeadingTilt,$ as distanceToScale,re as externalCameraToScale,N as externalToInternal,le as fromCenterDistanceAsync,se as fromCenterDistanceSync,ce as fromCenterScale,je as fromExtentAsync,Ce as fromExtentSync,ye as getObserverForPointAtDistanceAsync,he as getObserverForPointAtDistanceSync,K as getViewSR,Y as headingTiltToDirectionUp,ne as internalCameraToScale,B as internalToExternal,ee as removeTiltAdjustFromScale,oe as scaleErrorThreshold,Q as scaleToDistance,ae as scaleToTargetDistance,Ge as scaleToZoom,Ae as toArea,ze as toExtent,Ie as zoomToScale};
