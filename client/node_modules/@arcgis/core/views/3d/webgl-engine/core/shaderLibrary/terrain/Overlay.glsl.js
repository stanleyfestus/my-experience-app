/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{create as e}from"../../../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{hasArea as o,width as r,height as t}from"../../../../../../geometry/support/aaBoundingRect.js";import{OverlayIndex as a}from"../../../../terrain/interfaces.js";import{OverlayContent as l}from"../../../../terrain/OverlayContent.js";import{RenderPassIdentifier as i}from"../../renderPasses/AllRenderPasses.js";import{ShaderOutput as n}from"../ShaderOutput.js";import{addMainLightDirection as s,addMainLightIntensity as v}from"../shading/MainLighting.glsl.js";import{PBRMode as d}from"../shading/PhysicallyBasedRenderingParameters.glsl.js";import{Water as c}from"../shading/Water.glsl.js";import{Float4DrawUniform as x}from"../../shaderModules/Float4DrawUniform.js";import{FloatPassUniform as u}from"../../shaderModules/FloatPassUniform.js";import{glsl as y}from"../../shaderModules/interfaces.js";import{Texture2DPassUniform as m}from"../../shaderModules/Texture2DPassUniform.js";import{Uniform as p}from"../../shaderModules/Uniform.js";var f;function C(e,o){const{vertex:r,fragment:t}=e;r.uniforms.add(new x("overlayTexOffset",((e,o)=>T(e,o))),new x("overlayTexScale",((e,o)=>V(e,o)))),t.constants.add("overlayOpacity","float",1),t.uniforms.add(new m("ovColorTex",((e,o)=>h(e,o)))),O(e,o)}function g(e,o){const{vertex:r,fragment:t}=e;r.uniforms.add(new I("overlayTexOffset"),new I("overlayTexScale")),t.uniforms.add(new u("overlayOpacity",(e=>e.overlayOpacity)),new m("ovColorTex",((e,o)=>o.overlay?.getTexture(e.overlayContent)))),O(e,o)}function O(e,o){const r=o.pbrMode===d.Water||o.pbrMode===d.WaterOnIntegratedMesh||o.pbrMode===d.TerrainWithWater;r&&e.include(c,o);const{vertex:t,fragment:a}=e;e.varyings.add("vtcOverlay","vec4"),t.code.add(y`void setOverlayVTC(in vec2 uv) {
vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;
}`),a.code.add(y`bool isValid(vec2 uv, vec2 dxdy) {
return (uv.x >= 0.0 + dxdy.x) && (uv.x <= 1.0 - dxdy.x) && (uv.y >= 0.0 + dxdy.y) && (uv.y <= 1.0 - dxdy.y);
}
vec4 getOverlayColor(sampler2D ov0Tex, vec4 texCoords) {
vec4 color0 = texture(ov0Tex, vec2(texCoords.x * 0.5, texCoords.y));
vec4 color1 = texture(ov0Tex, vec2(texCoords.z * 0.5 + 0.5, texCoords.w));
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),a.code.add(y`vec4 getCombinedOverlayColor() {
return overlayOpacity * getOverlayColor(ovColorTex, vtcOverlay);
}`),a.code.add(y`vec4 getOverlayColorTexel(vec4 texCoords) {
vec2 texDim =  vec2(textureSize(ovColorTex, 0));
vec4 color0 = texelFetch(ovColorTex, ivec2(vec2(texCoords.x * 0.5, texCoords.y) * texDim), 0);
vec4 color1 = texelFetch(ovColorTex, ivec2(vec2(texCoords.z * 0.5 + 0.5, texCoords.w) * texDim), 0);
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),a.code.add(y`vec2 getAllOverlayHighlightValuesEncoded() {
vec4 texCoords = vtcOverlay;
vec2 uvInner = texCoords.xy;
vec2 uvOuter = texCoords.zw;
bool isValidInner = isValid(uvInner, fwidth(uvInner));
bool isValidOuter = isValid(uvOuter, vec2(0.0, 0.0));
vec2 texelCoordInner = vec2(uvInner.x * 0.5,       uvInner.y);
vec2 texelCoordOuter = vec2(uvOuter.x * 0.5 + 0.5, uvOuter.y);
vec2 texDim =  vec2(textureSize(ovColorTex, 0));
vec2 texelValueInner = texelFetch(ovColorTex, ivec2(texelCoordInner * texDim), 0).rg;
vec2 texelValueOuter = texelFetch(ovColorTex, ivec2(texelCoordOuter * texDim), 0).rg;
return
isValidInner ? texelValueInner :
isValidOuter ? texelValueOuter :
vec2(0.0);
}`),r&&(s(a),v(a),a.code.add(y`vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,
float shadow, vec3 localUp, mat3 tbn, vec3 position, vec3 positionWorld) {
vec3 n = normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));
vec3 v = vposEyeDir;
vec3 final = getSeaColor(n, v, mainLightDirection, colorInput.rgb, mainLightIntensity, localUp, 1.0 - shadow, maskInput.w, position, positionWorld);
return vec4(final, colorInput.w);
}`))}function h(e,o){return e.identifier===i.Material&&e.output===n.Color?o.overlay?.getTexture(l.ColorNoRasterImage):e.identifier===i.Material&&e.output===n.ObjectAndLayerIdColor?o.overlay?.getTexture(l.ObjectAndLayerIdColor):e.identifier===i.Highlight?o.overlay?.getTexture(l.Highlight):null}function T(e,l){const i=l.overlay?.overlays[a.INNER]?.extent;o(i)&&(b[0]=e.toMapSpace[0]/r(i)-i[0]/r(i),b[1]=e.toMapSpace[1]/t(i)-i[1]/t(i));const n=l.overlay?.overlays[a.OUTER]?.extent;return o(n)&&(b[2]=e.toMapSpace[0]/r(n)-n[0]/r(n),b[3]=e.toMapSpace[1]/t(n)-n[1]/t(n)),b}function V(e,l){const i=l.overlay?.overlays[a.INNER]?.extent;o(i)&&(b[0]=e.toMapSpace[2]/r(i),b[1]=e.toMapSpace[3]/t(i));const n=l.overlay?.overlays[a.OUTER]?.extent;return o(n)&&(b[2]=e.toMapSpace[2]/r(n),b[3]=e.toMapSpace[3]/t(n)),b}!function(e){e[e.Disabled=0]="Disabled",e[e.Enabled=1]="Enabled",e[e.EnabledWithWater=2]="EnabledWithWater",e[e.COUNT=3]="COUNT"}(f||(f={}));const b=e();class I extends p{constructor(e){super(e,"vec4")}}export{C as OverlayIM,f as OverlayMode,g as OverlayTerrain,h as getIMColorTexture};
