/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{ZEROS as o}from"../../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{LayerBlendMode as r}from"../output/BlendOptions.js";import{BackgroundGrid as e}from"./BackgroundGrid.glsl.js";import{BaseOpacityMode as t}from"./BaseOpacityMode.js";import{BlendLayersOutput as a}from"./BlendLayersOutput.js";import{PremultipliedAlphaSource as c}from"./PremultipliedAlphaSource.js";import{BlendModes as l}from"../util/BlendModes.glsl.js";import{Float3PassUniform as s}from"../../shaderModules/Float3PassUniform.js";import{FloatPassUniform as i}from"../../shaderModules/FloatPassUniform.js";import{NoParameters as u,glsl as d}from"../../shaderModules/interfaces.js";import{Texture2DPassUniform as p}from"../../shaderModules/Texture2DPassUniform.js";class n extends u{constructor(){super(...arguments),this.baseOpacity=1,this.backgroundColor=o,this.fboTexture=null}}function m(o,u){const n=u.output===a.GridComposite,m=u.output===a.ColorComposite,g=u.output===a.GroupBackgroundComposite,b=u.output===a.Composite,f=u.baseOpacityMode===t.Required,y=o.fragment;f&&y.uniforms.add(new i("baseOpacity",(o=>o.baseOpacity))),n?y.include(e):m?y.uniforms.add(new s("backgroundColor",(o=>o.backgroundColor))):b&&y.uniforms.add(new p("fboColor",(o=>o.fboTexture)));const C=u.blendMode!==r.Normal,v=u.premultipliedSource===c.On,h=!C&&!v&&(b&&!f||g);y.include(l,u),y.code.add(d`
    vec4 getBackground(vec2 uv) {
      return ${f?d`baseOpacity *`:""} ${g?d`vec4(0.0, 0.0, 0.0, 0.0)`:m?d`vec4(backgroundColor, 1.0)`:n?d`vec4(gridColor(uv), 1.0)`:d`texelFetch(fboColor, ivec2(gl_FragCoord.xy), 0)`};
    }

    vec4 blendLayers(vec2 bgUV, vec4 colorLayer, float opacity) {
      ${C?d`
          vec3 cl = colorLayer.a == 0.0 ? colorLayer.rgb : colorLayer.rgb / colorLayer.a;
          vec4 bgColor = getBackground(bgUV);
          vec3 cb = bgColor.a == 0.0 ? bgColor.rgb : bgColor.rgb / bgColor.a;
          return applyBlendMode(clamp(cl, vec3(0.0), vec3(1.0)), colorLayer.a * opacity, cb, bgColor.a);`:d`
          float composeAlpha = colorLayer.a * opacity;
          ${h?d`return colorLayer * opacity;`:d`
            vec4 bgColor = getBackground(bgUV);
            return bgColor * (1.0 - composeAlpha) + colorLayer * opacity;`}`}
    }`)}export{m as TileBackground,n as TileBackgroundPassParameters};
