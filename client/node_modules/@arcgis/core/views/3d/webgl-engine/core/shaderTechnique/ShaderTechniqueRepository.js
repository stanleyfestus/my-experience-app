/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../../../../../core/Error.js";import"../../../../../core/has.js";import{NestedMap as t}from"../../../../../core/NestedMap.js";import{ShaderTechniqueConfiguration as r}from"./ShaderTechniqueConfiguration.js";class o{constructor(e){this.context=e,this._debug=!1,this._precompiling=this._debug?0:1,this._cache=new t,this._frameCounter=0,this._keepAliveFrameCount=c}get precompiling(){return this._precompiling}set precompiling(e){this._precompiling=e,0===e&&this.context.rctx.gl.flush()}get viewingMode(){return this.context.viewingMode}destroy(){this._debug&&this._cache.forEach(((e,t)=>{e.forEach((e=>{e.refCount>0&&console.error(`Unreleased ${t} shader technique, refCount ${e.refCount}`)}))})),this._cache.forAll((e=>e.technique.destroy())),this._cache.clear()}precompile(e,t=s){++this.precompiling,this.acquire(e,t).release(),--this.precompiling}acquire(t,r=s){const o=r.key.code;let c=this._cache.get(t,o);if(null==c){if(0===this._precompiling){let o=`Uncached shader compile in ${(new Error).stack}\n  for configuration\n${r.decode()}`;const i=this._cache.getInner(t);throw i?.size&&(o+="\n\n  cached configurations:\n",o+=Array.from(i.values()).map((e=>r.decode(e.technique.key))).sort().join("\n\n")),console.log(o),new e(o)}const n=new t(this.context,r,(()=>this._release(n)));c=new i(n),this._cache.set(t,o,c)}return++c.refCount,c.technique}_release(e){if(null==e||this._cache.empty)return;const t=this._cache.get(e.constructor,e.key.code);null!=t&&(--t.refCount,0===t.refCount&&(t.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==c&&this._cache.forEach(((e,t)=>{e.forEach(((e,r)=>{0===e.refCount&&e.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(e.technique.destroy(),this._cache.delete(t,r))}))}))}async reloadAll(){const e=new Array;this._cache.forEach((t=>e.push(n(t)))),await Promise.all(e)}}class i{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}}const c=-1;async function n(e){let t=!0;e.forEach((async e=>{await e.technique.reload(t),t=!1}))}const s=new r;export{s as NoConfiguration,o as ShaderTechniqueRepository};
