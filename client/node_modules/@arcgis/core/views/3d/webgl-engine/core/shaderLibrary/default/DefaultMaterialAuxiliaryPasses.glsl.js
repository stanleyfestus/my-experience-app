/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{addNearFar as e}from"../ForwardLinearDepth.glsl.js";import{ShaderOutput as o}from"../ShaderOutput.js";import{SliceDraw as r}from"../Slice.glsl.js";import{Transform as t}from"../Transform.glsl.js";import{NormalAttribute as i,NormalType as a}from"../attributes/NormalAttribute.glsl.js";import{ObjectAndLayerIdColor as s}from"../attributes/ObjectAndLayerIdColor.glsl.js";import{TextureCoordinateAttribute as l}from"../attributes/TextureCoordinateAttribute.glsl.js";import{VertexNormal as d}from"../attributes/VertexNormal.glsl.js";import{OutputDepth as n}from"../output/OutputDepth.glsl.js";import{OutputHighlight as c}from"../output/OutputHighlight.glsl.js";import{VisualVariables as u}from"../shading/VisualVariables.glsl.js";import{DiscardOrAdjustAlphaPass as p}from"../util/DiscardOrAdjustAlpha.glsl.js";import{addProjViewLocalOrigin as m}from"../util/View.glsl.js";import{glsl as v,If as g}from"../../shaderModules/interfaces.js";import{Texture2DPassUniform as f}from"../../shaderModules/Texture2DPassUniform.js";import{AlphaDiscardMode as x}from"../../../lib/basicInterfaces.js";function h(h,O){const{vertex:j,fragment:w}=h,b=O.hasColorTexture&&O.alphaDiscardMode!==x.Opaque,{output:C,normalType:V,hasColorTextureTransform:A}=O;switch(C){case o.Depth:m(j,O),h.include(t,O),h.include(r,O),h.include(l,O),b&&w.uniforms.add(new f("tex",(e=>e.texture))),j.main.add(v`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();`),h.include(p,O),w.main.add(v`
          discardBySlice(vpos);
          ${g(b,v`vec4 texColor = texture(tex, ${A?"colorUV":"vuv0"});
                 discardOrAdjustAlpha(texColor);`)}`);break;case o.Shadow:case o.ShadowHighlight:case o.ShadowExcludeHighlight:case o.ViewshedShadow:case o.ObjectAndLayerIdColor:m(j,O),h.include(t,O),h.include(l,O),h.include(u,O),h.include(n,O),h.include(r,O),h.include(s,O),e(h),h.varyings.add("depth","float"),b&&w.uniforms.add(new f("tex",(e=>e.texture))),j.main.add(v`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
forwardTextureCoordinates();
forwardObjectAndLayerIdColor();`),h.include(p,O),w.main.add(v`
          discardBySlice(vpos);
          ${g(b,v`vec4 texColor = texture(tex, ${A?"colorUV":"vuv0"});
                 discardOrAdjustAlpha(texColor);`)}
          ${C===o.ObjectAndLayerIdColor?v`outputObjectAndLayerIdColor();`:v`outputDepth(depth);`}`);break;case o.Normal:{m(j,O),h.include(t,O),h.include(i,O),h.include(d,O),h.include(l,O),h.include(u,O),b&&w.uniforms.add(new f("tex",(e=>e.texture))),V===a.ScreenDerivative&&h.varyings.add("vPositionView","vec3");const e=V===a.Attribute||V===a.Compressed;j.main.add(v`
          vpos = getVertexInLocalOriginSpace();
          ${e?v`vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));`:v`vPositionView = (view * vec4(vpos, 1.0)).xyz;`}
          vpos = subtractOrigin(vpos);
          vpos = addVerticalOffset(vpos, localOrigin);
          gl_Position = transformPosition(proj, view, vpos);
          forwardTextureCoordinates();`),h.include(r,O),h.include(p,O),w.main.add(v`
          discardBySlice(vpos);
          ${g(b,v`vec4 texColor = texture(tex, ${A?"colorUV":"vuv0"});
                 discardOrAdjustAlpha(texColor);`)}

          ${V===a.ScreenDerivative?v`vec3 normal = screenDerivativeNormal(vPositionView);`:v`vec3 normal = normalize(vNormalWorld);
                     if (gl_FrontFacing == false){
                       normal = -normal;
                     }`}
          fragColor = vec4(0.5 + 0.5 * normal, 1.0);`);break}case o.Highlight:m(j,O),h.include(t,O),h.include(l,O),h.include(u,O),b&&w.uniforms.add(new f("tex",(e=>e.texture))),j.main.add(v`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();`),h.include(r,O),h.include(p,O),h.include(c,O),w.main.add(v`
          discardBySlice(vpos);
          ${g(b,v`vec4 texColor = texture(tex, ${A?"colorUV":"vuv0"});
                 discardOrAdjustAlpha(texColor);`)}
          calculateOcclusionAndOutputHighlight();`)}}export{h as DefaultMaterialAuxiliaryPasses};
