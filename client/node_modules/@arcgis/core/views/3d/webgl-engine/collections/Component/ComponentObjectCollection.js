/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../../../../../core/Logger.js";import t from"../../../../../core/PooledArray.js";import{isArray as o}from"../../../../../core/typedArrayUtil.js";import{s as n}from"../../../../../chunks/vec32.js";import{clone as i}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{create as r}from"../../../../../geometry/support/aaBoundingBox.js";import{compactIndices as s}from"../../../../../geometry/support/Indices.js";import{c as a}from"../../../../../chunks/vec3.js";import{c as l}from"../../../../../chunks/vec33.js";import{ViewingMode as c}from"../../../../ViewingMode.js";import{ColorMixModeEnum as m,encodeSymbolColor as f}from"../../../layers/support/symbolColorUtils.js";import{computeOffsetObb as p}from"../../../support/orientedBoundingBox.js";import{glLayout as h}from"../../../support/buffer/glUtil.js";import{newLayout as u}from"../../../support/buffer/InterleavedLayout.js";import d from"./ComponentData.js";import{ComponentObject as g}from"./ComponentObject.js";import{IntersectionGeometry as b}from"./IntersectionGeometry.js";import{Renderable as y}from"./Renderable.js";import{RenderGeometry as v}from"./RenderGeometry.js";import{RenderSubmitSystem as C}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as _}from"./SourceGeometry.js";import{UniformComponentParameters as M}from"./UniformComponentParameters.js";import{ComponentParametersVarying as j,ComponentParametersUniform as w,ComponentParameterSummary as x,ComponentMaterial as O}from"./Material/ComponentMaterial.js";import{vertexAttributeLocations as A}from"./Material/ComponentTechnique.js";import{encodeElevationOffset as R}from"./Material/shader/ComponentData.glsl.js";import{olidEnabled as D}from"../../effects/geometry/olidUtils.js";import{getVisibility as S,updateVisibilityWithCount as E}from"../../lib/ComponentUtils.js";import{assert as I}from"../../lib/Util.js";import{VertexAttribute as V}from"../../lib/VertexAttribute.js";import{getVerticalOffsetI3S as B}from"../../lib/verticalOffsetUtils.js";import{BufferManager as P}from"../../lib/TextureBackedBuffer/BufferManager.js";import{BufferObject as U}from"../../../../webgl/BufferObject.js";import{Usage as N,PrimitiveType as T}from"../../../../webgl/enums.js";import{VertexArrayObject as G}from"../../../../webgl/VertexArrayObject.js";const L=()=>e.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class k{constructor(e,o){this._renderManager=e,this._viewingMode=o,this._elevationRangeCacheVerticalOffset=NaN,this._elevationRangeCacheMin=NaN,this._elevationRangeCacheMax=NaN,this._visible=new t,this._hidden=new t,this._renderSubmit=new C(this),this._renderManager.register(this._renderSubmit),this._componentBufferManager=new P(e.rctx,2+(D()?1:0))}destroy(){I(0===this._hidden.length&&0===this._visible.length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy(),this._visible.forAll((e=>e.destroy())),this._hidden.forAll((e=>e.destroy())),this._visible.clear(),this._hidden.clear()}createObject(e){const t=e.geometry,o=new d(this._componentBufferManager,s(t.componentOffsets)),n=this._createRenderable(e,o),i=new b(this._viewingMode,t.positionData,o),r=new g(e.transform,e.toMapSpace,e.obb.clone(),o,n,i);return(r.visible?this._visible:this._hidden).push(r),r}destroyObject(e){const t=e;(t.visible?this._visible:this._hidden).removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const o=e;t!==o.visible&&(t?(this._hidden.removeUnordered(o),this._visible.push(o)):(this._visible.removeUnordered(o),this._hidden.push(o)),o.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=n(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const o=e.renderable.material;t(o),o.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const o=e;o.components.visibility.reset(t),o.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,o=t.components.visibility.componentCount;return{visible:o,invisible:t.components.count-o}}setComponentData(e,t){const o=e,n=o.renderable.material,i=o.components,r=i.materialDataBuffer,s=i.materialDataIndices,a=new M,l=r.textureBuffer,c=new Uint8Array(4),h=new Uint32Array(c.buffer);let u=0,d=0,g=0,b=i.verticalOffsets,y=1/0,v=-1/0,C=!1,_=!1,O=0;for(let p=0;p<i.count;p++){t(p,a),u+=+(a.externalColor[3]<1),d+=+(a.externalColorMixMode===m.Replace&&1===a.externalColor[3]),g+=+a.castShadows,f(a.externalColor,a.externalColorMixMode,c),c[2]=254&c[2]|+a.castShadows,l.setData(s[p],0,c[0],c[1],c[2],c[3]),C||=p>0&&O!==h[0],O=h[0],_||=0!==a.elevationOffset,_&&null==b&&(b=new Array(p).fill(0)),null!=b&&(b[p]=a.elevationOffset),y=Math.min(y,a.elevationOffset),v=Math.max(v,a.elevationOffset),R(a.elevationOffset,c),l.setData(s[p],1,c[0],c[1],c[2],c[3]);const e=a.objectAndLayerIdColor;null!=e&&l.setData(s[p],2,e[0],e[1],e[2],e[3]),a.pickable!==S(i.pickability,p)&&(i.pickability=E(i.pickability,i.count,p,a.pickable))}i.verticalOffsets=_?b:null,o.offsetObb=_?p(o.obb,y,v,this._viewingMode,o.offsetObb??o.obb.clone()):null,C||_||D()?(n.componentParameters=new j,n.componentParameters.castShadows=W(g,i.count),n.componentParameters.transparent=W(u,i.count),n.componentParameters.opaqueOverride=W(d,i.count),n.componentParameters.texture=l,l.updateTexture()):(n.componentParameters=new w,n.componentParameters.castShadows=a.castShadows?x.All:x.None,n.componentParameters.externalColor=a.externalColor,n.componentParameters.externalColorMixMode=a.externalColorMixMode),this._elevationRangeCacheVerticalOffset=NaN,this._notifyDirty()}getComponentAabb(e,t,o,n=!1){e.intersectionGeometry.getComponentAabb(t,o);const i=e,r=i.components.verticalOffsets;if(n||null==r)return o;const s=r[t];if(this._viewingMode===c.Local||0===s)return o[2]+=s,o[5]+=s,o;const a=B(s);return a.localOrigin=i.transform.position,a.applyToAabb(o)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,o){return e.intersectionGeometry.getComponentPositions(t,o)}expandRangeWithComponentObjectElevationRange(e,t,o,n){Number.isNaN(this._elevationRangeCacheVerticalOffset)||this._elevationRangeCacheVerticalOffset!==t||n.expandElevationRangeValues(this._elevationRangeCacheMin,this._elevationRangeCacheMax);const i=e,r=i.components,s=r.count,a=r.verticalOffsets,l=i.intersectionGeometry,m=this._viewingMode===c.Local,f=l.getComponentAabbs(),p=H;let h=1/0,u=-1/0;for(let c=0;c<s;c++){const e=6*c,r=a?.[c]??0;let s=1/0,l=-1/0;if(m)s=f[e+2]+r+t,l=f[e+5]+r+t;else{if(p[0]=f[e],p[1]=f[e+1],p[2]=f[e+2],p[3]=f[e+3],p[4]=f[e+4],p[5]=f[e+5],0!==r){const e=B(r);e.localOrigin=i.transform.position,e.applyToAabb(p)}const s=Math.max(Math.abs(p[3]),Math.abs(p[0])),a=Math.max(Math.abs(p[4]),Math.abs(p[1])),l=t+p[5]+o;n.expandElevationRangeValues(t+p[2],Math.sqrt(s*s+a*a+l*l)-o)}n.expandElevationRangeValues(s,l),h=Math.min(h,s),u=Math.max(u,l)}this._elevationRangeCacheVerticalOffset=t,this._elevationRangeCacheMin=h,this._elevationRangeCacheMax=u}intersect(e,t,o,n,i,r,s){const a=e,{transform:l}=a,{position:c}=l;return null!=i&&(i.localOrigin=c),a.intersectionGeometry.intersect(t,o,n,i,a.components.verticalOffsets,l,r,s)}addEdges(e,t,o,n,i){const r=e,{indices:s,positions:a}=r.intersectionGeometry,l=r.components.offsets;return t.addComponentObject(r,a,s,l,o,n,i)}async extractEdgeInformation(e,t,o){const n=e,r=n.components.visibility;if(r.allInvisible()){const{extractComponentsEdgeLocationsLayout:e}=await import("../../lib/edgeRendering/edgeProcessing.js");return{buffer:e.createBuffer(0),origin:[0,0,0]}}const{indices:s,positions:c}=n.intersectionGeometry,m=n.components.offsets,{EdgeInputBufferLayout:f}=await import("../../lib/edgeRendering/bufferLayouts.js"),p=f.createBuffer(c.length/3);l(p.position.typedBuffer,c,p.position.typedBufferStride,3),a(p.position,p.position,n.transform.rotationScale),this._setComponentIndices(p.componentIndex,s,m);const h=p.count,u=this._computeVisibilityIndices(s,r,m,h);return{origin:i(n.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:u,indicesLength:u.length,skipDeduplicate:!0,data:p,writerSettings:{reducedPrecision:!1,variants:0}},o)}}_setComponentIndices(e,t,o){let n=0;for(let i=0;i<o.length-1;i++){const r=o[i],s=o[i+1];for(let o=r;o<s;o++){const i=t?t[o]:o;e.set(i,n)}n++}}_computeVisibilityIndices(e,t,n,i){if(e&&t.allVisible())return e;let r=0;t.forEachComponentRange(((e,t)=>(r+=n[t]-n[e],!0)));const s=o(e)?new Array(r):2===e?.BYTES_PER_ELEMENT||i<=65536?new Uint16Array(r):new Uint32Array(r);let a=0;return t.forEachComponentRange(((t,o)=>{const i=n[t],r=n[o];for(let n=i;n<r;n++)s[a++]=e?e[n]:n;return!0})),s}addComponentHighlight(e,t,o){const n=e.components;let i=n.highlightCounts,r=n.highlightGroups;null!=i&&null!=r||(i=new Uint32Array(n.count+1),n.highlightCounts=i,r=new Array(n.count+1),n.highlightGroups=r),r[t]=o;0===i[t]++&&(n.highlightsDirty(),this._notifyDirty()),i[n.count]++}removeComponentHighlight(e,t){const o=e.components,n=o.highlightCounts;if(null==n)return void L().warn("Removing non-existing highlight.");const i=n[t];if(0===i)return void L().warn("Removing non-existing highlight.");const r=n[o.count];if(i>1)return n[t]=i-1,void(n[o.count]=r-1);n[t]=0,o.highlightsDirty(),this._notifyDirty(),1===r?(o.highlightCounts=null,o.highlightGroups=null):n[o.count]=r-1}clearHighlights(e){const t=e.components;null!=t.highlightCounts&&(t.highlightCounts=null,t.highlightGroups=null,t.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._visible}_createRenderable(e,t){const o=this._renderManager.rctx,n=e.geometry,i=n.vertices.layoutParameters,r=U.createVertex(o,N.STATIC_DRAW,n.vertices.data),s=n.indices?U.createIndex(o,N.STATIC_DRAW,n.indices):null,a=h(_(i)),l=new Uint16Array(n.vertices.count);for(let h=0;h<t.count;h++){const e=t.offsets[h],o=t.offsets[h+1],i=t.materialDataIndices[h];if(null!=n.indices)for(let t=e;t<o;t++){l[n.indices[t]]=i}else for(let t=e;t<o;t++)l[t]=i}const c=U.createVertex(o,N.STATIC_DRAW,l.buffer),m=new O(e.transform,e.toMapSpace),f=new G(o,A,new Map([["data",a],["componentIndices",q]]),new Map([["data",r],["componentIndices",c]]),s),p=new v(f,T.TRIANGLES,i,null!=s),u={cameraDepthSquared:.5,gpuMemoryEstimate:r.usedMemory+c.usedMemory+(null!=s?s.usedMemory:0)};return new y(m,p,u)}_notifyDirty(){this._renderManager.notifyDirty()}}const q=h(u().u16(V.COMPONENTINDEX));function W(e,t){return e===t?x.All:0===e?x.None:x.Some}const H=r();export{k as ComponentObjectCollection};
