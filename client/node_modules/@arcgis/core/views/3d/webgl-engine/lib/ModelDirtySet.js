/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import"../../../../core/has.js";import{nullUid as o}from"../../../../core/uid.js";import{property as r}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as s}from"../../../../core/accessorSupport/decorators/subclass.js";import{DirtyOperation as d,DirtyState as i}from"./ModelDirtyTypes.js";import{assert as c}from"./Util.js";class n{constructor(e,t,o,r){this.operation=e,this.geometry=t,this.states=o,this.sync=r}}let a=class extends t{constructor(e){super(e),this._residentGeomRecords=new Map,this._dirtyGeomRecords=new Map,this._dirtyRecordCount=0}get dirty(){return this._dirtyRecordCount>0}commitLayer(e,t){const o=this._dirtyGeomRecords.get(e);if(!o)return;let r=0;o.forEach(((o,s)=>{const n=this._ensureGeomRecord(e,s);r+=o.size,o.forEach((({geometry:e,operation:o,states:r},a)=>{let m=!1;if(o===d.UPDATE){const o=n.get(a);if(o){if(r&i.TRANSFORMATION){const t=this.model.getObject(s);this.model.updateRenderGeometryTransformation(t,e,o)&&(m=!0)}m||t.updates.push({renderGeometry:o,updateType:r})}else c(!1,"ModelDirtySet.commitLayer: invalid update")}if(o===d.REMOVE||m){const e=n.get(a);e?(t.removes.push(e),n.delete(a)):o===d.REMOVE&&c(!1,"ModelDirtySet.commitLayer: invalid remove")}if(o===d.ADD||m){const o=this.model.getObject(s);if(null!=o){const r=this.model.getRenderGeometry(o,e);t.adds.push(r),n.set(a,r)}}})),0===n.size&&this._residentGeomRecords.get(e).delete(s)})),0===this._residentGeomRecords.get(e).size&&this._residentGeomRecords.delete(e),this._dirtyGeomRecords.delete(e),this._dirtyRecordCount-=r}commitSyncUpdates(e,t){const o=this._dirtyGeomRecords.get(e);o&&o.forEach(((o,r)=>{const s=this._ensureGeomRecord(e,r);o.forEach((({geometry:e,operation:o,states:n,sync:a},m)=>{let h=!1;if(o===d.UPDATE&&a){const o=s.get(m);if(o){if(n&i.TRANSFORMATION){const t=this.model.getObject(r);this.model.updateRenderGeometryTransformation(t,e,o)&&(h=!0)}h||t.updates.push({renderGeometry:o,updateType:n})}else c(!1,"ModelDirtySet.commitSyncUpdates: invalid update")}}))}))}getResidentRenderGeometries(e,t){const o=this._residentGeomRecords.get(e);o&&o.forEach((e=>e.forEach((e=>t.push(e)))))}_objectStateChanged(e,t){for(const o of t.geometries)this._updateOrCreateDirtyRecord(t,o,null,d.UPDATE,e)}visibilityChanged(e){this._objectStateChanged(i.VISIBILITY,e)}highlightChanged(e){this._objectStateChanged(i.HIGHLIGHT,e)}occlusionChanged(e){this._objectStateChanged(i.OCCLUDEE,e)}attributesChanged({object:e,geometry:t,sync:o}){this._updateOrCreateDirtyRecord(e,t,null,d.UPDATE,i.GEOMETRY,o)}layerAdded(e){e.objects.forAll((t=>this._layerObjectAdded(e,t)))}layerRemoved(e){e.objects.forAll((t=>this._layerObjectRemoved(e,t)))}layerObjectAdded(e){this._layerObjectAdded(e.layer,e.object)}_layerObjectAdded(e,t){const o=e.id;for(const r of t.geometries)this._geometryAdded(t,r,o)}layerObjectRemoved(e){this._layerObjectRemoved(e.layer,e.object)}layerObjectsAdded(e){for(const t of e.objects)this._layerObjectAdded(e.layer,t)}layerObjectsRemoved(e){for(const t of e.objects)this._layerObjectRemoved(e.layer,t)}_layerObjectRemoved(e,t){const o=e.id;for(const r of t.geometries)this._geometryRemoved(t,r,o)}transformationChanged(e){const t=this._getParentLayerId(e),o=e.id;this._ensureGeomRecord(t,o).forEach((o=>{this._updateOrCreateDirtyRecord(e,o.geometry,t,d.UPDATE,i.TRANSFORMATION)}))}shaderTransformationChanged(e){const t=this._getParentLayerId(e),o=e.id;this._ensureGeomRecord(t,o).forEach((t=>{t.objectShaderTransformationChanged(e.shaderTransformation)}))}geometryAdded(e){this._geometryAdded(e.object,e.geometry)}_geometryAdded(e,t,o=null){this._updateOrCreateDirtyRecord(e,t,o,d.ADD)}geometryRemoved(e){this._geometryRemoved(e.object,e.geometry)}_geometryRemoved(e,t,o=null){this._updateOrCreateDirtyRecord(e,t,o,d.REMOVE)}_updateOrCreateDirtyRecord(e,t,o,r,s=i.NONE,a=!1){o=o??this._getParentLayerId(e);const m=e.id,h=t.id,y=this._ensureDirtyRecord(o,m),l=y.get(h);if(l){const e=l.operation;e===d.REMOVE&&r===d.ADD&&l.states!==i.NONE?l.operation=d.UPDATE:e===d.REMOVE&&r===d.ADD||e===d.ADD&&r===d.REMOVE?(y.delete(h),this._dirtyRecordCount--):e!==d.UPDATE||r!==d.REMOVE&&r!==d.UPDATE?(c((e===d.REMOVE||e===d.ADD)&&r===d.UPDATE,"ModelDirtySet.objectGeometryAdded: inconsistent state"),l.states|=s):(l.operation=r,l.states|=s),l.sync=l.sync||a}else y.set(h,new n(r,t,s,a)),this._dirtyRecordCount++}_ensureGeomRecord(e,t){let o=this._residentGeomRecords.get(e);o||(o=new Map,this._residentGeomRecords.set(e,o));let r=o.get(t);return r||(r=new Map,o.set(t,r)),r}_ensureDirtyRecord(e,t){let o=this._dirtyGeomRecords.get(e);o||(o=new Map,this._dirtyGeomRecords.set(e,o));let r=o.get(t);return r||(r=new Map,o.set(t,r)),r}_getParentLayerId(e){return e.parentLayer?e.parentLayer.id:o}formatDebugInfo(){const e=["ADD","UPD",void 0,"REM"];let t="";return this._dirtyGeomRecords.forEach(((o,r)=>{o.forEach(((o,s)=>{t.length>0&&(t+="\n"),t+=r+"."+s;const d=[];o.forEach((e=>{const t=e.operation;d[t]||(d[t]=[]),d[t].push(e.geometry.id)}));for(let r=0;r<d.length;r++)if(d[r]){t+=" "+e[r-1]+": ";for(let e=0;e<d[r].length;e++)t+=d[r][e]+", "}}))})),t}get test(){}};e([r()],a.prototype,"_dirtyRecordCount",void 0),e([r({constructOnly:!0})],a.prototype,"model",void 0),a=e([s("esri.views.3d.webgl-engine.lib.ModelDirtySet")],a);const m=a;export{m as default};
