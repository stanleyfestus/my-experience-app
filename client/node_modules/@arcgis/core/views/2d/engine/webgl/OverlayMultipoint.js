/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../../../geometry.js";import{on as t}from"../../../../core/events.js";import e from"../../../../core/Handles.js";import{disposeMaybe as r}from"../../../../core/maybe.js";import{when as i,initial as o}from"../../../../core/reactiveUtils.js";import{createScreenPoint as s}from"../../../../core/screenUtils.js";import{create as n}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{project as a}from"../../../../geometry/projection.js";import{DisplayObject as h}from"../DisplayObject.js";import l from"../../../layers/support/Geometry.js";import{TextureWrapMode as u}from"../../../webgl/enums.js";import{Texture as m}from"../../../webgl/Texture.js";import{TextureDescriptor as d}from"../../../webgl/TextureDescriptor.js";import p from"../../../../geometry/Polygon.js";import c from"../../../../geometry/Point.js";const f=2;class x extends h{constructor(r){super(),this.element=r,this._handles=new e,this.isWrapAround=!1,this.perspectiveTransform=n(),this.wrapAroundShift=0,this.clipGeometry=null,this._handles.add(i((()=>this.element),(()=>{const e=this.element;this.ready(),e&&this._handles.add(t(e,"play",(()=>this.requestRender())))}),o))}getMesh(t){throw new Error("Method not implemented.")}destroy(){this._handles.destroy(),this.texture=r(this.texture)}get textureSize(){if(!this.texture)return[1,1];const t=this.texture.descriptor;return[t.width,t.height]}get dvsMat3(){return this.parent.dvsMat3}beforeRender(t){const e=this.element;if(null==e)return;const{context:r}=t,{videoWidth:i,videoHeight:o}=e;if(0!==i&&0!==o){if(this.texture)e.paused||this.texture.setData(e);else{const t=new d;t.wrapMode=u.CLAMP_TO_EDGE,t.preMultiplyAlpha=!0,t.width=i,t.height=o,this.texture=new m(r,t,e)}e.paused||(this.texture.generateMipmap(),this.requestRender()),super.beforeRender(t)}}_createTransforms(){return null}updateDrawCoords(t,e,r,i){const o=this.element,s=this._getFrameInfo();if(!o||!s)return;this._initializeData(t,s,r);const{controlPoints:n,horizon:h}=s,u=Math.sqrt(n.length),m=u,{x:d,y:c}=t,x=this._vertices,y=n[0],g=n[u-1],P=n[(m-1)*u],w=n[(m-1)*u+u-1],_=a(h?h[0].mapPoint:y.mapPoint,r),v=a(h?h[1].mapPoint:g.mapPoint,r),j=a(P.mapPoint,r),A=a(w.mapPoint,r);this.clipGeometry=h?new l({geometry:p.fromJSON({rings:[[[j.x,j.y],[A.x,A.y],[v.x,v.y],[_.x,_.y],[j.x,j.y]]],spatialReference:r})}):null;for(let l=0;l<n.length;l++){const t=n[l],{sourcePoint:e,mapPoint:i}=t;if(null==e||null==i)continue;const o=a(i,r);x[l*f+0]=o.x-d,x[l*f+1]=o.y-c}let M=e;if(i){const t=Math.min(_.x,v.x,j.x,A.x),e=Math.max(_.x,v.x,j.x,A.x),{worldWidth:r,xBounds:o}=i,[s,n]=o;t<s&&e>s?M=r:e>n&&t<n&&(M=-r)}this.wrapAroundShift=M,this.isWrapAround=0!==M}draw(t,e){this.isReady&&this._vertices&&this._indices&&this._texCoords?e.render(t,{transform:{dvs:this.dvsMat3},config:{perspective:this.perspectiveTransform,texSize:this.textureSize,wrapAroundShift:this.wrapAroundShift,isWrapAround:this.isWrapAround,opacity:this.opacity,texture:{texture:this.texture,unit:0}},position:this._vertices,tex:this._texCoords,index:this._indices}):this.requestRender()}_initializeData(t,e,r){if(null!=this._vertices&&null!=this._indices)return;const{controlPoints:i}=e,o=Math.sqrt(i.length),s=o,n=new Float32Array(f*i.length),h=new Uint16Array(2*i.length);for(let m=0;m<i.length;m++){const e=i[m],{sourcePoint:o,mapPoint:s}=e;if(null==o||null==s)continue;const l=a(s,r);n[m*f+0]=l.x-t.x,n[m*f+1]=l.y-t.y,h[2*m+0]=o.x,h[2*m+1]=o.y}const l=new Uint16Array(s*o+(s-2)*(o+2));let u=0;for(let a=0;a<s;a++){for(let t=0;t<o;t++)l[u++]=a*o+t,l[u++]=(a+1)*o+t;a<s-2&&(l[u++]=(a+1)*o+(o-1),l[u++]=(a+1)*o)}this._vertices=n,this._texCoords=h,this._indices=l}_getFrameInfo(){if(!this.groundControlPoints)return null;const t=this._getFrameControlPoints(),e=this.frameHorizonPoints;let r=null;if(e){const t=e.startX,i=e.startY,o=e.endX,n=e.endY;r=[{sourcePoint:s(t,i),mapPoint:new c(e.startLongitude,e.startLatitude)},{sourcePoint:s(o,n),mapPoint:new c(e.endLongitude,e.endLatitude)}]}return{controlPoints:t,horizon:r}}_getFrameControlPoints(){const t=this.groundControlPoints,e=t?.length;if(!e)return[];const r=new Array(e),i=Math.max(...t.map((({x:t})=>t))),o=this.element.videoWidth/i;for(let n=0;n<e;n++){const{x:e,y:i,lat:a,lon:h}=t[n];r[n]={sourcePoint:s(e*o,-i*o),mapPoint:new c(h,a)}}return r}}export{x as default};
