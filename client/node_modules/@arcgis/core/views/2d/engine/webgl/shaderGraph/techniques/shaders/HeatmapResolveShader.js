/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{VertexInput as o,location as r,FragmentInput as s,UniformGroup as i,uniform as n,GraphShaderModule as a,define as l,FragmentOutput as p,input as u}from"../../GraphShaderModule.js";import{Vec4 as d,texture2D as m,Float as c,Vec2 as y,Sampler2D as v}from"../../graph/glsl.js";import{getHeatmapCompressionFactor as g}from"./heatmapUtils.js";class x extends o{}t([r(0,y)],x.prototype,"position",void 0);class f extends s{}class h extends i{}t([n(v)],h.prototype,"texture",void 0),t([n(y)],h.prototype,"minAndInvRange",void 0),t([n(c)],h.prototype,"normalization",void 0);class w extends i{}t([n(v)],w.prototype,"texture",void 0);class b extends a{constructor(){super(...arguments),this.usesHalfFloatPrecision=!1}vertex(t){return{glPosition:new d(t.position.multiply(2).subtract(1),1,1),uv:t.position}}fragment(t){const{accumulatedDensity:e,gradient:o}=this;let r=m(e.texture,t.uv).r.divide(new c(g(this.usesHalfFloatPrecision)));r=r.multiply(e.normalization),r=r.subtract(e.minAndInvRange.x).multiply(e.minAndInvRange.y);const s=m(o.texture,new y(r,.5)),i=new p;return i.glFragColor=new d(s.rgb.multiply(s.a),s.a),i}}t([l],b.prototype,"usesHalfFloatPrecision",void 0),t([n(h)],b.prototype,"accumulatedDensity",void 0),t([n(w)],b.prototype,"gradient",void 0),t([e(0,u(x))],b.prototype,"vertex",null),t([e(0,u(f))],b.prototype,"fragment",null);export{h as AccumulatedDensity,w as Gradient,f as HeatmapResolveFragmentInput,b as HeatmapResolveShader,x as HeatmapResolveVertexInput};
