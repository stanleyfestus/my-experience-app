/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{WGLDrawPhase as e}from"../../../enums.js";import{simplePipelineState as t}from"../../utils.js";import{Technique as r}from"../Technique.js";import{TechniqueType as s}from"../TechniqueType.js";import{BlendShader as i}from"../shaders/BlendShader.js";import{OpacityShader as u}from"../shaders/OpacityShader.js";import{BlendFactor as o,PixelFormat as n,TextureWrapMode as a}from"../../../../../../webgl/enums.js";import{Texture as c}from"../../../../../../webgl/Texture.js";import{TextureDescriptor as f}from"../../../../../../webgl/TextureDescriptor.js";class h extends r{constructor(){super(...arguments),this.type=s.Blend,this._backBufferTexture=null,this.shaders={blend:new i,opacity:new u}}shutdown(){super.shutdown(),null!==this._backBufferTexture&&(this._backBufferTexture.dispose(),this._backBufferTexture=null)}render(r,s){const{context:i,drawPhase:u,state:n,pixelRatio:a,inFadeTransition:c,painter:f}=r,{size:h}=n,l=i.getBoundFramebufferObject();let d,p;null!=l?(d=l.width,p=l.height):(d=Math.round(a*h[0]),p=Math.round(a*h[1]));const{blendMode:m}=s;if("normal"===m&&u!==e.LABEL){const e={shader:this.shaders.opacity,uniforms:{config:{layerTexture:{texture:s.colorTexture,unit:0},opacity:s.config.opacity}},defines:null,optionalAttributes:null,useComputeBuffer:!1};return f.setPipelineState(t),void f.submitDrawMesh(i,e,f.quadMesh)}const x=this._createOrResizeTexture(r,d,p);l.copyToTexture(0,0,d,p,0,0,x);const b={color:{write:[!0,!0,!0,!0],blendMode:"custom",blendParameters:{srcRGB:o.ONE,dstRGB:o.ZERO,srcAlpha:o.ONE,dstAlpha:o.ZERO}},depth:!1,stencil:!1};f.setPipelineState(b);const T={backbufferTexture:{texture:x,unit:0},layerTexture:{texture:s.colorTexture,unit:1},inFadeOpacity:c?1:0,...s.config},B={shader:this.shaders.blend,uniforms:{config:T},defines:{blendMode:m},optionalAttributes:null,useComputeBuffer:!1};f.submitDrawMesh(i,B,f.quadMesh)}_createOrResizeTexture(e,t,r){const{context:s}=e;if(null!==this._backBufferTexture&&this._backBufferTexture.descriptor?.width===t&&this._backBufferTexture.descriptor?.height===r)return this._backBufferTexture;if(null===this._backBufferTexture){const e=new f;e.internalFormat=n.RGBA,e.wrapMode=a.CLAMP_TO_EDGE,e.width=t,e.height=r,this._backBufferTexture=new c(s,e)}else this._backBufferTexture.resize(t,r);return this._backBufferTexture}}export{h as BlendTechnique};
