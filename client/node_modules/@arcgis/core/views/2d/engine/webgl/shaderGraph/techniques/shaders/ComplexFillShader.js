/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{location as o,uniform as i,input as r}from"../../GraphShaderModule.js";import{Vec2 as l,sin as s,cos as p,Vec3 as a,ifElse as n,Float as d,mod as m,mix as u,texture2D as f,greaterThan as y,equal as c,float as v,Vec4 as x,mat3 as h,negate as g,vec2 as b}from"../../graph/glsl.js";import{FeatureFragmentInput as w,BaseHittestVertexInput as j}from"./AFeatureShader.js";import{c256ToRad as O,bitsetGenericConsiderAlphaOnly as T,bitsetFillRandomPatternOffset as A}from"./constants.js";import{FillVertexInput as C,FillShader as F}from"./FillShader.js";import{LocalTileOffset as I}from"./LocalTileOffset.js";import{MosaicInfo as S}from"./MosaicInfo.js";import{getBit as z,isNan as M,rgba2float as V,rand as k}from"./utils.js";class q extends C{}t([o(5,x)],q.prototype,"tlbr",void 0),t([o(6,d)],q.prototype,"width",void 0),t([o(7,d)],q.prototype,"height",void 0),t([o(8,l)],q.prototype,"offset",void 0),t([o(9,l)],q.prototype,"scale",void 0),t([o(10,d)],q.prototype,"angle",void 0);class G extends w{}function L(t,e,o,i,r){const l=c(z(r,A),v(1)),s=V(new x(t,0));return n(l,h(i.divide(e.x),o.divide(e.y),0,g(o.divide(e.x)),i.divide(e.y),0,k(b(s,0)),k(b(0,s)),1),h(i.divide(e.x),o.divide(e.y),0,g(o.divide(e.x)),i.divide(e.y),0,0,0,1))}function P(t,e){const o=t.view.requiredZoomFactor,i=new l(e.width,e.height),r=i.multiply(e.scale).multiply(o),m=e.angle.multiply(O),u=s(m),f=p(m),y=L(e.id,r,u,f,e.bitset),c=t.localTileOffset.getPatternOffsetAtTileOrigin(i,u,f),v=o.multiply(e.scale).multiply(e.offset.subtract(c)).divide(r),x=new a(e.pos,1),h=y.multiply(x).xy.subtract(v),g=e.tlbr.divide(t.mosaicInfo.size.xyxy);let b=z(e.bitset,T);return null!=t.visualVariableColor&&(b=n(M(t.storage.getColorValue(e.id)),new d(0),b)),{tileTextureCoord:h,tlbr:g,sampleAlphaOnly:b}}function Z(t,e){const o=m(e.tileTextureCoord,new d(1)),i=u(e.tlbr.xy,e.tlbr.zw,o);let r=f(t.mosaicInfo.texture,i);return r=n(y(e.sampleAlphaOnly,new d(.5)),r.aaaa,r),e.color.multiply(r)}class _ extends F{vertex(t,e){return{...super.vertex(t,e),...P(this,t)}}fragment(t){const e=Z(this,t);return this.getFragmentOutput(e,t,new d(0))}}t([i(S)],_.prototype,"mosaicInfo",void 0),t([i(I)],_.prototype,"localTileOffset",void 0),t([e(0,r(q)),e(1,r(j))],_.prototype,"vertex",null),t([e(0,r(G))],_.prototype,"fragment",null);export{G as ComplexFillFragmentInput,_ as ComplexFillShader,q as ComplexFillVertexInput,Z as getComplexFillFragmentColor,P as getComplexFillVertexData};
