/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{DictionaryMatcher as e}from"./DictionaryMatcher.js";import{IntervalMatcher as t}from"./IntervalMatcher.js";import{LabelMatcher as r}from"./LabelMatcher.js";import{MapMatcher as s}from"./MapMatcher.js";import{FeatureMatcher as a}from"./Matcher.js";async function c(c,u){switch(u.type){case"simple":case"heatmap":case"dot-density":case"pie-chart":return a.from(c,u);case"interval":return t.fromIntervalSchema(c,u);case"dictionary":return e.fromDictionaryRenderer(c,u);case"label":return r.fromLabelSchema(c,u);case"map":return s.fromMatcherSchema(c,u);case"subtype":return n.fromSubtypes(c,u);case"cluster":return o.fromClusterSchema(c,u);default:throw new Error("Impl")}}class n extends a{constructor(e,t){super(),this._subMatchers=e,this._subtypeField=t}static async fromSubtypes(e,t){const r=new Map,s=[];for(const a in t.renderers){const n=parseInt(a,10),o=c(e,t.renderers[a]).then((e=>r.set(n,e)));s.push(o)}return await Promise.all(s),new n(r,t.subtypeField)}match(e,t){const r=e.readAttribute(this._subtypeField),s=this._subMatchers.get(r);return s?s.match(e,t):null}}class o extends a{static async fromClusterSchema(e,t){const[r,s]=await Promise.all([c(e,t.feature),c(e,t.cluster)]);return new o(r,s)}constructor(e,t){super(),this._featureMatcher=e,this._clusterMatcher=t}match(e,t){return 1===e.readAttribute("cluster_count")?this._featureMatcher.match(e,t):this._clusterMatcher.match(e,t)}}export{o as ClusterMatcher,n as SubtypeMatcher,c as createMatcher};
