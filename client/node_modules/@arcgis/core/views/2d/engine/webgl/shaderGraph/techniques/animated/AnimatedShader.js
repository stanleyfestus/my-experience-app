/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as i}from"../../../../../../../chunks/tslib.es6.js";import{animationDebugFlags as t}from"../../../../../../../symbols/cim/animationDebugFlags.js";import{generateVirtualMachineSource as o}from"../../../animations/instructions.js";import{location as e,uniform as r,option as a}from"../../GraphShaderModule.js";import{sin as s,cos as l,Float as n,Mat3 as m,Vec3 as u,lessThanEqual as p,cond as d,ifElse as c,equal as y,texture2D as f,clamp as h,abs as S,Vec2 as b,block as g,Vec4 as V}from"../../graph/glsl.js";import{AnimationUniformInfo as v}from"./AnimationUniformInfo.js";import{FeatureVertexInput as w,FeatureFragmentInput as x,AFeatureShader as j}from"../shaders/AFeatureShader.js";import{softEdgeRatio as z}from"../shaders/constants.js";import{MosaicInfo as T}from"../shaders/MosaicInfo.js";import{rgba2float as _}from"../shaders/utils.js";import{VisualVariableColor as I}from"../shaders/VisualVariableColor.js";import{VisualVariableOpacity as C}from"../shaders/VisualVariableOpacity.js";import{VisualVariableRotation as O}from"../shaders/VisualVariableRotation.js";import{VisualVariableSizeMinMaxValue as M}from"../shaders/VisualVariableSizeMinMaxValue.js";import{VisualVariableSizeScaleStops as P}from"../shaders/VisualVariableSizeScaleStops.js";import{VisualVariableSizeStops as D}from"../shaders/VisualVariableSizeStops.js";import{VisualVariableSizeUnitValue as F}from"../shaders/VisualVariableSizeUnitValue.js";import{getVisualVariableAngle as R}from"../shaders/vvUtils.js";class A extends w{}i([e(3,V)],A.prototype,"animationPointerAndBaseSizeAndReferenceSize",void 0),i([e(4,b)],A.prototype,"zoomRange",void 0);class L extends x{}class U extends j{_getScreenPosition(i){const{pos:t,translation:o,rotation:e,scale:r,offset:a,id:p,vvScale:d}=i,c=R(this,p).multiply(Math.PI/180),y=o.x.multiply(4/3),f=o.y.multiply(-1).multiply(4/3),h=s(e.subtract(c)),S=l(e.subtract(c)),b=new n(0),g=new n(1),{pixelRatio:V}=this.animationInfo,v=new m(g,b,b,b,g,b,y.multiply(V),f.multiply(V),g),w=new m(S,h.multiply(-1),b,h,S,b,0,0,g),x=r.multiply(d).multiply(V).multiply(4/3),j=w.multiply(x),z=this.animationInfo.toScreen.multiply(new u(t,1)),T=v.multiply(z).xy,_=j.multiply(new u(a,0)).xy;return T.add(_)}_clip(i,o){let e=super.clip(i,o);const r=p(this._getLocalTimeOrigin(i),new n(0));return t.forceGlobalTimeOrigin||(e=e.add(d([r,()=>new n(2)],[!0,()=>new n(0)]))),e}_getLocalTimeOrigin(i){return this.storage.getLocalTimeOrigin(i)}_toNdc(i){return this.animationInfo.toNdc.multiply(new u(i,1)).xy}_getEvalParams(i,t){const{globalTime:o,animationTextureSize:e,animationTexture:r}=this.animationInfo;return{globalTime:o,localTimeOrigin:this._getLocalTimeOrigin(i.id),animationTextureSize:e,animationTexture:r,pixelDimensions:t}}_getColor(i,t){return c(y(t.isSDF,new n(1)),this._getSDFColor(i,t),this._getSpriteColor(i,t))}_getSpriteColor(i,t){return f(this.mosaicInfo.texture,i).multiply(t.color)}_getSDFColor(i,t){const o=f(this.mosaicInfo.texture,i),e=new n(.5).subtract(_(o)).multiply(t.distanceToPx).multiply(z),r=h(new n(.5).subtract(e),new n(0),new n(1)),a=t.color.multiply(r),s=t.outlineSize.multiply(.5),l=S(e).subtract(s),m=h(new n(.5).subtract(l),new n(0),new n(1)),u=t.outlineColor.multiply(m);return new n(1).subtract(u.a).multiply(a).add(u)}}function E(i,t,e){const r=i.add(new b(t,0)),a=f(e.animationTexture,r.add(.5).divide(e.animationTextureSize)).xy;return i=i.add(a),g({animationPointer:i,...e},V,null,(i=>{const{out:t}=i;if(!t)throw new Error("out is null");return o({...i,out:t})}))}i([r(T)],U.prototype,"mosaicInfo",void 0),i([r(v)],U.prototype,"animationInfo",void 0),i([a(I)],U.prototype,"visualVariableColor",void 0),i([a(C)],U.prototype,"visualVariableOpacity",void 0),i([a(M)],U.prototype,"visualVariableSizeMinMaxValue",void 0),i([a(P)],U.prototype,"visualVariableSizeScaleStops",void 0),i([a(D)],U.prototype,"visualVariableSizeStops",void 0),i([a(F)],U.prototype,"visualVariableSizeUnitValue",void 0),i([a(O)],U.prototype,"visualVariableRotation",void 0);export{L as AAnimatedFragmentInput,U as AAnimatedShader,A as AAnimatedVertexInput,E as getValue};
