/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../AggregateGraphic.js";import"../../../geometry.js";import r from"../../../Graphic.js";import{isSome as i}from"../../../core/arrayUtils.js";import s from"../../../core/Collection.js";import{neverReached as a}from"../../../core/compilerUtils.js";import o from"../../../core/Error.js";import{makeHandle as n}from"../../../core/handleUtils.js";import has from"../../../core/has.js";import u from"../../../core/Logger.js";import{destroyMaybe as l}from"../../../core/maybe.js";import{notDeepEqual as h}from"../../../core/object.js";import{createAbortError as c,createResolver as p,ignoreAbortErrors as d,throwIfNotAbortError as y,isAbortError as g}from"../../../core/promiseUtils.js";import{watch as f,initial as m}from"../../../core/reactiveUtils.js";import{property as w}from"../../../core/accessorSupport/decorators/property.js";import{subclass as _}from"../../../core/accessorSupport/decorators/subclass.js";import v from"../../../layers/effects/FeatureEffectView.js";import{convertFromFeature as b}from"../../../layers/graphics/featureConversionUtils.js";import F from"../../../layers/support/FeatureFilter.js";import{packFields as A}from"../../../layers/support/fieldUtils.js";import{getEffectiveLayerCapabilities as S}from"../../../layers/support/layerUtils.js";import{combineTimeExtent as E}from"../../../layers/support/timeSupport.js";import x from"../../../rest/support/AggregateFeatureSet.js";import j from"../../../rest/support/FeatureSet.js";import C from"../../../rest/support/Query.js";import{LayerView2DMixin as V}from"./LayerView2D.js";import{FeatureContainer as R}from"./features/FeatureContainer.js";import{createFeaturePipelineWorkerProxy as U}from"./features/FeaturePipelineWorkerProxy.js";import{FeatureSourceEventLog as k}from"./features/FeatureSourceEventLog.js";import{CatalogFootprintLayerAdapter as q}from"./features/layerAdapters/CatalogFootprintLayerAdapter.js";import{FeatureLayerAdapter as Q}from"./features/layerAdapters/FeatureLayerAdapter.js";import{InMemoryLayerAdapter as I}from"./features/layerAdapters/InMemoryLayerAdapter.js";import{KnowledgeGraphSublayerAdapter as O}from"./features/layerAdapters/KnowledgeGraphSublayerAdapter.js";import{OGCFeatureLayerAdapter as L}from"./features/layerAdapters/OGCFeatureLayerAdapter.js";import{OrientedImageryLayerAdapter as T}from"./features/layerAdapters/OrientedImageryLayerAdapter.js";import{ParquetLayerAdapter as H}from"./features/layerAdapters/ParquetLayerAdapter.js";import{StreamLayerAdapter as P}from"./features/layerAdapters/StreamLayerAdapter.js";import{SubtypeGroupLayerAdapter as W}from"./features/layerAdapters/SubtypeGroupLayerAdapter.js";import{createComplexSymbolInstances as M}from"./features/schema/processor/symbols/ComplexSymbolSchema.js";import D from"./support/FeatureCommandQueue.js";import{handleNoEngineError as N}from"./support/handleNoEngineError.js";import{HighlightCounter as G}from"./support/HighlightCounter.js";import{toJSONGeometryType as J}from"./support/util.js";import{FeatureTileSubscriptionManager as $}from"../tiling/FeatureTileSubscriptionManager.js";import z from"../../layers/FeatureLayerView.js";import B from"../../layers/LayerView.js";import Z from"../../layers/RefreshableLayerView.js";import K from"../../../geometry/Extent.js";function X(e,t){const r=new Set;return e&&e.forEach((e=>r.add(e))),t&&t.forEach((e=>r.add(e))),r.has("*")?["*"]:Array.from(r)}const Y=4294967294;let ee=class extends(z(Z(V(B)))){constructor(){super(...arguments),this._commandsQueue=new D({process:e=>{switch(e.type){case"edit-by-feature":case"edit-by-id":return this._doEdit(e);case"update":return this._doUpdate();case"highlight":return this._updateHighlights()}}}),this._visibilityOverrides=new Set,this._highlightCounter=new G,this._lastAvailableFields=[],this._lastTargetState=null,this.eventLog=new k,this._sourceRefreshVersion=1,this._displayRefreshVersion=1,this._pipelineUpdating=!1,this._fields=null,this.featureEffectView=new v}destroy(){this._workerProxy?.destroy(),this._workerAttached.reject(c()),this._commandsQueue.destroy()}initialize(){this._workerAttached=p(),d(this._workerAttached.promise),this.addResolvingPromise(this._initProxy()),this.featureEffectView.featureEffect=this.featureEffect,this.featureEffectView.endTransition()}async _initProxy(){const e=this.layer;if("isTable"in e&&e.isTable)throw new o("featurelayerview:table-not-supported","table feature layer can't be displayed",{layer:e});if("mesh"===e.geometryType)throw new o("featurelayerview:geometry-type-not-supported",`Geometry type of ${e.geometryType} is not supported`,{layer:e});if(("feature"===e.type||"subtype-group"===e.type)&&!1===S(e)?.operations.supportsQuery)throw new o("featurelayerview:query-not-supported","layer view requires a layer with query capability",{layer:e});this._workerProxy&&this._workerProxy.destroy();const t=this._createClientOptions();this._workerProxy=await U(t)}async _attachProxy(){const e={service:await this.layerAdapter.createServiceOptions(this.view),tileInfoJSON:this.view?.featuresTilingScheme?.tileInfo?.toJSON()};let t=[];Array.isArray(e.service.source)&&(t=e.service.source);try{await this._workerProxy.pipeline.onAttach(e,{transferList:t}),this._workerAttached.resolve()}catch(r){this._workerAttached.reject(c()),y(r)}}async _detachProxy(){return this._workerProxy.pipeline.onDetach()}async getWorker(){return await this._workerAttached.promise,this._workerProxy}get hasAllFeatures(){return this.layer.visible&&!this.suspended&&this.eventLog.hasAllFeatures}get hasAllFeaturesInView(){return this.layer.visible&&!this.suspended&&this.eventLog.hasAllFeaturesInView}get hasFullGeometries(){return this.layer.visible&&!this.suspended&&this.eventLog.hasFullGeometries}get labelingCollisionInfos(){const e=this.layerAdapter.getLabelingDeconflictionInfo(this.view),t=this.layer.geometryType,r=!this.suspended;return e.map((({vvEvaluators:e,deconflictionEnabled:i})=>({container:this.featureContainer,vvEvaluators:e,deconflictionEnabled:i,geometryType:t,visible:r})))}get layerAdapter(){switch(this.layer.type){case"feature":return"memory"===this.layer.source.type?new I(this.layer):new Q(this.layer);case"geojson":case"csv":case"wfs":return new I(this.layer);case"parquet":return new H(this.layer);case"subtype-group":return new W(this.layer);case"ogc-feature":return new L(this.layer);case"stream":return new P(this.layer);case"oriented-imagery":return new T(this.layer);case"knowledge-graph-sublayer":return new O(this.layer);case"catalog-footprint":return new q(this.layer);default:a(this.layer)}return null}get timeExtent(){return E(this.layerAdapter.timeOptions,this.view?.timeExtent,this._get("timeExtent"))}getDisplayStatistics(e,t){return this.featureContainer?.getDisplayStatistics(e,t)}async queryHeatmapStatistics(e){return(await this.getWorker()).pipeline.queryHeatmapStatistics(e)}highlight(e,t="default"){let a;e instanceof r?a=[e.getObjectId()]:"number"==typeof e||"string"==typeof e?a=[e]:s.isCollection(e)&&e.length>0?a=e.map((e=>e?.getObjectId())).toArray():Array.isArray(e)&&e.length>0&&(a="number"==typeof e[0]||"string"==typeof e[0]?e:e.map((e=>e?.getObjectId())));const o=a?.filter(i);return o?.length?(this._addHighlights(o,t),n((()=>this._removeHighlights(o,t)))):n()}getHighlightIds(){return Array.from(this._highlightCounter.ids())}hasHighlight(){return!this._highlightCounter.empty}async hitTest(e,i){const s=await this.featureContainer.hitTest(i);if(0===s.length)return null;const a=await this.getWorker(),{features:o,aggregates:n}=await a.pipeline.getDisplayFeatures(s),u=this.featureContainer.getSortKeys(s),l=({displayId:e},{displayId:t})=>u.has(e)&&u.has(t)?u.get(e)-u.get(t):e-t;return o.sort(l).reverse(),n.sort(l).reverse(),[...n.map((r=>this._createGraphicHit(e,t.fromJSON(r)))),...o.map((t=>this._createGraphicHit(e,r.fromJSON(t))))]}async queryStatistics(){const e=await this.getWorker();return N(e.pipeline.queryStatistics(),{featureCount:0,ringCount:0,vertexCount:0})}async querySummaryStatistics(e,t,r){const i=await this.getWorker(),s={...t,scale:this.view.scale},a=i.features.executeQueryForSummaryStatistics(this._cleanUpQuery(e),s,r);return N(a,{})}async queryAggregateSummaryStatistics(e,t,r){const i={...t,scale:this.view.scale},s=(await this.getWorker()).aggregates.executeQueryForSummaryStatistics(this._cleanUpAggregateQuery(e),i,r);return N(s,{})}async queryUniqueValues(e,t,r){const i=await this.getWorker(),s={...t,scale:this.view.scale},a=i.features.executeQueryForUniqueValues(this._cleanUpQuery(e),s,r);return N(a,{uniqueValueInfos:[]})}async queryAggregateUniqueValues(e,t,r){const i=await this.getWorker(),s={...t,scale:this.view.scale},a=i.aggregates.executeQueryForUniqueValues(this._cleanUpAggregateQuery(e),s,r);return N(a,{uniqueValueInfos:[]})}async queryClassBreaks(e,t,r){const i=await this.getWorker(),s={...t,scale:this.view.scale},a=i.features.executeQueryForClassBreaks(this._cleanUpQuery(e),s,r);return N(a,{classBreakInfos:[]})}async queryAggregateClassBreaks(e,t,r){const i=await this.getWorker(),s={...t,scale:this.view.scale},a=i.aggregates.executeQueryForClassBreaks(this._cleanUpAggregateQuery(e),s,r);return N(a,{classBreakInfos:[]})}async queryHistogram(e,t,r){const i=await this.getWorker(),s={...t,scale:this.view.scale},a=i.features.executeQueryForHistogram(this._cleanUpQuery(e),s,r);return N(a,{bins:[],maxValue:null,minValue:null,normalizationTotal:null})}async queryAggregateHistogram(e,t,r){const i=await this.getWorker(),s={...t,scale:this.view.scale},a=i.aggregates.executeQueryForHistogram(this._cleanUpAggregateQuery(e),s,r);return N(a,{bins:[],maxValue:null,minValue:null,normalizationTotal:null})}queryFeatures(e,t){return this.queryFeaturesJSON(e,t).then((e=>{const t=j.fromJSON(e);return t.features.forEach((e=>this._setLayersForFeature(e))),t}))}async queryVisibleFeatures(e,t){const r=(await this.getWorker()).pipeline.queryVisibleFeatures(this._cleanUpQuery(e),t),i=await N(r,{features:[]}),s=j.fromJSON(i);return s.features.forEach((e=>this._setLayersForFeature(e))),s}async queryAggregates(e,t){const r=(await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e),t),i=await N(r,{features:[]}),s=x.fromJSON(i);return s.features.forEach((e=>this._setLayersForFeature(e))),s}async queryAggregateIds(e,t){const r=(await this.getWorker()).aggregates.executeQueryForIds(this._cleanUpAggregateQuery(e),t);return N(r,[])}async queryAggregateCount(e,t){const r=(await this.getWorker()).aggregates.executeQueryForCount(this._cleanUpAggregateQuery(e),t);return N(r,0)}async queryAggregateJSON(e,t){const r=(await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e),t);return N(r,{features:[]})}async queryFeaturesJSON(e,t){const r=(await this.getWorker()).features.executeQuery(this._cleanUpQuery(e),t);return N(r,{features:[]})}async queryObjectIds(e,t){const r=(await this.getWorker()).features.executeQueryForIds(this._cleanUpQuery(e),t);return N(r,[])}async queryFeatureCount(e,t){const r=(await this.getWorker()).features.executeQueryForCount(this._cleanUpQuery(e),t);return N(r,0)}async queryExtent(e,t){const r=(await this.getWorker()).features.executeQueryForExtent(this._cleanUpQuery(e),t),i=await N(r,{count:0,extent:null});return{count:i.count,extent:K.fromJSON(i.extent)}}async getSampleFeatures(e){return(await this.getWorker()).pipeline.getSampleFeatures(e)}setVisibility(e,t){t?this._visibilityOverrides.delete(e):this._visibilityOverrides.add(e),this._update()}update(e){if(!this._subscriptionManager)return;this.view.animation&&!this._lastTargetState&&(this._lastTargetState=e.state.clone()),!this.view.animation&&this._lastTargetState&&(this._lastTargetState=null);const t=this._subscriptionManager.update(e.targetState,this._lastTargetState);this.featureContainer.setVisibleTiles(t)}attach(){has("esri-2d-update-debug")&&console.debug("FeatureLayerView2D.attach"),d(this._updatingHandles.addPromise(this._workerAttached.promise)),d(this._attachProxy()),this.featureContainer=new R(this),this.container.addChild(this.featureContainer),this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`),this._subscriptionManager=new $({tileInfoView:this.view.featuresTilingScheme,updateSubscriptions:e=>{this.featureContainer.updateSubscriptions(e),d(this._updatingHandles.addPromise(this.getWorker().then((t=>t.pipeline.updateSubscriptions(e)))))},isDone:e=>this.featureContainer.isDone(e)}),this.requestUpdate(),this.addAttachHandles([f((()=>JSON.stringify({displayRefreshVersion:this._displayRefreshVersion,timeExtent:this.timeExtent,clips:this.clips,filter:this.filter,featureEffect:this.featureEffect,sourceRefreshVersion:this._sourceRefreshVersion,timeZone:this.view.timeZone,effect:this.featureEffect,...this.layerAdapter.getUpdateHashProperties(this.view)})),(()=>this._update()),m),f((()=>this.updateSuspended),(e=>{e||(this._subscriptionManager.resume(),this.view.labelManager.requestUpdate())})),f((()=>this.visible),(e=>{this.view.labelManager.requestUpdate()}))]),"stream"!==this.layer.type&&"parquet"!==this.layer.type&&"catalog-footprint"!==this.layer.type&&this.addAttachHandles(this.layer.on("edits",(e=>this._edit(e))))}detach(){has("esri-2d-update-debug")&&console.debug("FeatureLayerView2D.detach"),this._detachProxy(),this._fields=null,this.featureContainer.destroy(),this.featureContainer=null,this._commandsQueue.clear(),this.container.removeAllChildren(),this._subscriptionManager=l(this._subscriptionManager),this._workerProxy.pipeline.onDetach(),this._workerAttached=p(),d(this._workerAttached.promise),this._lastAvailableFields=[],this._lastSchema=null}viewChange(){this.requestUpdate()}moveEnd(){this.requestUpdate()}isUpdating(){const e="renderer"in this.layer&&null!=this.layer.renderer,t=this._commandsQueue.updateTracking.updating,r=null!=this._updatingRequiredFieldsPromise,i=this.featureContainer.updatingHandles.updating,s=this.updateRequested||e&&(t||r)||i||this._pipelineUpdating||this.dataUpdating;if(has("esri-2d-log-updating")){console.log(`Updating FLV2D (${this.layer.id}): ${s}\n  -> updateRequested ${this.updateRequested}\n  -> hasRenderer ${e}\n  -> updatingRequiredFields ${r}\n  -> hasPendingCommand ${t}\n  -> dataUpdating ${this.dataUpdating}\n  -> processing ${this._pipelineUpdating}\n  -> updatingContainer ${i}\n`);for(const e of this.featureContainer.subscriptions())console.log(`    -> Tile[${e.id}] Done: ${e.done}`)}return s}_createClientOptions(){const e=this;return{get container(){return e.featureContainer},setUpdating:e=>{this._set("_pipelineUpdating",e.pipeline),this._set("dataUpdating",e.data)},emitEvent:e=>{this.emit(e.name,e.event)},get eventLog(){return e.eventLog},fetch:t=>Promise.all(t.map((t=>e.view.stage.painter.textureManager.rasterizeItem(t)))),fetchDictionary:e=>Promise.all(e.map((e=>this._fetchDictionaryRequest(e))))}}async _fetchDictionaryRequest(e){try{if("subtype-group"===this.layer.type)throw new Error("InternalError: SubtypeGroupLayer does not support dictionary renderer");const t=this.layer.renderer;if(!t||"dictionary"!==t.type)throw new Error("InternalError: Expected layer to have a DictionaryRenderer");const r=this._lastSchema.processor.mesh.factory.symbology;if("dictionary"!==r.type)throw new Error("InternalError: Expected schema to be of type 'dictionary'");const i={cimAnalyzer:this.view.stage.cimAnalyzer,cimResourceManager:this.view.stage.painter.textureManager.resourceManager,store:this.featureContainer.instanceStore,scaleExpression:r.scaleExpression};this._fields||(this._fields=this.layer.fields.map((e=>e.toJSON())));const s=r.visualVariableUniforms,a=await t.getSymbolAsync(e.feature,{fields:this._fields});if(!a||!a.data)return{type:"dictionary-response",meshes:[]};return{type:"dictionary-response",meshes:await M(a.data,{uniforms:s,path:"renderer",schemaOptions:i})}}catch(t){return{type:"dictionary-response",meshes:[]}}}_cleanUpQuery(e){const t=C.from(e)||this.createQuery();return t.outSpatialReference||(t.outSpatialReference=this.view.spatialReference),t.toJSON()}_cleanUpAggregateQuery(e){const t=C.from(e)||this.createAggregateQuery();t.outSpatialReference||(t.outSpatialReference=this.view.spatialReference);const r=t.objectIds??[];for(const i of t.aggregateIds??[])r.push(i);return t.objectIds=r,t.aggregateIds=[],t.toJSON()}async _update(){return this._commandsQueue.push({type:"update"})}async _edit(e){if(this.updateSuspended)return void this._subscriptionManager.suspend();const t=this._getEffectiveEdit(e);return t?this._commandsQueue.push(t).catch(y):void 0}async doRefresh(e){this.attached&&(this.updateSuspended&&e||(e?this.incrementSourceRefreshVersion():this.incrementDisplayRefreshVersion()))}incrementSourceRefreshVersion(){this._sourceRefreshVersion=(this._sourceRefreshVersion+1)%Y+1}incrementDisplayRefreshVersion(){this._displayRefreshVersion=(this._displayRefreshVersion+1)%Y+1}_getEffectiveEdit(e){const t="globalIdField"in this.layer&&this.layer.globalIdField,r=e.deletedFeatures.some((e=>-1===e.objectId||!e.objectId)),i=t&&this.availableFields.includes(t);if(r&&!i)return u.getLogger(this).error(new o("mapview-apply-edits",`Editing the specified service requires the layer's globalIdField, ${t} to be included the layer's outFields for updates to be reflected on the map`)),null;const s=this.layer,a=e.historicMoment?.getTime()??null,n="layerId"in s&&e.editedFeatures?.find((e=>e.layerId===s.layerId));if(n&&this._canEditByFeature(n)){const e=!1,r=!1,i=J(this.layer.geometryType),{adds:s,deletes:o,updates:u}=n.editedFeatures,l=this.layer.objectIdField,h=s.map((t=>b(t,i,e,r))),c=u.map((t=>b(t.current,i,e,r)));return{type:"edit-by-feature",added:h,removed:o.map((e=>"attributes"in e?{globalId:t?e.attributes[t]:null,objectId:l?e.attributes[l]:null}:e)),updated:c,historicMoment:a}}return{type:"edit-by-id",added:e.addedFeatures,updated:e.updatedFeatures,removed:e.deletedFeatures,historicMoment:a}}_canEditByFeature(e){const{adds:t,updates:r}=e.editedFeatures;return t.every((e=>this.view.spatialReference.equals(e.geometry?.spatialReference)))&&r.every((e=>this.view.spatialReference.equals(e.current.geometry?.spatialReference)))}async _doUpdate(){"featureReduction"in this.layer&&this.layer.featureReduction&&this.layer.featureReduction!==this._lastFeatureReduction&&(this.layer.featureReduction=this.layer.featureReduction?.clone(),this._lastFeatureReduction=this.layer.featureReduction);try{if(await this._updateRequiredFields(),this.destroyed||!this.layerAdapter?.hasRequiredSupport||!this._subscriptionManager)return;const e=this.featureContainer.instanceStore;this.featureContainer.attributeView.lockTextureUploads(),e.updateStart();const t=this.featureEffect,r={store:e,cimAnalyzer:this.view.stage.cimAnalyzer,cimResourceManager:this.view.stage.painter.textureManager.resourceManager,scaleExpression:void 0},i=this._createViewSchemaConfig(),s={source:this.layerAdapter.createSourceSchema(i,this._sourceRefreshVersion),processor:await this.layerAdapter.createProcessorSchema(r,i,this._displayRefreshVersion)},a=h(this._lastSchema?.source.mutable,s.source.mutable)||h(this._lastSchema?.processor,s.processor);if(!a)return this.featureContainer.requestRender(),this.featureContainer.attributeView.unlockTextureUploads(),e.updateEnd(),void(this.featureEffectView.featureEffect=t);this._lastSchema=s,this._fields=null;const o=Math.round(performance.now());has("esri-2d-update-debug")&&console.debug(`Id[${this.layer.uid}] Version[${o}] FeatureLayerView2D._doUpdate`,{changes:a});const n=await this.getWorker();await n.pipeline.updateSchema(s,o),e.updateEnd(),this.featureEffectView.featureEffect=t,this.featureEffectView.endTransition(),this.featureContainer.restartAllAnimations(),this.featureContainer.attributeView.unlockTextureUploads(),this.featureContainer.swapRenderState(),this.featureContainer.requestRender(),has("esri-2d-update-debug")&&console.debug(`Version[${o}] FeatureLayerView2D.updateEnd`),this.requestUpdate()}catch(e){has("esri-2d-update-debug")&&console.error("Encountered an error during update",e)}}async _doEdit(e){const t=await this.getWorker();try{this.featureContainer.editStart(),await t.pipeline.onEdits(e),this.featureContainer.editEnd()}catch(r){g(r),0}}get hasFilter(){const e=this.layerAdapter.hasFilters?.(this.view)??!1;return null!=this.filter||null!=this.timeExtent||this._visibilityOverrides.size>0||e}_getEffectiveAvailableFields(e){const t=X(this._lastAvailableFields,e);return this._lastAvailableFields=t,A(this.layer.fieldsIndex,t)}_createViewSchemaConfig(){const e=[te(this.view,this.layerAdapter,this.timeExtent,this._visibilityOverrides,this.filter),this.featureEffect?.filter?.toJSON()??null];return{availableFields:this._getEffectiveAvailableFields(this.availableFields),filters:e,scale:this.view.scale,timeZone:this.view.timeZone}}_addHighlights(e,t){this._highlightCounter.addGroup(e,t),this._commandsQueue.push({type:"highlight"})}_removeHighlights(e,t){this._highlightCounter.deleteGroup(e,t),this._commandsQueue.push({type:"highlight"})}async _updateHighlights(){const e=[];for(const i of this._highlightCounter.ids()){const t=this._highlightCounter.getHighlightGroups(i),r=this._getHighlightBits(t);e.push({objectId:i,highlightFlags:r})}const t=await this.getWorker();if(this.destroyed)return;const r=t.pipeline.updateHighlight({highlights:e}).catch((e=>{g(e)||u.getLogger(this).error(e)}));this._updatingHandles.addPromise(r)}_setLayersForFeature(e){e.layer=e.sourceLayer=this.layer,this.layerAdapter.setGraphicOrigin&&this.layerAdapter.setGraphicOrigin(e)}_createGraphicHit(e,t){return this._setLayersForFeature(t),null!=t.geometry&&(t.geometry.spatialReference=this.view.spatialReference),{type:"graphic",graphic:t,layer:this.layer,mapPoint:e}}};function te(e,t,r,i,s){s&&(s=s.clone());const a=null!=s?s.timeExtent:null,o=null!=r&&null!=a?r.intersection(a):r||a;o&&(s??=new F,s.timeExtent=o),s=t.addFilters?.(s,e)??s;let n=s?.toJSON()??null;return i.size&&(n??=(new F).toJSON(),n.hiddenIds=Array.from(i)),n}e([w()],ee.prototype,"_commandsQueue",void 0),e([w()],ee.prototype,"_sourceRefreshVersion",void 0),e([w()],ee.prototype,"_displayRefreshVersion",void 0),e([w({readOnly:!0})],ee.prototype,"_pipelineUpdating",void 0),e([w({readOnly:!0})],ee.prototype,"hasAllFeatures",null),e([w({readOnly:!0})],ee.prototype,"hasAllFeaturesInView",null),e([w({readOnly:!0})],ee.prototype,"hasFullGeometries",null),e([w()],ee.prototype,"featureEffectView",void 0),e([w()],ee.prototype,"labelingCollisionInfos",null),e([w()],ee.prototype,"layerAdapter",null),e([w({readOnly:!0})],ee.prototype,"timeExtent",null),e([w()],ee.prototype,"updating",void 0),ee=e([_("esri.views.2d.layers.FeatureLayerView2D")],ee);const re=ee;export{re as default};
