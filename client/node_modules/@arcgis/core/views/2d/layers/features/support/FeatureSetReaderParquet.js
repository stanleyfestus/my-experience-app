/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../../../../core/has.js";import{lngLatToXY as e}from"../../../../../geometry/support/webMercatorUtils.js";import t from"../../../../../layers/graphics/OptimizedGeometry.js";import{FeatureSetReader as i}from"./FeatureSetReader.js";class r extends i{constructor(e,t,i,r,s,n=new Uint32Array(r.size())){super(e),this._fields=t,this._geometryInfo=i,this._inner=r,this._chunkId=s,this._displayIds=n,this._index=-1,this._size=this._inner.size(),"geometry"===this._geometryInfo.type&&(this._primaryGeometryIndex=this._fields.get(this._geometryInfo.primaryFieldName)?.index),null!=e.objectIdField&&(this._objectIdFieldIndex=this._fields.get(e.objectIdField)?.index),this._chunkId>65535&&console.error("Exceeded max allowed parquet reader size")}destroy(){super.destroy(),this._inner.free()}get fields(){return this._fields}get geometryType(){return"esriGeometryPoint"}get hasFeatures(){return!0}get hasNext(){throw new Error("Method not implemented.")}get exceededTransferLimit(){return!1}get hasZ(){return!1}get hasM(){return!1}getInTransform(){return null}getSize(){return this._size}getCursor(){return this.copy()}getAttributeHash(){let e="";for(const t of this.fields.fields)e+=this._readAttribute(t.name,!1)+".";return e}getObjectId(){return null!=this._objectIdFieldIndex?this._inner.readAttribute(this._index,this._objectIdFieldIndex):this._index<<16|this._chunkId}getDisplayId(){return this._displayIds[this._index]}setDisplayId(e){this._displayIds[this._index]=e}setIndex(e){this._index=e}getIndex(){return this._index}next(){for(;++this._index<this._size&&!this._getExists(););return this._index<this._size}readGeometryArea(){throw new Error("Method not implemented.")}copy(){const e=new r(this.metadata,this._fields,this._geometryInfo,this._inner,this._chunkId,this._displayIds);return this.copyInto(e),e}copyInto(e){super.copyInto(e),e._index=this._index}_readGeometry(i){const r=e(this._inner.readX(this._index),this._inner.readY(this._index));return new t([],r)}_readX(){return this._readGeometry()?.coords[0]}_readY(){return this._readGeometry()?.coords[1]}_readServerCentroid(){return null}_readAttribute(e,t){const i=this.fields.get(e);if(!i)return;const r=this._inner.readAttribute(this._index,i.index);if(null==r)return r;const s=this.fields.isDateField(i.name);return t?null==r?r:s?new Date(r):r:r}_readAttributes(){const e={};for(const t of this._fields.fields)this._inner.hasField(t.index)&&t.index!==this._primaryGeometryIndex&&(e[t.name]=this._readAttribute(t.name,!1));return null==this._objectIdFieldIndex&&(e.__OBJECTID=this.getObjectId()),e}}export{r as FeatureSetReaderParquet};
