/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{cyclicalDegrees as e,Cyclical as t}from"../../core/Cyclical.js";import{createAngle as r,convertRotationType as i}from"../../core/quantityUtils.js";import{convertUnit as o}from"../../core/unitUtils.js";import{angle as n}from"../../core/libs/gl-matrix-2/math/vec2.js";import{UNIT_Y as a,create as s}from"../../core/libs/gl-matrix-2/factories/vec2f64.js";import{i as c,p as l,c as u}from"../../chunks/vec32.js";import{create as f}from"../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectVectorToVector as m}from"../../geometry/projection/projectVectorToVector.js";import{geodesicCompatibleSpatialReference as g,inverseGeodeticSolver as p,directGeodeticSolver as v,InverseGeodeticSolverResult as d}from"../../geometry/support/geodesicUtils.js";import{equals as h}from"../../geometry/support/spatialReferenceUtils.js";var j;function R(e,t){if(null==e||null==t)return;const i=b(e,t);return null!=i?r(i,"radians","geographic"):void 0}!function(e){e.Absolute="absolute",e.Relative="relative",e.RelativeBilateral="relative-bilateral"}(j||(j={}));const b=(()=>{const e=f(),t=f();return(r,i)=>(c(e,r.x,r.y,r.z??0),c(t,i.x,i.y,i.z??0),y(e,t,r.spatialReference,i.spatialReference))})(),y=(()=>{const e=s(),t=f(),r=f();return(i,s,c,u)=>{if(l(i,s))return;const f=g(c),v=g(u);if(f&&v&&h(f,v)&&m(i,c,t,f)&&m(s,u,r,v)){const{azimuth:e}=p(k,t,r,f);return null!=e?o(e,"degrees","radians"):void 0}e[0]=s[0]-i[0],e[1]=s[1]-i[1];let d=n(a,e);return e[0]<0&&(d=q-d),d}})();function x(e,t,r,i=j.Absolute){if(t&&r)switch(i){case j.Absolute:return R(t,r);case j.Relative:return w(z(e,t,r),j.Relative);case j.RelativeBilateral:return w(z(e,t,r),j.RelativeBilateral)}}function z(e,t,i){if(!e||!t||!i)return;const o=b(e,t),n=b(t,i);return null!=o&&null!=n?r(n-o,"radians","geographic"):void 0}function w(e,t){if(null!=e)switch(t){case j.Absolute:return A(e);case j.Relative:{const t=T(e);let i=I.normalize(t,0,!0);return-180===i&&(i=180),r(i,"degrees","geographic")}case j.RelativeBilateral:{const t=T(e),i=Math.abs(I.normalize(t,0,!0));return r(i,"degrees","geographic")}}}function A(e){const t=T(e),i=C.normalize(t,0,!0);return r(i,"degrees","geographic")}function B(e,t,n){let a=o(e.value,e.unit,"degrees");return a=i(a,e.rotationType,n),a=o(a,"degrees",t),r(a,t,n)}const M=(()=>{const e=f();return(t,r,n,a,s,l="geodesic")=>{u(e,r);const f=T(s);if("geodesic"===l){const i=g(n);if(i&&m(e,n,e,i))return v(t,e,f,a,i),t[2]=r[2],!!m(t,i,t,n)}const p=i(f,"geographic","arithmetic"),d=o(p,"degrees","radians"),h=r[0]+a*Math.cos(d),j=r[1]+a*Math.sin(d),R=r[2];return c(t,h,j,R),!0}})();function T(e){if(null!=e)return i(V(e),e.rotationType,"geographic")}function U(e){if(null!=e)return i(V(e),e.rotationType,"arithmetic")}function V(e){return o(e.value,e.unit,"degrees")}const k=new d,q=2*Math.PI,C=e,I=new t(-180,180);export{j as DirectionMode,B as convertAngle,R as directionBetweenPoints,x as directionForVertices,U as getDegreesArithmetic,T as getDegreesGeographic,w as getNormalizedDirection,A as getNormalizedGeographicOrientation,M as pointFromDistanceAlongAzimuth,y as radiansGeographicBetweenVec};
