/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../Graphic.js";import{pickRandom as i}from"../../../core/arrayUtils.js";import r from"../../../core/Error.js";import{throwIfAborted as a}from"../../../core/promiseUtils.js";import{property as s}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import{subclass as n}from"../../../core/accessorSupport/decorators/subclass.js";import{resolveTimeZone as o}from"../../../intl/date.js";import{isHostedAgolService as l}from"../../../layers/support/arcgisLayerUrl.js";import{isTimeOnlyField as u,isNumericField as m,isDateOnlyField as p}from"../../../layers/support/fieldUtils.js";import{generateRenderer as c}from"../../../rest/generateRenderer.js";import d from"../../../rest/support/AutoIntervalBinParameters.js";import h from"../../../rest/support/BinsQuery.js";import f from"../../../rest/support/DateBinParameters.js";import y from"../../../rest/support/FixedBoundariesBinParameters.js";import F from"../../../rest/support/FixedIntervalBinParameters.js";import w from"../../../rest/support/GenerateRendererParameters.js";import g from"../../../rest/support/StatisticDefinition.js";import v from"../../../rest/support/UniqueValueDefinition.js";import{getArcadeForPredominantCategory as S,getSQLForPredominantCategoryName as x}from"../../statistics/support/predominanceUtils.js";import{getSQLFilterForNormalization as z,mergeWhereClauses as _,getRangeExpr as T}from"../../statistics/support/utils.js";import{WorkerClient as V}from"../../statistics/support/WorkerClient.js";import{isAnyDateField as q,fieldDelimiter as E}from"../utils.js";import j from"./InMemoryLayerAdapter.js";import{ensureFeaturesJSON as L,getSummaryStatsQuery as b,getSummaryStatisticsFromFeatureSet as Q,getUVQuery as B,getUniqueValuesFromFeatureSet as N,getSQLExpressionForDateOrTimeField as M,getFieldExpr as R,defaultNumBins as I,updateQueryWithFeatureFilter as C,getHistogramFromFeatureSet as P,generateBinParams as $,getDomainsForFields as D,getBins as k,getPredominantCategoriesFromUVInfos as O,getMissingFields as G}from"./support/utils.js";import{processSummaryStatisticsResult as A,createUVResult as U,getEqualIntervalBins as W,createClassBreaksDefinition as J,resolveCBResult as Z}from"../../../statistics/utils.js";import{getScaleToResolutionFactor as H}from"../../../views/2d/viewpointUtils.js";const K=5,X=2e4,Y=4e5;function ee(e,t=!1){if("string"!=typeof e)return e;return(t?new Date(`1970-01-01T${e}Z`):new Date(e)).getTime()}let te=class extends j{constructor(){super(...arguments),this.adapterName="feature-layer-adapter"}_isStatsSupportedOnService(){const e=this.layer;if(!e.capabilities?.query?.supportsStatistics||"multipatch"===this.geometryType&&!l(e.url)&&e.version<10.5)throw new r(`${this.adapterName}:not-supported`,"Layer does not support statistics query");return Promise.resolve()}_fetchFeaturesFromService(e,t){return this.layer.queryFeatures(e,{signal:t}).then((e=>e.features))}_fetchFeaturesJSONFromService(e,t){return this._fetchFeaturesFromService(e,t).then(L)}_summaryStatsFromGenRend(e){const t=e.normalizationType,i=e.normalizationField;return this.classBreaks({field:e.field,numClasses:K,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:t,normalizationField:"field"===t?i:void 0,minValue:e.minValue,maxValue:e.maxValue,filter:e.filter,signal:e.signal}).then((t=>{let i,r,a;if(t.classBreakInfos?.some((e=>(e.hasAvg&&(i=e),!!i))),i){const e=i.maxValue-i.minValue;r=i.minValue+e/2,a=4*e}const s={min:t.minValue,max:t.maxValue,avg:r,stddev:a};return A(s,e.outStatisticTypes)}))}async _summaryStatsFromServiceQuery(e,t){await this._isStatsSupportedOnService(),"percent-of-total"===e.normalizationType&&(e.normalizationTotal=await this._getNormalizationTotal(e.field,e.normalizationType,e.filter));const i=q(t)||u(t),r=b(this,e,t),a=await this.layer.queryFeatures(r,{signal:e.signal}),s=Q(a,i);return A(s,e.outStatisticTypes)}_uvFromGenRenderer(e,t){const i=e.field??void 0,r=new v({attributeField:i}),a=new w({classificationDefinition:r});return this.generateRenderer(a,e.signal).then((e=>{const t={},r=this.getField(i);return e.uniqueValues.forEach((e=>{let i=e.value;null!=i&&""!==i&&("string"!=typeof i||""!==i.trim()&&"<null>"!==i.toLowerCase())||(i=null),null==t[i]?t[i]={count:e.count,data:m(r)&&i?Number(i):i}:t[i].count=t[i].count+e.count})),{count:t}})).then((i=>U(i,[t],e.returnAllCodedValues)))}async _uvFromServiceQuery(e,t){return this._isStatsSupportedOnService().then((()=>this.layer.queryFeatures(B(this,e),{signal:e.signal}))).then((t=>N(t,{layer:this,field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:E,view:e.view,signal:e.signal}))).then((i=>U(i,t,e.returnAllCodedValues,E)))}_getNormalizationTotal(e,t,i,r){return e&&"percent-of-total"===t?this.summaryStatistics({field:e,outStatisticTypes:{include:["sum"]},filter:i,signal:r}).then((e=>e.sum)):Promise.resolve(null)}_getQueryParamsForExpr(e,t){const i=e.valueExpression||e.sqlExpression,r=e.signal;if(!i){const{field:i,normalizationType:a,normalizationField:s}=e,n=i?this.getField(i):null,o=q(n)||u(n),l={field:i,normalizationType:a,normalizationField:s,normalizationTotal:t,layer:this};return{sqlExpression:o?M(this,n):R(l),sqlWhere:o?null:e.sqlWhere||z({field:i,normalizationType:a,normalizationField:s}),filter:e.filter,signal:r}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,filter:e.filter,signal:r}}_getDataRange(e,t,i){return null!=t&&null!=i?Promise.resolve({min:t,max:i}):this.summaryStatistics({...e,outStatisticTypes:{include:["min","max"]}}).then((e=>({min:e.min,max:e.max})))}_histogramForExpr(e){return this._getNormalizationTotal(e.field,e.normalizationType,e.filter,e.signal).then((t=>{const i=this._getQueryParamsForExpr(e,t);return this._getDataRange(i,e.minValue,e.maxValue).then((r=>{const a=r.min,s=r.max;if(null==a||null==s)return{bins:[],minValue:a,maxValue:s,normalizationTotal:t};const n=e.numBins||I,o=W(a,s,n),l=ie(i.sqlExpression,o,null!=e.minValue&&null!=e.maxValue),u=new g({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),m=this.layer.createQuery();return m.where=_(m.where,i.sqlWhere),m.sqlFormat="standard",m.outStatistics=[u],m.groupByFieldsForStatistics=[l],m.orderByFields=[l],C(m,e.filter),this._isStatsSupportedOnService().then((()=>this.layer.queryFeatures(m,{signal:i.signal}))).then((e=>P(e,a,s,n,t)))}))}))}async _getBinQueryParams(e,t,i,a){const{field:s,sqlExpression:n,normalizationField:o,classificationMethod:l,normalizationType:m}=e,c=s?this.getField(s):null,h=u(c),w=p(c)||h,g=e.numBins||I;if(w){if(m||l)throw new r(`${this.adapterName}:not-supported`,"NormalizationType and classificationMethod are not supported for date-only and time-only fields");const e=(i-t)/g/1e3,a=e/86400;return new f({field:s,expression:n,interval:{units:h?"seconds":"days",value:Math.ceil(h?e:a)},start:t,end:i})}if("defined-interval"===l)return new F({field:s,expression:n,normalizationField:o,normalizationTotal:a,normalizationType:m,interval:e.definedInterval??Math.ceil((i-t)/g),start:m?null:t,end:m?null:i,normalizationMinValue:m?t:null,normalizationMaxValue:m?i:null});if("manual"===l)throw new r(`${this.adapterName}:not-supported`,"Layer does not support manual classificationMethod");if("natural-breaks"===l||"quantile"===l||"standard-deviation"===l){const i=R({field:s,normalizationField:o,normalizationTotal:a,normalizationType:m,layer:this}),l=null!==e.minValue&&null!==e.maxValue?T(i,e.minValue,e.maxValue):void 0,u=await this._binParamsFromGenRend(e,l);if(!u.intervals)throw new r(`${this.adapterName}:invalid`,"Invalid intervals returned from generate renderer");const p=[t,...u.intervals.map((e=>e[1]))];return new y({field:m?null:s,expression:m?i:n,boundaries:p})}return new d({field:s,normalizationField:o,normalizationTotal:a,normalizationType:m,expression:n,bins:g,start:m?null:t,end:m?null:i,normalizationMinValue:m?t:null,normalizationMaxValue:m?i:null})}async _histogramFromQueryBins(e){const{field:t,normalizationType:i,minValue:r,maxValue:a,filter:s,view:n,signal:l}=e,m=await this._getNormalizationTotal(t,i,s,l),p=this._getQueryParamsForExpr(e,m),{min:c,max:d}=await this._getDataRange(p,r,a);if(null==c||null==d)return{bins:[],minValue:c,maxValue:d,normalizationTotal:m};const f="countOFExpr",y=new g({statisticType:"count",outStatisticFieldName:f,onStatisticField:"1"}),F=this.layer.createQuery(),w=_(F.where,p.sqlWhere),v="lowerBoundary",S="upperBoundary",x=new h({binParameters:await this._getBinQueryParams(e,c,d,m),outStatistics:[y],binOrder:e.sortOrder,where:w,lowerBoundaryAlias:v,upperBoundaryAlias:S,outTimeZone:n?.timeZone?o(n?.timeZone):null});C(x,s);const z=await this.layer.queryBins(x,{signal:l}),T=u(t?this.getField(t):null);return{bins:z.features.map((e=>({minValue:ee(e.attributes[v],T),maxValue:ee(e.attributes[S],T),count:e.attributes[f]}))),minValue:c,maxValue:d,normalizationTotal:m}}_binParamsFromGenRend(e,t){const{field:i,normalizationType:r,normalizationField:a,signal:s}=e,n=z({field:i,normalizationType:r,normalizationField:a}),o=new w({classificationDefinition:J({field:i,normalizationType:r,normalizationField:a,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,definedInterval:e.definedInterval,breakCount:e.numBins||I}),where:_(n,t)});return this.generateRenderer(o,s).then((e=>{const{normalizationTotal:t,classBreaks:s}=e;return $({field:i,normalizationType:r,normalizationField:a,normalizationTotal:t,classBreaks:s,where:n,layer:this})}))}_classBreaksFromGenRend(e){const{field:t,normalizationType:i,normalizationField:r,normalizationTotal:a,signal:s}=e,n=z({field:t,normalizationType:i,normalizationField:r}),o=R({field:t,normalizationType:i,normalizationField:r,normalizationTotal:a,layer:this}),l=T(o,e.minValue,e.maxValue),u=J({field:t,normalizationType:i,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||K}),m=new w({classificationDefinition:u});return m.where=_(n,l),this.generateRenderer(m,s).then((t=>Z(t,e.classificationMethod)))}async summaryStatistics(e){const{field:t,normalizationType:i,sqlExpression:s,view:n,features:o,useFeaturesInView:l}=e,m=t?this.getField(t):null,p=q(m)||u(m),c=e.valueExpression||s,d=c&&!s,h=this._hasLocalSource||o||l,f=n&&"3d"===n.type;if(h||d)return d||o||l||f?this._summaryStatsFromMemory(e,m):this._summaryStatsFromClientQuery(e,m);if(!this.supportsSQLExpression&&(p||c||"natural-log"===i||"square-root"===i))throw new r(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return(i&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(e):this._summaryStatsFromServiceQuery(e,m)).catch((()=>(a(e.signal),this._summaryStatsFromMemory(e,m))))}async uniqueValues(e){const{valueExpression:t,sqlExpression:i,features:r,useFeaturesInView:s,signal:n}=e,o=t&&(!i||!this.supportsSQLExpression),l=this._hasLocalSource||r||s||o,u=e.view,m=u&&"3d"===u.type,p=await D(e,this);return l?o||r||s||m?this._uvFromMemory(e,p):this._uvFromClientQuery(e,p):this._uvFromServiceQuery(e,p).catch((t=>(a(n),!e.field||e.field2||e.field3||e.filter?t:this._uvFromGenRenderer(e,p[0])))).catch((()=>(a(n),m?this._uvFromMemory(e,p):this._uvFromClientQuery(e,p))))}async histogram(e){const{field:t,normalizationType:i,normalizationField:a,classificationMethod:s,view:n,filter:o,signal:l}=e,m=t?this.getField(t):null,p=q(m)||u(m),c=e.valueExpression||e.sqlExpression,d=c&&!e.sqlExpression,h=this._hasLocalSource||e.features||e.useFeaturesInView||d,f=this.supportsSQLExpression,y=!s||"equal-interval"===s,F=e.minValue,w=e.maxValue,g=null!=F&&null!=w,v=e.numBins||I;if(h)return this._histogramFromMemory(e);if(this.layer.capabilities?.operations?.supportsQueryBins&&e.useQueryBins)return this._histogramFromQueryBins(e);if((c||f)&&y){if(!f&&(c||"natural-log"===i||"square-root"===i))throw new r(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return this._histogramForExpr(e)}if(p&&y)throw new r(`${this.adapterName}:not-supported`,"Normalization and date field are not allowed when layer does not support standardized SQL expression for queries");return i||!y?this._binParamsFromGenRend(e).then((s=>{if(!g)return k(this,s,t,v,n,o,l);if(F>s.max||w<s.min)throw new r(`${this.adapterName}:insufficient-data`,"Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(y)return k(this,{min:F,max:w,sqlExpr:s.sqlExpr,excludeZerosExpr:s.excludeZerosExpr},t,v,n,o,l);{const r={field:t,normalizationType:i,normalizationField:a,normalizationTotal:s.normTotal,layer:this},u=R(r),m=T(u,F,w);return this._binParamsFromGenRend(e,m).then((e=>k(this,e,t,v,n,o,l)))}})):this._histogramForField(e)}async classBreaks(e){const t=!1!==e.analyzeData,i=this._hasLocalSource||e.features||e.useFeaturesInView||e.valueExpression||e.filter;if(t&&i)return this._classBreaksFromMemory(e);return(t?this._classBreaksFromGenRend(e):this._classBreaksFromInterpolation(e)).catch((()=>(a(e.signal),this._classBreaksFromMemory(e))))}async queryFeatureCount(e){if(this._hasLocalSource)throw new r(`${this.adapterName}:not-supported`,"Layer does not support count query");const t=this.layer,i=t.createQuery();return i.where=_(i.where,e.whereClause),C(i,e.filter),t.queryFeatureCount(i,{signal:e.signal})}async generateRenderer(e,t){const i=this.layer;if(this._hasLocalSource||i.version<10.1)throw new r(`${this.adapterName}:not-supported`,"Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)");const a=i.createQuery();return e.where=_(e.where,a.where),c(i.parsedUrl?.path??"",{source:i.dynamicDataSource??void 0,gdbVersion:i.gdbVersion??void 0},e,{signal:t})}async predominantCategories(e){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new r(`${this.adapterName}:not-supported`,"Layer does not support advanced SQL expressions and standardized queries");const{fields:t,view:i,signal:a,filter:s}=e,n=S(t),o=x(t),l=i&&this._hasLocalSource?await this._uvFromMemory({valueExpression:n,view:i,signal:a,filter:s}):await this._uvFromServiceQuery({sqlExpression:o.expression,valueExpression:n,signal:a,filter:s});return O(l.uniqueValueInfos,t)}async getSampleFeatures(e,r){const{view:s,requiredFields:n,returnGeometry:o,filter:l,signal:u}=e,m=e.sampleSize;if(null==m||0===m)return[];const p=this.layer.createQuery(),c=1,d="json"===r;p.outSpatialReference=s?.spatialReference,p.returnGeometry=!!o,p.outFields=n,C(p,l);let h=[],f=!1;if(s)try{const a=await s.whenLayerView(this.layer);if(f=!G(this,n,a).length,f){if(m>=1&&!e.filter&&"getSampleFeatures"in a){await this._waitForLayerViewUpdate(a);const e=await a.getSampleFeatures({minFeatureCount:m,sampleSize:m});if(null!=e)return d?e:e.map((e=>t.fromJSON(e)))}if(h=await this._fetchFeaturesFromMemory(a,p,u,r),h.length>=m&&m>0)return i(h,m,c)}}catch(y){a(u)}try{if(this._hasLocalSource)return f?h:d?await this._fetchFeaturesJSONFromService(p,u):await this._fetchFeaturesFromService(p,u);const t=await this.queryFeatureCount({view:s,filter:l,signal:u}),r=this.layer.capabilities.query.maxRecordCount;let a=-1===m?t:m;if(a=r&&a>r?r:a,t<=h.length||h.length>=r)return h;if(p.maxAllowableOffset=e.resolution||(s?s.extent.width/s.width/s.scale:H(this.layer.spatialReference))*Y,t<=a)return d?await this._fetchFeaturesJSONFromService(p,u):await this._fetchFeaturesFromService(p,u);if(t<=X){const e=this.layer.createQuery();C(e,l);const t=await this.layer.queryObjectIds();return p.objectIds=i(t,a,c),d?await this._fetchFeaturesJSONFromService(p,u):await this._fetchFeaturesFromService(p,u)}return this.layer.capabilities?.query?.supportsPagination&&(p.num=Math.min(a,X)),d?await this._fetchFeaturesJSONFromService(p,u):await this._fetchFeaturesFromService(p,u)}catch(y){return a(u),h}}load(e){const t=this.layer.load(e).then((async t=>{this.geometryType=t.geometryType,this.objectIdField=t.objectIdField,this.supportsSQLExpression=t.capabilities?.query?.supportsSqlExpression,this._hasLocalSource=!t.url&&!!t.source,this.hasQueryEngine=this._hasLocalSource,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,this.workerClient=V.getInstance(),await this.workerClient.open(e.signal)}));return this.addResolvingPromise(t),Promise.resolve(this)}};function ie(e,t,i){const r=[],a=t.length;return t.forEach(((t,s)=>{const[n,o]=t;let l=null;l=0!==s||i?s!==a-1||i?_(`${e} >= ${n}`,`${e} ${s===a-1?" <= ":" < "} ${o}`):`${e} >= ${n}`:`${e} < ${o}`,r.push("WHEN ("+l+") THEN "+(s+1))})),["CASE",r.join(" "),"ELSE 0","END"].join(" ")}e([s({constructOnly:!0})],te.prototype,"layer",void 0),te=e([n("esri.smartMapping.support.adapters.FeatureLayerAdapter")],te);const re=te;export{re as default};
