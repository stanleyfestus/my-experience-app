/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import{createUniqueColors as i}from"../../core/colorUtils.js";import a from"../../core/Error.js";import{toPt as r}from"../../core/screenUtils.js";import{ensureClass as n}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as s}from"../../intl/messages.js";import l from"../../renderers/support/AuthoringInfo.js";import t from"../../renderers/support/AuthoringInfoSizeStop.js";import o from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as m}from"../../renderers/support/utils.js";import u from"../../renderers/visualVariables/SizeVariable.js";import{castSizeFromStringOrNumber as d}from"../../renderers/visualVariables/support/castSizeVariable.js";import p from"../../renderers/visualVariables/support/SizeVariableLegendOptions.js";import{TransformationType as c}from"../../renderers/visualVariables/support/sizeVariableUtils.js";import f from"../heuristics/ageUnit.js";import y from"../heuristics/outline.js";import v from"../heuristics/referenceSize.js";import z from"../heuristics/sizeRange.js";import{getReferenceSizeStops as w,createPrimitiveOverrides as b,updateReferenceSizeSymbol as h,createReferenceSizeSymbol as g}from"./support/referenceSizeUtils.js";import{isSizeVV as S,spliceVisualVariables as x,findSizeVVIndex as E,findOutlineVVIndex as T,processRegenerateParams as V,getRendererToUpdate as I,hasScaleDependentSizeVV as O,getStyleType as k,hasOutlineVV as B}from"./support/regenerateUtils.js";import{getSummaryStatistics as j,errorCallback as R,getClassBreaks as F,getTitleAndExpressionForAgeRenderer as q,updateAgeRendererAuthoringInfoVV as D,verifyBasicFieldValidity as U,getDataRange as P,getSizeRangeForAxis as G,createSymbol as M,getSymbolOutlineFromScheme as C,getSymbolSizeFromScheme as $,getBasemapInfo as A}from"./support/utils.js";import{verifyDates as L,supportedAgeUnits as W}from"../statistics/support/ageUtils.js";import{verifyBinningParams as H}from"../support/binningUtils.js";import{getFieldsList as J,getNormalizationType as K,isAnyDateField as N}from"../support/utils.js";import{binningCapableLayerTypes as Q,featureCapableLayerTypes as X,createLayerAdapter as Y,getLayerTypeLabels as Z}from"../support/adapters/support/layerUtils.js";import{cloneScheme as _,getSchemes as ee}from"../symbology/size.js";import{getColorFromSymbol as ie}from"../../symbols/support/utils.js";const ae=2**53-1;async function re(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new a("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new a("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");if("reference-size"===e.theme&&!e.view&&!e.field)throw new a("size-visual-variable:missing-parameters","'view' and 'field' are required when 'theme' is 'reference-size'");if("reference-size"===e.theme&&e.valueExpression)throw new a("size-visual-variable:missing-parameters","'valueExpression' is not supported when 'theme' is 'reference-size'");e.forBinning&&H(e,"size-visual-variable");const i={...e},r=e.forBinning?Q:X,n=Y(i.layer,r,e.forBinning);if(!n)throw new a("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+Z(r).join(", "));"height"===i.axis&&(i.sizeOptimizationEnabled=!1);const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType;if("mesh"===l)throw new a("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(i.worldScale){if("polyline"===l||"polygon"===l)throw new a("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!i.view||"3d"!==i.view.type)throw new a("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}if("reference-size"===i.theme&&!e.forBinning&&"polygon"!==l)throw new a("size-visual-variable:invalid-parameters","Reference size is only supported for polygon layers");const t=await J({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),o=U(n,t,"size-visual-variable:invalid-parameters");if(o)throw o;return await se(i),{...i,layer:n}}async function ne(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new a("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new a("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&H(e,"size-continuous-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0;const r=e.forBinning?Q:X,n=Y(i.layer,r,e.forBinning);if(!n)throw new a("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+Z(r).join(", "));const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType,t=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="reference-size"!==i.theme&&"polygon"===l&&i.outlineOptimizationEnabled,"mesh"===l)throw new a("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new a("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new a("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");if("reference-size"===i.theme&&!e.forBinning&&"polygon"!==l)throw new a("size-continuous-renderer:invalid-parameters","Reference size is only supported for polygon layers");const o=await J({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),m=U(n,o,"size-continuous-renderer:invalid-parameters");if(m)throw m;return await se(i),{...i,layer:n}}async function se(e){const i=e.layer;if(("polygon"===i.geometryType||e.forBinning)&&e.view&&e.field&&!e.valueExpression&&(!e.theme||"reference-size"===e.theme)){try{e.referenceSizeResult=e.referenceSizeResult??await v({layer:i,view:e.view,filter:e.filter,forBinning:e.forBinning,signal:e.signal})}catch{}!e.theme&&e.referenceSizeResult?.isGrid&&(e.theme="reference-size"),e.referenceSizeOptions?.symbolStyle||(e.referenceSizeOptions?e.referenceSizeOptions.symbolStyle="circle":e.referenceSizeOptions={symbolStyle:"circle"})}}async function le(e){if(!e||!(e.layer&&e.view&&e.sizeStops))throw new a("update-renderer-with-reference-size:missing-parameters","'layer', 'view and 'sizeStops' parameters are required");const{view:i,forBinning:r}=e,n=e.forBinning?Q:X,s=Y(e.layer,n,e.forBinning);if(!s)throw new a("update-renderer-with-reference-size:invalid-parameters","'layer' must be one of these types: "+Z(n).join(", "));const l=s.layer;let t=e.renderer;if(!t)if(e.forBinning){if(!("featureReduction"in l&&l.featureReduction&&"renderer"in l.featureReduction&&l.featureReduction.renderer)||"class-breaks"!==l.featureReduction.renderer.type&&"unique-value"!==l.featureReduction.renderer.type)throw new a("update-renderer-with-reference-size:invalid-parameters","Feature reduction renderer is not supported");t=l.featureReduction.renderer}else{if(!("renderer"in l)||!l.renderer||"class-breaks"!==l.renderer.type&&"unique-value"!==l.renderer.type)throw new a("update-renderer-with-reference-size:invalid-parameters","Renderer is not supported");t=l.renderer}const o=t.authoringInfo;if(!o||!o?.visualVariables?.some((e=>"reference-size"===e.theme)))throw new a("update-renderer-with-reference-size:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'reference-size'");const m=e.referenceSizeResult??await v({view:i,layer:l,forBinning:r});return{...e,referenceSizeResult:m,renderer:t,layer:s}}async function te(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new a("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new a("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&H(e,"size-class-breaks-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0,i.classificationMethod??="equal-interval",i.normalizationType=K(i);const r=e.forBinning?Q:X,n=Y(i.layer,r,e.forBinning);if(!n)throw new a("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+Z(r).join(", "));if(!(null!=i.minValue&&null!=i.maxValue)&&(null!=i.minValue||null!=i.maxValue))throw new a("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType,t=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="polygon"===l&&i.outlineOptimizationEnabled,"mesh"===l)throw new a("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new a("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new a("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const o=await J({field:i.field,normalizationField:i.normalizationField}),m=U(n,o,"size-class-breaks-renderer:invalid-parameters");if(m)throw m;return{...i,layer:n}}function oe(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const a=i;return a.analyzeData=!(null!=i.minValue&&null!=i.maxValue),a}function me(e){const i={...e},a=!!i.symbolType?.includes("3d-volumetric"),r=i;return r.worldScale=a,a&&(r.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,r}async function ue(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new a("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const i={...e};i.symbolType??="2d",i.defaultSymbolEnabled??=!0;const r=Y(i.layer,X);if(!r)throw new a("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+Z(X).join(", "));const n=null!=i.signal?{signal:i.signal}:null;await r.load(n);const s=r.geometryType,l=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,"mesh"===s)throw new a("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(l&&("polyline"===s||"polygon"===s))throw new a("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new a("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=L(r,i.startTime,i.endTime,"size-age-renderer:invalid-parameters");if(t)throw t;if(i.unit&&!W.includes(i.unit))throw new a("size-age-renderer:invalid-unit",`Supported units are: ${W.join(", ")}`);return{...i,layer:r}}async function de(e){const i="regenerate-size-visual-variables";V(e,i);const r=await I(e);if("class-breaks"!==r?.type)throw new a(`${i}:invalid-parameters`,"Renderer must be a ClassBreaksRenderer to regenerate a size visual variable");const n=r.authoringInfo?.visualVariables.find((e=>"size"===e.type));if(!n)throw new a(`${i}:invalid-parameters`,"Renderer does not have a size visual variable authoringInfo");const s="reference-size"===n.theme,l=r.visualVariables?.find(S);if(!l&&!s)throw new a(`${i}:invalid-parameters`,"Renderer does not have a size visual variable");const t=l?.field??r.field,o=l?.normalizationField??r.normalizationField,m=l?.valueExpression??r.valueExpression,u=l?.valueExpressionTitle??r.valueExpressionTitle,d=n.theme,{layer:p,forBinning:c,filter:f,view:y,signal:v}=e,z=O(r),w=await re({layer:p,field:t,valueExpression:m,valueExpressionTitle:u,normalizationField:o,theme:d,sizeOptimizationEnabled:z,forBinning:c,filter:f,view:y,signal:v});return{...e,creatorParameters:w,renderer:r}}async function pe(e){const i="regenerate-size-continuous-renderer";V(e,i);const r=await I(e);if("size-continuous"!==k(r))throw new a(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n,field:s,normalizationField:l,valueExpression:t,valueExpressionTitle:o}=r,m=n?.visualVariables.find((e=>"size"===e.type)),u=m.theme,{layer:d,forBinning:p,filter:c,view:f,signal:y}=e,v=B(r),z=O(r),w=await ne({layer:d,field:s,valueExpression:t,valueExpressionTitle:o,normalizationField:l,theme:u,outlineOptimizationEnabled:v,sizeOptimizationEnabled:z,forBinning:p,filter:c,view:f,signal:y});return{...e,creatorParameters:w,renderer:r}}async function ce(e){const i="regenerate-size-class-breaks-renderer";await V(e,i);const r=await I(e);if("size-class-breaks"!==k(r))throw new a(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n,field:s,normalizationField:l,normalizationType:t,normalizationTotal:o,valueExpression:m,valueExpressionTitle:u}=r,{classificationMethod:d,standardDeviationInterval:p}=n,c=r.classBreakInfos.length,{layer:f,forBinning:y,filter:v,view:z,signal:w}=e,b=B(r),h=await te({layer:f,field:s,valueExpression:m,valueExpressionTitle:u,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:d,standardDeviationInterval:p,numClasses:c,outlineOptimizationEnabled:b,forBinning:y,filter:v,view:z,signal:w});return{...e,creatorParameters:h,renderer:r}}async function fe(e){const i="regenerate-size-age-renderer";await V(e,i);const r=await I(e);if("size-age"!==k(r))throw new a(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n}=r,s=n?.visualVariables.find((e=>"size"===e.type)),l=s.startTime,t=s.endTime,o=s.units,m=s.theme,{layer:u,filter:d,view:p,signal:c}=e,f=B(r),y=O(r),v=await ue({layer:u,startTime:l,endTime:t,unit:o,theme:m,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:d,view:p,signal:c});return{...e,creatorParameters:v,renderer:r}}async function ye(e){let i=e.sizeScheme,a=null,r=null;const n=await A(e.basemap,e.view);if(a=null!=n.basemapId?n.basemapId:null,r=null!=n.basemapTheme?n.basemapTheme:null,i)return{scheme:_(i),basemapId:a,basemapTheme:r};const s=ee({basemapTheme:r,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return s&&(i=s.primaryScheme,a=s.basemapId,r=s.basemapTheme),{scheme:i,basemapId:a,basemapTheme:r}}function ve(e,i){switch(i){case"point":case"multipoint":{const i=e;return[d(i.minSize),d(i.maxSize)]}case"polyline":{const i=e;return[d(i.minWidth),d(i.maxWidth)]}case"polygon":{const i=e;return[d(i.marker.minSize),d(i.marker.maxSize)]}}}function ze(e,i){e.transformationType===c.ClampedLinear&&"below"===i&&e.flipSizes()}async function we(e,i,a,r,n){return"reference-size"===a&&i?[1,i.size]:e?[e.minSize,e.maxSize]:ve(r,n)}function be(e,i,a){return"reference-size"===a&&i?[1,i.size]:e?[e.minSize,e.maxSize]:null}function he(e,i){if("reference-size"===i.theme&&null!=e.min&&null!=e.max&&null!=e.avg&&null!=e.stddev){const i=100,a=0,r=0,n=1,s=e.avg,l=e.min,t=e.max,o=e.stddev,m=0!==s?o/s:0,u=l>r&&l<n&&t<2*n&&m<.5,d=l>a&&l<i&&t<2*i&&m<.5;return{minDataValue:u?r:d?a:l,maxDataValue:u?n:d?i:s+2*o,defaultValuesUsed:!1}}const{theme:a,field:r}=i,n=i.layer,s=r&&!("function"==typeof r)?n.getField(r):null,l=N(s);return P(e,a,l,"above"===a||"below"===a)}async function ge(e,i,r,s){const{theme:m,field:d,normalizationField:c,minValue:f,maxValue:y,axis:v}=e,z=e.layer.geometryType,b=await ye({basemap:e.basemap,geometryType:z,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),h=b.scheme;if(!h)throw new a("size-visual-variable:insufficient-info","Unable to find size scheme");const g=await we(r,s,m,h,z),{minDataValue:S,maxDataValue:x,defaultValuesUsed:E}=he(i,e),T=[],V="height"===v,I=V?v:void 0,O=g[0];let k=g[1];if(V&&"number"==typeof O&&"number"==typeof k){const e=G({minSize:O,maxSize:k},I);T.push(new u({axis:"width-and-depth",minSize:e.minSize})),k=e.maxSize}const B=new u({field:d??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:c,axis:I,minSize:O,maxSize:k,minDataValue:S,maxDataValue:x,legendOptions:n(p,e.legendOptions)});ze(B,m),T.unshift(B);const j=new o("reference-size"===m?{type:"size",field:e.field,normalizationField:e.normalizationField,sizeStops:w(B).map((({label:e,size:i,value:a})=>new t({label:e,size:i,value:a}))),theme:m,referenceSizeScale:s?.isGrid||e.sizeOptimizationEnabled?e?.view?.scale:void 0,referenceSizeSymbolStyle:e.referenceSizeOptions?.symbolStyle,minSliderValue:null!=f?f:i.min,maxSliderValue:null!=y?y:i.max}:{type:"size",theme:m,minSliderValue:null!=f?f:i.min,maxSliderValue:null!=y?y:i.max}),R=new l({visualVariables:[j]});return{basemapId:b.basemapId,basemapTheme:b.basemapTheme,visualVariables:T,statistics:i,isGrid:s?.isGrid,defaultValuesUsed:E,sizeScheme:_(h),authoringInfo:R}}async function Se(i,a,r,n,l){const t=await s("esri/smartMapping/t9n/smartMapping"),o=l.layer,m=l.field,u=o.geometryType,d=l.defaultSymbolEnabled,p=_(i.sizeScheme),c="polygon"===u,f=c?p.marker:p,y=c?p.background:null,v=c?"point":u,z=a?.opacity,h=i.isGrid,S="reference-size"===l.theme,x=S?[]:i.visualVariables.map((e=>e.clone()));a?.visualVariables?.length&&x.push(...a.visualVariables.map((e=>e.clone())));const E=S?b({view:l.view,field:m,normalizationField:n,sizeStops:w(i.visualVariables[0]),sizeByScaleEnabled:h||!!l.sizeOptimizationEnabled}):null;return{renderer:new e({backgroundFillSymbol:!h&&y?M(u,{type:l.symbolType,color:y.color,outline:C(y,u,z)}):null,classBreakInfos:[{minValue:-ae,maxValue:ae,symbol:E?g({type:l.referenceSizeOptions?.symbolStyle||"circle",color:f.color,primitiveOverrides:E}):M(v,{type:l.symbolType,color:f.color,size:$(f,v),outline:C(f,v,z)})}],defaultLabel:d?t.other:null,defaultSymbol:d&&!S?M(v,{type:l.symbolType,color:f.noDataColor,size:$(f,v,!0),outline:C(f,v,z)}):null,field:m,normalizationField:n,normalizationType:r,valueExpression:l.valueExpression,valueExpressionTitle:l.valueExpressionTitle,visualVariables:x,authoringInfo:i.authoringInfo?.clone()}),visualVariables:i.visualVariables.map((e=>e.clone())),statistics:i.statistics,defaultValuesUsed:i.defaultValuesUsed,isGrid:h,sizeScheme:_(i.sizeScheme),basemapId:i.basemapId,basemapTheme:i.basemapTheme}}function xe(e,i){const a=r(e.minSize),n=(r(e.maxSize)-a)/(i>=4?i-1:i),s=[];for(let r=0;r<i;r++)s.push(a+n*r);return s}async function Ee(i,a){const r=await s("esri/smartMapping/t9n/smartMapping"),n=i.layer,t=i.defaultSymbolEnabled,o=n.geometryType,u="polygon"===o,d=i.symbolType?.includes("3d-volumetric"),p=await ye({basemap:i.basemap,geometryType:o,sizeScheme:i.sizeScheme,worldScale:d,view:i.view}),c=p.scheme,{result:f,outlineResult:y}=a,v=f?.classBreakInfos??[],z=i.classificationMethod,w=i.normalizationType,b=u?c.marker:c,h=u?c.background:null,g=u?"point":o,S=ve(b,g),x=d?G({minSize:S[0],maxSize:S[1]},"height"):null,E=xe({minSize:S[0],maxSize:x?x.maxSize:S[1]},v.length),T=y?.opacity,V=new e({backgroundFillSymbol:h&&M(o,{type:i.symbolType,color:h.color,outline:C(h,o,T)}),classBreakInfos:v.map(((e,a)=>({minValue:e.minValue,maxValue:e.maxValue,symbol:M(g,{type:i.symbolType,color:b.color,size:E[a],widthAndDepth:x?.minSize,outline:C(b,g,T)}),label:e.label}))),defaultLabel:t?r.other:null,defaultSymbol:t?M(g,{type:i.symbolType,color:b.noDataColor,size:$(b,g,!0),widthAndDepth:x?.minSize,outline:C(b,g,T)}):null,field:i.field,valueExpression:i.valueExpression,valueExpressionTitle:i.valueExpressionTitle,normalizationType:w,normalizationField:i.normalizationField,normalizationTotal:"percent-of-total"===w?f?.normalizationTotal:void 0,legendOptions:i.legendOptions,authoringInfo:new l({type:"class-breaks-size",classificationMethod:z,standardDeviationInterval:i.standardDeviationInterval})});return"standard-deviation"!==z&&m({classBreakInfos:V.classBreakInfos,classificationMethod:z,normalizationType:w,round:!0}),y?.visualVariables?.length&&(V.visualVariables=y.visualVariables.map((e=>e.clone()))),{renderer:V,sizeScheme:_(c),classBreaksResult:f,defaultValuesUsed:!!a.defaultValuesUsed,basemapId:p.basemapId,basemapTheme:p.basemapTheme}}async function Te(e){const i=await re(e),{view:a,field:r,valueExpression:n,minValue:s,maxValue:l,layer:t,normalizationField:o,signal:m,statistics:u,filter:d}=i,p=o?"field":void 0,[c,f]=await Promise.all([u??j({layer:t,field:r,valueExpression:n,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:p,normalizationField:o,filter:d,minValue:s,maxValue:l,view:a,signal:m}),i.sizeOptimizationEnabled?z({view:a,layer:t,signal:m,filter:d}).catch(R):null]);return ge(i,c,f,i.referenceSizeResult)}async function Ve(e){const{view:i,filter:a,renderer:r,signal:n,creatorParameters:s}=await de(e),{field:l,normalizationField:o,valueExpression:m,theme:d,layer:p,sizeOptimizationEnabled:c,referenceSizeResult:f,valueExpressionTitle:y}=s,v=o?"field":void 0,[b,h]=await Promise.all([j({layer:p,field:l,valueExpression:m,normalizationField:o,normalizationType:v,filter:a,view:i,signal:n}),c?z({view:i,layer:p,signal:n,filter:a}).catch(R):null]),g=be(h,f,d),{minDataValue:x,maxDataValue:E}=he(b,{theme:d,layer:p,field:l}),T=r.visualVariables?.find(S)??new u({field:l??void 0,valueExpression:m,valueExpressionTitle:y,valueUnit:"unknown",normalizationField:o});g&&(T.minSize=g[0],T.maxSize=g[1]),T.minDataValue=x,T.maxDataValue=E,ze(T,d);const V=r.authoringInfo.clone(),I=V.visualVariables.find((e=>"size"===e.type));return I.minSliderValue=b.min,I.maxSliderValue=b.max,"reference-size"===d&&(I.sizeStops=w(T).map((({label:e,size:i,value:a})=>new t({label:e,size:i,value:a}))),I.referenceSizeScale=f?.isGrid||c?i?.scale:void 0),{visualVariables:[T],isGrid:!!f?.isGrid,authoringInfo:V}}async function Ie(e){const i=await ne(e),a={layer:i.layer,view:i.view,filter:i.filter,signal:i.signal},[r,n]=await Promise.all([Te(me(i)),i.outlineOptimizationEnabled?y(a).catch(R):null]),s=i.normalizationField;return Se(r,n,s?"field":void 0,s,i)}async function Oe(e){const{renderer:i,view:a,signal:r,filter:n,creatorParameters:s,forBinning:l}=await pe(e),{layer:t,outlineOptimizationEnabled:o,normalizationField:m,theme:u,referenceSizeResult:d}=s,[p,c]=await Promise.all([Ve({...e,referenceSizeResult:d}),o?y({layer:t,view:a,filter:n,signal:r}).catch(R):null]),f=p.isGrid,v="reference-size"===u;v||x(i,p.visualVariables,E),x(i,c?.visualVariables,T);const z=p.authoringInfo.clone(),w=z.visualVariables.find((e=>"size"===e.type));return i.authoringInfo=z,f&&(i.backgroundFillSymbol=null),{renderer:v&&w.sizeStops?await ke({layer:t,field:i.field,normalizationField:m,view:a,forBinning:l,sizeStops:w.sizeStops,referenceSizeResult:d}):i,isGrid:f}}async function ke(e){const{layer:r,referenceSizeOptions:n,renderer:s,sizeScheme:o,sizeStops:m,typeScheme:u,view:d,referenceSizeResult:p}=await le(e),c=p?.isGrid,f=s.clone();f.authoringInfo??=new l;const y=f.authoringInfo.visualVariables.find((e=>"reference-size"===e.theme)),v=e.field??y?.field,z=e.normalizationField??y?.normalizationField;if(!v)throw new a("update-renderer-with-reference-size:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const w=b({view:d,field:v,normalizationField:z,sizeStops:m,sizeByScaleEnabled:c||!!e.sizeOptimizationEnabled}),S=n?.symbolStyle||y?.referenceSizeSymbolStyle||"circle";if("class-breaks"===f.type){const e="polygon"===("geometryType"in r?r.geometryType:null)&&o&&"marker"in o?o.marker:null;f.classBreakInfos.forEach((i=>{const a=e?.color??ie(i.symbol,1);"cim"===i.symbol.type?h(i.symbol,{type:S,color:a,primitiveOverrides:w}):a&&(i.symbol=g({type:S,color:a,primitiveOverrides:w}))}))}else if("unique-value"===f.type){const e=f.uniqueValueGroups,a="polygon"===("geometryType"in r?r.geometryType:null)&&u&&"colors"in u?u.colors:null,n=a?i(a,f.uniqueValueInfos?.length??0):null;let s=0;if(e){for(const i of e)for(const e of i.classes??[]){const i=n?n[s]:ie(e.symbol,1);"cim"===e.symbol?.type?h(e.symbol,{type:S,color:i,primitiveOverrides:w}):i&&(e.symbol=g({type:S,color:i,primitiveOverrides:w})),s++}f.uniqueValueGroups=e}}return y&&(y.field=v,y.normalizationField=z,y.sizeStops=m.map((({label:e,size:i,value:a})=>new t({label:e,size:i,value:a}))),y.referenceSizeScale=c||e.sizeOptimizationEnabled?d.scale:void 0,y.referenceSizeSymbolStyle=S),f}async function Be(e){const i=await te(e);return Ee(i,await F(oe(i),i.outlineOptimizationEnabled))}async function je(e){const{renderer:i,creatorParameters:r}=await ce(e),{outlineOptimizationEnabled:n,normalizationType:s,classificationMethod:l}=r,{result:t,outlineResult:o}=await F(oe(r),n),u=t.classBreakInfos;if(r.numClasses!==u.length)throw new a("regenerate-class-breaks-renderer:invalid-parameters","The number of class breaks generated does not match the number of class breaks in the renderer.");return i.classBreakInfos.forEach(((e,i)=>{e.minValue=u[i].minValue,e.maxValue=u[i].maxValue,e.label=u[i].label})),i.normalizationTotal="percent-of-total"===s?t.normalizationTotal:void 0,"standard-deviation"!==l&&m({classBreakInfos:i.classBreakInfos,classificationMethod:l,normalizationType:s,round:!0}),x(i,o?.visualVariables,T),{renderer:i}}async function Re(e){const i=await ue(e),{defaultSymbolEnabled:a,view:r,startTime:n,endTime:s,symbolType:l,minValue:t,maxValue:o,signal:m,filter:u,layer:d}=i,[p,c]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await f({view:r,layer:d,startTime:n,endTime:s,minValue:t,maxValue:o,signal:m,filter:u}),i.outlineOptimizationEnabled?y({layer:d,view:r,filter:u,signal:m}).catch(R):null]),{unit:v,statistics:z}=p,{valueExpression:w,title:b}=await q(i,v),h=await Te(me({layer:d,basemap:i.basemap,valueExpression:w,symbolType:l,statistics:z,legendOptions:{title:b},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:t,maxValue:o,filter:u,signal:m})),g={layer:d,valueExpression:w,defaultSymbolEnabled:a,symbolType:l},S=await Se(h,c,null,null,g),x=S.renderer.authoringInfo?.visualVariables;return x?.forEach((e=>D(e,n,s,v))),{...S,unit:v}}async function Fe(e){const{renderer:i,creatorParameters:a}=await fe(e),{layer:r,outlineOptimizationEnabled:n,sizeOptimizationEnabled:s,startTime:l,endTime:t,theme:o,view:m,signal:u,filter:d}=a,[p,c]=await Promise.all([f({view:m,layer:r,startTime:l,endTime:t,signal:u,filter:d}),n?y({layer:r,view:m,filter:d,signal:u}).catch(R):null]),{unit:v,statistics:z}=p,{valueExpression:w,title:b}=await q(a,v),h=await Te(me({layer:r,valueExpression:w,statistics:z,legendOptions:{title:b},sizeOptimizationEnabled:s,theme:o,view:m,filter:d,signal:u}));x(i,h.visualVariables,E),x(i,c?.visualVariables,T),i.authoringInfo=h.authoringInfo.clone();const g=i.authoringInfo?.visualVariables;return g?.forEach((e=>D(e,l,t,v))),{renderer:i}}export{Re as createAgeRenderer,Be as createClassBreaksRenderer,Ie as createContinuousRenderer,Te as createVisualVariables,Fe as regenerateAgeRenderer,je as regenerateClassBreaksRenderer,Oe as regenerateContinuousRenderer,Ve as regenerateVisualVariables,ke as updateRendererWithReferenceSize};
