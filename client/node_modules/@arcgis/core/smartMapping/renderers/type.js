/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import"../../renderers/PointCloudRGBRenderer.js";import"../../renderers/PointCloudStretchRenderer.js";import e from"../../renderers/PointCloudUniqueValueRenderer.js";import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import r from"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import{createUniqueColors as i}from"../../core/colorUtils.js";import n from"../../core/Error.js";import{clone as l}from"../../core/lang.js";import{fetchMessageBundle as o}from"../../intl/messages.js";import{isTimeOnlyField as s}from"../../layers/support/fieldUtils.js";import t from"../../renderers/support/RendererLegendOptions.js";import{createUniqueValueLabel as a,calculateDateFormatInterval as u,dateFormatIntervalOptions as p}from"../../renderers/support/utils.js";import d from"../../renderers/support/pointCloud/ColorUniqueValueInfo.js";import m from"../heuristics/outline.js";import c from"../heuristics/sizeRange.js";import{spliceVisualVariables as f,findOutlineVVIndex as y,findScaleDependentSizeVVIndex as v,processRegenerateParams as b,getRendererToUpdate as h,getStyleType as g,hasOutlineVV as w,hasScaleDependentSizeVV as T}from"./support/regenerateUtils.js";import{errorCallback as E,getPointSizeAlgorithm as j,verifyBasicFieldValidity as z,isValidPointSize as x,getSymbolSizeFromScheme as I,getSymbolOutlineFromScheme as V,createSymbol as S,getBasemapInfo as M}from"./support/utils.js";import C from"../statistics/uniqueValues.js";import{verifyBinningParams as q}from"../support/binningUtils.js";import{getFieldsList as O,fieldDelimiter as R,isAnyDateField as U}from"../support/utils.js";import{binningCapableLayerTypes as P,featureCapableLayerTypes as B,createLayerAdapter as D,getLayerTypeLabels as k,LayerType as Z}from"../support/adapters/support/layerUtils.js";import{cloneScheme as F,getSchemes as L}from"../symbology/type.js";async function A(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new n("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new n("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&q(e,"type-renderer");const r={...e,layer:e.layer};r.symbolType=r.symbolType||"2d",r.defaultSymbolEnabled??=!0,r.sortBy??="count",r.sortEnabled??=!0,r.statistics=l(r.statistics);const i=null==r.numTypes?10:r.numTypes,o=e.forBinning?P:B,s=D(r.layer,o,e.forBinning);if(!s)throw new n("type-renderer:invalid-parameters","'layer' must be one of these types: "+k(o).join(", "));const t=null!=r.signal?{signal:r.signal}:null;await s.load(t);const a=s.geometryType;if(r.outlineOptimizationEnabled="polygon"===a&&r.outlineOptimizationEnabled,r.sizeOptimizationEnabled=("point"===a||"multipoint"===a||"polyline"===a)&&r.sizeOptimizationEnabled,"mesh"===a)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else{if("3d-volumetric-uniform"===r.symbolType&&"point"!==a)throw new n("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new n("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const u=await O({field:r.field,field2:r.field2,field3:r.field3,valueExpression:r.valueExpression}),p=z(s,u,"type-renderer:invalid-parameters");if(p)throw p;return{...r,layer:s,numTypes:i}}async function G(e){const r="regenerate-size-class-breaks-renderer";await b(e,r);const i=await h(e);if("type"!==g(i))throw new n(`${r}:invalid-parameters`,"Renderer is invalid");const{field:l,field2:o,field3:s,valueExpression:t,valueExpressionTitle:a}=i,u=i.uniqueValueInfos.length,{layer:p,forBinning:d,filter:m,view:c,signal:f}=e,y=w(i),v=T(i),E=await A({layer:p,field:l,field2:o,field3:s,valueExpression:t,valueExpressionTitle:a,numTypes:u,outlineOptimizationEnabled:y,sizeOptimizationEnabled:v,forBinning:d,filter:m,view:c,signal:f});return{...e,creatorParameters:E,renderer:i}}async function H(e){if(!e?.layer||!e.field)throw new n("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const r={...e,layer:e.layer};r.statistics=l(r.statistics);const i=[Z.PointCloudLayer],o=D(r.layer,i);if(!o)throw new n("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+k(i).join(", "));if(r.layer=o,r.density=r.density||25,r.size=r.size||"100%",!x(r.size))throw new n("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const s=null!=r.signal?{signal:r.signal}:null;await o.load(s);const t=await O({field:r.field}),a=z(o,t,"type-point-cloud-class-renderer:invalid-parameters");if(a)throw a;return r}async function $(e){let r=e.typeScheme,i=null,n=null;const l=await M(e.basemap,e.view);if(i=null!=l.basemapId?l.basemapId:null,n=null!=l.basemapTheme?l.basemapTheme:null,r)return{scheme:F(r),basemapId:i,basemapTheme:n};const o=L({numColors:e.numColors,basemapTheme:n,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return o&&(r=o.primaryScheme,i=o.basemapId,n=o.basemapTheme),{scheme:r,basemapId:i,basemapTheme:n}}function J(e,r){let i;return i=e.label<r.label?-1:e.label>r.label?1:0,i}function K(e,r){let i;return i=e.value<r.value?-1:e.value>r.value?1:0,i}function N(e,r){let i=r.count-e.count;return 0===i&&(i=J(e,r)),i}function Q(e,r){let i=r.count-e.count;return 0===i&&(i=K(e,r)),i}function W(e,r,i){let n;"count"===r?(n=Q,i&&"codedValues"in i&&i.codedValues&&(n=N)):"value"===r&&(n=K,i&&"codedValues"in i&&i.codedValues&&(n=J)),n&&e.sort(n)}async function X(e,i,n,l){const s=await o("esri/smartMapping/t9n/smartMapping"),{field:u,field2:p,field3:d}=i,m=e.uniqueValueInfos,c=i.layer,f=u?c.getField(u):null,y=f?c.getFieldDomain(f.name):null,v=-1===i.numTypes?m.length:i.numTypes,b=c.geometryType,h=new r({field:u,field2:p,field3:d,fieldDelimiter:u&&p?R:null}),g=[],w=[],T={value:null,domain:y,fieldInfo:f};m.forEach(((e,r)=>{T.value=e.value,e.label=a(T);const i=e.value;(null===i||"string"==typeof i&&i.toLowerCase().includes("<null>"))&&g.unshift(r)}));for(const r of g)w.unshift(m.splice(r,1)[0]);!1!==i.sortEnabled&&W(m,i.sortBy,y),Y(T,i,m);const E=n?.opacity,j=await $({numColors:m.length,basemap:i.basemap,geometryType:b,typeScheme:i.typeScheme,worldScale:!!i.symbolType?.includes("3d-volumetric"),view:i.view}),z=j.scheme,x=z.colors.map((e=>e.clone())),M=I(z,b),C=V(z,b,E);m.forEach(((e,r)=>{T.value=e.value,e.label=a(T),e.symbol=S(b,{type:i.symbolType,color:x[r],size:M,outline:C,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})),i.valueExpression&&(h.valueExpression=i.valueExpression,h.valueExpressionTitle=i.valueExpressionTitle),i.legendOptions&&(h.legendOptions=new t(i.legendOptions));for(let r=0;r<v;r++){const e=m[r];e&&h.addUniqueValueInfo({value:e.value,label:e.label,symbol:S(b,{type:i.symbolType,color:x[r].clone(),size:M,outline:C,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})}i.defaultSymbolEnabled&&(h.defaultSymbol=S(b,{type:i.symbolType,color:z.noDataColor,size:M,outline:C,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),h.defaultLabel=s.other);for(const r of w)r.symbol=S(b,{type:i.symbolType,color:z.noDataColor,size:M,outline:C,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),m.push(r);const q=[],O=h.uniqueValueInfos?.length??0,U=O===m.length?-1:O;if(U>-1)for(let r=U;r<m.length;r++)q.push({...m[r]});return n?.visualVariables?.length&&(h.visualVariables=n.visualVariables.map((e=>e.clone()))),l?.minSize&&(h.visualVariables?h.visualVariables.push(l.minSize):h.visualVariables=[l.minSize]),{renderer:h,uniqueValueInfos:m,excludedUniqueValueInfos:q,typeScheme:F(z),basemapId:j.basemapId,basemapTheme:j.basemapTheme}}function Y(e,r,i){const{field:n,numTypes:l,layer:o,view:t}=r,a=n?o.getField(n):null;if(a&&(U(a)||s(a))){const r=i.filter(((e,r)=>r<l)).map((e=>e.value)),n=s(a)?null:u(r),d=n?p[n]:void 0;if(e.dateFormatOptions={fieldType:a.type,format:d},t){const r=o.layer;e.dateFormatOptions.timeZoneOptions={layerTimeZone:"preferredTimeZone"in r?r.preferredTimeZone:null,viewTimeZone:t.timeZone,datesInUnknownTimezone:"datesInUnknownTimezone"in r&&r.datesInUnknownTimezone}}}}async function _(e,r){const n=e.uniqueValueInfos,l=await $({numColors:n.length,basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:r}),o=l?.scheme,s="point-cloud-class"===o?.theme,t=s?o.colors:i(o?.colors??[],n.length);return W(n,"value"),n.map(((e,r)=>{const i=e.value;let n=null;return s?(n=t[i],n||(n=t[t.length-1])):n=t[r],new d({values:[i],color:n,label:e.label})}))}async function ee(e){const r=await A(e),{layer:i,view:n,signal:l,filter:o}=r,s={layer:i,field:r.field,field2:r.field2,field3:r.field3,valueExpression:r.valueExpression,returnAllCodedValues:r.returnAllCodedValues,view:n,filter:o,signal:l},[t,a,u]=await Promise.all([null!=r.statistics?r.statistics:C(s),r.outlineOptimizationEnabled?m({layer:i,view:n,signal:l,filter:o}).catch(E):null,r.sizeOptimizationEnabled?c({layer:i,view:n,signal:l,filter:o}).catch(E):null]);return X(t,r,a,u)}async function re(e){const{creatorParameters:r,view:i,signal:n,filter:l,renderer:o}=await G(e),{layer:s,field:t,field2:a,field3:u,valueExpression:p,outlineOptimizationEnabled:d,sizeOptimizationEnabled:b}=r,h={layer:s,field:t,field2:a,field3:u,valueExpression:p,view:i,filter:l,signal:n},[g,w,T]=await Promise.all([C(h),d?m({layer:s,view:i,signal:n,filter:l}).catch(E):null,b?c({layer:s,view:i,signal:n,filter:l}).catch(E):null]),{uniqueValueInfos:j,excludedUniqueValueInfos:z,typeScheme:x}=await X(g,r,w,T);return f(o,w?.visualVariables,y),f(o,T?.minSize,v),{renderer:o,uniqueValueInfos:j,excludedUniqueValueInfos:z,typeScheme:x}}async function ie(r){const i=await H(r),n=null!=i.statistics?i.statistics:await C({layer:i.layer,field:i.field,signal:i.signal});return{renderer:new e({field:i.field,pointsPerInch:i.density??void 0,pointSizeAlgorithm:j(i.size),colorUniqueValueInfos:await _(n,i.typeScheme)})}}export{ie as createPCClassRenderer,ee as createRenderer,re as regenerateRenderer};
