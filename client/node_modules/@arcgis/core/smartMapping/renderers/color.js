/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import e from"../../renderers/PointCloudRGBRenderer.js";import i from"../../renderers/PointCloudStretchRenderer.js";import"../../renderers/PointCloudUniqueValueRenderer.js";import r from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import{createUniqueColors as a}from"../../core/colorUtils.js";import o from"../../core/Error.js";import{clone as n}from"../../core/lang.js";import{ensureClass as l}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as s}from"../../intl/messages.js";import t from"../../renderers/support/AuthoringInfo.js";import u from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as d,createColorStops as m}from"../../renderers/support/utils.js";import c from"../../renderers/visualVariables/ColorVariable.js";import p from"../../renderers/visualVariables/support/ColorStop.js";import f from"../../renderers/visualVariables/support/VisualVariableLegendOptions.js";import y from"../heuristics/ageUnit.js";import v from"../heuristics/outline.js";import h from"../heuristics/sizeRange.js";import{spliceVisualVariables as w,findColorVVIndex as b,findOutlineVVIndex as g,findScaleDependentSizeVVIndex as T,processRegenerateParams as x,getRendererToUpdate as E,getStyleType as z,hasOutlineVV as V,hasScaleDependentSizeVV as I}from"./support/regenerateUtils.js";import{getSummaryStatistics as S,errorCallback as M,getClassBreaks as j,getPointSizeAlgorithm as B,getTitleAndExpressionForAgeRenderer as O,updateAgeRendererAuthoringInfoVV as k,verifyBasicFieldValidity as R,isValidPointSize as C,getDefaultDataRange as F,createDefaultStopValues as q,createStopValues as U,getDataRange as P,createDataValues as D,createSymbol as L,getSymbolSizeFromScheme as $,getSymbolOutlineFromScheme as A,getBasemapInfo as G}from"./support/utils.js";import{verifyDates as W,supportedAgeUnits as H}from"../statistics/support/ageUtils.js";import{verifyBinningParams as J}from"../support/binningUtils.js";import{isAnyDateField as K,getFieldsList as N,getNormalizationType as Q}from"../support/utils.js";import{binningCapableLayerTypes as X,featureCapableLayerTypes as Y,createLayerAdapter as Z,getLayerTypeLabels as _,LayerType as ee}from"../support/adapters/support/layerUtils.js";import{cloneScheme as ie,getSchemes as re,getSchemeById as ae}from"../symbology/color.js";const oe="high-to-low",ne=2**53-1,le=5;async function se(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new o("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new o("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&J(e,"color-visual-variable");const i={...e},r=e.forBinning?X:Y,a=Z(i.layer,r,e.forBinning);if(!a)throw new o("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+_(r).join(", "));const n=null!=i.signal?{signal:i.signal}:null;await a.load(n);if("mesh"!==a.geometryType&&i.worldScale&&(!i.view||"3d"!==i.view.type))throw new o("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true");const l=await N({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),s=R(a,l,"color-visual-variable:invalid-parameters");if(s)throw s;return{...i,layer:a}}async function te(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new o("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new o("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&J(e,"color-continuous-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0;const r=e.forBinning?X:Y,a=Z(i.layer,r,e.forBinning);if(!a)throw new o("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+_(r).join(", "));const n=null!=i.signal?{signal:i.signal}:null;await a.load(n);const l=a.geometryType;if(i.outlineOptimizationEnabled="polygon"===l&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===l||"multipoint"===l||"polyline"===l)&&i.sizeOptimizationEnabled,"mesh"===l)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==l)throw new o("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new o("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await N({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),t=R(a,s,"color-continuous-renderer:invalid-parameters");if(t)throw t;return{...i,layer:a}}async function ue(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new o("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new o("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&J(e,"color-class-breaks-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0,i.classificationMethod??="equal-interval",i.normalizationType=Q(i);const r=e.forBinning?X:Y,a=Z(i.layer,r,e.forBinning);if(!a)throw new o("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+_(r).join(", "));if(!(null!=i.minValue&&null!=i.maxValue)&&(null!=i.minValue||null!=i.maxValue))throw new o("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=null!=i.signal?{signal:i.signal}:null;await a.load(n);const l=a.geometryType;if(i.outlineOptimizationEnabled="polygon"===l&&i.outlineOptimizationEnabled,"mesh"===l)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==l)throw new o("color-class-breaks-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new o("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await N({field:i.field,normalizationField:i.normalizationField}),t=R(a,s,"color-class-breaks-renderer:invalid-parameters");if(t)throw t;return{...i,layer:a}}function de(e){const i={...e};delete i.basemap,delete i.colorScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled,delete i.colorMixMode,delete i.edgesType;const r=i;return r.analyzeData=!(null!=i.minValue&&null!=i.maxValue),r}async function me(e){if(!e?.layer)throw new o("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required");const i={...e,layer:e.layer},r=[ee.PointCloudLayer],a=Z(i.layer,r);if(!a)throw new o("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+_(r).join(", "));if(i.layer=a,i.density=i.density||25,i.size=i.size||"100%",!C(i.size))throw new o("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const n=null!=i.signal?{signal:i.signal}:null;return await a.load(n),i}async function ce(e){if(!e?.layer||!e.field)throw new o("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required");const i=e.field.toLowerCase();if("intensity"!==i&&"elevation"!==i)throw new o("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'");const r={...e,layer:e.layer,field:e.field},a=[ee.PointCloudLayer],n=Z(r.layer,a);if(!n)throw new o("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+_(a).join(", "));if(r.layer=n,r.density=r.density||25,r.size=r.size||"100%",!C(r.size))throw new o("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const l=null!=r.signal?{signal:r.signal}:null;return await n.load(l),r}function pe(e){const i={...e},r=!!i.symbolType?.includes("3d-volumetric");delete i.symbolType,delete i.defaultSymbolEnabled,delete i.colorMixMode,delete i.edgesType;const a=i;return a.worldScale=r,a}async function fe(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new o("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0;const r=Z(i.layer,Y);if(!r)throw new o("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+_(Y).join(", "));const a=null!=i.signal?{signal:i.signal}:null;await r.load(a);const n=r.geometryType;if(i.outlineOptimizationEnabled="polygon"===n&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===n||"multipoint"===n||"polyline"===n)&&i.sizeOptimizationEnabled,"mesh"===n)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else if("3d-volumetric-uniform"===i.symbolType&&"point"!==n)throw new o("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new o("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const l=W(r,i.startTime,i.endTime,"color-age-renderer:invalid-parameters");if(l)throw l;if(i.unit&&!H.includes(i.unit))throw new o("color-age-renderer:invalid-unit",`Supported units are: ${H.join(", ")}`);return{...i,layer:r}}async function ye(e){const i="regenerate-color-visual-variable";await x(e,i);const r=await E(e);if("class-breaks"!==r?.type)throw new o(`${i}:invalid-parameters`,"Renderer must be a ClassBreaksRenderer to regenerate a color visual variable");const a=r.authoringInfo?.visualVariables.find((e=>"color"===e.type));if(!a)throw new o(`${i}:invalid-parameters`,"Renderer does not have a color visual variable in authoringInfo");const n=r.visualVariables?.find((e=>"color"===e.type));if(!n)throw new o(`${i}:invalid-parameters`,"Renderer does not have a color visual variable");const{field:l,normalizationField:s,valueExpression:t,valueExpressionTitle:u}=n,d=a.theme,{layer:m,forBinning:c,filter:p,view:f,signal:y}=e,v=await se({layer:m,field:l,valueExpression:t,valueExpressionTitle:u,normalizationField:s,theme:d,forBinning:c,filter:p,view:f,signal:y});return{...e,creatorParameters:v,renderer:r}}async function ve(e){const i="regenerate-color-continuous-renderer";await x(e,i);const r=await E(e);if("color-continuous"!==z(r))throw new o(`${i}:invalid-renderer`,"Renderer is invalid");const{authoringInfo:a,field:n,normalizationField:l,valueExpression:s,valueExpressionTitle:t}=r,u=a?.visualVariables.find((e=>"color"===e.type)),d=u?.theme,{layer:m,forBinning:c,filter:p,view:f,signal:y}=e,v=V(r),h=I(r),w=await te({layer:m,field:n,valueExpression:s,valueExpressionTitle:t,normalizationField:l,theme:d,outlineOptimizationEnabled:v,sizeOptimizationEnabled:h,forBinning:c,filter:p,view:f,signal:y});return{...e,creatorParameters:w,renderer:r}}async function he(e){const i="regenerate-color-class-breaks-renderer";await x(e,i);const r=await E(e);if("color-class-breaks"!==z(r))throw new o(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:a,field:n,normalizationField:l,normalizationType:s,normalizationTotal:t,valueExpression:u,valueExpressionTitle:d}=r,{classificationMethod:m,standardDeviationInterval:c}=a,p=r.classBreakInfos.length,{layer:f,forBinning:y,filter:v,view:h,signal:w}=e,b=V(r),g=await ue({layer:f,field:n,valueExpression:u,valueExpressionTitle:d,normalizationType:s,normalizationField:l,normalizationTotal:t,classificationMethod:m,standardDeviationInterval:c,numClasses:p,outlineOptimizationEnabled:b,forBinning:y,filter:v,view:h,signal:w});return{...e,creatorParameters:g,renderer:r}}async function we(e){const i="regenerate-color-age-renderer";await x(e,i);const r=await E(e);if("color-age"!==z(r))throw new o(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:a}=r,n=a?.visualVariables.find((e=>"color"===e.type)),l=n.startTime,s=n.endTime,t=n.units,u=n.theme,{layer:d,filter:m,view:c,signal:p}=e,f=V(r),y=I(r),v=await fe({layer:d,startTime:l,endTime:s,unit:t,theme:u,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:m,view:c,signal:p});return{...e,creatorParameters:v,renderer:r}}async function be(e,i){let r=e.colorScheme,a=null,o=null;const{view:n}=e,l=await G(e.basemap,n);if(a=null!=l.basemapId?l.basemapId:null,o=null!=l.basemapTheme?l.basemapTheme:null,r)return{scheme:ie(r),basemapId:a,basemapTheme:o};const s=e.theme||oe,t=re({theme:s,basemapTheme:o,geometryType:e.geometryType,worldScale:e.worldScale,view:n});if(t)if(a=t.basemapId,o=t.basemapTheme,e.schemeId){const i=s+"/"+a+"/"+e.schemeId;r=ae({id:i,geometryType:e.geometryType})}else r=t.primaryScheme;return{scheme:r,basemapId:a,basemapTheme:o}}async function ge(e,i){const r=i.layer,n=await be({basemap:i.basemap,colorScheme:i.colorScheme,geometryType:r.geometryType,schemeId:"elevation"===i.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),l=n.scheme;if(!l)throw new o("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const s=a(l.colors,le);if(s.length<le)throw new o("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const t=F(e,!1,!0),u=t?q(t[0],t[1],5):U(e);return{stops:m({values:u,isDate:!1,colors:s,labelIndexes:[0,2,4]}),basemapId:n.basemapId,basemapTheme:n.basemapTheme,statistics:e,defaultValuesUsed:!!t,colorScheme:ie(l)}}function Te(e,i,r,a){const o=P(e,i,r,!0);return{values:D(o,e,i,a),defaultValuesUsed:o.defaultValuesUsed}}async function xe(e,i,r,n){const{field:s,theme:d}=e,m=await be({basemap:e.basemap,theme:e.theme,geometryType:r,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),y=m.scheme;if(!y)throw new o("color-visual-variable:insufficient-info","Unable to find color scheme");const v=a(y.colors,le);if(v.length<le)throw new o("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const h=y.id.includes("seq-"),{values:w,defaultValuesUsed:b}=Te(i,d,n,h),g=a(v,le),T=new c({field:s??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:w.map(((e,i)=>new p({value:e,color:g[i]}))),legendOptions:l(f,e.legendOptions)}),x=new u({type:"color",minSliderValue:null!=e.minValue?e.minValue:i.min,maxSliderValue:null!=e.maxValue?e.maxValue:i.max,theme:y.theme}),E=new t({visualVariables:[x]});return{basemapId:m.basemapId,basemapTheme:m.basemapTheme,visualVariable:T,statistics:i,defaultValuesUsed:b,colorScheme:ie(y),authoringInfo:E}}async function Ee(e,i,a,o,n,l,t){const u=await s("esri/smartMapping/t9n/smartMapping"),{field:d,defaultSymbolEnabled:m}=t,c=ie(e.colorScheme),p=i?.opacity,f=[e.visualVariable.clone()];i?.visualVariables?.length&&f.push(...i.visualVariables.map((e=>e.clone()))),a?.minSize&&f.push(a.minSize);return{renderer:new r({classBreakInfos:[{minValue:-ne,maxValue:ne,symbol:L(l,{type:t.symbolType,color:c.noDataColor,size:$(c,l),outline:A(c,l,p),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}})}],defaultLabel:m?u.other:null,defaultSymbol:m?L(l,{type:t.symbolType,color:c.noDataColor,size:$(c,l),outline:A(c,l,p),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}}):null,field:d,normalizationType:o,normalizationField:n,valueExpression:t.valueExpression,valueExpressionTitle:t.valueExpressionTitle,visualVariables:f,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:ie(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function ze(e){const i=await se(e),{view:r,field:a,valueExpression:o,minValue:n,maxValue:l,layer:s,normalizationField:t,signal:u,filter:d,statistics:m}=i,c=t?"field":void 0,p=await(m??S({layer:s,field:a,valueExpression:o,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:c,normalizationField:t,minValue:n,maxValue:l,filter:d,view:r,signal:u})),f=s,y=a&&"function"!=typeof a?f.getField(a):null;return xe(i,p,f.geometryType,K(y))}async function Ve(e){const{view:i,filter:r,creatorParameters:a,renderer:n,signal:l}=await ye(e),s=n.authoringInfo.clone(),t=s.visualVariables.find((e=>"color"===e.type)),u=n.visualVariables.find((e=>"color"===e.type)),{field:d,normalizationField:m,valueExpression:c,theme:p,layer:f}=a,y=await S({layer:f,field:d,valueExpression:c,normalizationField:m,filter:r,view:i,signal:l}),v=d&&"function"!=typeof d?f.getField(d):null,{values:h}=Te(y,p,K(v),"high-to-low"===p);if(h.length!==u.stops.length)throw new o("regenerate-color-visual-variable:invalid-parameters","Visual variable is invalid");return u.stops.forEach(((e,i)=>e.value=h[i])),t.minSliderValue=y.min,t.maxSliderValue=y.max,{visualVariable:u,authoringInfo:s}}function Ie(e,i){const r=e.colorsForClassBreaks;if(r?.length)for(const a of r)if(a.numClasses===i)return n(a.colors);return a(e.colors,i)}async function Se(e,i){const a=await s("esri/smartMapping/t9n/smartMapping"),n=e.layer,l=e.defaultSymbolEnabled,u=n.geometryType,m=e.classificationMethod,c="standard-deviation"===m,p=await be({basemap:e.basemap,geometryType:u,theme:c?"above-and-below":null,colorScheme:e.colorScheme,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view}),f=p.scheme,{result:y,outlineResult:v}=i,h=y.classBreakInfos,w=e.normalizationType;if(!f)throw new o("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const b=Ie(f,h.length);if(!b||b.length!==h.length)throw new o("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const g=v?.opacity,T=new r({classBreakInfos:h.map(((i,r)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:L(u,{type:e.symbolType,color:b[r],size:$(f,u),outline:A(f,u,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:i.label}))),defaultLabel:l?a.other:null,defaultSymbol:l?L(u,{type:e.symbolType,color:f.noDataColor,size:$(f,u),outline:A(f,u,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?y.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new t({type:"class-breaks-color",classificationMethod:m,standardDeviationInterval:e.standardDeviationInterval})});return c||d({classBreakInfos:T.classBreakInfos,classificationMethod:m,normalizationType:w,round:!0}),v?.visualVariables?.length&&(T.visualVariables=v.visualVariables.map((e=>e.clone()))),{renderer:T,colorScheme:ie(f),classBreaksResult:y,defaultValuesUsed:i.defaultValuesUsed,basemapId:p.basemapId,basemapTheme:p.basemapTheme}}async function Me(e){const i=await te(e),{layer:r,view:a,signal:o,filter:n}=i,[l,s,t]=await Promise.all([ze(pe(i)),i.outlineOptimizationEnabled?v({layer:r,view:a,signal:o,filter:n}).catch(M):null,i.sizeOptimizationEnabled?h({layer:r,view:a,signal:o,filter:n}).catch(M):null]),u=i.normalizationField;return Ee(l,s,t,u?"field":void 0,u,r.geometryType,i)}async function je(e){const{renderer:i,view:r,signal:a,filter:o,creatorParameters:n}=await ve(e),{layer:l,outlineOptimizationEnabled:s,sizeOptimizationEnabled:t}=n,[u,d,m]=await Promise.all([Ve(e),s?v({layer:l,view:r,signal:a,filter:o}).catch(M):null,t?h({layer:l,view:r,signal:a,filter:o}).catch(M):null]);return w(i,u.visualVariable,b),w(i,d?.visualVariables,g),w(i,m?.minSize,T),i.authoringInfo=u.authoringInfo.clone(),{renderer:i}}async function Be(e){const i=await ue(e);return Se(i,await j(de(i),i.outlineOptimizationEnabled))}async function Oe(e){const{renderer:i,creatorParameters:r}=await he(e),{normalizationType:a,outlineOptimizationEnabled:n,classificationMethod:l}=r,{result:s,outlineResult:t}=await j(de(r),n),u=s.classBreakInfos;if(r.numClasses!==u.length)throw new o("regenerate-color-class-breaks-renderer:insufficient-info","The number of class breaks generated does not match the number of class breaks in the renderer.");return i.classBreakInfos.forEach(((e,i)=>{e.minValue=u[i].minValue,e.maxValue=u[i].maxValue,e.label=u[i].label})),i.normalizationTotal="percent-of-total"===a?s.normalizationTotal:void 0,"standard-deviation"!==l&&d({classBreakInfos:i.classBreakInfos,classificationMethod:l,normalizationType:a,round:!0}),w(i,t?.visualVariables,g),{renderer:i}}function ke(i){return me(i).then((i=>({renderer:new e({field:"RGB",pointsPerInch:i.density??void 0,pointSizeAlgorithm:B(i.size)})})))}async function Re(e){const r=await ce(e),a=r.statistics??await S({layer:r.layer,field:r.field,signal:r.signal}),o=await ge(a,r);return{renderer:new i({field:r.field,pointsPerInch:r.density??void 0,pointSizeAlgorithm:B(r.size),stops:o.stops}),basemapId:o.basemapId,basemapTheme:o.basemapTheme,statistics:o.statistics,defaultValuesUsed:o.defaultValuesUsed,colorScheme:o.colorScheme}}async function Ce(e){const i=await fe(e),{defaultSymbolEnabled:r,view:a,startTime:o,endTime:n,symbolType:l,colorMixMode:s,edgesType:t,minValue:u,maxValue:d,signal:m,filter:c}=i,p=i.layer,[f,w,b]=await Promise.all([i.unit?{unit:i.unit,statistics:null}:y({view:a,layer:p,startTime:o,endTime:n,minValue:u,maxValue:d,signal:m,filter:c}),i.outlineOptimizationEnabled?v({layer:p,view:a,signal:m,filter:c}).catch(M):null,i.sizeOptimizationEnabled?h({layer:p,view:a,signal:m,filter:c}).catch(M):null]),{unit:g,statistics:T}=f,{valueExpression:x,title:E}=await O(i,g),z=await ze(pe({layer:p,basemap:i.basemap,valueExpression:x,symbolType:l,statistics:T,legendOptions:{title:E},colorScheme:i.colorScheme,theme:i.theme,view:a,minValue:i.minValue,maxValue:i.maxValue,filter:c,signal:m})),V={layer:p,valueExpression:x,defaultSymbolEnabled:r,symbolType:l,colorMixMode:s,edgesType:t},I=await Ee(z,w,b,null,null,p.geometryType,V),S=I.renderer.authoringInfo?.visualVariables;return S?.forEach((e=>k(e,o,n,g))),{...I,unit:g}}async function Fe(e){const{renderer:i,creatorParameters:r}=await we(e),{layer:a,outlineOptimizationEnabled:o,sizeOptimizationEnabled:n,startTime:l,endTime:s,theme:t,view:u,signal:d,filter:m}=r,[c,p,f]=await Promise.all([y({view:u,layer:a,startTime:l,endTime:s,signal:d,filter:m}),o?v({layer:a,view:u,signal:d,filter:m}).catch(M):null,n?h({layer:a,view:u,signal:d,filter:m}).catch(M):null]),{unit:x,statistics:E}=c,{valueExpression:z,title:V}=await O(r,x),I=await ze(pe({layer:a,valueExpression:z,statistics:E,legendOptions:{title:V},theme:t,view:u,filter:m,signal:d}));w(i,I.visualVariable,b),w(i,p?.visualVariables,g),w(i,f?.minSize,T),i.authoringInfo=I.authoringInfo.clone();const S=i.authoringInfo?.visualVariables;return S?.forEach((e=>k(e,l,s,x))),{renderer:i}}export{Ce as createAgeRenderer,Be as createClassBreaksRenderer,Me as createContinuousRenderer,Re as createPCContinuousRenderer,ke as createPCTrueColorRenderer,ze as createVisualVariable,Fe as regenerateAgeRenderer,Oe as regenerateClassBreaksRenderer,je as regenerateContinuousRenderer,Ve as regenerateVisualVariable};
