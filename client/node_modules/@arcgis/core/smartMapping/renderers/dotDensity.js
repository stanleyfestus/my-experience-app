/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import e from"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import{createUniqueColors as r}from"../../core/colorUtils.js";import t from"../../core/Error.js";import{getResolutionForScale as i}from"../../geometry/support/scaleUtils.js";import s from"../../renderers/support/AuthoringInfo.js";import a from"../heuristics/outline.js";import{roundValue as n}from"./support/dotDensityUtils.js";import{errorCallback as l,getSymbolOutlineFromScheme as o,verifyBasicFieldValidity as u,getBasemapInfo as m}from"./support/utils.js";import d from"../statistics/spatialStatistics.js";import p from"../statistics/summaryStatisticsForAttributes.js";import c from"../statistics/support/attributeDensity.js";import{verifyBinningParams as f}from"../support/binningUtils.js";import{getFieldsList as y}from"../support/utils.js";import{LayerType as b,binningCapableLayerTypes as g,createLayerAdapter as w,getLayerTypeLabels as h}from"../support/adapters/support/layerUtils.js";import{cloneScheme as v,getSchemes as S}from"../symbology/dotDensity.js";const j=500;async function V(e){const r=e.view;if(!(e?.layer&&r&&e.attributes?.length))throw new t("dot-density-renderer:missing-parameters","'layer', 'view' and 'attributes' parameters are required");if(e.attributes.length>8)throw new t("dot-density-renderer:invalid-parameters","Dot density renderer does not support more than 8 attributes");e.forBinning&&f(e,"dot-density-renderer");const i={...e,view:r,layer:e.layer,attributes:e.attributes},s=[b.FeatureLayer,b.OGCFeatureLayer,b.GeoJSONLayer,b.WFSLayer],a=e.forBinning?g:s,n=w(i.layer,a,e.forBinning);if(!n)throw new t("dot-density-renderer:invalid-parameters","'layer' must be one of these types: "+h(a).join(", "));i.layer=n,i.dotBlendingEnabled??=!0,i.dotValueOptimizationEnabled??=!0;const l=null!=i.signal?{signal:i.signal}:null;await Promise.all([r.when(),n.load(l)]);if("polygon"!==n.geometryType)throw new t("dot-density-renderer:not-supported","Dot density renderer is supported for polygon layers only");const o=[],m=i.attributes;for(const t of m){const e=await y({field:t.field,valueExpression:t.valueExpression});o.push(...e)}const d=u(n,o.filter(Boolean),"dot-density-renderer:invalid-parameters");if(d)throw d;return i}async function x(e){let r=e.dotDensityScheme,t=null,i=null;const s=await m(e.basemap,e.view);if(t=null!=s.basemapId?s.basemapId:null,i=null!=s.basemapTheme?s.basemapTheme:null,r)return{scheme:v(r),basemapId:t,basemapTheme:i};const a=S({numColors:e.attributes.length,basemapTheme:i});return a&&(r=a.primaryScheme,t=a.basemapId,i=a.basemapTheme),{scheme:r,basemapId:t,basemapTheme:i}}function E(e){return{dotValue:1,referenceScale:e.scale,minSliderValue:1,maxSliderValue:100}}async function D(e){const{view:r,layer:t,attributes:s,signal:a,filter:l}=e,o=await t.getSampleFeatures({view:r,sampleSize:j,returnGeometry:!0,filter:l,signal:a},"json"),[u,m]=await Promise.all([d({features:o,geometryType:t.geometryType}),p({layer:t,attributes:s,filter:l,includeZeros:!1,includeNegatives:!1,view:r,signal:a})]),c=null!=u&&"avgSize"in u&&u.avgSize,f=m.avg;if(!c||!f)return E(r);const y=i(r.scale,r.spatialReference);return{dotValue:n(f/(c*c/(y*y)*.1))||1,referenceScale:r.scale,minSliderValue:1,maxSliderValue:n(f)}}async function T(e){const{view:r,layer:t,attributes:s,signal:a,filter:l}=e,o=[];for(const i of s){const e=await y({field:i.field,valueExpression:i.valueExpression});o.push(...e)}const u=await t.getSampleFeatures({view:r,sampleSize:j,requiredFields:o,filter:l,returnGeometry:!0,signal:a},"json"),{minDensity:m,maxDensity:d,avgDensity:p}=await c({features:u,attributes:s,includeZeros:!1,includeNegatives:!1,view:r});if(!p||!m||!d)return E(r);const f=i(r.scale,r.spatialReference),b=f*f,g=n(m*b),w=n(d*b);let h=n(p*b*10)||1;return h>w&&(h=w),{dotValue:h,referenceScale:r.scale,minSliderValue:g,maxSliderValue:w}}async function R(i){const n=await V(i),u=n.layer,m=u.geometryType,d=await x(n),p=d?.scheme;if(!p)throw new t("dot-density-renderer:insufficient-info","Unable to find dot-density scheme");const c=n.view,f=n.filter,y={layer:u,view:c,filter:f,attributes:n.attributes,signal:n.signal},b={layer:n.layer,view:c,filter:f,signal:n.signal},[g,w]=await Promise.all([n.trueDensity?T(y):D(y),n.outlineOptimizationEnabled?a(b).catch(l):null]),{dotValue:h,referenceScale:v,minSliderValue:S,maxSliderValue:j}=g,E=r(p.colors,n.attributes.length),R=n.attributes.map(((e,r)=>({field:e.field,valueExpression:e.valueExpression,label:e.label,valueExpressionTitle:e.valueExpressionTitle,color:E[r]}))),I=new e({attributes:R,dotBlendingEnabled:n.dotBlendingEnabled,outline:w?o(p,m,w.opacity):null,dotValue:h,referenceScale:n.dotValueOptimizationEnabled?v:null,legendOptions:n.legendOptions});return w?.visualVariables.length&&(I.visualVariables=w.visualVariables.map((e=>e.clone()))),I.authoringInfo=new s({type:"dot-density",minSliderValue:S,maxSliderValue:j}),{renderer:I,dotDensityScheme:p,basemapId:d.basemapId,basemapTheme:d.basemapTheme}}export{R as createRenderer};
