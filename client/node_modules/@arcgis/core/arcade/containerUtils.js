/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"./Dictionary.js";import{ArcadeExecutionError as a,ExecutionErrorCodes as r}from"./executionError.js";import t from"./ImmutablePathArray.js";import n from"./ImmutablePointArray.js";import{o as s,q as c,r as i,c as l,v as o,p as u,b as f}from"../chunks/languageUtils.js";import h from"../core/Accessor.js";let d=0;function p(s,c,i,l,o=1){let u;switch(c=c.toLowerCase()){case"hasz":{const e=s.hasZ;return void 0!==e&&e}case"hasm":{const e=s.hasM;return void 0!==e&&e}case"spatialreference":{let a=s.spatialReference._arcadeCacheId;if(void 0===a){let e=!0;h.isFrozen(s.spatialReference)&&(e=!1),e&&(d++,s.spatialReference._arcadeCacheId=d,a=d)}const r=new e({wkt:s.spatialReference.wkt,wkid:s.spatialReference.wkid});return void 0!==a&&(r._arcadeCacheId="SPREF"+a.toString()),r}}switch(s.type){case"extent":switch(c){case"xmin":case"xmax":case"ymin":case"ymax":case"zmin":case"zmax":case"mmin":case"mmax":{const e=s[c];return void 0!==e?e:null}case"type":return"Extent"}break;case"polygon":switch(c){case"rings":u=s.cache._arcadeCacheId,void 0===u&&(d++,u=d,s.cache._arcadeCacheId=u);return new t(s.rings,s.spatialReference,!0===s.hasZ,!0===s.hasM,u);case"type":return"Polygon"}break;case"point":switch(c){case"x":case"y":case"z":case"m":return s[c]??null;case"type":return"Point"}break;case"polyline":switch(c){case"paths":u=s.cache._arcadeCacheId,void 0===u&&(d++,u=d,s.cache._arcadeCacheId=u);return new t(s.paths,s.spatialReference,!0===s.hasZ,!0===s.hasM,u);case"type":return"Polyline"}break;case"multipoint":switch(c){case"points":u=s.cache._arcadeCacheId,void 0===u&&(d++,u=d,s.cache._arcadeCacheId=u);return new n(s.points,s.spatialReference,!0===s.hasZ,!0===s.hasM,u,1);case"type":return"Multipoint"}}if(1===o)throw new a(i,r.InvalidIdentifier,l);return 2===o?{keystate:"notfound"}:null}function m(e,a){let r,t=e;if(null==t)return null;if(s(a))r=a;else if(c(a))r=a.toArray();else{if(null==a)return null;r=[a]}for(const n of r){if(i(t)){if(!1===l(n))return null;if(!t.hasField(n))return null;t=t.field(n)}else if(o(t)){if(!1===l(n))return null;if(!t.hasField(n))return null;t=t.field(n)}else if(u(t)){if(!1===l(n))return null;t=p(t,n,null,null,0)}else if(s(t)){if(!1===f(n))return null;t=n>=0?t[n]:t[t.length+n]}else{if(!c(t))return null;if(!1===f(n))return null;t=n>=0?t.get(n):t.get(t.length()+n)}if(null==t)return null}return t}export{p as geometryMember,m as getNestedOptionalValue};
