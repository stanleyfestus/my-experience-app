/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import"../../geometry.js";import t from"../../Graphic.js";import{rasterRendererTypes as i,websceneRasterRendererTypes as r,read as s}from"../../rasterRenderers.js";import n from"../../request.js";import a from"../../core/Error.js";import{clone as o}from"../../core/lang.js";import l from"../../core/Logger.js";import{watch as u}from"../../core/reactiveUtils.js";import{urlToObject as p}from"../../core/urlUtils.js";import{property as c}from"../../core/accessorSupport/decorators/property.js";import{Integer as m,ensureClass as d,ensureRange as h,ensureNumber as f}from"../../core/accessorSupport/ensureType.js";import{reader as y}from"../../core/accessorSupport/decorators/reader.js";import{subclass as g}from"../../core/accessorSupport/decorators/subclass.js";import{writer as R}from"../../core/accessorSupport/decorators/writer.js";import{srToRESTValue as b}from"../../geometry/support/spatialReferenceUtils.js";import{opacity as w,url as v}from"../support/commonProperties.js";import I from"../support/DimensionalDefinition.js";import{ExportImageServiceParameters as S}from"../support/ExportImageServiceParameters.js";import x from"../support/Field.js";import _ from"../support/FieldsIndex.js";import{createBitmap as F}from"../support/imageBitmapUtils.js";import{isSupportedRendererType as D}from"../support/imageryRendererUtils.js";import T from"../support/MosaicRule.js";import O from"../support/MultidimensionalSubset.js";import P from"../support/PixelBlock.js";import{interpolationKebab as C,noDataInterpretationKebab as M,pixelTypeKebabDict as N}from"../support/rasterEnums.js";import j from"../support/RasterFunction.js";import q from"../support/RasterInfo.js";import A from"../support/RasterJobHandler.js";import{intersectMultimensionalSubset as J,getSubsetVariablesFromMdInfo as E,getDefaultMultidimensionalDefinition as V}from"../support/rasterDatasets/multidimensionalUtils.js";import{decode as Q,getFormat as H}from"../support/rasterFormats/RasterCodec.js";import{uvComponentToVector as U}from"../support/rasterFunctions/vectorFieldUtils.js";import{getSupportedRendererTypes as B,matchPresetRenderer as L,getDefaultBandCombination as z,createDefaultRenderer as G,normalizeRendererJSON as k}from"../../renderers/support/rasterRendererHelper.js";import W from"../../renderers/support/RasterSymbolizer.js";import{computeAngles as $,computePixelSpaceLocations as X,computeHistograms as K,computeStatisticsHistograms as Y,measureHeight as Z,measureAreaAndPerimeter as ee,measureDistanceAndAngle as te,measurePointOrCentroid as ie,measureLengthFromImage as re,measureAreaFromImage as se,getImageSpatialReferenceQueryParameter as ne,getSamples as ae,identify as oe,imageToMap as le,imageToMapMultiray as ue,mapToImage as pe,findImages as ce,getImageUrl as me,queryBoundary as de,queryGPSInfo as he}from"../../rest/imageService.js";import{fetchServiceRasterInfo as fe,generateRasterInfo as ye,patchServiceInfo as ge}from"../../rest/imageService/fetchRasterInfo.js";import{getCatalogItemRasterInfo as Re}from"../../rest/imageService/getCatalogItemRasterInfo.js";import{executeForCount as be}from"../../rest/query/executeForCount.js";import{executeForIds as we}from"../../rest/query/executeForIds.js";import{executeQueryJSON as ve}from"../../rest/query/executeQueryJSON.js";import Ie from"../../rest/support/FeatureSet.js";import Se from"../../rest/support/ImageIdentifyParameters.js";import xe from"../../rest/support/Query.js";import{createFlowMesh as _e}from"../../views/2d/engine/flow/dataUtils.js";import Fe from"../../geometry/Extent.js";import De from"../../geometry/SpatialReference.js";import Te from"../../geometry/Polygon.js";const Oe=new Set(["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff"]),Pe=h(f,{min:0,max:255});function Ce(e){const t=JSON.stringify(e),i=t.includes('"rasterFunctionDefinition":{'),r=i?t.match(/"type":"(.*?FunctionArguments")/gi):t.match(/"rasterFunction":"(.*?")/gi),s=r?.map((e=>i?e.slice(8,-18):e.slice(18,-1)));return s?s.join("/"):null}const Me=h=>{let f=class extends h{constructor(){super(...arguments),this._functionRasterInfos={},this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this._cachedRendererJson=null,this._serviceSupportsMosaicRule=null,this._rasterAttributeTableFieldPrefix="Raster.",this.adjustAspectRatio=null,this.bandIds=void 0,this.capabilities=null,this.compressionQuality=void 0,this.compressionTolerance=.01,this.copyright=null,this.defaultMosaicRule=null,this.definitionExpression=null,this.exportImageServiceParameters=null,this.rasterInfo=null,this.fields=null,this.fullExtent=null,this.hasMultidimensions=!1,this.imageMaxHeight=4100,this.imageMaxWidth=4100,this.interpolation=void 0,this.minScale=0,this.maxScale=0,this.multidimensionalInfo=null,this.multidimensionalSubset=null,this.noData=null,this.noDataInterpretation=void 0,this.objectIdField=null,this.geometryType="polygon",this.typeIdField=null,this.types=[],this.pixelFilter=null,this.raster=void 0,this.sourceType=null,this.viewId=void 0,this.symbolizer=null,this.rasterFunctionInfos=null,this.serviceDataType=null,this.spatialReference=null,this.pixelType=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.url=null,this.version=void 0}initialize(){this._set("exportImageServiceParameters",new S({layer:this}))}readServiceSupportsMosaicRule(e,t){return this._isMosaicRuleSupported(t)}get _rasterFunctionNamesIndex(){const e=new Map;return!this.rasterFunctionInfos||null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.length<1||null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.forEach((t=>{e.set(t.name.toLowerCase().replaceAll(/ /gi,"_"),t.name)})),e}readBandIds(e,t){if(Array.isArray(e)&&e.length>0&&e.every((e=>"number"==typeof e)))return e}readCapabilities(e,t){return this._readCapabilities(t)}writeCompressionQuality(e,t,i){null!=e&&"lerc"!==this.format&&(t[i]=e)}writeCompressionTolerance(e,t,i){"lerc"===this.format&&null!=e&&(t[i]=e)}readDefaultMosaicRule(e,t){return this._serviceSupportsMosaicRule?T.fromJSON(t):null}get fieldsIndex(){return this.fields?new _(this.fields):null}set format(e){e&&Oe.has(e.toLowerCase())&&this._set("format",e.toLowerCase())}readFormat(e,t){return"esriImageServiceDataTypeVector-UV"===t.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===t.serviceDataType||null!=this.pixelFilter?"lerc":"jpgpng"}readMinScale(e,t){return null!=t.minLOD&&null!=t.maxLOD?e:0}readMaxScale(e,t){return null!=t.minLOD&&null!=t.maxLOD?e:0}set mosaicRule(e){let t=e;t?.mosaicMethod&&(t=T.fromJSON({...t.toJSON(),mosaicMethod:t.mosaicMethod,mosaicOperation:t.mosaicOperation})),this._set("mosaicRule",t)}readMosaicRule(e,t){const i=e||t.mosaicRule;return i?T.fromJSON(i):this._isMosaicRuleSupported(t)?T.fromJSON(t):null}writeMosaicRule(e,t,i){let r=this.mosaicRule;const s=this.definitionExpression;r?s&&s!==r.where&&(r=r.clone(),r.where=s):s&&(r=new T({where:s})),this._isValidCustomizedMosaicRule(r)&&(t[i]=r.toJSON())}writeNoData(e,t,i){null!=e&&"number"==typeof e&&(t[i]=Pe(e))}readObjectIdField(e,t){if(!e){const i=t.fields.find((e=>"esriFieldTypeOID"===e.type||"oid"===e.type));e=i?.name}return e}get parsedUrl(){return p(this.url)}readSourceType(e,t){return this._isMosaicDataset(t)?"mosaic-dataset":"raster-dataset"}get renderer(){const{activePresetRendererName:e,presetRenderers:t}=this;if(e){const i=t?.find((({name:t})=>t===e));return i?.renderer.clone()}return this.internalRenderer}set renderer(e){this.activePresetRendererName=null,this.internalRenderer=e}set internalRenderer(e){this.loaded&&(e=this._configRenderer(e)),this._set("internalRenderer",e)}readRenderer(e,t,i){const r=t?.layerDefinition?.drawingInfo?.renderer,n=s(r,i);return null==n?null:("vector-field"===n.type&&t.symbolTileSize&&!r.symbolTileSize&&(n.symbolTileSize=t.symbolTileSize),D(n)||l.getLogger(this).warn("ArcGISImageService","Imagery layer doesn't support given renderer type."),n)}writeRenderer(e,t,i){t.layerDefinition=t.layerDefinition||{},t.layerDefinition.drawingInfo=t.layerDefinition.drawingInfo||{},t.layerDefinition.drawingInfo.renderer=e.toJSON(),"vector-field"===e.type&&(t.symbolTileSize=e.symbolTileSize)}get rasterFields(){const e=this._rasterAttributeTableFieldPrefix,t=new x({name:"Raster.ItemPixelValue",alias:"Item Pixel Value",domain:null,editable:!1,length:50,type:"string"}),i=new x({name:"Raster.ServicePixelValue",alias:"Service Pixel Value",domain:null,editable:!1,length:50,type:"string"}),r=new x({name:"Raster.ServicePixelValue.Raw",alias:"Raw Service Pixel Value",domain:null,editable:!1,length:50,type:"string"});let s=this.fields?o(this.fields):[];s.push(i),this.capabilities?.operations.supportsQuery&&this.fields&&this.fields.length>0&&s.push(t),this.version>=10.4&&null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.some((e=>"none"===e.name.toLowerCase()))&&s.push(r),null!=this.rasterFunctionInfos&&this.rasterFunctionInfos.filter((e=>"none"!==e.name.toLowerCase())).forEach((e=>{s.push(new x({name:"Raster.ServicePixelValue."+e.name,alias:e.name,domain:null,editable:!1,length:50,type:"string"}))})),this._isVectorDataSet()&&(s.push(new x({name:"Raster.Magnitude",alias:"Magnitude",domain:null,editable:!1,type:"double"})),s.push(new x({name:"Raster.Direction",alias:"Direction",domain:null,editable:!1,type:"double"})));const{attributeTable:n}=this.rasterInfo??{};if(null!=n){const t=n.fields.filter((e=>"esriFieldTypeOID"!==e.type&&"value"!==e.name.toLowerCase())).map((t=>{const i=o(t);return i.name=e+t.name,i}));s=s.concat(t)}return s}set rasterFunction(e){let t=e;t?.rasterFunction&&(t=j.fromJSON({...t.toJSON(),rasterFunction:t.rasterFunction,rasterFunctionArguments:t.rasterFunctionArguments})),this._set("rasterFunction",t)}readRasterFunction(e,t){const i=t.rasterFunctionInfos;return t.renderingRule||i?.length&&"None"!==i[0].name?this._isRFTJson(t.renderingRule)?j.fromJSON({rasterFunctionDefinition:t.renderingRule}):j.fromJSON(t.renderingRule||{rasterFunctionInfos:t.rasterFunctionInfos}):null}readSpatialReference(e,t){const i=e||t.extent.spatialReference;return i?De.fromJSON(i):null}readPixelType(e){return N.fromJSON(e)||e}writePixelType(e,t,i){null!=this.serviceRasterInfo&&this.pixelType===this.serviceRasterInfo.pixelType||(t[i]=N.toJSON(e))}readVersion(e,t){let i=t.currentVersion;return i||(i=t.hasOwnProperty("fields")||t.hasOwnProperty("timeInfo")?10:9.3),i}applyFilter(e){let t=e;return this.pixelFilter&&(t=this._clonePixelData(e),this.pixelFilter(t)),t}async applyRenderer(e,t){let i=e;const{renderer:r,symbolizer:s,pixelFilter:n,bandIds:a}=this;if(!this._isPicture()&&r&&s&&!n){const n=JSON.stringify(this._cachedRendererJson)!==JSON.stringify(r.toJSON()),o=this._rasterJobHandler.instance;if(o){n&&(s.bind(),await o.updateSymbolizer(s,t),this._cachedRendererJson=r.toJSON());const l=await o.symbolize({bandIds:a,...e},t);i={extent:e.extent,pixelBlock:l}}else i={extent:e.extent,pixelBlock:s.symbolize({bandIds:a,...e})}}return i}destroy(){this._shutdownJobHandler()}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}async computeAngles(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeAngles)throw new a("imagery-layer:compute-angles","this operation is not supported on the input image service");return $(this.url,e,this._getRequestOptions(t))}async computePixelSpaceLocations(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputePixelLocation)throw new a("imagery-layer:compute-pixel-space-locations","this operation is not supported on the input image service");return X(this.url,e,this._getRequestOptions(t))}async computeHistograms(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeHistograms)throw new a("imagery-layer:compute-histograms","this operation is not supported on the input image service");return e=o(e),this._applyMosaicAndRenderingRules(e),K(this.url,e,this._getRequestOptions(t))}async computeStatisticsHistograms(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsComputeStatisticsHistograms)throw new a("imagery-layer:compute-statistics-histograms","this operation is not supported on the input image service");return e=o(e),this._applyMosaicAndRenderingRules(e),Y(this.url,e,this._getRequestOptions(t))}async measureHeight(e,t){const i=await this._fetchCapabilities(t?.signal);if(!("base-and-top"===e.operationType?i.mensuration.supportsHeightFromBaseAndTop:"base-and-top-shadow"===e.operationType?i.mensuration.supportsHeightFromBaseAndTopShadow:i.mensuration.supportsHeightFromTopAndTopShadow))throw new a("imagery-layer:measure-height","this operation is not supported on the input image service");return e=o(e),this._applyMosaicAndRenderingRules(e),Z(this.url,e,this._getRequestOptions(t))}async measureAreaAndPerimeter(e,t){const i=await this._fetchCapabilities(t?.signal);if(!(i.mensuration.supportsAreaAndPerimeter&&(!e.is3D||i.mensuration.supports3D)))throw new a("imagery-layer:measure-area-and-perimeter","this operation is not supported on the input image service");return e=o(e),this._applyMosaicAndRenderingRules(e),ee(this.url,e,this._getRequestOptions(t))}async measureDistanceAndAngle(e,t){const i=await this._fetchCapabilities(t?.signal);if(!(i.mensuration.supportsDistanceAndAngle&&(!e.is3D||i.mensuration.supports3D)))throw new a("imagery-layer:measure-distance-and-angle","this operation is not supported on the input image service");return e=o(e),this._applyMosaicAndRenderingRules(e),te(this.url,e,this._getRequestOptions(t))}async measurePointOrCentroid(e,t){const i=await this._fetchCapabilities(t?.signal);if(!(i.mensuration.supportsPointOrCentroid&&(!e.is3D||i.mensuration.supports3D)))throw new a("imagery-layer:measure-point-or-centroid","this operation is not supported on the input image service");return e=o(e),this._applyMosaicAndRenderingRules(e),ie(this.url,e,this._getRequestOptions(t))}async measureLengthFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new a("imagery-layer:measure-length-from-image","this operation is not supported on the input image service");if("polyline"!==e.geometry.type)throw new a("imagery-layer:measure-length-from-image","this input geometry must be a polyline");return re(this.url,e,this._getRequestOptions(t))}async measureAreaFromImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMeasureFromImage)throw new a("imagery-layer:measure-area-from-image","this operation is not supported on the input image service");if("polygon"!==e.geometry.type)throw new a("imagery-layer:measure-area-from-image","this input geometry must be a polygon");return se(this.url,e,this._getRequestOptions(t))}getField(e){const{fieldsIndex:t}=this;return null!=t?t.get(e):void 0}getFieldDomain(e,t){const i=this.getField(e);return i?i.domain:null}async fetchImage(e,t,i,r={}){if(null==e||null==t||null==i)throw new a("imagery-layer:fetch-image","Insufficient parameters for requesting an image. A valid extent, width and height values are required.");if(this.renderer||this.symbolizer){const e=await this._generateRasterInfo(this.rasterFunction,{signal:r.signal});e&&(this.rasterInfo=e)}const s=this.getExportImageServiceParameters(e,t,i,r.timeExtent);if(null==s){if(r.requestAsImageElement&&this._canRequestImageElement(this.format)){const e=document.createElement("canvas");if(e.width=t,e.height=i,r.returnImageBitmap){return{imageBitmap:await F(e,`${Me(this.parsedUrl)}/exportImage`,r.signal)}}return{imageOrCanvasElement:e}}const{bandIds:s,rasterInfo:n}=this,a=(s?.length||n.bandCount)??0,o=t*i,l=n.pixelType,u=[];for(let e=0;e<a;e++)u.push(P.createEmptyBand(l,o));return{pixelData:{pixelBlock:new P({width:t,height:i,pixels:u,mask:new Uint8Array(o),pixelType:l}),extent:e}}}const n=!!r.requestAsImageElement&&!this.pixelFilter,o=n&&!!r.returnImageBitmap,l={imageServiceParameters:s,imageProps:{extent:e,width:t,height:i,format:this.format},requestAsImageElement:n,returnImageBitmap:o,signal:r.signal};return this._requestArrayBuffer(l)}fetchKeyProperties(e){return n(Me(this.parsedUrl)+"/keyProperties",{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then((e=>e.data))}fetchRasterAttributeTable(e){return this.version<10.1?Promise.reject(new a("#fetchRasterAttributeTable()","Failed to get rasterAttributeTable")):n(Me(this.parsedUrl)+"/rasterAttributeTable",{query:this._getQueryParams({renderingRule:this.version>=10.3?e?.rasterFunction:null})}).then((e=>Ie.fromJSON(e.data)))}getCatalogItemRasterInfo(e,t){const i={...t,query:this._getQueryParams()};return Re(Me(this.parsedUrl),e,i)}async getCatalogItemICSInfo(e,t){const{data:i}=await n(Me(this.parsedUrl)+"/"+e+"/info/ics",{query:this._getQueryParams(),...t}),r=i?.ics;if(!r)return;let s=null;try{s=(await n(Me(this.parsedUrl)+"/"+e+"/info",{query:this._getQueryParams(),...t})).data.extent}catch{}if(!s?.spatialReference)return{ics:r,icsToPixelTransform:null,icsExtent:null,northDirection:null};const a=this.version>=10.7?n(Me(this.parsedUrl)+"/"+e+"/info/icstopixel",{query:this._getQueryParams(),...t}).then((e=>e.data)).catch((()=>({}))):{},o=s.spatialReference,l={geometries:JSON.stringify({geometryType:"esriGeometryEnvelope",geometries:[s]}),inSR:b(o),outSR:"0:"+e},u=n(Me(this.parsedUrl)+"/project",{query:this._getQueryParams(l),...t}).then((e=>e.data)).catch((()=>({}))),p=5,c=(s.xmin+s.xmax)/2,m=(s.ymax-s.ymin)/(p+1),d=s.ymin+m,h=[];for(let n=0;n<p;n++)h.push({x:c,y:d+m*n});const f={geometries:JSON.stringify({geometryType:"esriGeometryPoint",geometries:h}),inSR:b(o),outSR:"0:"+e},y=n(Me(this.parsedUrl)+"/project",{query:this._getQueryParams(f),...t}).then((e=>e.data)).catch((()=>({}))),g=await Promise.all([a,u,y]);let R=g[0].ipxf;if(null==R){const e=r.geodataXform?.xf_0;"topup"===e?.name?.toLowerCase()&&6===e?.coefficients?.length&&(R={affine:{name:"ics [sensor: Frame] to pixel (column, row) transformation",coefficients:e.coefficients,cellsizeRatio:0,type:"GeometricXform"}})}const w=Fe.fromJSON(g[1]?.geometries?.[0]);w&&(w.spatialReference=new De({wkid:0,imageCoordinateSystem:r}));const v=g[2].geometries?g[2].geometries.filter((e=>null!=e?.x&&null!=e.y&&"NaN"!==e.x&&"NaN"!==e.y)):[],I=v.length;if(I<3)return{ics:r,icsToPixelTransform:R,icsExtent:w,northDirection:null};let S=0,x=0,_=0,F=0;for(let n=0;n<I;n++)S+=v[n].x,x+=v[n].y,_+=v[n].x*v[n].x,F+=v[n].x*v[n].y;const D=(I*F-S*x)/(I*_-S*S);let T=0;const O=v[p-1].x>v[0].x,P=v[p-1].y>v[0].y;return D===1/0?T=P?90:270:0===D?T=O?0:180:D>0?T=O?180*Math.atan(D)/Math.PI:180*Math.atan(D)/Math.PI+180:D<0&&(T=P?180+180*Math.atan(D)/Math.PI:360+180*Math.atan(D)/Math.PI),{ics:r,icsToPixelTransform:R,icsExtent:w,northDirection:T}}async generateRasterInfo(e,t){e=d(j,e);const i={...t,query:this._getQueryParams()};if(!e||"none"===e.functionName?.toLowerCase()||this._isVectorFieldResampleFunction(e))return this.serviceRasterInfo??fe(Me(this.parsedUrl),this.sourceJSON,i);const r=Ce(e);if(!r)throw new a("imagery-layer:generate-raster-info","the rendering rule is not supported");if(this._functionRasterInfos[r])return this._functionRasterInfos[r];const s=ye(Me(this.parsedUrl),e,i);this._functionRasterInfos[r]=s;try{return await s}catch(n){throw this._functionRasterInfos[r]=null,n}}getExportImageServiceParameters(e,t,i,r){e=e.clone().shiftCentralMeridian();const s=ne(e.spatialReference,Me(this.parsedUrl));this.pixelType!==this.serviceRasterInfo.pixelType&&(this.exportImageServiceParameters.pixelType=this.pixelType);const n=this.exportImageServiceParameters.toJSON(),{bandIds:a,noData:o}=n;let{renderingRule:l}=n;const u=this.rasterFunction?.rasterFunctionDefinition,p=this.renderer?.type,c=!p||"raster-stretch"===p||"raster-colormap"===p||"unique-value"===p||"class-breaks"===p||"raster-shaded-relief"===p;if(a?.length&&this._hasRasterFunction(this.rasterFunction)&&!u&&c){const e={rasterFunction:"ExtractBand",rasterFunctionArguments:{BandIds:a}};if("Stretch"===l.rasterFunction)e.rasterFunctionArguments.Raster=l.rasterFunctionArguments.Raster,l.rasterFunctionArguments.Raster=e;else if("Colormap"===l.rasterFunction){const t=l.rasterFunctionArguments.Raster;"Stretch"===t?.rasterFunction?(e.rasterFunctionArguments.Raster=t.rasterFunctionArguments.Raster,t.rasterFunctionArguments.Raster=e):(e.rasterFunctionArguments.Raster=t,l.rasterFunctionArguments.Raster=e)}else e.rasterFunctionArguments.Raster=l,l=e;n.bandIds=void 0}else n.bandIds=a?.join(",");Array.isArray(o)&&o.length>0&&(n.noData=o.join(","));const m=this._processMultidimensionalIntersection(null,r,this.exportImageServiceParameters.mosaicRule);if(m.isOutSide)return null;n.mosaicRule=null!=m.mosaicRule?JSON.stringify(m.mosaicRule):null,r=m.timeExtent,n.renderingRule=this._getRenderingRuleString(j.fromJSON(l));const d={};if(null!=r){const{start:e,end:t}=r.toJSON();e&&t&&e===t?d.time=""+e:null==e&&null==t||(d.time=`${e??"null"},${t??"null"}`)}return{bbox:e.xmin+","+e.ymin+","+e.xmax+","+e.ymax,bboxSR:s,imageSR:s,size:t+","+i,...n,...d}}async getSamples(e,t){const i=await this._fetchCapabilities(t?.signal);if(!i?.operations.supportsGetSamples)throw new a("imagery-layer:get-samples","getSamples operation is not supported on the input image service");e=o(e);const{raster:r}=this;return r&&null==e.raster&&(e.raster=r),ae(this.url,e,this._getRequestOptions(t))}async identify(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsIdentify)throw new a("imagery-layer:identify","identify operation is not supported on the input image service");e=o(e),this.version<10.91&&"extent"===e.geometry?.type&&(e.geometry=Te.fromExtent(e.geometry));const i=this._processMultidimensionalIntersection(e.geometry,e.timeExtent,e.mosaicRule||this.mosaicRule);if(i.isOutSide)throw new a("imagery-layer:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");e.timeExtent=i.timeExtent,e.mosaicRule=i.mosaicRule;const{raster:r,rasterFunction:s}=this;return s&&null==e.rasterFunction&&(e.rasterFunction=s),r&&null==e.raster&&(e.raster=r),oe(this.url,e,this._getRequestOptions(t))}async imageToMap(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMap)throw new a("imagery-layer:image-to-map","imageToMap operation is not supported on the input image service");return le(Me(this.parsedUrl),e,this._getRequestOptions(t))}async imageToMapMultiray(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsImageToMapMultiray)throw new a("imagery-layer:image-to-map-multiray","imageToMapMultiray operation is not supported on the input image service");return ue(Me(this.parsedUrl),e,this._getRequestOptions(t))}async mapToImage(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsMapToImage)throw new a("imagery-layer:map-to-image","mapToImage operation is not supported on the input image service");return pe(Me(this.parsedUrl),e,this._getRequestOptions(t))}async findImages(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsFindImages)throw new a("imagery-layer:find-images","findImages operation is not supported on the input image service");return ce(Me(this.parsedUrl),e,this._getRequestOptions(t))}async getImageUrl(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsGetImageUrl)throw new a("imagery-layer:get-image-url","getImageUrl operation is not supported on the input image service");return me(Me(this.parsedUrl),e,this._getRequestOptions(t))}createQuery(){return new xe({outFields:["*"],returnGeometry:!0,where:this.definitionExpression||"1=1"})}async queryBoundary(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryBoundary)throw new a("imagery-layer:query-boundary","queryBoundary operation is not supported on the input image service");return e=e??{outSpatialReference:this.spatialReference},de(Me(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasters(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),ve(this.url,e,t)}async queryObjectIds(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),we(this.url,e,t)}async queryGPSInfo(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQueryGPSInfo)throw new a("imagery-layer:query-gps-info","queryGPSInfo operation is not supported on the input image service");return e=e??{where:"1=1"},he(Me(this.parsedUrl),e,this._getRequestOptions(t))}async queryRasterCount(e,t){return({query:e,requestOptions:t}=await this._prepareForQuery(e,t)),be(this.url,e,t)}async queryVisibleRasters(e,t){if(!e)throw new a("imagery-layer: query-visible-rasters","missing query parameter");await this.load();const{pixelSize:i,returnDomainValues:r,returnTopmostRaster:s,showNoDataRecords:n}=t||{pixelSize:null,returnDomainValues:!1,returnTopmostRaster:!1,showNoDataRecords:!1};let o=!1,l=null,u=null;const p="raster.servicepixelvalue",c=this._rasterFunctionNamesIndex;if(null!=e.outFields&&(o=e.outFields.some((e=>!e.toLowerCase().includes(p))),this.version>=10.4)){const t=e.outFields.filter((e=>e.toLowerCase().includes(p)&&e.length>p.length)).map((e=>{const t=e.slice(p.length+1);return[this._updateRenderingRulesFunctionName(t,c),t]}));l=t.map((e=>new j({functionName:e[0]}))),u=t.map((e=>e[1]));const{rasterFunction:i}=this;0===l.length?i?.functionName?(l.push(i),u.push(i.functionName)):l=null:i?.functionName&&!l.some((e=>e.functionName===i.functionName))&&(l.push(i),u.push(i.functionName))}const m=null==e.outSpatialReference||e.outSpatialReference.equals(this.spatialReference),{multidimensionalSubset:d}=this;let h=e.timeExtent||this.timeExtent;if(d){const{isOutside:t,intersection:i}=J(d,{geometry:e.geometry,timeExtent:e.timeExtent,multidimensionalDefinition:this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition});if(t)throw new a("imagery-layer:query-visible-rasters","the request cannot be fulfilled when falling outside of the multidimensional subset");null!=i?.timeExtent&&(h=i.timeExtent)}const f=this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule,h);let y=e.geometry;this.version<10.91&&"extent"===y?.type&&(y=Te.fromExtent(y));const g=this._getQueryParams({geometry:y,timeExtent:h,mosaicRule:f,rasterFunction:this.version<10.4?this.rasterFunction:null,rasterFunctions:l,pixelSize:i,returnCatalogItems:o,returnGeometry:m,raster:this.raster,maxItemCount:s?1:null});delete g.f;const R=new Se(g);try{await this._generateRasterInfo(this.rasterFunction);const i=await oe(this.url,R,{signal:t?.signal,query:{...this.customParameters}}),s=e.outFields,a=null!=i.value&&i.value.toLowerCase().includes("nodata");if(!(o&&!m&&i?.catalogItems?.features.length&&(n||!a)))return this._processVisibleRastersResponse(i,{returnDomainValues:r,templateRRFunctionNames:u,showNoDataRecords:n,templateFields:s});const l=this.objectIdField||"ObjectId",p=i.catalogItems?.features??[],c=p.map((e=>e.attributes?.[l])),d=new xe({objectIds:c,returnGeometry:!0,outSpatialReference:e.outSpatialReference,outFields:[l]}),h=await this.queryRasters(d);return h?.features?.length&&h.features.forEach((t=>{p.forEach((i=>{i.attributes[l]===t.attributes[l]&&t.geometry&&(i.geometry=t.geometry.clone(),null!=e.outSpatialReference&&(i.geometry.spatialReference=e.outSpatialReference))}))})),this._processVisibleRastersResponse(i,{returnDomainValues:r,templateRRFunctionNames:u,showNoDataRecords:n,templateFields:s})}catch{throw new a("imagery-layer:query-visible-rasters","encountered error when querying visible rasters")}}async fetchVariableStatisticsHistograms(e,t){const i=n(Me(this.parsedUrl)+"/statistics",{query:this._getQueryParams({variable:e}),signal:t}).then((e=>e.data?.statistics)),r=n(Me(this.parsedUrl)+"/histograms",{query:this._getQueryParams({variable:e}),signal:t}).then((e=>e.data?.histograms)),s=await Promise.all([i,r]);return s[0]&&s[0].forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),{statistics:s[0]||null,histograms:s[1]||null}}async createFlowMesh(e,t){const i=this._rasterJobHandler.instance;return i?i.createFlowMesh(e,t):_e(e.meshType,e.simulationSettings,e.flowData,null!=t.signal?t.signal:(new AbortController).signal)}getMultidimensionalSubsetVariables(e){const t=e??this.serviceRasterInfo.multidimensionalInfo;return E(this.multidimensionalSubset,t)}async _fetchService(e){await this._fetchServiceInfo(e),this.rasterInfo||(this.rasterInfo=this.serviceRasterInfo);const t=this.sourceJSON,i=null!=this.serviceRasterInfo?Promise.resolve(this.serviceRasterInfo):fe(Me(this.parsedUrl),t,{signal:e,query:this._getQueryParams()}).then((e=>(this._set("serviceRasterInfo",e),this._set("multidimensionalInfo",e.multidimensionalInfo),ge(e,t),e))),r=this._hasRasterFunction(this.rasterFunction)?this._generateRasterInfo(this.rasterFunction,{signal:e}):null,s=this._getRasterFunctionInfos();return Promise.all([i,r,s]).then((e=>{e[1]?this._set("rasterInfo",e[1]):this._set("rasterInfo",e[0]),e[2]&&this._set("rasterFunctionInfos",e[2]),this.internalRenderer&&!this._isSupportedRenderer(this.internalRenderer)&&(this._set("internalRenderer",null),l.getLogger(this).warn("ArcGISImageService","Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")),this._set("internalRenderer",this._configRenderer(this.renderer)),this.addHandles([u((()=>this.rasterFunction),(e=>{(this.renderer||this.symbolizer||this.popupEnabled&&this.popupTemplate)&&this._generateRasterInfo(e).then((e=>{e&&(this.rasterInfo=e)}))}))]);const{serviceRasterInfo:t}=this;null!=t.multidimensionalInfo&&this._updateMultidimensionalDefinition(t)}))}_combineMosaicRuleWithTimeExtent(e,t){const i=this.timeInfo,{multidimensionalInfo:r}=this.serviceRasterInfo;if(null==e||null==r||null==t||null==i?.startField)return e;const{startField:s}=i,n=r.variables.some((e=>e.dimensions.some((e=>e.name===s))))?s:"StdTime";if(e=e.clone(),"mosaic-dataset"===this.sourceType)return e.multidimensionalDefinition=e.multidimensionalDefinition?.filter((e=>e.dimensionName!==n)),this._cleanupMultidimensionalDefinition(e);e.multidimensionalDefinition=e.multidimensionalDefinition||[];const a=e.multidimensionalDefinition.filter((e=>e.dimensionName===n)),o=null!=t.start?t.start.getTime():null,l=null!=t.end?t.end.getTime():null,u=null==o||null==l||o===l,p=u?[o||l]:[[o,l]],c=this.version>=10.8;if(a.length)a.forEach((e=>{e.dimensionName===n&&(c?(e.dimensionName=null,e.isSlice=!1,e.values=[]):(e.isSlice=u,e.values=p))}));else if(!c){const t=e.multidimensionalDefinition.filter((e=>null!=e.variableName&&null==e.dimensionName));t.length?t.forEach((e=>{e.dimensionName=n,e.isSlice=u,e.values=p})):e.multidimensionalDefinition.push(new I({variableName:"",dimensionName:n,isSlice:u,values:p}))}return this._cleanupMultidimensionalDefinition(e)}_cleanupMultidimensionalDefinition(e){return null==e?null:(e.multidimensionalDefinition&&(e.multidimensionalDefinition=e.multidimensionalDefinition.filter((e=>!(!e.variableName&&!e.dimensionName))),0===e.multidimensionalDefinition.length&&(e.multidimensionalDefinition=null)),"mosaic-dataset"!==this.sourceType&&null==e.multidimensionalDefinition?null:e)}async _prepareForQuery(e,t){if(!(await this._fetchCapabilities(t?.signal)).operations.supportsQuery)throw new a("imagery-layer:query-rasters","query operation is not supported on the input image service");return e=null!=e?d(xe,e):this.createQuery(),t=this._getRequestOptions(t),this.raster&&(t.query={...t.query,raster:this.raster}),{query:e,requestOptions:t}}async _initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new A;this._rasterJobHandler.connectionPromise=e.initialize().then((()=>{this._rasterJobHandler.instance=e}),(()=>{})),await this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null}_isSupportedRenderer(e){const{rasterInfo:t,rasterFunction:i}=this;return"unique-value"===e.type&&this._hasRasterFunction(i)&&1===t?.bandCount&&["u8","s8"].includes(t.pixelType)||null!=t&&null!=e&&B(t).includes(e.type)}async _fetchCapabilities(e){return this.capabilities||await this._fetchServiceInfo(e),this.capabilities}async _fetchServiceInfo(e){let t=this.sourceJSON;if(!t){const{data:i,ssl:r}=await n(Me(this.parsedUrl),{query:this._getQueryParams(),signal:e});t=i,this.sourceJSON=t,r&&(this.url=this.url.replace(/^http:/i,"https:"))}if(t.capabilities?.toLowerCase().split(",").map((e=>e.trim())).indexOf("tilesonly")>-1)throw new a("imagery-layer:fetch-service-info","use ImageryTileLayer to open tiles-only image services");this.read(t,{origin:"service",url:this.parsedUrl})}_isMosaicDataset(e){return e.serviceSourceType?"esriImageServiceSourceTypeMosaicDataset"===e.serviceSourceType:e.fields?.length>0}_isMosaicRuleSupported(e){if(!e)return!1;const t=this._isMosaicDataset(e),i=e.currentVersion>=10.71&&e.hasMultidimensions&&!(e.fields?.length>1);return t||i}_isVectorFieldResampleFunction(e){if(null==e)return!1;const{functionName:t,functionArguments:i}=e,r="resample"===t?.toLowerCase(),s=i?.ResampleType||i?.resampleType;return r&&(7===s||10===s)}_isPicture(){return!this.format||this.format.includes("jpg")||this.format.includes("png")}_configRenderer(e){const t=this._isPicture(),{rasterInfo:i}=this;if(!t&&!this.pixelFilter||this._isVectorDataSet()){const t=this.mosaicRule?.multidimensionalDefinition?.[0].variableName,r=L({variableName:t,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&i.bandCount>=3){const e=r?.bandIds??z(i);!e||3===i.bandCount&&0===e[0]&&1===e[1]&&2===e[2]||(this.bandIds=e)}e||(e=r?.renderer??G(i,{bandIds:this.bandIds,variableName:this.rasterFunction?null:t}));const s=k(e.toJSON());this.symbolizer?(this.symbolizer.rendererJSON=s,this.symbolizer.rasterInfo=i):this.symbolizer=new W({rendererJSON:s,rasterInfo:i}),this.symbolizer.bind().success||(this.symbolizer=null)}return e}_clonePixelData(e){return null==e?e:{extent:e.extent&&e.extent.clone(),pixelBlock:null!=e.pixelBlock?e.pixelBlock.clone():null}}_getQueryParams(e){null!=e?.renderingRule&&"string"!=typeof e.renderingRule&&(e.renderingRule=this._getRenderingRuleString(e.renderingRule));const{raster:t,viewId:i}=this;return{raster:t,viewId:i,f:"json",...e,...this.customParameters}}_getRequestOptions(e){return{...e,query:{...e?.query,...this.customParameters}}}_decodePixelBlock(e,t,i){return this._rasterJobHandler.instance?this._rasterJobHandler.instance.decode({data:e,options:t}):Q(e,t,i)}async _getRasterFunctionInfos(e){const t=this.sourceJSON.rasterFunctionInfos;if(this.loaded)return t;if(t&&this.version>=10.3){if(1===t.length&&"none"===t[0].name.toLowerCase())return t;const i=await n(Me(this.parsedUrl)+"/rasterFunctionInfos",{query:this._getQueryParams(),signal:e});return i.data?.rasterFunctionInfos}return null}_canRequestImageElement(e){return!this.pixelFilter&&(!e||e.includes("png"))}async _requestArrayBuffer(e){const{imageProps:t,requestAsImageElement:i,returnImageBitmap:r,signal:s}=e;if(i&&this._canRequestImageElement(t.format)){const i=`${Me(this.parsedUrl)}/exportImage`,{data:a}=await n(i,{responseType:r?"blob":"image",query:this._getQueryParams({f:"image",...this.refreshParameters,...e.imageServiceParameters}),signal:s});if(a instanceof Blob){return{imageBitmap:await F(a,i,s),params:t}}return{imageOrCanvasElement:a,params:t}}const o=this._initJobHandler(),l=n(Me(this.parsedUrl)+"/exportImage",{responseType:"array-buffer",query:this._getQueryParams({f:"image",...e.imageServiceParameters}),signal:s}),u=(await Promise.all([l,o]))[0].data,p=t.format||"jpgpng";let c=p;if("bsq"!==c&&"bip"!==c&&(c=H(u)),!c)throw new a("imagery-layer:fetch-image","unsupported format signature "+String.fromCharCode.apply(null,new Uint8Array(u)));const m={signal:s},d="gif"===p||"bmp"===p||p.includes("png")&&("png"===c||"jpg"===c)?Q(u,{useCanvas:!0,...t},m):this._decodePixelBlock(u,{width:t.width,height:t.height,planes:null,pixelType:null,noDataValue:null,format:p},m);return{pixelData:{pixelBlock:await d,extent:t.extent},params:t}}_generateRasterInfo(e,t){return this.generateRasterInfo(e,t).catch((()=>null))}_isValidCustomizedMosaicRule(e){return e&&JSON.stringify(e.toJSON())!==JSON.stringify(this.defaultMosaicRule?.toJSON())}_updateMultidimensionalDefinition(e){if(this._isValidCustomizedMosaicRule(this.mosaicRule))return;let t=V(e,{multidimensionalSubset:this.multidimensionalSubset});if(null!=t&&t.length>0){this.mosaicRule=this.mosaicRule||new T;const e=this.mosaicRule.multidimensionalDefinition;!this.sourceJSON.defaultVariableName&&this.rasterFunction&&"none"!==this.rasterFunction.functionName?.toLowerCase()&&t.forEach((e=>e.variableName="")),t=t.filter((({variableName:e,dimensionName:t})=>e&&"*"!==e||t)),!e?.length&&t.length&&(this.mosaicRule.multidimensionalDefinition=t)}}_processVisibleRastersResponse(e,i){i=i||{};const r=e.value,{templateRRFunctionNames:s,showNoDataRecords:n,returnDomainValues:a,templateFields:o}=i,l=e.processedValues;let u=e.catalogItems?.features,p=e.properties?.Values?.map((e=>e.replaceAll(/ /gi,", ")))||[];const c=this.objectIdField||"ObjectId",m="string"==typeof r&&r.toLowerCase().includes("nodata"),d=[];if(r&&!u&&!m){const e={};e[c]=0;p=[r],u=[new t({geometry:this.fullExtent,attributes:e})]}if(!u)return[];let h,f,y;this._updateResponseFieldNames(u,o),m&&!n&&(u=[]);for(let t=0;t<u.length;t++){if(h=u[t],null!=r){if(f=p[t],y=this.rasterFunction&&l&&l.length>0&&s&&s.length>0&&s.includes(this.rasterFunction.functionName)?l[s.indexOf(this.rasterFunction.functionName)]:r,"nodata"===f.toLowerCase()&&!n)continue;const e="Raster.ItemPixelValue",i="Raster.ServicePixelValue";h.attributes[e]=f,h.attributes[i]=y,this._updateFeatureWithMagDirValues(h,f);const a=this.fields&&this.fields.length>0;let o=this.rasterFunction&&null!=this.serviceRasterInfo.attributeTable?a?f:r:y;this.rasterFunction||(o=a?f:r),this._updateFeatureWithRasterAttributeTableValues(h,o)}if(h.sourceLayer=h.layer=this,a&&this._updateFeatureWithDomainValues(h),s&&l&&s.length===l.length)for(let e=0;e<s.length;e++){const t="Raster.ServicePixelValue."+s[e];h.attributes[t]=l[e]}d.push(u[t])}return d}_processMultidimensionalIntersection(e,t,i){const{multidimensionalSubset:r}=this;if(!r)return{isOutSide:!1,timeExtent:t,mosaicRule:i=this._combineMosaicRuleWithTimeExtent(i,t)};if(r){const{isOutside:i,intersection:s}=J(r,{geometry:e,timeExtent:t});if(i)return{isOutSide:!0,timeExtent:null,mosaicRule:null};null!=s?.timeExtent&&(t=s.timeExtent)}if(i=this._combineMosaicRuleWithTimeExtent(i,t),i?.multidimensionalDefinition){const{isOutside:e}=J(r,{multidimensionalDefinition:i.multidimensionalDefinition});if(e)return{isOutSide:!0,timeExtent:null,mosaicRule:null}}return{isOutSide:!1,timeExtent:t,mosaicRule:i}}_updateFeatureWithRasterAttributeTableValues(e,t){const i=this.rasterInfo.attributeTable||this.serviceRasterInfo.attributeTable;if(null==i)return;const{features:r,fields:s}=i,n=s.map((e=>e.name)).find((e=>"value"===e.toLowerCase()));if(!n)return;const a=r.filter((e=>e.attributes[n]===(null!=t?parseInt(t,10):null)));a&&a[0]&&s.forEach((t=>{const i=this._rasterAttributeTableFieldPrefix+t.name;e.attributes[i]=a[0].attributes[t.name]}))}_updateFeatureWithMagDirValues(e,t){if(!this._isVectorDataSet())return;const i=t.split(/,\s*/).map((e=>parseFloat(e))),r=i.map((e=>[e])),s=i.map((e=>({minValue:e,maxValue:e,noDataValue:null}))),n=new P({height:1,width:1,pixelType:"f32",pixels:r,statistics:s});null!=this.pixelFilter&&this.pixelFilter({pixelBlock:n,extent:new Fe(0,0,0,0,this.spatialReference)});const a="esriImageServiceDataTypeVector-MagDir"===this.serviceDataType?[n.pixels[0][0],n.pixels[1][0]]:U([n.pixels[0][0],n.pixels[1][0]]);e.attributes["Raster.Magnitude"]=a[0],e.attributes["Raster.Direction"]=a[1]}_updateFeatureWithDomainValues(e){const t=this.fields&&this.fields.filter((e=>e.domain&&"coded-value"===e.domain.type));null!=t&&t.forEach((t=>{const i=e.attributes[t.name];if(null!=i){const r=t.domain.codedValues.find((e=>e.code===i));r&&(e.attributes[t.name]=r.name)}}))}_updateResponseFieldNames(e,t){if(!t||t.length<1)return;const i=this.fieldsIndex;null!=i&&e.forEach((e=>{if(e?.attributes)for(const r of t){const t=i.get(r)?.name;t&&t!==r&&(e.attributes[r]=e.attributes[t],delete e.attributes[t])}}))}_getRenderingRuleString(e){if(e){let t=e.toJSON();return t=t.rasterFunctionDefinition??t,(t.thumbnail||t.thumbnailEx)&&(t.thumbnail=t.thumbnailEx=null),JSON.stringify(t)}return null}_hasRasterFunction(e){return null!=e?.functionName&&"none"!==e.functionName.toLowerCase()}_updateRenderingRulesFunctionName(e,t){if(!e||e.length<1)return;if("Raw"===e)return e.replace("Raw","None");const i=e.toLowerCase().replaceAll(/ /gi,"_");return t.has(i)?t.get(i):e}_isRFTJson(e){return e?.name&&e.arguments&&e.function&&e.hasOwnProperty("functionType")}_isVectorDataSet(){return"esriImageServiceDataTypeVector-UV"===this.serviceDataType||"esriImageServiceDataTypeVector-MagDir"===this.serviceDataType}_applyMosaicAndRenderingRules(e){const{raster:t,mosaicRule:i,rasterFunction:r}=this;r&&"rasterFunction"in e&&null==e.rasterFunction&&(e.rasterFunction=r),i&&null==e.mosaicRule&&(e.mosaicRule=i),t&&null==e.raster&&(e.raster=t)}_readCapabilities(e){const t=e.capabilities?e.capabilities.toLowerCase().split(",").map((e=>e.trim())):["image","catalog"],{currentVersion:i,advancedQueryCapabilities:r,maxRecordCount:s}=e,n=t.includes("image"),a="esriImageServiceDataTypeElevation"===e.serviceDataType,o=!(!e.spatialReference&&!e.extent?.spatialReference),l=t.includes("edit"),u=t.includes("mensuration")&&o,p=null==e.mensurationCapabilities?[]:e.mensurationCapabilities.toLowerCase().split(",").map((e=>e.trim())),c=u&&p.includes("basic"),m=this._isMosaicDataset(e)&&t.includes("catalog"),d=t.includes("download");return{data:{supportsAttachment:!1},operations:{supportsComputeHistograms:n,supportsExportImage:n,supportsIdentify:n,supportsImageToMap:i>=11.2&&m,supportsImageToMapMultiray:i>=11.2&&m,supportsMapToImage:i>=11.2&&m,supportsFindImages:i>=11.2&&m,supportsGetImageUrl:i>=11.3&&d,supportsMeasure:u,supportsMeasureFromImage:i>=11.2,supportsDownload:d,supportsQuery:m&&e.fields&&e.fields.length>0,supportsGetSamples:i>=10.2&&n,supportsProject:i>=10.3&&n,supportsComputeStatisticsHistograms:i>=10.4&&n,supportsQueryBoundary:i>=10.6&&n,supportsCalculateVolume:i>=10.7&&a,supportsComputePixelLocation:i>=10.7&&m,supportsComputeAngles:i>=10.91,supportsQueryGPSInfo:i>=11.2&&m,supportsAdd:l,supportsDelete:l,supportsEditing:l,supportsUpdate:l,supportsCalculate:!1,supportsTruncate:!1,supportsValidateSql:!1,supportsChangeTracking:!1,supportsQueryAttachments:!1,supportsResizeAttachments:!1,supportsSync:!1,supportsExceedsLimitStatistics:!1,supportsQueryAnalytics:!1,supportsQueryBins:!1,supportsQueryTopFeatures:!1,supportsAsyncConvert3D:!1},query:{maxRecordCount:s,maxRecordCountFactor:void 0,supportsStatistics:!!r?.supportsStatistics,supportsOrderBy:!!r?.supportsOrderBy,supportsDistinct:!!r?.supportsDistinct,supportsPagination:!!r?.supportsPagination,supportsStandardizedQueriesOnly:!!r?.useStandardizedQueries,supportsPercentileStatistics:!!r?.supportsPercentileStatistics,supportsCentroid:!!r?.supportsReturningGeometryCentroid,supportsDistance:!!r?.supportsQueryWithDistance,supportsExtent:!!r?.supportsReturningQueryExtent,supportsGeometryProperties:!!r?.supportsReturningGeometryProperties,supportsHavingClause:!!r?.supportsHavingClause,supportsQuantization:!1,supportsQuantizationEditMode:!1,supportsQueryGeometry:!1,supportsResultType:!1,supportsMaxRecordCountFactor:!1,supportsSqlExpression:!1,supportsTopFeaturesQuery:!1,supportsQueryByAnonymous:!1,supportsQueryByOthers:!1,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!1,supportsCacheHint:!1,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsDefaultSpatialReference:!!r?.supportsDefaultSR,supportsFullTextSearch:!1,supportsCompactGeometry:!1,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0},mensuration:{supportsDistanceAndAngle:c,supportsAreaAndPerimeter:c,supportsPointOrCentroid:c,supportsHeightFromBaseAndTop:u&&p.includes("base-top height"),supportsHeightFromBaseAndTopShadow:u&&p.includes("base-top shadow height"),supportsHeightFromTopAndTopShadow:u&&p.includes("top-top shadow height"),supports3D:u&&p.includes("3d")}}}};function Me(e){return e?.path??""}return e([c({clonable:!1})],f.prototype,"_functionRasterInfos",void 0),e([c({clonable:!1})],f.prototype,"_rasterJobHandler",void 0),e([c({clonable:!1})],f.prototype,"_cachedRendererJson",void 0),e([c({readOnly:!0})],f.prototype,"_serviceSupportsMosaicRule",void 0),e([y("_serviceSupportsMosaicRule",["currentVersion","fields"])],f.prototype,"readServiceSupportsMosaicRule",null),e([c({readOnly:!0})],f.prototype,"_rasterAttributeTableFieldPrefix",void 0),e([c({readOnly:!0})],f.prototype,"_rasterFunctionNamesIndex",null),e([c()],f.prototype,"adjustAspectRatio",void 0),e([c({type:[m],json:{write:!0}})],f.prototype,"bandIds",void 0),e([y("bandIds")],f.prototype,"readBandIds",null),e([c({readOnly:!0,json:{read:!1}})],f.prototype,"capabilities",void 0),e([y("service","capabilities",["capabilities","currentVersion","serviceDataType"])],f.prototype,"readCapabilities",null),e([c({type:Number})],f.prototype,"compressionQuality",void 0),e([R("compressionQuality")],f.prototype,"writeCompressionQuality",null),e([c({type:Number})],f.prototype,"compressionTolerance",void 0),e([R("compressionTolerance")],f.prototype,"writeCompressionTolerance",null),e([c({json:{read:{source:"copyrightText"}}})],f.prototype,"copyright",void 0),e([c({readOnly:!0,dependsOn:["_serviceSupportsMosaicRule"]})],f.prototype,"defaultMosaicRule",void 0),e([y("defaultMosaicRule",["defaultMosaicMethod"])],f.prototype,"readDefaultMosaicRule",null),e([c({type:String,json:{name:"layerDefinition.definitionExpression",write:{enabled:!0,allowNull:!0}}})],f.prototype,"definitionExpression",void 0),e([c({readOnly:!0,constructOnly:!0})],f.prototype,"exportImageServiceParameters",void 0),e([c()],f.prototype,"rasterInfo",void 0),e([c({readOnly:!0,type:[x]})],f.prototype,"fields",void 0),e([c({readOnly:!0})],f.prototype,"fieldsIndex",null),e([c({type:["png","png8","png24","png32","jpg","bmp","gif","jpgpng","lerc","tiff","bip","bsq"],json:{write:!0}})],f.prototype,"format",null),e([y("service","format",["serviceDataType"])],f.prototype,"readFormat",null),e([c({type:Fe})],f.prototype,"fullExtent",void 0),e([c({readOnly:!0})],f.prototype,"hasMultidimensions",void 0),e([c({json:{read:{source:"maxImageHeight"}}})],f.prototype,"imageMaxHeight",void 0),e([c({json:{read:{source:"maxImageWidth"}}})],f.prototype,"imageMaxWidth",void 0),e([c({type:String,json:{type:C.jsonValues,read:C.read,write:C.write}})],f.prototype,"interpolation",void 0),e([c()],f.prototype,"minScale",void 0),e([y("service","minScale")],f.prototype,"readMinScale",null),e([c()],f.prototype,"maxScale",void 0),e([y("service","maxScale")],f.prototype,"readMaxScale",null),e([c({type:T})],f.prototype,"mosaicRule",null),e([y("mosaicRule",["mosaicRule","defaultMosaicMethod"])],f.prototype,"readMosaicRule",null),e([R("mosaicRule")],f.prototype,"writeMosaicRule",null),e([c()],f.prototype,"multidimensionalInfo",void 0),e([c({type:O,json:{write:!0}})],f.prototype,"multidimensionalSubset",void 0),e([c({json:{type:m}})],f.prototype,"noData",void 0),e([R("noData")],f.prototype,"writeNoData",null),e([c({type:String,json:{type:M.jsonValues,read:M.read,write:M.write}})],f.prototype,"noDataInterpretation",void 0),e([c({type:String,readOnly:!0,json:{read:{source:["fields"]}}})],f.prototype,"objectIdField",void 0),e([y("objectIdField")],f.prototype,"readObjectIdField",null),e([c({readOnly:!0})],f.prototype,"geometryType",void 0),e([c({})],f.prototype,"typeIdField",void 0),e([c({})],f.prototype,"types",void 0),e([c({readOnly:!0})],f.prototype,"parsedUrl",null),e([c({type:Function})],f.prototype,"pixelFilter",void 0),e([c()],f.prototype,"raster",void 0),e([c({readOnly:!0})],f.prototype,"sourceType",void 0),e([y("sourceType",["serviceSourceType","fields"])],f.prototype,"readSourceType",null),e([c()],f.prototype,"viewId",void 0),e([c()],f.prototype,"renderer",null),e([c({types:i,json:{name:"layerDefinition.drawingInfo.renderer",origins:{"web-scene":{types:r,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],f.prototype,"internalRenderer",null),e([y("internalRenderer")],f.prototype,"readRenderer",null),e([R("internalRenderer")],f.prototype,"writeRenderer",null),e([c({clonable:!1})],f.prototype,"symbolizer",void 0),e([c(w)],f.prototype,"opacity",void 0),e([c({readOnly:!0})],f.prototype,"rasterFields",null),e([c({constructOnly:!0})],f.prototype,"rasterFunctionInfos",void 0),e([c({type:j,json:{name:"renderingRule"}})],f.prototype,"rasterFunction",null),e([y("rasterFunction",["renderingRule","rasterFunctionInfos"])],f.prototype,"readRasterFunction",null),e([c({readOnly:!0})],f.prototype,"serviceDataType",void 0),e([c({readOnly:!0,type:De})],f.prototype,"spatialReference",void 0),e([y("spatialReference",["spatialReference","extent"])],f.prototype,"readSpatialReference",null),e([c({json:{type:N.jsonValues}})],f.prototype,"pixelType",void 0),e([y("pixelType")],f.prototype,"readPixelType",null),e([R("pixelType")],f.prototype,"writePixelType",null),e([c({constructOnly:!0,type:q})],f.prototype,"serviceRasterInfo",void 0),e([c()],f.prototype,"sourceJSON",void 0),e([c(v)],f.prototype,"url",void 0),e([c({readOnly:!0})],f.prototype,"version",void 0),e([y("version",["currentVersion","fields","timeInfo"])],f.prototype,"readVersion",null),f=e([g("esri.layers.mixins.ArcGISImageService")],f),f};export{Me as ArcGISImageService};
