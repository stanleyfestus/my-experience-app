/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{b as t}from"../../../chunks/languageUtils.js";import n from"../../../core/Error.js";import{isSerializable as a}from"../../../core/JSONSupport.js";import{deg2rad as i,rad2deg as e}from"../../../core/mathUtils.js";import{throwIfAborted as o}from"../../../core/promiseUtils.js";import{create as r}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{create as c,fromValues as s}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{fromArray as l}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{zeros as f}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{multiply as u,transpose as h}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{invertOrIdentity as m,mul as p}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{a as M,g}from"../../../chunks/vec32.js";import{projectWithZConversion as v}from"../../../geometry/projection.js";import{earth as x}from"../../../geometry/support/Ellipsoid.js";import{isWebMercator as d}from"../../../geometry/support/spatialReferenceUtils.js";import{a as y}from"../../../chunks/vec3.js";import{isElevationSource as w,isConstantElevation as O,ConstantElevation as b}from"../core/ElevationSourceDefinitions.js";import{getElevationSampler as j}from"./updateElevationUtils.js";import{defaultImageSphereSize as z}from"../../../widgets/PanoramicViewer/constants.js";import S from"../../../geometry/SpatialReference.js";import E from"../../../geometry/Point.js";function F(t,n,a){const[i,e,o,r]=n,[s,l,f,u]=a;P(i,e,o,r);const h=P(s,l,f,u),M=R(i,e,o,r),g=R(s,l,f,u),v=m(c(),M),x=p(c(),v,g),[d,y,w,O]=C(t,x);return[d/O,y/O,h?0:w/O]}function P(t,n,a,i){return 0===t[2]&&0===n[2]&&0===a[2]&&0===i[2]&&(t[2]=n[2]=a[2]=i[2]=1,!0)}function V(t){return 0===t?1:t}function C(t,n){const[a,i,e]=t,o=[0,0,0,0];return o[0]=a*n[0]+i*n[1]+e*n[2]+n[3],o[1]=a*n[4]+i*n[5]+e*n[6]+n[7],o[2]=a*n[8]+i*n[9]+e*n[10]+n[11],o[3]=V(a*n[12]+i*n[13]+e*n[14]+n[15]),o}function R(t,n,a,i){const e=N(l([...i,1]),m(new Array(16),s(t[0],n[0],a[0],0,t[1],n[1],a[1],0,t[2],n[2],a[2],0,1,1,1,1))),o=e[0],r=e[1],f=e[2],u=c();return u[0]=o*t[0],u[1]=r*n[0],u[2]=f*a[0],u[3]=0,u[4]=o*t[1],u[5]=r*n[1],u[6]=f*a[1],u[7]=0,u[8]=o*t[2],u[9]=r*n[2],u[10]=f*a[2],u[11]=0,u[12]=o,u[13]=r,u[14]=f,u[15]=1,u}function L(t,n,a,i,e=f()){return e[0]=t[0]+n[0]*a,e[1]=t[1]+n[1]*a,e[2]=t[2]+n[2]*(a/i),e}function D(t,n,a){const i=f();return i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*(n/a),i}function I(t,n){const[a,i,e]=t,o=f();return o[0]=a*n[0]+i*n[3]+e*n[6],o[1]=a*n[1]+i*n[4]+e*n[7],o[2]=a*n[2]+i*n[5]+e*n[8],o}function N(t,n){const[a,i,e,o]=t,r=new Array(4);return r[0]=a*n[0]+i*n[1]+e*n[2]+o*n[3],r[1]=a*n[4]+i*n[5]+e*n[6]+o*n[7],r[2]=a*n[8]+i*n[9]+e*n[10]+o*n[11],r[3]=a*n[12]+i*n[13]+e*n[14]+o*n[15],r}function H(t,a,e,o=!0){if(!Number.isFinite(t))throw new n("InvalidRotationAngle","Please specify a valid angle for rotation");const c=e*(o?i(t):t),s=Math.cos(c),l=Math.sin(c),f=r();switch(a){case 0:f[4]=s,f[5]=-l,f[7]=l,f[8]=s;break;case 1:f[0]=s,f[2]=l,f[6]=-l,f[8]=s;break;case 2:f[0]=s,f[1]=-l,f[3]=l,f[4]=s;break;default:throw new n("InvalidRotationAxis","Please specify either 0, 1 or 2 for X, Y or Z axis respectively")}return f}const k={HPR:[[2,-1],[0,1],[2,-1]],OPK:[[0,1],[1,1],[2,1]]};function q(t,a,i=!0){if(3!==t?.length||3!==a?.length)throw new n("InvalidRotationAngles","Please specify three angles with config for rotation");const e=r();for(let n=0;n<3;n++){const[o,r]=a[n],c=H(t[n],o,r,i);u(e,c,e)}return e}function A(t,n=!0){return q(t,k.OPK,n)}function U(t,n=!0){return q(t,k.HPR,n)}function W(t,n,a){const e=Math.sin(i(a)),o=Math.cos(i(a)),r=[[t,0],[t,n],[0,n]];r.forEach(((t,n)=>{r[n]=[o*t[0]-e*t[1],e*t[0]+o*t[1]]}));const c={xmin:Math.min(0,r[0][0],r[1][0],r[2][0]),xmax:Math.max(0,r[0][0],r[1][0],r[2][0]),ymin:Math.min(0,r[0][1],r[1][1],r[2][1]),ymax:Math.max(0,r[0][1],r[1][1],r[2][1])};return{hfov:Math.abs(c.xmax-c.xmin),vfov:Math.abs(c.ymax-c.ymin)}}function K(t,n,a,i,e,o){const r=a*(n.x-t.x)+i*(n.y-t.y)+e*(n.z-t.z);if(0===r)return null;const c=-(a*t.x+i*t.y+e*t.z+o)/r;return{x:t.x+c*(n.x-t.x),y:t.y+c*(n.y-t.y),z:t.z+c*(n.z-t.z)}}function T(t,n){const a=i(t[1]),e=i(t[0]),o=t[2],[r,c,s,l]=n,f=i(r),u=i(c),h=s/Math.sqrt(1-l*Math.sin(f)**2),m=e-u,p=s/Math.sqrt(1-l*Math.sin(f)**2),M=l*(h*Math.sin(f)-p*Math.sin(a));return[(p+o)*Math.cos(a)*Math.sin(m),(p+o)*(Math.sin(a)*Math.cos(f)-Math.sin(f)*Math.cos(f)*Math.cos(m))+M*Math.cos(f),(p+o)*(Math.sin(a)*Math.sin(f)+Math.cos(f)*Math.cos(a)*Math.cos(m))-h+M*Math.sin(f)]}function J(t,n){const a=Number(t[0]),o=Number(t[1]),r=Number(t[2]),[c,s,l,f]=n,u=i(c),h=i(s),m=l/Math.sqrt(1-f*Math.sin(u)**2),p=a/m,M=o/m,g=r/m,v=Math.cos(u)-Math.sin(u)*M+Math.cos(u)*g,x=Math.sin(u)+Math.cos(u)*M+Math.sin(u)*g,d=Math.sqrt(v**2+p**2),y=f*m*Math.sin(u),w=(t,n=5)=>{if(0===n)return t;const a=w(t,n-1);return Math.atan(x/d-(y-f*(l/Math.sqrt(1-f*Math.sin(a)**2))*Math.sin(a))/(m*d))},O=w(u),b=Math.atan(a/(m*v))+h,j=e(O);return[e(b),j,a/(Math.cos(O)*Math.sin(b-h))-l/Math.sqrt(1-f*Math.sin(O)**2)]}function X(t,n,a){const i=360/n,e=180/a;return{heading:(t.x-n/2)*i,pitch:90-(t.y-a/2)*e}}function Y(t,n,a,i=z/2){const{heading:e,pitch:o}=G(t,i);return Z(e,o,n,a)}function Z(t,n,a,i){return{x:a/2+t/(360/a),y:i-n/(180/i),heading:t,pitch:n}}function G(t,n){const a=e(Math.acos(-t.z/n));return{heading:e(Math.atan2(t.x,t.y)),pitch:a}}function $(t,n,a=z/2){return[a*(Math.sin(i(t))*Math.sin(i(n))),a*(Math.cos(i(t))*Math.sin(i(n))),a*Math.cos(i(180-n))]}async function B(t,n,a){const i=await v(n,t.spatialReference,a);let o=e(Math.atan2(i.y-t.y,i.x-t.x));return o=o>=0&&o<=90?90-o:o>90&&o<=180?360-o+90:90+Math.abs(o),o}function Q(t,n,a){const i=Math.cos(a),e=Math.sin(a),o=[1,0,0,1,0,0],r=o[0]*i+o[2]*e,c=o[1]*i+o[3]*e,s=-o[0]*e+o[2]*i,l=-o[1]*e+o[3]*i;o[0]=r,o[1]=c,o[2]=s,o[3]=l;return[t*o[0]+n*o[2]+o[4],t*o[1]+n*o[3]+o[5]]}function _(t){return 4===t?.type}async function tt(t,n,a){const i=await v(t,S.WGS84,a);return o(a),T(i.toArray(),n)}const nt=t=>t.toArray(),at=(...t)=>t.some((t=>t));function it(t,n){if(at(0===t.length,t.some((({x:t,y:n})=>at(null==t,null==n))),!n.hasZ))throw new Error("Input pixels must have x, y and camera location must have z value")}function et(t,n){if(t.some((t=>null==t.z))||null==n.z)throw new Error("Input points and camera location must have z value")}function ot(t){if(9!==t?.length)throw new Error("Rotation matrix is not provided or is not a valid 3x3 matrix")}function rt(t,n){return d(n)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*t/x.radius))):1}const ct=t=>n=>new E(n,t),st=t=>null!=t&&"queryExtent"in t;function lt(t,n,a,i){return[[-n,-n],[+n,-n],[+n,+n],[-n,+n]].map((([n,e])=>F(y(f(),a,[n,e,0]),i,t)))}function ft({a0:t,a1:n,a2:a,b0:i,b1:e,b2:o},r,c,s){const l=[t??r/2-.5,n,a??0,i??c/2-.5,e??0,o].map(ut);return null!=s&&ht(l)?{affines:l,focalLength:s}:{affines:[r/2-.5,1,0,c/2-.5,0,-1]}}function ut(t,n){if(null==t)return null;const a=parseFloat(`${t}`);return isNaN(a)?null:a}function ht(t){return null!=t[1]&&null!=t[5]}function mt(t,n,a){const{cameraHeight:i,cameraPitch:e,cameraRoll:o,elevation:r,farDistance:c,horizontalFieldOfView:s,location:l,verticalFieldOfView:f}=t,u=r??(l.z??0)-i;return{...gt(t,n,a),averageElevation:u,cameraPitch:e,cameraRoll:o??0,farDistance:c,horizontalFieldOfView:s,verticalFieldOfView:f}}function pt(t,n,a,i){return jt(i)?A([i.omega,i.phi,i.kappa]):zt(i)?U([i.heading,i.pitch,i.roll]):U([t,n,a??0])}function Mt(t,n,a){const{cameraHeading:i,cameraHeight:e,elevation:o,farDistance:r,horizontalFieldOfView:c,location:s,verticalFieldOfView:l}=t;return{averageElevation:o??(s.z??0)-e,cameraLocation:s,cameraHeading:i,farDistance:r,horizontalFieldOfView:c,imageHeight:a,imageWidth:n,verticalFieldOfView:l}}function gt(t,n,a){const{a0:i,a1:e,a2:o,b0:r,b1:c,b2:s,cameraHeading:l,cameraOrientation:f,cameraPitch:u,cameraRoll:h,focalLength:m,horizontalFieldOfView:p,location:M,matrix:g,principalX:v,principalY:x,radial:d,tangential:y,verticalFieldOfView:w}=t,{affines:O,focalLength:b}=ft({a0:i,a1:e,a2:o,b0:r,b1:c,b2:s},n,a,m),j=g??pt(l,u,h,f),z=null!=v&&null!=x?[v,x]:void 0;return{affineTransformations:f?.affineTransformations??O,cameraLocation:M.clone(),focalLength:f?.focalLength??b,horizontalFieldOfView:p,imageHeight:a,imageWidth:n,principalOffsetPoint:f?.principalOffsetPoint??z,radialDistortionCoefficients:f?.radialDistortionCoefficients??d,rotationMatrix:j,tangentialDistortionCoefficients:f?.tangentialDistortionCoefficients??y,verticalFieldOfView:w}}const vt=t=>null!=t&&"elevationSample"in t&&null!=t.elevationSample,xt=t=>w(t?.elevationSource)&&null!=t?.extent,dt=t=>O(t?.elevationSource),yt=async(t,n)=>null!=n&&(vt(n)||dt(n))?n:xt(n)?{elevationSample:await j({...a(n.elevationSource)?n.elevationSource.toJSON():n.elevationSource,extent:n.extent}),elevationSource:new b({constantElevation:t})}:{elevationSource:new b({constantElevation:t})},wt=n=>t(n?.heading)&&t(n?.pitch),Ot=(t,n)=>[[-t,-n],[t,-n],[t,n],[-t,n]];function bt(t){const{cameraLocation:n,farDistance:a,horizontalFieldOfView:e,rotationMatrix:o,scalingFactor:c,verticalFieldOfView:s}=t,l=r();h(l,o);const u=2*Math.tan(i(s)/2)*a*c,m=2*Math.tan(i(e)/2)*a*c,p=I([0,0,-1],l),v=L([n.x,n.y,n.z],p,t.farDistance*c,c),x=I([0,1,0],l),d=I([1,0,0],l),y=D(x,u/2,c),w=D(d,m/2,c),O=M(f(),y,w),b=g(f(),y,w);return[g(f(),v,O),g(f(),v,b),M(f(),v,O),M(f(),v,b)]}const jt=t=>2===t?.type,zt=t=>1===t?.type;var St;!function(t){t[t.CLOCKWISE=-1]="CLOCKWISE",t[t.COUNTERCLOCKWISE=1]="COUNTERCLOCKWISE"}(St||(St={}));export{bt as computeFarplaneVertices,W as computeHFOVAndVFOV,lt as computeNewReferenceCoordinates,$ as convertHeadingPitchToSphereVertex,Z as convertOrientationToPixelLocation,X as convertPixelToHeadingPitch,G as convertSphereVertexToOrientation,Y as convertSphereVertexToPixelLocation,tt as convertToLTP,q as createRotationMatrix,U as createRotationMatrixFromHPR,A as createRotationMatrixFromOPK,T as geographicToLTP,ft as getAffinesAndFocalLength,Mt as getImageToWorldPanoramicProperties,mt as getImageToWorldProperties,B as getInitialAngle,K as getPlaneLineIntersectionPoint,yt as getUpdateElevationProps,rt as getWebMercatorScalingFactor,gt as getWorldToImageProperties,wt as hasAngles,_ as hasCameraOrientationLTP,zt as hasHeadingPitchRoll,jt as hasOmegaPhiKappa,st as isElevationSampler,vt as isUpdateElevationWithElevationSampler,xt as isUpdateElevationWithElevationSource,dt as isUpdateUsingConstantElevation,ht as isValidAffines,R as linearEquationSolve,J as ltpToGeographic,at as or,nt as pointToArray,F as projectiveTransform,Ot as reducerFn,Q as rotatePixel,L as scaleAndAddWithFactor,D as scaleWithFactor,I as transformMat3,N as transformMat4,it as validatePixelsToTransform,et as validatePointsToTransform,ot as validateRotationMatrix,ct as vecToPoint};
