/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{rad2deg as t,deg2rad as a}from"../../../core/mathUtils.js";import{create as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{a as o,j as n}from"../../../chunks/vec32.js";import{webMercatorToGeographic as e}from"../../../geometry/support/webMercatorUtils.js";import{convertOrientationToPixelLocation as i,validatePointsToTransform as c,validateRotationMatrix as s,getWebMercatorScalingFactor as f}from"./utils.js";function m(t,a){const{cameraLocation:r,pointsToTransform:o,scalingFactor:n}=h(t,a.cameraLocation,a.rotationMatrix),e=new Array;return u(o,e,{...a,cameraLocation:r,scalingFactor:n,...A(a)}),Array.isArray(t)?e:e[0]}function l(t,a,r){return m(t?a.map((t=>e(t))):a,r).map((t=>({...t,z:1})))}function u(t,a,n){const{affineTransformations:e,cameraLocation:i,focalLengthX:c,focalLengthY:s,principalOffsetPoint:f,radialDistortionCoefficients:m,rotationMatrix:l,scalingFactor:u,tangentialDistortionCoefficients:p}=n;for(const h of t){const t=r();o(t,h,i),t[0]=t[0]/u,t[1]=t[1]/u;const n=-c*((l[0]*t[0]+l[3]*t[1]+l[6]*t[2])/(l[2]*t[0]+l[5]*t[1]+l[8]*t[2])),g=-s*((l[1]*t[0]+l[4]*t[1]+l[7]*t[2])/(l[2]*t[0]+l[5]*t[1]+l[8]*t[2])),y=n*n+g*g;let L=0,A=0,T=0,b=0,d=0,w=0,M=0;m&&(L=m[0]??0,A=m[1]??0,T=m[2]??0),p&&(b=p[0],d=p[1]),f&&(w=f[0]??0,M=f[1]??0);const j=1+L*y+A*y*y+T*y*y*y;let F=n*j+b*(y+2*n**2)+2*d*n*g,N=g*j+d*(y+2*g**2)+2*b*n*g;F+=w,N+=M;const x=Number(e[0])+Number(e[1])*F+Number(e[2])*N,v=Number(e[3])+Number(e[4])*F+Number(e[5])*N;a.push({x,y:v})}}function p(a,r){const{cameraHeading:o,imageHeight:e,imageWidth:c}=r,{cameraLocation:s,pointsToTransform:f}=g(a,r.cameraLocation),m=new Array;for(const l of f){const a=n(s,l),r=(t(Math.atan2(l[0]-s[0],l[1]-s[1]))-o)%360,f=t(Math.acos((s[2]-l[2])/a));m.push(i(r,f,c,e))}return Array.isArray(a)?m:m[0]}function h(t,a,r){const o=Array.isArray(t)||"items"in t?t:[t];c(o,a),y(o,a),s(r);const n=f(a.y,a.spatialReference);return{pointsToTransform:o.map((t=>t.toArray())),scalingFactor:n,cameraLocation:a.toArray()}}function g(t,a){const r=Array.isArray(t)||"items"in t?t:[t];return c(r,a),y(r,a),{pointsToTransform:r.map((t=>t.toArray())),cameraLocation:a.toArray()}}function y(t,a){if(t.some((t=>!t.spatialReference.equals(a.spatialReference))))throw new Error("Input points and camera location must have the same spatial reference")}function L(t){return null!=t?.focalLength}function A(t){if(L(t))return{focalLengthX:t.focalLength,focalLengthY:t.focalLength};const{imageWidth:r,imageHeight:o,horizontalFieldOfView:n,verticalFieldOfView:e}=t;return{focalLengthX:r/(2*Math.tan(a(n)/2)),focalLengthY:o/(2*Math.tan(a(e)/2))}}export{m as worldToImage,p as worldToImagePanoramic,l as worldToImageWithLTPFlag};
