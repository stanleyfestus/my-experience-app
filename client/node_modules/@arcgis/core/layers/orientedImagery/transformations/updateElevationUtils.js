/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import t from"../../../core/Logger.js";import{waitTick as r,isAbortError as a}from"../../../core/promiseUtils.js";import{projectWithZConversion as o}from"../../../geometry/projection.js";import{fromExtent as n}from"../../../geometry/support/aaBoundingRect.js";import i from"../../ElevationLayer.js";import s from"../../ImageryLayer.js";import c from"../../ImageryTileLayer.js";import{TileElevationSampler as l}from"../../support/ElevationSampler.js";import{ElevationTile as u}from"../../support/ElevationTile.js";import{ElevationTileData as m}from"../../support/ElevationTileData.js";import p from"../../support/RasterFunction.js";import f from"../../support/TileInfo.js";import{TileKey as w}from"../../support/TileKey.js";import{identify as y}from"../../../rest/imageService.js";import g from"../../../rest/support/ImageIdentifyParameters.js";import{fetchArcGISServiceJSON as d}from"../../../support/requestPresets.js";import{logAndThrow as v}from"../../../widgets/OrientedImageryViewer/utils.js";async function I(t,r,a){if(!r.extent||!r.url)throw v("esri.layer.orientedImagery.transformations",new e("update-elevation:missing-property","both extent and url are required to create a sampler",r));const o=await j(r);if(!o)throw v("esri.layers.orientedImagery.transformations",new e("update-elevation:elevation-source","could not create a sampler using provided elevation source",r));return E(t,o,a)}async function E(e,t,a){await r(a);const o=N(t,a),n=Array.isArray(e)?e:[e];return await Promise.all(n.map(o))}var h;!function(e){e[e.DYNAMIC=0]="DYNAMIC",e[e.ELEVATION=1]="ELEVATION",e[e.IMAGE=2]="IMAGE"}(h||(h={}));const j=async(e,r)=>{let o;const{extent:n,rasterFunction:i,url:s,lod:c}=e;try{o=await R(s)}catch(l){if(a(l))return;t.getLogger("esri.layers.orientedImagery.transformations").error("updateElevationUsingElevationSource",l)}switch(o){case h.DYNAMIC:return await L(s,n,i,r);case h.ELEVATION:return await A(s,n,c,r);default:return}};async function A(e,r,o,n){const s=new i(e);let c;try{const{tileInfo:e}=await s.load(),t=(o&&e.lodAt(Math.min(e.lods.length-1,o))?.resolution)??"finest-contiguous";c=await s.createElevationSampler(r,{...n,demResolution:t})}catch(l){if(a(l))return;t.getLogger(s).error(l)}finally{s.destroy()}return c}async function L(e,t,r,a){const o=r?new p({functionName:r}):void 0,i=new s({url:e,rasterFunction:o,format:"lerc"});await i.load(a);let c,y=512,g=512;const d=t.width/t.height;d>1?(g/=d,c=t.height/g):(y*=d,c=t.width/y);const v=await i.fetchImage(t,y,g,a),I=f.create({scales:[c],size:512,spatialReference:t.spatialReference}),E=new w(null,0,0,0,n(t)),h=new m(v.pixelData.pixelBlock.pixels[0],y,g,0),j=new u(E,h);return new l(j,I,void 0)}async function R(t,a){await r(a);const o=await d(t),{tileInfo:n,cacheType:i}=o;if(!o.hasOwnProperty("bandCount")||!o.hasOwnProperty("pixelSizeX"))throw new e("elevation-source:invalid-service-url",`ElevationSource URL expects an elevation 3D image service but given ${t}`);return n?"LERC"!==n?.format?.toUpperCase()||i&&"elevation"!==i.toLowerCase()?h.IMAGE:h.ELEVATION:h.DYNAMIC}function N(e,t){return async r=>{let a=r.clone();const n=r.spatialReference.equals(e.spatialReference)?a:await o(r,e.spatialReference,t),i=e.queryElevation(n);if(i){a=r.spatialReference.equals(e.spatialReference)?i.clone():await o(i,r.spatialReference,t)}return a.z=a.z??1,a}}async function T(e,t,a){return await r(a),e.map((e=>(e.z=t,e)))}async function M(e,r,o){const{url:n,rasterFunction:i}=r;let s;try{s=await R(n,o)}catch(l){a(l)||t.getLogger("esri.layers.orientedImagery.transformations").error(l)}switch(s){case h.ELEVATION:case h.DYNAMIC:{const t=await y(n,new g({geometry:e,rasterFunction:i?new p({functionName:i}):void 0}));if(t.value?.[0]){const r=e.clone();return r.z=+t.value[0],r}break}case h.IMAGE:{const t=new c(n,o);await t.load();const r=await t.identify(e,o);if(r.value?.[0]){const t=e.clone();return t.z=+r.value[0],t}break}}return e}export{j as getElevationSampler,L as getElevationSamplerFromDynamicImageService,A as getElevationSamplerFromElevationLayer,T as updateUsingConstant,E as updateUsingElevationSampler,I as updateUsingElevationSource,M as updateZfromService,R as validateElevationSourceURL};
