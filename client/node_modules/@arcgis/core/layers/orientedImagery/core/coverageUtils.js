/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{throwIfAborted as e}from"../../../core/promiseUtils.js";import{create as t}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{zeros as n}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{transpose as r}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{a,g as o}from"../../../chunks/vec32.js";import i from"../../../geometry/Circle.js";import s from"../../../geometry/Mesh.js";import{projectWithZConversion as c}from"../../../geometry/projection.js";import{earth as f}from"../../../geometry/support/Ellipsoid.js";import{wrap as l}from"../../../geometry/support/lineSegment.js";import m from"../../../geometry/support/MeshComponent.js";import{MeshVertexAttributes as u}from"../../../geometry/support/MeshVertexAttributes.js";import{intersectLineSegmentClamp as p,create as h,fromArray as y}from"../../../geometry/support/plane.js";import{isWebMercator as g}from"../../../geometry/support/spatialReferenceUtils.js";import{getWebMercatorScalingFactor as x,createRotationMatrixFromHPR as w,transformMat3 as M,scaleAndAddWithFactor as d,scaleWithFactor as R,computeHFOVAndVFOV as j,projectiveTransform as P}from"../transformations/utils.js";import v from"../../../geometry/Polygon.js";import A from"../../../geometry/SpatialReference.js";import D from"../../../geometry/Multipoint.js";const b=Math.PI/180;function z(e){return e.isSpherical?O(e):V(e)}function V(e){const{horizontalFieldOfView:t,verticalFieldOfView:n,geometry:r,cameraHeading:a}=e,o=x(r.y,r.spatialReference);let i=e.cameraPitch,s=e.cameraRoll??0,c=150;t>150&&(i=90,s=0,c=5);const f=Math.ceil(t/c),l=F(f,a,t);let m=e.farDistance?e.farDistance*o:e.cameraHeight*o/Math.cos(i*b);e.cameraPitch+n/2>=90&&(m=(e.farDistance||20)*o);const u=new v({spatialReference:r?.spatialReference});u.imageID=e.objectId;let p=null;for(const h of l)p=H(h,i,e.cameraHeight,r,m,o,n,t,f,u,s,e.nearDistance);return p.imageID=e.objectId,{polygon:u,frustum:p}}function F(e,t,n){const r=[];if(e%2==0)for(let a=0;a<e/2;a++)r.push(t-n/e*(a+.5),t+n/e*(a+.5));else{r.push(t);for(let a=1;a<e/2;a++)r.push(t-n/e*a,t+n/e*a)}return r.sort(),r}function H(e,i,s,c,f,l,m,u,p,h,y=0,g=0){const x=r(t(),w([e,i,y??0])),j=q({cameraHeight:s,cameraPitch:i,farDistance:f,location:c,horizontalFieldOfView:u,nearDistance:g,verticalFieldOfView:m},x),P=M([0,0,-1],x),{x:v,y:A}=c,D=d([v,A,s],P,f,l),z=2*Math.tan(m*b/2)*f,V=2*Math.tan(u/p*b/2)*f,F=M([0,1,0],x),H=M([1,0,0],x),O=R(F,z/2,l),S=R(H,V/2,l),U=a(n(),O,S),C=o(n(),O,S),k=I([o(n(),D,U),o(n(),D,C),a(n(),D,U),a(n(),D,C)],s,c,l);return k.push(k[0]),h.addRing(k),j}function I(e,t,n,r){return e.map((e=>C(e,t,n,r)))}function O(e){const{geometry:t,farDistance:n,objectId:r,nearDistance:a,cameraHeight:o}=e,c=x(t.y,t.spatialReference),f=new i({center:t.clone(),radius:n*c});if(f.imageID=r,a){const e=new i({center:t.clone(),radius:a*c});f.addRing(e.rings[0])}const l=t.clone();l.z=o-n*c;const m=s.createSphere(l,{size:2*n*c});return m.imageID=r,{polygon:f,frustum:m}}function S(e,t){return e.contains(t)}function U(e,t){return Math.sign(e)!==Math.sign(t)}function q(e,t,r){const{cameraHeight:i,cameraPitch:c,farDistance:f,location:l,horizontalFieldOfView:m,nearDistance:p,verticalFieldOfView:h}=e,y=E(l),g=c+h/2>=90==!1,x=2*Math.tan(h*b/2)*p,w=2*Math.tan(m*b/2)*p,j=2*Math.tan(h*b/2)*f,P=2*Math.tan(m*b/2)*f;let v,A;A=[0,0,-1],A=M(A,t),v=d([l.x,l.y,i],A,f,y),g&&(v[2]=0);const D=d([l.x,l.y,i],A,p,y);let z=[0,1,0];z=M(z,t);let V=[1,0,0];V=M(V,t);let F=[],H=[];p?(H=[{faces:[4,0,3,4,7,3]},{faces:[5,1,2,5,6,2]},{faces:[4,0,1,4,5,1]},{faces:[6,2,3,6,7,3]}],F=F.concat(o(n(),D,a(n(),R(z,x/2,y),R(V,w/2,y)))),F=F.concat(o(n(),D,o(n(),R(z,x/2,y),R(V,w/2,y)))),F=F.concat(a(n(),D,a(n(),R(z,x/2,y),R(V,w/2,y)))),F=F.concat(a(n(),D,o(n(),R(z,x/2,y),R(V,w/2,y))))):(F=[l.x,l.y,i],H=[{faces:[0,1,2,0,2,3,0,3,4,0,4,1]}]),F=F.concat(o(n(),v,a(n(),R(z,j/2,y),R(V,P/2,y)))),F=F.concat(o(n(),v,o(n(),R(z,j/2,y),R(V,P/2,y)))),F=F.concat(a(n(),v,a(n(),R(z,j/2,y),R(V,P/2,y)))),F=F.concat(a(n(),v,o(n(),R(z,j/2,y),R(V,P/2,y))));const I=new u({position:Float64Array.from(F)});return new s({vertexAttributes:I,components:H,spatialReference:l.spatialReference})}function C(e,t,r,o){{const i=Math.sqrt((e[2]-t)**2+(Math.sqrt((e[0]-r.x)**2+(e[1]-r.y)**2)/o)**2)*o,s=R(a(n(),[e[0],e[1],e[2]],[r.x,r.y,t]),1/i,1/o),c=t/(t-e[2]),f={x:(1-c)*r.x+c*e[0],y:(1-c)*r.y+c*e[1],z:(1-c)*t+c*e[2]},l=Math.sqrt((f.z-t)**2+(Math.sqrt((f.x-r.x)**2+(f.y-r.y)**2)/o)**2)*o,m=R(a(n(),[f.x,f.y,f.z],[r.x,r.y,t]),1/l,1/o);return U(s[0],m[0])&&U(s[1],m[1])&&U(s[2],m[2])||e[2]>=0?[e[0],e[1],0]:[f.x,f.y,f.z]}}function k(e){const{spatialReference:t,x:n,y:r}=e.geometry,{cameraHeading:a,cameraPitch:o,farDistance:i,nearDistance:s}=e,c=E(e.geometry),f=new v({spatialReference:t}),l=Math.abs(1.44*i*c);let m=Math.abs(1.44*s*c);(o<20||null==a)&&(m=l);const u=[];return u[0]={x:n+l*Math.sin((a-45)*b),y:r+l*Math.cos((a-45)*b)},u[1]={x:n+l*Math.sin((a+45)*b),y:r+l*Math.cos((a+45)*b)},u[2]={x:n+m*Math.sin((a+135)*b),y:r+m*Math.cos((a+135)*b)},u[3]={x:n+m*Math.sin((a+225)*b),y:r+m*Math.cos((a+225)*b)},f.addRing([[u[0].x,u[0].y,0],[u[1].x,u[1].y,0],[u[2].x,u[2].y,0],[u[3].x,u[3].y,0],[u[0].x,u[0].y,0]]),f}function E(e){return e&&g(e?.spatialReference)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*e.y/f.radius))):1}function L(e,t){const r=1+t/100;if("esri.geometry.Circle"===e.declaredClass){const{radius:t,center:n}=e,a=new i({radius:t*r,center:n});return e.rings.length>1&&a.addRing(e.rings[1]),a}if("esri.geometry.Polygon"===e.declaredClass){const t=new v({spatialReference:e.spatialReference}),o=e.centroid;if(o){const i=[];for(let t=0;t<e.rings[0].length;t++){const s=Math.sqrt((o.x-e.rings[0][t][0])**2+(o.y-e.rings[0][t][1])**2),c=R(a(n(),[e.rings[0][t][0],e.rings[0][t][1],0],[o.x,o.y,0]),1/s,1),f=d([o.x,o.y,0],c,s*r,1);i.push({x:f[0],y:f[1]})}t.addRing([[i[0].x,i[0].y,0],[i[1].x,i[1].y,0],[i[2].x,i[2].y,0],[i[3].x,i[3].y,0],[i[0].x,i[0].y,0]])}return t}return e}async function W(e,t,n){const{cameraHeight:r,cameraLocation:a,cameraPitch:o,frustumVertices:i,horizontalFieldOfView:s,imageHeight:c,imageWidth:f,inSRS:l,outSRS:m,verticalFieldOfView:u,cameraRoll:p,imageRotation:h,options:y}=n,g=new A(l),x=new A(m),w=j(s,u,p??0),M=i.length>15;return o+w.vfov/2>=90?await N(i,e,f,c,g,x,M,h,y):await B(i,e,t,a,r,M,g,x,y)}async function B(e,t,n,r,a,o,i,c,f){const l=G(e,t,n,r,a);if(!l)return;const{farPlane:m,nearPlane:p}=l,h=await Q([...p?.vertexPositions??e.slice(0,3),...m.vertexPositions],i,c,f);return new s({vertexAttributes:new u({position:h}),components:Z(Y(o)),spatialReference:c})}function G(e,t,n,r,a){const o=X(e),i=X(e,"near");if(!o)return;const{coefficients:s}=o,c=t.length;for(let f=0;f<c;f++){const e=T([n[f][0],n[f][1]],s),t=n[f];t[2]=(t[2]>=0?e:t[2])??0;const c=[t[0]-r[0],t[1]-r[1],t[2]-(r[2]??a)];K(r,c,f,i),J(r,c,f,o,n,e)}return{farPlane:o,nearPlane:i}}function J(e,t,r,a,o,i){const{coefficients:s,vertexPositions:c}=a;if(null!=i&&i>=0)c.splice(3*r,3,...o[r]);else{const a=n();p(s,l(e,t),a)&&c.splice(3*r,3,...a)}}function K(e,t,r,a){if(!a)return;const o=n();p(a.coefficients,l(e,t),o)&&a.vertexPositions.splice(3*r,3,...o)}async function N(e,t,n,r,a,o,i,c=0,f){const l=Math.cos((c??0)*b),m=Math.sin((c??0)*b),p=Math.abs(n*l+r*m),h=Math.abs(n*-m+r*l);let y,g,x=i?new Array:[e[0],e[1],e[2]],w=new Array;const M=t.length;for(let s=0;s<M;s++){const a=[p/2,h/2],o=t[s];g=[(o[0]-a[0])*l-(o[1]-a[1])*m+a[0],(o[0]-a[0])*m+(o[1]-a[1])*l+a[1]],i?(y=P([g[0],g[1],1],[[0,0,1],[n,0,1],[n,r,1],[0,r,1]],[[e[0],e[1],e[2]],[e[3],e[4],e[5]],[e[6],e[7],e[8]],[e[9],e[10],e[11]]]),x=x.concat(...y),y=P([g[0],g[1],1],[[0,0,1],[n,0,1],[n,r,1],[0,r,1]],[[e[12],e[13],e[14]],[e[15],e[16],e[17]],[e[18],e[19],e[20]],[e[21],e[22],e[23]]]),w=w.concat(...y)):(y=P([g[0],g[1],1],[[0,0,1],[n,0,1],[n,r,1],[0,r,1]],[[e[3],e[4],e[5]],[e[6],e[7],e[8]],[e[9],e[10],e[11]],[e[12],e[13],e[14]]]),x=x.concat(...y))}x=x.concat(w);const d=await Q(x,a,o,f);return new s({vertexAttributes:new u({position:d}),components:Z(Y(i)),spatialReference:o})}async function Q(t,n,r,a){if(n.equals(r))return t;const o=t.reduce(((e,t,n)=>{const r=Math.floor(n/3);return e[r]||(e[r]=new Array),e[r].push(t),e}),new Array),{points:i}=await c(new D(o,n),r,a);return e(a),i.flat()}function T(e,t){if(t)return(-t[3]-t[0]*e[0]-t[1]*e[1])/t[2]}function X(e,t="far"){const n=h();let r;switch(t){case"far":if(r=Array.from(15===e.length?e.slice(3):e.slice(12)),y(n,r,!1))return{coefficients:n,vertexPositions:r};break;case"near":if(r=Array.from(e.slice(0,12)),15===e.length||!y(n,r,!1))return;return{coefficients:n,vertexPositions:r}}}const Y=e=>e?[{faces:new Uint32Array([4,0,3,4,7,3])},{faces:new Uint32Array([5,1,2,5,6,2])},{faces:new Uint32Array([4,0,1,4,5,1])},{faces:new Uint32Array([6,2,3,6,7,3])}]:[{faces:new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1])}],Z=e=>e.map((e=>new m(e)));export{S as checkIfPolygonContainsSelectedPoint,k as computePolygonForInspection,z as createCoveragePolygon,I as limitZToGround,Q as projectVertices,L as resizePolygon,W as updateFrustum};
