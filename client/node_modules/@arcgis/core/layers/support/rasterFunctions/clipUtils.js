/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{getMetersPerUnitForSR as t}from"../../../core/unitUtils.js";import e from"../../../geometry/Extent.js";import i from"../../../geometry/Point.js";import n from"../PixelBlock.js";function a(e,i){if(e.spatialReference.equals(i))return e;const n=t(e.spatialReference),a=t(i);if(n===a)return e;const h=n/a;return{x:e.x*h,y:e.y*h}}async function h(t,e,i){if("extent"===i.type)return o(t,e,i);const{width:a,height:h}=t,m=new Uint8Array(a*h),{contains:l,intersects:s}=await import("../../../geometry/geometryEngine.js");return s(e,i)?"polyline"===i.type?r(t,e,i):l(i,e)?t:x(t,e,i):new n({pixelType:t.pixelType,width:a,height:h,mask:m,maskIsAlpha:!1,pixels:[...t.pixels]})}function x(t,e,i){if(!t)return t;const{width:a,height:h}=t,x=e.width/a,o=e.height/h,{xmin:r,ymax:m}=e;let l;if("extent"===i.type){const t=(i.xmin-r)/x,e=(i.xmax-r)/x,n=(m-i.ymax)/o,a=(m-i.ymin)/o;l=[[[t,n],[t,a],[e,a],[e,n],[t,n]]]}else l=i.rings.map((t=>t.map((([t,e])=>[(t-r)/x,(m-e)/o]))));const s=document.createElement("canvas");s.width=a,s.height=h;const p=s.getContext("2d");p.fillStyle="#f00",p.beginPath(),l.forEach((t=>{p.moveTo(t[0][0],t[0][1]);for(let e=0;e<t.length;e++)p.lineTo(t[e][0],t[e][1]);p.closePath()})),p.fill();const y=p.getImageData(0,0,a,h).data,f=t.mask,c=a*h,M=new Uint8Array(c);for(let n=0;n<c;n++)f&&!f[n]||(M[n]=y[4*n+3]>127?255:0);return new n({pixelType:t.pixelType,width:a,height:h,mask:M,maskIsAlpha:!1,pixels:[...t.pixels]})}function o(t,e,i){const{width:a,height:h}=t,x=new Uint8Array(a*h),o=e.width/a,r=e.height/h;if(i.width/o<.5||i.height/r<.5)return new n({pixelType:t.pixelType,width:a,height:h,mask:x,pixels:[...t.pixels]});const{xmin:m,xmax:l,ymin:s,ymax:p}=e,{xmin:y,xmax:f,ymin:c,ymax:M}=i,u=Math.max(m,y),d=Math.min(l,f),w=Math.max(s,c),g=Math.min(p,M),T=.5*o,k=.5*r;if(d-u<T||g-w<k||d<m+T||u>l-T||w>p-k||g<s+k)return new n({pixelType:t.pixelType,width:a,height:h,mask:x,pixels:[...t.pixels]});const R=Math.max(0,(u-m)/o),A=Math.min(a,Math.max(0,(d-m)/o)),j=Math.max(0,(p-g)/r),U=Math.min(h,Math.max(0,(p-w)/r)),E=Math.round(R),P=Math.round(A)-1,S=Math.round(j),z=Math.round(U)-1;if(E===P&&R%1>.5&&A%1<.5||S===z&&j%1>.5&&U%1<.5)return new n({pixelType:t.pixelType,width:a,height:h,mask:x,pixels:[...t.pixels]});if(0===E&&0===S&&P===a&&z===h)return t;const I=t.mask;for(let n=S;n<=z;n++)for(let t=E;t<=P;t++){const e=n*a+t;x[e]=I?I[e]:255}return new n({pixelType:t.pixelType,width:a,height:h,mask:x,pixels:[...t.pixels]})}function r(t,e,i){const{width:a,height:h}=t,x=new Uint8Array(a*h),o=e.width/a,r=e.height/h,{xmin:m,ymax:l}=e,{paths:s}=i,p=t.mask;for(let n=0;n<s.length;n++){const t=s[n];for(let e=0;e<t.length-1;e++){const[i,n]=t[e],[s,y]=t[e+1];let f=Math.floor((l-n)/r),c=Math.floor((l-y)/r);if(c<f){const t=f;f=c,c=t}f=Math.max(0,f),c=Math.min(h-1,c);const M=(s-i)/(y-n);for(let t=f;t<=c;t++){const e=t===f?Math.max(n,y):(h+1-t)*r,l=t===c?Math.min(n,y):e-r;let u=y===n?Math.floor((i-m)/o):Math.floor((M*(e-n)+i-m)/o),d=y===n?Math.floor((s-m)/o):Math.floor((M*(l-n)+i-m)/o);if(d<u){const t=u;u=d,d=t}const w=t*a;u=Math.max(0,u),d=Math.min(a-1,d);for(let t=w+u;t<=w+d;t++)x[t]=p?p[t]:255}}}return new n({pixelType:t.pixelType,width:a,height:h,mask:x,pixels:[...t.pixels]})}function m(t,e){const{extent:n}=l(t,e,new i({x:t.pixelSize.x,y:t.pixelSize.y,spatialReference:t.spatialReference})),{extent:a}=t.extent;if(n.xmax=Math.min(n.xmax,a.xmax),n.ymax=Math.min(n.ymax,a.ymax),n.xmin<n.xmax&&n.ymin<n.ymax){const{x:e,y:i}=t.pixelSize,a=Math.round(n.width/e),h=Math.round(n.height/i);t.extent=n,t.width=a,t.height=h}}function l(t,i,n,h=!0){const{spatialReference:x}=t,{x:o,y:r}=a(n,x);let m,l,s;const p="extent"===i.type?i:i.extent;let{xmin:y,xmax:f,ymax:c,ymin:M}=p;const{xmin:u,ymax:d}=t.extent;return h?(y=u+(y>u?o*Math.round((y-u)/o):0),c=d-(c<d?r*Math.round((d-c)/r):0),f=u+(f>u?o*Math.round((f-u)/o):0),M=d-(M<d?r*Math.round((d-M)/r):0),m=new e({xmin:y,ymax:c,xmax:f,ymin:M,spatialReference:x}),l=Math.round(m.width/o),s=Math.round(m.height/r)):(l=Math.floor((f-y)/o+.8),s=Math.floor((c-M)/r+.8),y=u+(y>u?o*Math.floor((y-u)/o+.1):0),c=d-(c<d?r*Math.floor((d-c)/r+.1):0),f=y+l*o,M=c-s*r,m=new e({xmin:y,ymax:c,xmax:f,ymin:M,spatialReference:x})),{extent:m,width:l,height:s}}export{h as clip,m as clipRasterInfo,l as snapToRaster};
