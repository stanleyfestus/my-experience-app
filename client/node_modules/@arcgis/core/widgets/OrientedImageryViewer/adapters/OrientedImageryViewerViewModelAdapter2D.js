/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../../geometry.js";import e from"../../../Graphic.js";import{isSome as t}from"../../../core/arrayUtils.js";import i from"../../../core/Logger.js";import{waitTick as o,throwIfAborted as r,isAbortError as a}from"../../../core/promiseUtils.js";import{convertOrientationToPixelLocation as s}from"../../../layers/orientedImagery/transformations/utils.js";import{activePolygonSymbol as n,polygonSymbol as l}from"../symbols.js";import m from"../../../geometry/Polygon.js";class c{constructor(c){this.viewModel=c,this.createFootprints=async t=>{await o(t);const{coveragePolygons:i,currentBestFeature:r,isAdditionalCoverageVisible:a}=this.viewModel;for(const o of i)o?.imageID===r.attributes.objectId?this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:o?.imageID},geometry:o,symbol:n,visible:!1}):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:o?.imageID},geometry:o,symbol:l.clone(),visible:a}))},this.updateFootprint=async(o,s)=>{const{activeViewer:l,currentBestFeature:c,currentCoverageVisible:g,footprintExtent:u}=this.viewModel,p=l?.imageSize;if(c&&p&&u)try{const i=await this.viewModel.getMapPoint(o,{feature:c,mode:"default",imageSize:p});r(s);const a=i.filter(t);if(!a.length)return;const l=[a.map((({x:e,y:t})=>[e,t,1]))];l[0].push(l[0][0]);const u=new m({rings:l,spatialReference:a[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:u,attributes:{imageID:c.attributes.objectId},symbol:n,visible:g}))}catch(d){a(d)||i.getLogger(this.viewModel).error("update-footprint",d)}else this.viewModel.updateCurrentCoveragePolygon(null)},this.updateFootprintPanorama=async(t,i)=>{const{horizontalFieldOfView:o,pitch:a,verticalFieldOfView:l,yaw:c}=t,{activeViewer:g,currentBestFeature:u,currentCoverageVisible:p,footprintExtent:d}=this.viewModel,f=g?.imageSize;if(!u||!f||!d)return void this.viewModel.updateCurrentCoveragePolygon(null);const{cameraPitch:v,objectId:h}=u.attributes;if(a+v-l/2>180)return void this.viewModel.updateCurrentCoveragePolygon(null);let w=[];if(a+v+l/2<180){w=[[-o/2,l/2],[o/2,l/2],...a-l/2<0?[[-o/2,-l/2],[o/2,-l/2]]:[[o/2,-l/2],[-o/2,-l/2]]]}else if(a+v-l/2<180&&a+v+l/2>180){w=[[-o/2,-l/2]];const e=Math.floor(o/6),t=o/e;for(let i=0;i<=e;i++)w.push([i*t-o/2,90-a]);w.push([o/2,-l/2]);a-l/2<0&&([w[0],w[w.length-1]]=[w[w.length-1],w[0]])}const y=w.map((([e,t])=>s(c+e,a+t,f[0],f[1]))),b=await this.viewModel.getMapPoint(y,{feature:u,mode:"panorama",imageSize:f});r(i);const M=[b.map((({x:e,y:t})=>[e,t,1]))];M[0].push(M[0][0]);const C=new m({rings:M,spatialReference:b[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:C,attributes:{imageID:h},symbol:n.clone(),visible:p}))}}}export{c as default};
