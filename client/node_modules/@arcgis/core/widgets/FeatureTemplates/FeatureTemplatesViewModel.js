/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import{createTask as e}from"../../core/asyncUtils.js";import s from"../../core/Evented.js";import{abortMaybe as r}from"../../core/maybe.js";import{throwIfAborted as o}from"../../core/promiseUtils.js";import{watch as l,when as i,syncAndInitial as a,sync as n}from"../../core/reactiveUtils.js";import{property as p}from"../../core/accessorSupport/decorators/property.js";import"../../core/has.js";import"../../core/Logger.js";import"../../core/RandomLCG.js";import{subclass as u}from"../../core/accessorSupport/decorators/subclass.js";import{UpdatingHandles as m}from"../../core/support/UpdatingHandles.js";import{getEffectiveLayerCapabilities as y}from"../../layers/support/layerUtils.js";import{isTemplateItemGroup as c,mapItemsByTemplate as d,loadLayerWithTemplates as h}from"./featureTemplatesUtils.js";import f from"./TemplateItem.js";import g from"./TemplateItemGroup.js";import{getAllTemplatesForLayer as _}from"../support/templateUtils.js";var I;const b=({layer:t})=>({key:t,label:t.title??""}),F=({layer:t})=>({key:t.geometryType,label:t.geometryType??""});let B=I=class extends s.EventedAccessor{constructor(t){super(t),this._allItems=[],this._updatingHandles=new m,this._updateAllItemsTask=null,this.disabled=!1,this.disabledItemFunction=null,this.filterFunction=null,this.selectedItem=null}initialize(){this._get("groupBy")||(this.groupBy="layer"),this.addHandles([l((()=>[this._featureTemplatesByLayer,this._groupByFunction]),(()=>{this._updateAllItemsTask=r(this._updateAllItemsTask);const t=e((t=>this._updateAllItems(t)));this._updateAllItemsTask=t,this._updatingHandles.addPromise(t.promise)}),a),l((()=>this.filterFunction),(t=>{for(const e of this._allItems)c(e)&&(e.filterFunction=t)}),n)])}get _featureTemplatesByLayer(){const t=new Map;if(!this.layers)return t;for(const e of this.layers)if("subtype-group"===e.type)for(const s of e.sublayers)t.set(s,_(s));else t.set(e,_(e));return t}set groupBy(t){if(this._set("groupBy",t),"function"!=typeof t)switch(t){case"layer":this._groupByFunction=b;break;case"geometry":this._groupByFunction=F;break;default:this._groupByFunction=null}else this._groupByFunction=e=>this._ensureGroupByObject(t(e))}get layers(){return this._get("layers")}set layers(t){const e="layers";if(this.removeHandles(e),t){const s=()=>this.notifyChange("state");this.addHandles(t.map((t=>i((()=>t.loadStatus),s))),e)}this._set("layers",t)}get state(){return this.updating?"loading":0===this.layers.length?"disabled":"ready"}get numberOfFeatureTemplates(){return Array.from(this._featureTemplatesByLayer.values()).reduce(((t,e)=>t+e.length),0)}get items(){const{filterFunction:t}=this;return null==t?this._allItems:this._allItems.filter((e=>c(e)?e.items.length>0:t(e)))}get updating(){return this._updatingHandles.updating}refresh(){this.notifyChange("filterFunction");for(const t of this._allItems)c(t)&&t.reapplyFilter()}select(t,{emit:e=!0}={}){const s=this.selectedItem,r=t?.clone()||null;this._set("selectedItem",r),e&&this.emit("select",{item:r,oldItem:s,template:r?.template??null})}_createItem(t,e){return new f({disabledFunction:this.disabledItemFunction,layer:e,template:t})}_ensureGroupByObject(t){return"string"==typeof t?{key:t,label:t}:t}async _updateAllItems(t){const e=this._allItems;if(0===this.numberOfFeatureTemplates)return j(e),void(this._allItems=[]);const[s,r]=d(e),l={signal:t},i=this._featureTemplatesByLayer,a=[];for(const[m,c]of i){await h(m,l),o(t);const e=y(m)?.operations;if(e?.supportsEditing&&e?.supportsAdd)for(const t of c)s.has(t)?(a.push(s.get(t)),s.delete(t)):a.push(this._createItem(t,m))}for(const o of[...s.values(),...r])o.destroy();if(null==this._groupByFunction)return o(t),void(this._allItems=a);const n=new Map;for(const o of a){const t=this._groupByFunction(o),{key:e,label:s}=null!=t.key?t:I.nullGroupBy;n.has(e)||n.set(e,{label:s,items:[]}),n.get(e)?.items.push(o)}const{filterFunction:p}=this,u=Array.from(n.values()).map((({label:t,items:e})=>new g({allItems:e,filterFunction:p,label:t})));o(t),1===u.length&&u[0].label===I.nullGroupBy.label?this._allItems=u[0].allItems:this._allItems=u}};function j(t){for(const e of t){if(c(e))for(const t of e.items)t.destroy();e.destroy()}}B.nullGroupBy={key:Symbol(),label:"Otherâ€‹"},t([p()],B.prototype,"_allItems",void 0),t([p()],B.prototype,"_featureTemplatesByLayer",null),t([p()],B.prototype,"_groupByFunction",void 0),t([p()],B.prototype,"_updatingHandles",void 0),t([p()],B.prototype,"disabled",void 0),t([p()],B.prototype,"disabledItemFunction",void 0),t([p({value:null})],B.prototype,"filterFunction",void 0),t([p()],B.prototype,"groupBy",null),t([p({value:[]})],B.prototype,"layers",null),t([p()],B.prototype,"state",null),t([p({readOnly:!0})],B.prototype,"numberOfFeatureTemplates",null),t([p({readOnly:!0})],B.prototype,"items",null),t([p({readOnly:!0})],B.prototype,"selectedItem",void 0),t([p()],B.prototype,"updating",null),B=I=t([u("esri.widgets.FeatureTemplates.FeatureTemplatesViewModel")],B);const v=B;export{v as default};
