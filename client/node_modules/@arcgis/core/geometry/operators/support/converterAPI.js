/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{P as e}from"../../../chunks/Transformation2D.js";import{i as t,E as n,M as s,P as r,a,b as o,c as i,d as u}from"../../../chunks/QuadraticBezier.js";import{G as c}from"../../../chunks/Geometry.js";import"../../../geometry.js";import{gradGcsIds as l,getMetersPerUnit as h,isProjectedWKT as m}from"../../../core/unitUtils.js";import{isGeographic as p}from"../../support/spatialReferenceUtils.js";import f from"../../Extent.js";import g from"../../Multipoint.js";import y from"../../Point.js";import w from"../../Polygon.js";import C from"../../Polyline.js";const M="_gxVersion",x=2,V=1;function P(e){return Array.isArray(e)?e[0].spatialReference:e.spatialReference}function d(e){switch(e.type){case"point":return k(e);case"multipoint":return j(e);case"polyline":return R(e);case"polygon":return E(e);case"extent":return Z(e);default:throw new Error(`Unsupported geometry type: ${e.type}`)}}function Z(e){if(!e.getCacheValue(M)){const t=new n;t.setCoords(e.xmin,e.ymin,e.xmax,e.ymax),e.hasM&&t.setInterval(x,0,e.mmin,e.mmax),e.hasZ&&t.setInterval(V,0,e.zmin,e.zmax),e.setCacheValue(M,t)}return e.getCacheValue(M)}function j(e){if(!e.getCacheValue(M)){const t=new s,n=new r,a=e.points,o=e.hasM,i=e.hasZ,u=i?3:2;for(let e=0,s=a.length;e<s;e++){const s=a[e];n.setXYCoords(s[0],s[1]),i&&n.setZ(s[2]??0),o&&n.setM(s[u]??NaN),t.add(n)}e.setCacheValue(M,t)}return e.getCacheValue(M)}function k(e){if(!e.getCacheValue(M)){const t=new r;t.setXYCoords(e.x,e.y),e.hasM&&t.setM(e.m),e.hasZ&&t.setZ(e.z),e.setCacheValue(M,t)}return e.getCacheValue(M)}function E(e){if(!e.getCacheValue(M)){const t=new a;v(t,e),e.setCacheValue(M,t)}return e.getCacheValue(M)}function R(e){if(!e.getCacheValue(M)){const t=new o;v(t,e),e.setCacheValue(M,t)}return e.getCacheValue(M)}function v(e,t){const n="polygon"===t.type,s=new r,a=n?t.rings:t.paths,o=t.hasM,i=t.hasZ,u=i?3:2;for(let r=0,c=a.length;r<c;r++){const t=a[r],c=n?t.length-1:t.length;for(let n=0;n<c;n++){const r=t[n];s.setXYCoords(r[0],r[1]),i&&s.setZ(r[2]??0),o&&s.setM(r[u]??NaN),0===n?e.startPathPoint(s):e.lineToPoint(s)}}}function X(e){if(e.wkid)return i(e.wkid);const t=e.wkt2||e.wkt;return t?u(t):null}function Y(e,t){if(e)switch(e.getGeometryType()){case c.enumPoint:return D(e,t);case c.enumEnvelope:return z(e,t);case c.enumMultiPoint:return I(e,t);case c.enumPolyline:return N(e,t);case c.enumPolygon:return U(e,t)}return null}function z(e,t){if(e.isEmpty())return null;const n=new f({xmin:e.getXMin(),ymin:e.getYMin(),xmax:e.getXMax(),ymax:e.getYMax(),spatialReference:t}),s=e.getDescription();if(s.hasM()){const t=e.queryInterval(x,0);n.mmin=t.vmin,n.mmax=t.vmax}if(s.hasZ()){const t=e.queryInterval(V,0);n.zmin=t.vmin,n.zmax=t.vmax}return n.setCacheValue(M,e),n}function I(e,t){if(e.isEmpty())return null;const n=e.getDescription(),s=n.hasM(),a=n.hasZ(),o=[],i=new r;for(let r=0,c=e.getPointCount();r<c;r++){e.getPointByVal(r,i);const t=[i.getX(),i.getY()];a&&t.push(i.getZ()),s&&t.push(i.getM()),o.push(t)}const u=new g({hasM:s,hasZ:a,points:o,spatialReference:t});return u.setCacheValue(M,e),u}function D(t,n){if(t instanceof e)return new y({x:t.x,y:t.y,spatialReference:n});if(t.isEmpty())return null;const s=new y({x:t.getX(),y:t.getY(),spatialReference:n}),r=t.getDescription();return r.hasM()&&(s.m=t.getM()),r.hasZ()&&(s.z=t.getZ()),s.setCacheValue(M,t),s}function U(e,t){if(e.isEmpty())return null;const n=new w({spatialReference:t});return T(n,e),n.setCacheValue(M,e),n}function N(e,t){if(e.isEmpty())return null;const n=new C({spatialReference:t});return T(n,e),n.setCacheValue(M,e),n}function T(e,t){const n="polygon"===e.type,s=t.getDescription(),a=s.hasM(),o=s.hasZ(),i=[],u=new r;for(let r=0,c=t.getPathCount();r<c;r++){i.push([]);for(let e=t.getPathStart(r),n=t.getPathEnd(r);e<n;e++){t.getPointByVal(e,u);const n=[u.getX(),u.getY()];o&&n.push(u.getZ()),a&&n.push(u.getM()),i[r].push(n)}n&&i[r].push(i[r][0].slice())}e.hasM=a,e.hasZ=o,n?e.rings=i:e.paths=i}t((e=>{let t,n;"number"==typeof e?t=e:n=e;const s={wkid:t,wkt:n};let r,a;if(n){r=m(n);const e=p(s);if(!r&&!e)throw new Error(`Unsupported WKT type: ${n}`)}else r=!p(s);return a=t&&l.has(t)?Math.PI/200:r?h(s):Math.PI/180,{isPCS:r,metersOrRadiansPerUnit:a,semiMajor:0,wkidOrWkt:e}}));export{Z as fromExtent,d as fromGeometry,j as fromMultipoint,k as fromPoint,E as fromPolygon,R as fromPolyline,X as fromSpatialReference,P as getSpatialReference,z as toExtent,Y as toGeometry,I as toMultipoint,D as toPoint,U as toPolygon,N as toPolyline};
