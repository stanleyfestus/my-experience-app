/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{S as e,G as t}from"../../../chunks/SimpleGeometryCursor.js";import{e as n,a as r,g as s,G as o}from"../../../chunks/Geometry.js";import{P as i,c as u}from"../../../chunks/Transformation2D.js";import{t as m,h as a,bf as c,I as p,M as l}from"../../../chunks/QuadraticBezier.js";class h{getOperatorType(){return 10003}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,n,r){return new y(e,t,n,r)}execute(t,r,s,o){const i=new e([t]),u=new e([r]),m=this.executeMany(i,u,s,o).next();return m||n("null output"),m}}function f(e,t,n,r){const s=e.getDimension(),i=t.getDimension();if(s!==i)return s>i?e:t;if(e.isEmpty())return t;if(t.isEmpty())return e;const u=new m,p=new m,l=new m;e.queryEnvelope(u),t.queryEnvelope(p),l.setCoords({env2D:u}),l.mergeEnvelope2D(p);const h=a(n,l,!0),f=e.getGeometryType(),y=t.getGeometryType();return f===o.enumPoint&&y===o.enumPoint?d(e,t,h):f===o.enumPoint&&y===o.enumMultiPoint?g(t,e,h):f===o.enumMultiPoint&&y===o.enumPoint?g(e,t,h):c(e,t,n,r)}function d(e,t,n,r){const s=p(n),o=s*s,u=e.getXY(),m=t.getXY(),a=new l({vd:e.getDescription()});return i.sqrDistance(u,m)>o&&(a.add(e),a.add(t)),a}function g(e,t,n,r){const s=e.getImpl().getAttributeStreamRef(0),o=e.getPointCount(),i=t.getXY(),a=e.createInstance(),c=p(n),l=new m;if(e.queryEnvelope(l),l.inflateCoords(c,c),l.contains(i)){const n=c*c;let r=!1;const m=u(o,!1);for(let e=0;e<o;e++){const t=s.read(2*e),o=s.read(2*e+1),u=t-i.x,a=o-i.y;u*u+a*a<=n&&(r=!0,m[e]=!0)}if(r)for(let t=0;t<o;t++)m[t]||a.addPoints(e,t,t+1);else a.addPoints(e,0,o),a.add(t)}else a.addPoints(e,0,o),a.add(t);return a}class y extends t{constructor(e,t,n,s){super(),this.m_progressTracker=s,this.m_index=-1,this.m_inputGeoms=e,this.m_spatialReference=n,this.m_rightGeom=t.next(),this.m_bEmpty=!this.m_rightGeom,r(this.m_rightGeom)}tock(){return s(0),!1}getRank(){return s(0),0}next(){if(this.m_bEmpty)return null;const e=this.m_inputGeoms.next();return e?(r(e),this.m_index=this.m_inputGeoms.getGeometryID(),f(e,this.m_rightGeom,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}}const G=new h;function _(e,t,n){return G.execute(e,t,n,null)}function x(t,n,r){const s=G.executeMany(new e(t),new e([n]),r,null);return Array.from(s)}function w(){return G.supportsCurves()}export{_ as execute,x as executeMany,w as supportsCurves};
