/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{S as e,G as r}from"../../../chunks/SimpleGeometryCursor.js";import{e as t,g as n,k as s,a as o,G as i,f as u,t as a}from"../../../chunks/Geometry.js";import{aZ as c,a_ as m,a as l,a$ as g,M as d}from"../../../chunks/QuadraticBezier.js";import{d as p,P as y}from"../../../chunks/Transformation2D.js";class h{getOperatorType(){return 10113}supportsCurves(){return!1}accelerateGeometry(e,r,t){return!1}canAccelerateGeometry(e){return!1}executeMany(e,r,t){return new C(e,r,t)}execute(r,n){const s=new e([r]),o=this.executeMany(s,!1,n).next();return o||t("null output"),o}minimumBoundingCircle(e,r,t,n){return c(e,r,t)}}class C extends r{constructor(e,r,t){super(),this.m_geometryCursor=e,this.m_bMerge=r,this.m_progressTracker=t}tock(){return n(0),!1}getRank(){return n(0),0}next(){if(this.m_bMerge)return this.mergedMinimumBoundingCircle();const e=this.m_geometryCursor.next();return e?this.minimumBoundingCircle(e):null}getGeometryID(){return this.m_geometryCursor.getGeometryID()}minimumBoundingCircle(e){if(s(e),o(e),this.m_progressTracker?.checkProgress(),e.isEmpty())return e.clone();const r=e.getGeometryType();if(r===i.enumPoint)return this.makeCircle([e.getXY()],1);if(r===i.enumLine){const r=e,t=[r.getStartXY(),r.getEndXY()];return this.makeCircle(t,2)}if(r===i.enumEnvelope){const r=e,t=p(y,2);return r.queryCorner(0,t[0]),r.queryCorner(2,t[1]),this.makeCircle(t,2)}if(u(r)){const r=e,t=[0,0,0],n=m(r,t),s=new Array(n);for(let e=0;e<n;++e)s[e]=r.getXY(t[e]);return this.makeCircle(s,n)}a("Geometry type not supported.")}makeCircle(e,r){const t=new l,n=new g;if(1===r)n.constructCircleRadius(0,e[0],!1);else if(2===r){const r=y.lerp(e[0],e[1],.5),t=y.distance(e[0],r),s=y.distance(e[1],r);n.constructCircleRadius(Math.max(t,s),r,!1)}else if(3===r){const r=y.calculateCircleCenterFromThreePoints(e[0],e[1],e[2]),t=y.distance(e[0],r),s=y.distance(e[1],r),o=y.distance(e[2],r);n.constructCircleRadius(Math.max(t,s,o),r,!1)}return t.addPathFromClosedSegment(n,!1),t}mergedMinimumBoundingCircle(){let e=null,r=this.m_geometryCursor.next();if(!r)return null;e=new d;const t=e.getImpl();do{s(r),o(r),this.m_progressTracker?.checkProgress();switch(r.getGeometryType()){case i.enumPoint:t.addPoint2D(r.getXY());break;case i.enumLine:t.addPoint2D(r.getStartXY()),t.addPoint2D(r.getEndXY());break;case i.enumEnvelope:for(let e=0;e<4;++e){const n=new y;r.queryCorner(e,n),t.addPoint2D(n)}break;case i.enumMultiPoint:case i.enumPolyline:case i.enumPolygon:{const e=r.getImpl();for(let r=0,n=e.getPointCount();r<n;r++)t.addPoint2D(e.getXY(r));break}default:a("Geometry type not supported.")}}while(r=this.m_geometryCursor.next());return this.minimumBoundingCircle(e)}}const f=new h;function k(e){return f.execute(e,null)}function P(r,t){const n=f.executeMany(new e(r),t,null);return Array.from(n)}function x(){return f.supportsCurves()}export{k as execute,P as executeMany,x as supportsCurves};
