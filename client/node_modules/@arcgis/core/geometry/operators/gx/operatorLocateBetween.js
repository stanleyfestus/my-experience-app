/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{G as t,S as e}from"../../../chunks/SimpleGeometryCursor.js";import{g as n,a as r,G as s,t as o,l as i,c as u,e as l}from"../../../chunks/Geometry.js";import{E as a,s as m}from"../../../chunks/Transformation2D.js";import{aI as c,aX as p,P as h,M as g,S as d,b as y,aY as _}from"../../../chunks/QuadraticBezier.js";function f(t,e,n,r,s){return new w(e,n,r,s).processGeometry(t)}class w{constructor(t,e,n,r){this.m_interval=n,this.m_progressTracker=r,this.m_attribute=t,this.m_ord=e,(p.getComponentCount(this.m_attribute)<=e||e<0)&&o("LocateBetween: ordinate");2===p.getInterpolation(this.m_attribute)&&o("LocateBetween: angular interpolation")}processGeometry(t){const e=t.getGeometryType();if(e===s.enumGeometryCollection)return this.processGeometryCollection(t);if(i(e)&&o("LocateBetween does not support Polygons and Envelopes."),t.isEmpty()||!t.hasAttribute(this.m_attribute))return new h({vd:t.getDescription()});if(u(e))return this.processSegment(t);switch(e){case s.enumPoint:return this.processPoint(t);case s.enumMultiPoint:return this.processMultiPoint(t);case s.enumPolyline:return this.processPolyline(t);default:l("LocateBetween")}}processPoint(t){const e=t.getAttributeAsDbl(this.m_attribute,this.m_ord);return this.m_interval.containsCoordinate(e)?new g({point:t}):new h({vd:t.getDescription()})}processMultiPoint(t){let e=null,n=-1;const r=t.getAttributeStreamRef(this.m_attribute),s=p.getComponentCount(this.m_attribute);for(let o=0,i=0,u=t.getPointCount();o<u;++o,i+=s){const s=r.readAsDbl(i);this.m_interval.containsCoordinate(s)?-1===n&&(n=o):n>=0&&(e||(e=new g({vd:t.getDescription()})),e.addPoints(t,n,o),n=-1)}return n>=0&&(e||(e=new g({vd:t.getDescription()})),e.addPoints(t,n,-1)),e||new h({vd:t.getDescription()})}processPolyline(t){const e=t.queryInterval(this.m_attribute,this.m_ord);if(this.m_interval.contains(e))return t;if(!this.m_interval.isIntersecting(e))return new h({vd:t.getDescription()});let n=null,r=null;const o=t.querySegmentIterator(),i=new d,u=new h,l=new h,a=new h;let m=!0,c=!1;for(;o.nextPath();)for(m=!0,c=!1;o.hasNextSegment();){const t=o.nextSegment(),e=[null],p=this.processSegmentHelper(t,i,e,u);if(p!==s.enumUnknown)if(p===s.enumPoint){if(!m&&(r.getPointByVal(r.getPointCount()-1,l),l.equals(u)))continue;if(m=!0,c&&(t.queryStart(l),u.equals(l)))continue;t.queryEnd(l),c=u.equals(l),n?n.add(u):n=new g({point:u})}else p===s.enumLine&&(c=!1,r||(r=new y),m&&(null===n||n.isEmpty()||(n.getPointByVal(n.getPointCount()-1,l),e[0].queryStart(u),l.equals(u)&&n.removePoint(n.getPointCount()-1))),r.addSegment(e[0],m),t.queryEnd(l),e[0].queryEnd(a),m=!l.equals(a));else m=!0,c=!1}if(null!==n&&n.isEmpty()&&(n=null),null!==n&&null!==r){const t=new _;return t.addGeometry(r),t.addGeometry(n),t}return null!==n?n:null!==r?r:new h({vd:t.getDescription()})}processSegment(t){return n(0),{}}processGeometryCollection(t){if(t.isEmpty()||!t.hasAttribute(this.m_attribute))return new h({vd:t.getDescription()});const e=c(t),n=new _;for(let r=e.next();null!==r;r=e.next()){const t=this.processGeometry(r);t.isEmpty()||n.addGeometry(t)}return n.isEmpty()?new h({vd:t.getDescription()}):n}processSegmentHelper(t,e,n,r){const o=t.getAttributeAsDbl(0,this.m_attribute,this.m_ord),i=t.getAttributeAsDbl(1,this.m_attribute,this.m_ord),u=Number.isNaN(o)?i:o,l=Number.isNaN(i)?o:i,c=new a;c.setCoords(u,l);const p=c.clone();if(p.intersect(this.m_interval),p.isEmpty())return s.enumUnknown;if(c.equals(p))return n[0]=t,s.enumLine;const h=l-u,g=t.calculateLength2D();if(0===p.width()){const e=(p.vmin-u)/h,n=1===e?1:t.lengthToT(e*g);return t.queryCoord(n,r),s.enumPoint}let d=(p.vmin-u)/h,y=(p.vmax-u)/h;return d>y&&(y=m(d,d=y)),d=1===d?1:t.lengthToT(d*g),y=1===y?1:t.lengthToT(y*g),t.queryCut(d,y,e),n[0]=e.get(),s.enumLine}}class C{getOperatorType(){return 10801}accelerateGeometry(t,e,n){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,n){return new v(t,e,n)}}class v extends t{constructor(t,e,n){super(),this.m_collectionCursor=null,this.m_interval=e,this.m_progressTracker=n,this.m_inputGeoms=t,this.m_index=-1}tock(){return n(0),!1}getRank(){return n(0),0}next(){if(this.m_collectionCursor){const t=this.m_collectionCursor.next();if(t)return t;this.m_collectionCursor=null}const t=this.m_inputGeoms.next();if(null===t)return null;r(t),this.m_index=this.m_inputGeoms.getGeometryID();const e=f(t,2,0,this.m_interval,this.m_progressTracker);if(e.getGeometryType()===s.enumGeometryCollection){this.m_collectionCursor=c(e);return this.m_collectionCursor.next()}return e}getGeometryID(){return this.m_index}}const b=new C;function G(t,n){const r=b.executeMany(new e(t),n,null);return Array.from(r)}function P(){return b.supportsCurves()}export{G as executeMany,P as supportsCurves};
