/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{G as t,S as e}from"../../../chunks/SimpleGeometryCursor.js";import{g as s,t as r}from"../../../chunks/Geometry.js";import{b5 as n,t as i,b6 as o,b7 as a,b8 as l,b as u,e as h,b9 as m,j as c,a as p,P as _,z as g,ba as f,n as y}from"../../../chunks/QuadraticBezier.js";import{K as d,f as x,T,E as A,d as E,P as v,s as N,l as S}from"../../../chunks/Transformation2D.js";import{O as w}from"../../../chunks/OperatorMultiPartToSinglePart.js";import{O as C}from"../../../chunks/OperatorCut.js";function b(t,e,s,r,n){return new L(n).findSlicesByArea(t,e,s,r)}function X(t,e,s,r,n){return new L(n).sliceIntoStrips(t,e,s,r)}function H(t,e,s,r){return new L(r).recursiveSliceEqualArea(t,e,s)}function P(t){this.currentX=this.calcX(t)}function k(t){if(null===this.curve){const e=(t-this.y0)/(this.y1-this.y0);return S(this.x0,this.x1,e)}return this.curve.intersectionOfYMonotonicWithAxisX(t,this.x0)}function Y(){return{x0:Number.NaN,y0:Number.NaN,x1:Number.NaN,y1:Number.NaN,currentX:Number.NaN,nextAET:null,prevAET:null,startNodeNext:null,nextInChain:null,curve:null,advance:P,calcX:k}}function I(t,e){const s=Y();return s.x0=t.getStartX(),s.y0=t.getStartY(),s.x1=t.getEndX(),s.y1=t.getEndY(),e&&(s.y0=N(s.x0,s.x0=s.y0),s.y1=N(s.x1,s.x1=s.y1)),s.y1<s.y0&&(s.y1=N(s.y0,s.y0=s.y1),s.x1=N(s.x0,s.x0=s.x1)),s.currentX=Number.NaN,s.nextAET=null,s.prevAET=null,s.startNodeNext=null,s.nextInChain=null,s.curve=null,s}function O(t){const e=Y();return e.x0=t.getStartX(),e.y0=t.getStartY(),e.x1=t.getEndX(),e.y1=t.getEndY(),e.curve=t,e.y1<e.y0&&(e.y1=N(e.y0,e.y0=e.y1),e.x1=N(e.x0,e.x0=e.x1)),e.currentX=Number.NaN,e.nextAET=null,e.prevAET=null,e.startNodeNext=null,e.nextInChain=null,e}function q(t){if(this.x===t.x&&this.y===t.y){const e=null!==this.endEdge,s=null!==t.startEdge;return e&&s?-1:1}return this.y!==t.y?this.y-t.y:this.x-t.x}function R(){return{x:Number.NaN,y:Number.NaN,startEdge:null,endEdge:null,compare:q}}function M(t,e){return{y:t,startingEdges:e}}class B{constructor(t,e,s,r,n,i){this.m_parent=t,this.m_y0=e,this.m_y1=s,this.m_t0=r,this.m_area=i}getMaxDerivative(){return 1}getValue(t,e){return 1===t?0:this.getArea(e)-this.m_area}getError(t){return s(0),0}getArea(t){const e=.5*(this.m_parent.m_sumBase-this.m_parent.m_sumA),s=this.m_y1-this.m_y0;let r=(this.m_parent.m_sumBase-e*(t+this.m_t0))*s*(t-this.m_t0),n=!1;for(let i=this.m_parent.m_AETHead;null!==i;i=i.nextAET)if(n=!n,n&&(null!==i.curve||null!==i.nextAET.curve)){const e=this.m_y0+s*this.m_t0,n=this.m_y0+s*t;i.curve&&(r+=z(i.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),i.nextAET.curve&&(r-=z(i.nextAET.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t));r+=(n-e)*(i.nextAET.calcX(e)-i.calcX(e)+(i.nextAET.calcX(n)-i.calcX(n)))*.5}return r}}function D(t,e,s){return{polygon:t,from:e,to:s}}function z(t,e,r){const n=[0,0],i=t.intersectionWithAxis2D(!0,e,null,n);s(1===i);const o=n[0],a=t.intersectionWithAxis2D(!0,r,null,n);s(1===a);const l=n[0],u=E(v,4);f(t,u,!0);const h=u[3],m=u[2],c=u[1],p=t.getCoordX(o)-t.getStartX(),_=t.getCoordY(o)-t.getStartY(),g=t=>{const e=t*t;return e*t*(10*(m.x*c.y-m.y*c.x)-15*t*(h.y*c.x-h.x*c.y)+6*e*(m.y*h.x-h.y*m.x))/60},y=t=>(-t*(c.y+t*(m.y+h.y*t))*p+t*(c.x+t*(m.x+h.x*t))*_)/2;return g(l)-g(o)-(y(l)-y(o))}class V extends t{constructor(t){super(),this.m_geoms=[],this.m_index=-1,this.m_id=-1,this.m_geoms=t}tock(){return!0}getRank(){return 1}next(){return this.m_index++,this.m_index>=this.m_geoms.length?null:(this.m_id=this.m_geoms[this.m_index].second,this.m_geoms[this.m_index].first)}getGeometryID(){return this.m_id}}class L{constructor(t){this.m_edges=[],this.m_curves=[],this.m_sortedNodes=[],this.m_sortHelper=[],this.m_cuts=[],this.m_cutAreas=[],this.m_totalAreaOfTraps=new d(0),this.m_areaTracking=0,this.m_splitArea=0,this.m_sumBase=0,this.m_sumA=0,this.m_numberOfCuts=0,this.m_currentScan=0,this.m_progressCounter=0,this.m_AETHead=null,this.m_bHorizontalSweep=!1,this.m_bPolygonHasCurves=!1,this.m_progressTracker=t}findSlicesByArea(t,e,s,i){i<0&&r("remainingArea");let o=t,a=null;o.hasNonLinearSegments()&&(this.m_bPolygonHasCurves=!0,a=n(t,1e-16,!0),G(a),o=a);const l=Math.abs(o.calculateArea2D());return 0===l||0===s||i>=l||1===s&&0===i?[]:(this.m_splitArea=(l-i)/s,this.m_numberOfCuts=s-1,i>0&&this.m_numberOfCuts++,this.m_edges.length=0,this.m_sortedNodes.length=0,this.m_cuts.length=0,this.m_areaTracking=0,this.m_totalAreaOfTraps.reset(),this.m_curves.length=0,this.buildEdges(o),this.buildScanNodes(),this.trapezoidation(),this.m_cuts)}sliceIntoStrips(t,s,r,n){if(0===n)return new e([t]);const o=new i;t.queryLooseEnvelope(o);const a=o.width()+o.height();return new V(this.splitPolygon(t,s,o.xmin-a-1+1,o.xmax+a+1,r,n))}recursiveSliceEqualArea(t,r,n){if(n<=1||t.isEmpty())return new e([t]);{const e=[],o=[];o.push(x(t.clone(),n));let a=0,l=0;for(;o.length>0;){s(l++<2*n);const t=o.at(-1);if(o.pop(),1===t.second){e.push(x(t.first,a++));continue}const u=new i;t.first.queryEnvelope(u);const h=u.width()+u.height(),m=new T;m.setIdentity(),u.width()>u.height()&&(m.setRotateCcw90(),t.first.applyTransformation(m),m.transformEnvInPlace(u));const c=t.first.calculateArea2D(),p=c/t.second,_=c-Math.trunc(t.second/2)*p,g=new L(this.m_progressTracker).findSlicesByArea(t.first,r,1,_),f=new L(this.m_progressTracker).splitPolygon(t.first,r,u.xmin-h-1+1,u.xmax+h+1,g,1),y=f.length;if(s(y>0&&y<=2),!m.isIdentity()){const t=new T;t.setRotateCw90(),f[0].first.applyTransformation(t),2===y&&f[1].first.applyTransformation(t)}2===y?(o.push(x(f[1].first,t.second-Math.trunc(t.second/2))),o.push(x(f[0].first,Math.trunc(t.second/2)))):o.push(x(f[0].first,t.second))}return new V(e)}}recursiveSliceEqualAreaImpl(t,e,r,n){return s(0),{}}processTraps(t,e,s){s?this.processTrapsCurves(t,e):this.processTrapsLinear(t,e)}processTrapsLinear(t,e){let s=0,r=1;const n=.5*(this.m_sumBase-this.m_sumA),i=e-t,a=(this.m_sumBase-n*(r+s))*i*(r-s);if(a+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(a),void(this.m_areaTracking+=a);const l=new d(a),u=new A(0,1);let h=!1;for(;s<1;){const e=this.m_splitArea-this.m_areaTracking,m=[Number.NaN,Number.NaN];if(!(o(-n*i,this.m_sumBase*i,(n*s-this.m_sumBase)*i*s-e,u,!1,m)>0)){h?this.m_areaTracking=l.getResult():this.m_areaTracking+=a;break}{h=!0,r=m[0],this.m_areaTracking=0,s=r,l.me(e);const n=r*i+t;if(this.m_cuts.push(n),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+a-l.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(a-l.getResult())}}this.m_totalAreaOfTraps.pe(a)}processTrapsCurves(t,e){let s=0,r=1;const n=new B(this,t,e,0,1,0).getArea(1);if(n+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(n),void(this.m_areaTracking+=n);const i=e-t,o=new d(n);let l=!1;for(;s<1;){const u=this.m_splitArea-this.m_areaTracking,h=new B(this,t,e,s,1,u),m=[0],c=new A(s,1);if(!(a(h,c,1,m)>0)){l?this.m_areaTracking=o.getResult():this.m_areaTracking+=n;break}{l=!0,r=m[0],this.m_areaTracking=0,s=r,o.me(u);const e=r*i+t;if(this.m_cuts.push(e),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+n-o.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(n-o.getResult())}}this.m_totalAreaOfTraps.pe(n)}advanceAET(){const t=this.m_sortedNodes[this.m_currentScan-1].y,e=this.m_sortedNodes[this.m_currentScan];let s=!1,r=!1;const n=new d(0);for(let a=this.m_AETHead;null!==a;a=a.nextAET){const t=a.prevAET;s=!s,null!==a.nextAET&&s&&(this.m_bPolygonHasCurves&&(a.curve||a.nextAET.curve)||n.pe(a.nextAET.currentX-a.currentX)),a.advance(e.y),null!==t&&a.currentX<t.currentX&&(r=!0)}this.m_sumBase=n.getResult(),r&&this.sortAET();const i=new d(0);s=!1;let o=!1;for(let a=this.m_AETHead;null!==a;a=a.nextAET){o=o||null!==a.curve;s=!s,null!==a.prevAET&&(s||this.m_bPolygonHasCurves&&(a.curve||a.prevAET.curve)||i.pe(a.currentX-a.prevAET.currentX))}this.m_sumA=i.getResult(),this.processTraps(t,e.y,o);for(let a=this.m_AETHead;null!=a;){const t=a.prevAET,s=a.nextAET;if(e.y===a.y1)if(a.prevAET=null,a.nextAET=null,null!==a.nextInChain){const e=a.currentX;a=a.nextInChain,a.currentX=e,a.prevAET=t,t?t.nextAET=a:this.m_AETHead=a,a.nextAET=s,s&&(s.prevAET=a)}else t?t.nextAET=s:this.m_AETHead=s,s&&(s.prevAET=t);a=s}}mergeNewEdgesToAET(){for(let r=this.m_sortedNodes[this.m_currentScan].startingEdges;null!==r;r=r.startNodeNext)Number.isNaN(r.currentX)&&(this.m_sortHelper.push(r),r.currentX=r.x0);if(!this.m_sortHelper.length)return;this.sortHelper();let t=this.m_AETHead,e=0,s=t;for(;null!==t&&e<this.m_sortHelper.length;)t.currentX>this.m_sortHelper[e].currentX?(this.m_sortHelper[e].prevAET=t.prevAET,t.prevAET?t.prevAET.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=t,t.prevAET=this.m_sortHelper[e],e++):(s=t,t=t.nextAET);for(;e<this.m_sortHelper.length;)this.m_sortHelper[e].prevAET=s,null!==s?s.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=null,s=this.m_sortHelper[e],e++;this.m_sortHelper.length=0}sortAET(){for(let e=this.m_AETHead;null!==e;e=e.nextAET)this.m_sortHelper.push(e);this.sortHelper(),this.m_AETHead=null;let t=null;for(const e of this.m_sortHelper)e.prevAET=t,t?t.nextAET=e:this.m_AETHead=e,e.nextAET=null,t=e;this.m_sortHelper.length=0}sortHelper(){this.m_sortHelper.sort(((t,e)=>t.currentX-e.currentX))}trapezoidation(){for(this.m_currentScan=0,this.mergeNewEdgesToAET(),this.m_currentScan++;this.m_currentScan<this.m_sortedNodes.length&&(this.progress(),this.advanceAET(),this.m_cuts.length!==this.m_numberOfCuts);)this.mergeNewEdgesToAET(),this.m_currentScan++}buildEdges(t){const e=t.querySegmentIterator();for(e.stripAttributes();e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(t.isCurve()){const e=t;if(l(e),this.m_bHorizontalSweep){const t=E(v,4);e.queryControlPoints(t);for(const e of t)e.y=N(e.x,e.x=e.y);e.constructPoints(t)}const s=e.getStartY(),r=e.getEndY();if(r===s)continue;r<s&&e.reverse(),this.m_curves.push(e.clone()),this.m_edges.push(O(this.m_curves.at(-1)))}else{const e=this.m_bHorizontalSweep?t.getStartX():t.getStartY();if((this.m_bHorizontalSweep?t.getEndX():t.getEndY())===e)continue;this.m_edges.push(I(t,this.m_bHorizontalSweep))}}this.m_edges.sort(((t,e)=>t.y0===e.y0?t.x0-e.x0:t.y0-e.y0))}buildScanNodes(){const t=[];for(const n of this.m_edges){const e=R();e.x=n.x0,e.y=n.y0,e.startEdge=n,e.endEdge=null,t.push(e);const s=R();s.x=n.x1,s.y=n.y1,s.startEdge=null,s.endEdge=n,t.push(s)}t.sort(((t,e)=>t.compare(e)));let e=0,s=t[e].y;this.m_sortedNodes.push(M(s,t[e].startEdge));let r=e;for(e++;e!==t.length;++e){t[e].y!==s&&(this.m_sortedNodes.push(M(t[e].y,null)),s=t[e].y);const n=t[e].startEdge;if(n){const t=this.m_sortedNodes.at(-1);n.startNodeNext=t.startingEdges,t.startingEdges=n}if(t[r].x!==t[e].x||t[r].y!==t[e].y){if(e-r==2){let e=r;e++,null!==t[r].endEdge&&null!==t[e].startEdge&&(t[r].endEdge.nextInChain=t[e].startEdge)}r=e}}}progress(){}splitPolygonLinear(t,r,n,o,a,l){const h=[];h.push([t,0,l]);const m=[],c=new u;for(c.startPathCoords(n,0),c.lineToCoords(o,0);h.length>0;){const u=h.at(-1);h.pop();const p=u[0],_=u[1],g=u[2],f=(new w).executeMany(new e([p]),r,this.m_progressTracker);for(let e=f.next();null!==e;e=f.next()){const u=e,p=new i;u.queryLooseEnvelope(p);let f=_,y=g;for(let t=_,e=g-1;t<g;++t,--e)p.ymin>=a[t]&&(f=t+1),p.ymax<=a[e]&&(y=e);if(f!==g)if(y!==_)if(f!==y)if(this.isYMonotone(u))this.splitYMonotone(m,u,r,a,f,y);else{const e=Math.trunc((f+y)/2);c.setXYCoords(0,n,a[e]),c.setXYCoords(1,o,a[e]);const _=(new C).execute(!1,u,c,null,this.m_progressTracker),g=_.next(),d=_.next(),T=_.next();if(null!==g){if(g.isEmpty()||(e===y-1?(m.push(x(g,e)),s(j(m.at(-1).first,r,t,m.at(-1).second,a,l))):h.push([g,e+1,y])),d.isEmpty()||(e===f?(m.push(x(d,e-1)),s(j(m.at(-1).first,r,t,m.at(-1).second,a,l))):h.push([d,f,e])),null!==T&&!T.isEmpty()){const t=new i;T.queryLooseEnvelope(t),t.ymin>=a[e]?h.push([T,e+1,y]):t.ymax<=a[e]?h.push([T,f,e]):h.push([T,f,y])}}else e+1===y?(a[e]-p.ymin<p.ymax-a[e]?m.push(x(u,e)):m.push(x(u,e+1)),s(j(m.at(-1).first,r,t,m.at(-1).second,a,l))):h.push([u,e+1,y])}else m.push(x(e,f-1));else m.push(x(e,_-1));else m.push(x(e,g-1))}}return m}splitPolygon(t,e,s,r,n,o){const a=new i;t.queryLooseEnvelope(a),a.inflateCoords(0,Math.max(a.width(),a.height()));const l=[],u=[];for(u.push(D(t,0,o));u.length;){const o={...u.at(-1)};if(u.pop(),o.polygon.hasNonLinearSegments()){const t=Math.trunc((o.to+o.from)/2),m=n[t],c=new i(s,a.ymin,r,m),p=(new h).execute(o.polygon,c,e,this.m_progressTracker);p.isEmpty()||(t-o.from==0?l.push(x(p,t-1)):u.push(D(p,o.from,t)));const _=new i(s,m,r,a.ymax),g=(new h).execute(o.polygon,_,e,this.m_progressTracker);g.isEmpty()||(o.to-t==1?l.push(x(g,t)):u.push(D(g,t+1,o.to)))}else{const i=this.splitPolygonLinear(t,e,s,r,n.slice(o.from),o.to-o.from);l.push(...i)}}l.sort(((t,e)=>t.second-e.second));const c=[];return m(l,((t,e)=>t.second===e.second),((t,e)=>{const s=new p;for(let r=t;r!==e;++r)s.add(l[r].first,!1);c.push(x(s,l[t].second))})),c}isYMonotone(t){if(1!==t.getPathCount())return!1;const e=t.getXY(0);let s=0,r=0;const n=new v;for(let i=1,o=t.getPointCount();i<=o;i++){t.queryXY(i===o?0:i,n);const a=n.y>e.y?1:n.y<e.y?-1:0;if(e.setCoordsPoint2D(n),s!==a&&0!==a){if(0!==s&&(r++,r>2))return!1;s=a}}return!0}splitYMonotone(t,e,r,n,i,o){const a=new c;a.addGeometry(e);const l=a.getFirstPath(a.getFirstGeometry()),u=a.getFirstVertex(l),h=new v,m=new v;let p=u,_=u;{const t=a.getXY(u);h.setCoordsPoint2D(t),m.setCoordsPoint2D(t)}let g=a.getNextVertex(u);const f=new v;for(let s=0,c=a.getPathSize(l);s<c;s++,g=a.getNextVertex(g))a.queryXY(g,f),f.compare(h)<0?(p=g,h.setCoordsPoint2D(f)):f.compare(m)>0&&(_=g,m.setCoordsPoint2D(f));let d=p,T=p,A=d,E=T,N=!1,S=!1,w=i,C=h.y,b=h.y,X=!1;for(;w<o;)if(n[w]<=h.y)w++;else{if(n[w]>=m.y)break;if(!N){const t=a.getNextVertex(d),e=a.getY(t);if(e<C)break;const s=n[w];C<=s&&e>=s?N=!0:(C=e,d=t)}if(!S){const t=a.getPrevVertex(T),e=a.getY(t);if(e<b)break;const s=n[w];b<=s&&e>=s?S=!0:(b=e,T=t)}if(N&&S){X=!0;let e=a.getXY(d);const r=a.getNextVertex(d);let i=a.getXY(r),o=y;if(i.y===e.y)o=i.x<e.x?d:r;else{const t=(n[w]-e.y)/(i.y-e.y);if(0===t)o=d;else if(1===t)o=r;else{const e=a.splitSegmentAxisAware(d,[t],1,null,-1);s(1===e),o=a.getNextVertex(d),a.getY(o)!==n[w]&&a.setXYCoords(o,a.getX(o),n[w])}}const l=a.getPrevVertex(T);e=a.getXY(l),i=a.getXY(T);let u=y;if(i.y===e.y)u=i.x<e.x?T:l;else{const t=(n[w]-e.y)/(i.y-e.y);if(0===t)u=l;else if(1===t)u=T;else{const e=a.splitSegmentAxisAware(l,[t],1,null,-1);s(1===e),u=a.getNextVertex(l),a.getY(u)!==n[w]&&a.setXYCoords(u,a.getX(u),n[w])}}t.push(x(this.extractTrapezoid(a,A,o,E,u),w-1)),A=o,E=u,d=o,T=u,C=b=n[w],N=!1,S=!1,w++}}X?t.push(x(this.extractTrapezoid(a,A,_,E,_),w-1)):t.push(x(e,w))}extractTrapezoid(t,e,s,r,n){const i=new p({vd:t.getVertexDescription()}),o=new _;let a=!0;for(let l=e;;l=t.getNextVertex(l)){const e=t.getSegment(l);if(e?i.addSegment(e,a):(t.queryPoint(l,o),a?i.startPathPoint(o):i.lineToPoint(o)),a=!1,l===s)break}s!==n&&(t.queryPoint(n,o),i.lineToPoint(o)),a=!0;for(let l=n;;l=t.getNextVertex(l)){const s=t.getSegment(l);if(s?i.addSegment(s,a):a||l===e||(t.queryPoint(l,o),i.lineToPoint(o)),a=!1,l===r)break}return i}}function G(t){return t.getImpl().ensureXYMonotoneSegments()}function j(t,e,s,r,n,o){const a=new i;t.queryEnvelope(a);const l=4*g(e,s,!0).total();return(!(r>=0)||a.ymin+l>=n[r])&&!(r+1<o&&a.ymax>n[r+1]+l)}class F{getOperatorType(){return 10011}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}sliceIntoStrips(t,e,s,r,n,i){return new W(0,t,e,s,n,0,i)}findSlicesByArea(t,e,s,r,n,i){if(!n||n.isIdentity())return b(t,e,s,r,i);{const o=t.clone();return o.applyTransformation(n),b(o,e,s,r,i)}}recursiveSliceEqualArea(t,e,s,r,n){return new W(1,t,e,null,r,s,n)}}class W extends t{constructor(t,e,s,r,n,i,o){super(),this.m_resultCursor=null,this.m_method=t,this.m_polygon=e,this.m_sr=s,this.m_ySplits=r?.slice()??null,this.m_transform=n,this.m_bReversePaths=n?.isReflective()??!1,this.m_inverseTransform=n?n.clone().invertThis():null,this.m_partCount=i,this.m_tracker=o}tock(){return!0}getRank(){return 1}next(){this.m_resultCursor||(this.m_method?this.recursiveSliceEqualArea():this.sliceIntoStrips());const t=this.m_resultCursor.next();return t?(this.m_inverseTransform&&!this.m_inverseTransform.isIdentity()&&(t.applyTransformation(this.m_inverseTransform),this.m_bReversePaths&&t.reverseAllPaths()),t):t}getGeometryID(){return s(0),-1}sliceIntoStrips(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=X(this.m_polygon,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=X(t,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker)}}recursiveSliceEqualArea(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=H(this.m_polygon,this.m_sr,this.m_partCount,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=H(t,this.m_sr,this.m_partCount,this.m_tracker)}}}const K=new F;function Q(t,e,s,r,n){return K.findSlicesByArea(t,e,s,r,n,null)}function J(t,e,s,r){const n=K.recursiveSliceEqualArea(t,e,s,r,null);return Array.from(n)}function U(t,e,s,r){const n=K.sliceIntoStrips(t,e,s,0,r,null);return Array.from(n)}function Z(){return K.supportsCurves()}export{Q as findSlicesByArea,J as recursiveSliceEqualArea,U as sliceIntoStrips,Z as supportsCurves};
