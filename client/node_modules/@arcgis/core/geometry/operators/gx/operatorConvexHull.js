/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{G as t,S as e}from"../../../chunks/SimpleGeometryCursor.js";import{k as n,a as r,G as o,c as u,t as i}from"../../../chunks/Geometry.js";import{aF as s,aG as m,aH as a,P as c,b as g,t as y,a as l,aI as f,aJ as p}from"../../../chunks/QuadraticBezier.js";class x{getOperatorType(){return 10102}supportsCurves(){return!1}accelerateGeometry(t,e,n){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,n){return new C(e,t,n)}execute(t,e){return G(t)}isConvex(t,e){if(n(t),r(t),t.isEmpty())return!0;const i=t.getGeometryType();if(i===o.enumPoint)return!0;if(i===o.enumEnvelope){const e=t;return e.getXMin()!==e.getXMax()&&e.getYMin()!==e.getYMax()}if(u(i)){const e=t;return!e.getStartXY().equals(e.getEndXY())}if(i===o.enumMultiPoint){return 1===t.getPointCount()}if(i===o.enumPolyline){const e=t;return 1===e.getPathCount()&&2===e.getPointCount()&&!e.getXY(0).equals(e.getXY(1))}if(i===o.enumGeometryCollection){const n=t;return 1===n.getGeometryCount()&&this.isConvex(n.getGeometry(0),e)}const m=t;return!(1!==m.getPathCount()||m.getPointCount()<3)&&s(m,0)}constructOrientedMinimumBoundingBox(t,e,n,r,o){m(t,e,n,r,o)}}class C extends t{constructor(t,e,n){super(),e||i(""),this.m_progressTracker=n,this.m_index=-1,this.m_bMerge=t,this.m_bDone=!1,this.m_inputGeometryCursor=e}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge){if(!this.m_bDone){const t=h(this.m_inputGeometryCursor);return this.m_bDone=!0,t}return null}if(!this.m_bDone){const t=this.m_inputGeometryCursor.next();if(null!==t)return n(t),r(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),G(t);this.m_bDone=!0}return null}}function h(t,e){const o=new a;let u;for(;u=t.next();)n(u),r(u),o.addGeometry(u);return o.getBoundingGeometry()}function G(t,e){if(t||i(""),n(t),r(t),t.isEmpty())return t.createInstance();const s=t.getGeometryType();if(u(s)){const e=t;if(e.getStartXY().equals(e.getEndXY())){const t=new c;return e.queryStart(t),t}{const n=new c,r=new g({vd:t.getDescription()});return e.queryStart(n),r.startPathPoint(n),e.queryEnd(n),r.lineToPoint(n),r}}if(s===o.enumEnvelope){const e=t,n=new y;if(e.queryEnvelope(n),n.xmin===n.xmax&&n.ymin===n.ymax){const t=new c;return e.queryCornerByVal(0,t),t}if(n.xmin===n.xmax||n.ymin===n.ymax){const n=new c,r=new g({vd:t.getDescription()});return e.queryCornerByVal(0,n),r.startPathPoint(n),e.queryCornerByVal(1,n),r.lineToPoint(n),r}{const n=new l({vd:t.getDescription()});return n.addEnvelope(e,!1),n}}if(s===o.enumGeometryCollection)return h(f(t,-1));if(P(t)){if(s===o.enumMultiPoint){const e=t,n=new c;return e.getPointByVal(0,n),n}return t}return p(t)}function P(t,e){if(n(t),r(t),t.isEmpty())return!0;const i=t.getGeometryType();if(i===o.enumPoint)return!0;if(i===o.enumEnvelope){const e=t;return e.getXMin()!==e.getXMax()&&e.getYMin()!==e.getYMax()}if(u(i)){const e=t;return!e.getStartXY().equals(e.getEndXY())}if(i===o.enumMultiPoint){return 1===t.getPointCount()}if(i===o.enumPolyline){const e=t;return 1===e.getPathCount()&&2===e.getPointCount()&&!e.getXY(0).equals(e.getXY(1))}if(i===o.enumGeometryCollection){const e=t;return 1===e.getGeometryCount()&&P(e.getGeometry(0))}const m=t;return!(1!==m.getPathCount()||m.getPointCount()<3)&&s(m,0)}const d=new x;function M(t){return d.execute(t,null)}function _(t,n){const r=d.executeMany(new e(t),n,null);return Array.from(r)}function X(t){return d.isConvex(t,null)}function Y(t,e,n,r,o){return d.constructOrientedMinimumBoundingBox(t,e,n,r,o)}function v(){return d.supportsCurves()}export{Y as constructOrientedMinimumBoundingBox,M as execute,_ as executeMany,X as isConvex,v as supportsCurves};
