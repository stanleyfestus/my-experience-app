/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{G as e,S as t}from"../../../chunks/SimpleGeometryCursor.js";import{g as n,a as r,t as o,G as s}from"../../../chunks/Geometry.js";import{P as a,t as i,h as l,a as u,aV as c,q as m,L as N}from"../../../chunks/QuadraticBezier.js";import{P as g,l as y,o as h,d as P}from"../../../chunks/Transformation2D.js";import{a as d}from"../../../chunks/Centroid-DZi-eb9F.js";import{O as x}from"../../../chunks/OperatorProximity.js";class f{getOperatorType(){return 10203}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t){return new p(e,t)}execute(e,t){return new p(null,t).labelPoint(e)}}class p extends e{progress_(){}tock(){return n(0),!1}getRank(){return n(0),0}constructor(e,t){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=t,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(r(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(null===e&&o("null pointer is not allowed"),e.getGeometryType()===s.enumPoint)return e;if(e.isEmpty())return new a({vd:e.getDescription()});switch(e.getGeometryType()){case s.enumPolygon:return this.labelPointPolygon(e);case s.enumPolyline:return this.labelPointPolyline(e);case s.enumMultiPoint:return this.labelPointMultiPoint(e);case s.enumEnvelope:return this.labelPointEnvelope(e);default:o("geometry is not supported")}}labelPointPolygon(e){const t=new i;e.queryEnvelope(t);const r=l(null,t,!0).total();let o=null,s=e;if(e.hasNonLinearSegments()){const t=new u({copy:e}),a=c(t,.25*r,r);n(a!==e),o=a,s=o}let N=0,P=0;for(let n=0,a=s.getPathCount();n<a;++n){const e=Math.abs(s.calculateRingArea2D(n));e>P&&(P=e,N=n)}const f=new g;if(Math.abs(P)<=2*r*r?f.setNAN():f.assign(d(s,N)),Number.isNaN(f.x)){const e=new i;return s.queryPathEnvelope(N,e),new a({pt:e.getCenter()})}if(s.getPointCount()<4)return new a({x:f.x,y:f.y});const p=g.getNAN(),w=[p.clone(),p.clone(),p.clone(),p.clone()],b=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],C=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let _=!1,D=(new x).getNearestCoordinate(s,f,!0,!1);if(0===D.m_distance&&(_=!0,w[0]=f,D=(new x).getNearestCoordinate(s,f,!1,!1),D.m_distance>.25*t.minDimension()*1.66666666))return new a({x:f.x,y:f.y});b[0]=D.m_distance,C[0]=0;const A=new g;let E=!1,k=.25,q=-1;const G=new i;s.queryPathEnvelope(N,G);do{let e=Number.NaN;if(w[1]=this.calculateParacentroid_(s,y(G.xmin,G.xmax,k),r),w[1].isNAN()||(D=(new x).getNearestCoordinate(s,w[1],!1,!1),e=D.m_distance),e>r&&1===m(s,w[1],r))E=!0,b[1]=e,C[1]=g.sqrDistance(w[1],f);else if(e>q&&(q=e,A.setCoordsPoint2D(w[1])),k-=.01,k<.1){if(!(q>=0))break;E=!0,b[1]=q,w[1]=A,C[1]=g.sqrDistance(w[1],f)}}while(!E);E=!1,k=.5,q=-1;let M=.01,S=1;do{let e=Number.NaN;if(w[2]=this.calculateParacentroid_(s,y(G.xmin,G.xmax,k),r),w[2].isNAN()||(D=(new x).getNearestCoordinate(s,w[2],!1,!1),e=D.m_distance),e>r&&1===m(s,w[2],r))E=!0,b[2]=e,C[2]=g.sqrDistance(w[2],f);else if(e>q&&(q=e,A.setCoordsPoint2D(w[2])),k=.5+M*S,M+=.01,S*=-1,k<.3||k>.7){if(!(q>=0))break;E=!0,b[2]=q,w[2]=A,C[2]=g.sqrDistance(w[2],f)}}while(!E);E=!1,k=.75,q=-1;do{let e=Number.NaN;if(w[3]=this.calculateParacentroid_(s,y(G.xmin,G.xmax,k),r),w[3].isNAN()||(D=(new x).getNearestCoordinate(s,w[3],!1,!1),e=D.m_distance),e>r&&1===m(s,w[3],r))E=!0,b[3]=e,C[3]=g.sqrDistance(w[3],f);else if(e>q&&(q=e,A.setCoordsPoint2D(w[3])),k+=.01,k>.9){if(!(q>=0))break;E=!0,b[3]=q,w[3]=A,C[3]=g.sqrDistance(w[3],f)}}while(!E);const v=[0,1,2,3],X=_?0:1;for(let n=X;n<4;n++)for(let e=X;e<3;e++){const t=C[e],n=C[e+1];if(h(t,n)>0){const r=v[e];v[e]=v[e+1],v[e+1]=r,C[e]=n,C[e+1]=t}}let L=X,T=0,j=0;for(let n=X;n<4;n++){switch(n){case 0:j=2*b[v[n]];break;case 1:j=1.66666666*b[v[n]];break;case 2:j=1.33333333*b[v[n]];break;case 3:j=b[v[n]]}j>T&&(T=j,L=v[n])}return n(!w[L].isNAN()),new a({x:w[L].x,y:w[L].y})}labelPointPolyline(e){const t=new g;if(e.getPointCount()>2*e.getPathCount()){let n=-1,r=-Number.MAX_VALUE;for(let t=0,i=e.getPathCount();t<i;t++)if(e.getPathSize(t)>2){const o=e.calculatePathLength2D(t);o>r&&(r=o,n=t)}const o=e.getPathStart(n),s=e.getPathEnd(n),a=Math.trunc((o+s)/2);t.assign(e.getXY(a))}else{let n=-Number.MAX_VALUE;const r=e.querySegmentIterator();for(;r.nextPath();)if(r.hasNextSegment()){const e=r.nextSegment(),o=e.calculateLength2D();o>n&&(n=o,t.assign(e.getCoord2D(e.lengthToT(.5*o))))}}return new a({x:t.x,y:t.y})}labelPointMultiPoint(e){const t=new i;e.queryEnvelope(t);const n=t.getCenter(),r=(new x).getNearestCoordinate(e,n,!1,!1).m_coordinate;return new a({x:r.x,y:r.y})}labelPointEnvelope(e){const t=e.getCenterXY();return new a({x:t.x,y:t.y})}calculateParacentroid_(e,t,r){const o=new i;e.queryEnvelope(o);const s=new g(t,0);let a=Number.MAX_VALUE,l=Number.MAX_VALUE,u=!1,c=!1;const m=new N;m.setStartXYCoords(s.x,o.ymin-1),m.setEndXYCoords(s.x,o.ymax+1);const y=new i,h=new g,d=new g,x=P(g,2),f=e.querySegmentIterator();for(;f.nextPath();)for(;f.hasNextSegment();){const e=f.nextSegment();if(e.queryEnvelope(y),n(e.isMonotoneQuickAndDirty()),h.setCoordsPoint2D(m.getStartXY()),d.setCoordsPoint2D(m.getEndXY()),0===y.clipLine(h,d))continue;if(1!==m.intersect(e,x,null,null,r))continue;const t=x[0].y;a>l?t<a&&(a=t,u=!0):t<l&&(l=t,c=!0)}return u&&c?s.y=(a+l)/2:s.setNAN(),s}}const w=new f;function b(e){return w.execute(e,null)}function C(e){const n=w.executeMany(new t(e),null);return Array.from(n)}function _(){return w.supportsCurves()}export{b as execute,C as executeMany,_ as supportsCurves};
