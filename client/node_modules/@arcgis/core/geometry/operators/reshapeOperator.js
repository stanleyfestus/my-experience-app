/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{d as e,k as t,G as r,e as s}from"../../chunks/Geometry.js";import{t as a,h as n,b as m,S as i,P as o,a as h,x as l}from"../../chunks/QuadraticBezier.js";import{getSpatialReference as c,fromGeometry as u,fromPolyline as g,fromSpatialReference as d,toGeometry as _}from"./support/converterAPI.js";function x(s,i,o,h){if(i.getPathCount()>1&&e(""),s.isEmpty()||i.isEmpty())return null;t(s),t(i);let l=null;const c=new a;s.queryEnvelope(c);const u=new a;i.queryEnvelope(u);const g=new a;g.setCoords({env2D:c}),g.mergeEnvelope2D(u);const d=n(o,g,!1).total(),_=new A(h);let x=_.setIndicesAndScalars(s,i,d);if(x){const e=_.getTrimmedPolyline(s,i);if(e.isEmpty())return null;l=_.getReshapedMultiPath(s,e,o)}else{if(Number.isNaN(_.m_scalarB0)||s.getGeometryType()===r.enumPolyline)return null;const e=new m;if(e.add(i,!0),_.clearIndicesAndScalars(),x=_.setIndicesAndScalars(s,e,d),!x)return null;const t=_.getTrimmedPolyline(s,e);if(t.isEmpty())return null;l=_.getReshapedMultiPath(s,t,o)}return l}class A{constructor(e){this.m_progressTracker=e,this.clearIndicesAndScalars()}setIndicesAndScalars(e,t,s){const n=new a,m=new a;e.queryEnvelope(n),e.queryEnvelope(m),n.inflateCoords(s,s);if(!n.intersect(m))return!1;const i=e.getImpl().querySegmentIterator(),o=t.getImpl().querySegmentIterator(),h=[0,0],l=[0,0];let c=-1,u=-1,g=-1,d=-1,_=-1,x=-1,A=Number.NaN,p=Number.NaN,S=Number.NaN,y=Number.NaN;for(o.nextPath();o.hasNextSegment();){const e=o.nextSegment(),t=new a;for(e.queryEnvelope(t),t.inflateCoords(s,s),i.resetToFirstPath();i.nextPath();){for(;i.hasNextSegment();){const r=i.nextSegment(),n=new a;if(r.queryEnvelope(n),t.isIntersecting(n)){if(0!==e.intersect(r,null,l,h,s)&&(Number.isNaN(S)||l[0]<S)&&(c=i.getPathIndex(),g=i.getStartPointIndex(),_=o.getStartPointIndex(),A=h[0],S=l[0],0===S))break}}if(0===S)break}if(!Number.isNaN(S)&&1!==S)break}if(Number.isNaN(S))return!1;this.m_pathA0=c,this.m_vertexA0=g,this.m_vertexB0=_,this.m_scalarA0=A,this.m_scalarB0=S;const v=e.getGeometryType();for(o.resetToLastSegment();o.hasPreviousSegment();){const e=o.previousSegment(),t=new a;for(e.queryEnvelope(t),t.inflateCoords(s,s),v===r.enumPolygon?i.resetToPath(c):i.resetToFirstPath();i.nextPath();){for(;i.hasNextSegment();){const r=i.nextSegment(),n=new a;if(r.queryEnvelope(n),t.isIntersecting(n)){const t=e.intersect(r,null,l,h,s);if(0!==t&&(Number.isNaN(y)||l[t-1]>y)&&(o.getStartPointIndex()!==this.m_vertexB0||l[t-1]!==this.m_scalarB0)&&(u=i.getPathIndex(),d=i.getStartPointIndex(),x=o.getStartPointIndex(),p=h[t-1],y=l[t-1],1===y))break}}if(1===y)break;if(v===r.enumPolygon)break}if(!Number.isNaN(y))break}return!Number.isNaN(y)&&(this.m_pathA1=u,this.m_vertexA1=d,this.m_vertexB1=x,this.m_scalarA1=p,this.m_scalarB1=y,!0)}getTrimmedPolyline(e,t){const r=new i,s=t.createInstance();let a=!0;const n=t.getImpl().querySegmentIterator();if(n.resetToVertex(this.m_vertexB0,0),this.m_vertexB0>this.m_vertexB1)return s;if(this.m_vertexB0===this.m_vertexB1){n.nextSegment().queryCut(this.m_scalarB0,this.m_scalarB1,r,!1),s.addSegment(r.get(),!0)}else for(;;){const e=n.nextSegment(),t=n.getStartPointIndex();if(t===this.m_vertexB0)1!==this.m_scalarB0&&(e.queryCut(this.m_scalarB0,1,r,!1),s.addSegment(r.get(),a),a=!1);else{if(t===this.m_vertexB1){0!==this.m_scalarB1&&(e.queryCut(0,this.m_scalarB1,r),s.addSegment(r.get(),a),a=!1);break}s.addSegment(e,a)}}if(s.isEmpty())return s;if(e.getDescription().getAttributeCount()>1){const t=e.getImpl().querySegmentIterator(),r=new o,a=s.getPointCount();t.resetToVertex(this.m_vertexA0,this.m_pathA0);t.nextSegment().queryCoord(this.m_scalarA0,r),s.setPointByVal(0,r),t.resetToVertex(this.m_vertexA1,this.m_pathA1);t.nextSegment().queryCoord(this.m_scalarA1,r),s.setPointByVal(a-1,r),s.interpolateAttributesRange(0,0,0,a-1)}return s}getReshapedMultiPath(e,t,s){let a;return a=e.getGeometryType()===r.enumPolygon?this.getReshapedPolygon(e,t,s):this.getReshapedPolyline(e,t),a}getReshapedPolygon(e,t,r){const s=e.getImpl().querySegmentIterator();s.setCirculator(!0);const a=new i;new o;const n=new h({vd:e.getDescription()});if(n.addSegmentsFromPath(t,0,0,t.getSegmentCountPath(0),!0),s.resetToVertex(this.m_vertexA1,this.m_pathA0),this.m_vertexA1===this.m_vertexA0&&this.m_scalarA1<=this.m_scalarA0){s.nextSegment().queryCut(this.m_scalarA1,this.m_scalarA0,a),n.addSegment(a.get(),!1)}else{{const e=s.nextSegment();1!==this.m_scalarA1&&(e.queryCut(this.m_scalarA1,1,a),n.addSegment(a.get(),!1))}for(;;){const e=s.nextSegment();if(s.getStartPointIndex()===this.m_vertexA0){0!==this.m_scalarA0&&(e.queryCut(0,this.m_scalarA0,a),n.addSegment(a.get(),!1));break}n.addSegment(e,!1)}}const m=new h({vd:e.getDescription()}),c=t.clone();if(c.reversePath(0),m.addSegmentsFromPath(c,0,0,c.getSegmentCountPath(0),!0),s.resetToVertex(this.m_vertexA0,this.m_pathA0),this.m_vertexA0===this.m_vertexA1&&this.m_scalarA0<this.m_scalarA1){s.nextSegment().queryCut(this.m_scalarA0,this.m_scalarA1,a),m.addSegment(a.get(),!1)}else{{const e=s.nextSegment();1!==this.m_scalarA0&&(e.queryCut(this.m_scalarA0,1,a),m.addSegment(a.get(),!1))}for(;;){const e=s.nextSegment();if(s.getStartPointIndex()===this.m_vertexA1){0!==this.m_scalarA1&&(e.queryCut(0,this.m_scalarA1,a),m.addSegment(a.get(),!1));break}m.addSegment(e,!1)}}const u=Math.abs(n.calculateArea2D()),g=Math.abs(m.calculateArea2D());let d=e.createInstance();for(let i=0;i<e.getPathCount();i++)i===this.m_pathA0?u>=g?d.add(n,!1):d.add(m,!1):d.addPath(e,i,!0);return d=(new l).execute(d,r,!1,this.m_progressTracker),d}getReshapedPolyline(e,t){const r=e.getImpl().querySegmentIterator(),a=new m,n=new i;let o=!1,h=-1,l=Number.NaN;o=this.m_pathA0>this.m_pathA1||this.m_pathA0===this.m_pathA1&&(this.m_vertexA0>this.m_vertexA1||this.m_vertexA0===this.m_vertexA1&&this.m_scalarA0>this.m_scalarA1),o?(h=this.m_vertexA1,l=this.m_scalarA1,r.resetToPath(this.m_pathA1)):(h=this.m_vertexA0,l=this.m_scalarA0,r.resetToPath(this.m_pathA0));let c=!0;for(r.nextPath()||s("reshaper");;){const e=r.nextSegment();if(r.getStartPointIndex()===h){0!==l&&(e.queryCut(0,l,n),a.addSegment(n.get(),c),c=!1);break}a.addSegment(e,c),c=!1}if(o){const e=t.clone();e.reversePath(0),a.addSegmentsFromPath(e,0,0,e.getSegmentCount(),c)}else a.addSegmentsFromPath(t,0,0,t.getSegmentCount(),c);o?(l=this.m_scalarA0,r.resetToVertex(this.m_vertexA0,this.m_pathA0)):(l=this.m_scalarA1,r.resetToVertex(this.m_vertexA1,this.m_pathA1));{const e=r.nextSegment();1!==l&&(e.queryCut(l,1,n),a.addSegment(n.get(),!1))}for(;r.hasNextSegment();){const e=r.nextSegment();a.addSegment(e,!1)}const u=e.createInstance();let g=!1;for(let s=0;s<e.getPathCount();s++)s===this.m_pathA0||s===this.m_pathA1?g||(u.add(a,!1),g=!0):u.addPath(e,s,!0);return u}clearIndicesAndScalars(){this.m_pathA0=-1,this.m_pathA1=-1,this.m_vertexA0=-1,this.m_vertexA1=-1,this.m_vertexB0=-1,this.m_vertexB1=-1,this.m_scalarA0=Number.NaN,this.m_scalarA1=Number.NaN,this.m_scalarB0=Number.NaN,this.m_scalarB1=Number.NaN}}class p{getOperatorType(){return 10006}accelerateGeometry(e,t,r){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!1}execute(e,t,r,s){return x(e,t,r,s)}}const S=new p;function y(e,t){const r=c(e),s=S.execute(u(e),g(t),d(r),null);return _(s,r)}function v(){return S.supportsCurves()}export{y as execute,v as supportsCurves};
