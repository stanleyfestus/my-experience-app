/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import t from"../../../core/Logger.js";import{fromMat4 as e}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{create as r}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{fromRotationTranslationScaleOrigin as o,multiply as i,getScaling as n,scale as s,getTranslation as a,fromRotation as l}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{create as c}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{setAxisAngle as m}from"../../../core/libs/gl-matrix-2/math/quat.js";import{create as f}from"../../../core/libs/gl-matrix-2/factories/quatf64.js";import{i as p,u,q as g,t as x}from"../../../chunks/vec32.js";import{ONES as j,ZEROS as v,create as b}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import A from"../../Point.js";import{getSphericalPCPF as h}from"../../spatialReferenceEllipsoidUtils.js";import{computeTranslationToOriginAndRotation as R}from"../../projection/computeTranslationToOriginAndRotation.js";import{projectPointToVector as d}from"../../projection/projectPointToVector.js";import{create as y,angleRad as w,axis as q,fromMatrix as F}from"../axisAngleDegrees.js";import S from"../MeshTransform.js";import{isMeshWithRelativeVertexSpace as T}from"../meshVertexSpaceUtils.js";import{performGlobalOperation as U}from"./geographicUtils.js";import{logProjectionError as C,loadProjectErrorMessage as k,projectToPCPF as z,projectNormalToPCPF as L,projectTangentToPCPF as M,projectFromPCPF as P,projectNormalFromPCPF as V,projectTangentFromPCPF as D}from"./projection.js";import{projectPointToVertexSpace as E}from"./vertexSpaceConversion.js";const O=()=>t.getLogger("esri.geometry.support.meshUtils.rotate");function B(t,e,r){if(!t.vertexAttributes?.position||0===e[3])return;const{spatialReference:o,vertexSpace:i}=t,n=r?.origin??t.origin,s=r?.geographic,a=U(O,i,o,s);T(t)?G(t,e,n):a?H(t,e,n):I(t,e,n)}function G(t,e,r){t.transform??=new S;const{vertexSpace:l,transform:c,spatialReference:f}=t,[g,x,h]=l.origin,R=new A({x:g,y:x,z:h,spatialReference:f}),d=K;if(R.equals(r))p(d,0,0,0);else if(!E(d,r,t))return void C(O(),r.spatialReference,f,k);m(Z,q(e),w(e));const y=o(N,Z,v,j,d),{localMatrix:T}=c,U=i(N,y,T);c.scale=n(b(),U),s(U,U,u(K,c.scale));const z=c.rotationAxis;c.rotation=F(U),0===c.rotationAngle&&(c.rotationAxis=z),c.translation=a(b(),U)}function H(t,r,o){const i=t.spatialReference,n=h(i),s=Y;if(!d(o,s,n)&&(C(O(),o.spatialReference,n,"Falling back to mesh origin"),!d(t.origin,s,n)))return void C(O(),t.origin.spatialReference,n);const a=t.vertexAttributes.position,l=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,m=new Float64Array(a.length),f=null!=l?new Float32Array(l.length):null,p=null!=c?new Float32Array(c.length):null;R(n,s,W,n),e(X,W);const u=Q;g(q(Q),q(r),X),u[3]=r[3],z(a,i,m,n)&&(null==l||null==f||L(l,a,i,m,n,f))&&(null==c||null==p||M(c,a,i,m,n,p))?(J(m,u,3,s),P(m,n,a,i)&&(null==l||null==f||(J(f,u,3),V(f,a,i,m,n,l)))&&(null==c||null==p||(J(p,u,4),D(p,a,i,m,n,c)))?t.vertexAttributesChanged():C(O(),n,i)):C(O(),i,n)}function I(t,e,r){const o=Y;if(!d(r,o,t.spatialReference)){const e=t.origin;return o[0]=e.x,o[1]=e.y,o[2]=e.z,void C(O(),r.spatialReference,t.spatialReference,k)}J(t.vertexAttributes.position,e,3,o),J(t.vertexAttributes.normal,e,3),J(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}function J(t,e,r,o=v){if(null!=t){l(W,w(e),q(e));for(let e=0;e<t.length;e+=r){for(let r=0;r<3;r++)K[r]=t[e+r]-o[r];x(K,K,W);for(let r=0;r<3;r++)t[e+r]=K[r]+o[r]}}}const K=b(),N=c(),Q=y(),W=c(),X=r(),Y=b(),Z=f();export{B as rotate};
