/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{b as e,c as t}from"./tslib.es6.js";import{t as n,G as s,i as o,d as r,e as i,g as a}from"./Geometry.js";import{m as c,a as m,c as l}from"./SideCalculator2D-CsYV5zVZ.js";import{a as u,K as g,P as f,f as y,ac as S,ad as d,ae as N,af as x,S as h,ag as p,ah as A,ai as C,aj as w,a2 as P,a0 as E,a1 as _,ak as T,al as j,r as G,am as I,an as D,ao as v}from"./QuadraticBezier.js";import{d as b,P as R,c as U,s as q}from"./Transformation2D.js";import{G as V}from"./SimpleGeometryCursor.js";import{O as Y}from"./OperatorShapePreservingDensify.js";class k{getOperatorType(){return 10501}supportsCurves(){return!1}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}getNearestCoordinate(e,t,w,E,_,T){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return c();if(Number.isNaN(E)&&(E=0),E>=0||n("maxDeviationMeters"),0===e.getDimension())return this.getNearestVertex(e,t,w);const j=e.getGeometryType();if(j===s.enumGeometryCollection){const n=e;let s=c();for(let e=0,o=n.getGeometryCount();e<o;++e){const o=n.getGeometry(e),r=this.getNearestCoordinate(o,t,w,E,_,T);if(!r.isEmpty()){if(0===r.m_distance)return r;r.m_distance>=s.m_distance||(s=r,s.m_geometryIndex=e)}}return s}if(j===s.enumEnvelope){const n=new u;return n.addEnvelope(e,!1),this.getNearestCoordinate(n,t,w,E,_,T)}o(j)||r("Operation is not implemented for this geometry type");const G=e;if((_||T)&&j===s.enumPolygon){const n=()=>{const e=m(t,-1,0);return e.m_bRightSide=!0,e};if(w.isPannable()){const s=(new g).foldInto360Range(new f(t),w);if(s.isEmpty())return c();const o=(new g).foldInto360Range(e,w);if(o.isEmpty())return c();if((new y).execute(o,s,w,null)&&_)return n()}else{const e=(new g).clipToSpatialReference(new f(t),w,null,1);if(e.isEmpty())return c();const s=S(G,w,0,null);if(s.isEmpty())return c();if((new y).execute(s,e,w,null)&&_)return n()}}const I=w!==w.getGCS()?w.getSRToGCSTransform():null,v=new R;if(I?(new g).transform(I,[t],1,[v],!1):v.assign(t),v.isNAN())return c();const b=F(G,t,w,1);let U=b.m_distance;if(0===U)return b;Number.isNaN(U)?U=Number.POSITIVE_INFINITY:U*=1+1e-7;const q=w.getGCS(),V=q.getUnit().getUnitToBaseFactor(),k=v.clone();k.scale(V);const B=P();w.querySpheroidData(B);const X=d(B.majorSemiAxis,B.e2,k),L=N(B.majorSemiAxis,B.e2),z=new M(G.querySegmentIterator());0===E&&(E=.01);const K=B.majorSemiAxis*x(45),Q=(new Y).executeMany(z,w,K,E,0,null),Z=[];let H=-1;const J=new D,W=new h;for(let n=Q.next();null!==n;n=Q.next()){if(n.isEmpty())continue;const t=Q.getGeometryID(),s=e.getPathIndexFromPointIndex(t);e.isClosedPath(s)&&G.getPathEnd(s);const o=n;for(let e=0,n=o.getPathCount();e<n;++e){Z.length=0;for(let t=o.getPathStart(e),r=o.getPathEnd(e);t<r;++t)Z.push(o.getXY(t));if(I&&(new g).transform(I,Z,Z.length,Z,!1),Z.length>3){const e=O(Z,Z.length,v,q,1);if(e.m_distance<U){U=e.m_distance,J.assign(d(B.majorSemiAxis,B.e2,e.m_coordinate.mul(V))),H=t;let n=e.m_vertexIndex;n+1===Z.length&&(n-=1),o.getSegmentBuffer(n,W,!0)}}Z.forEach((e=>e.mulThis(V)));const n=d(B.majorSemiAxis,B.e2,Z[0]),s=new D;for(let e=1,r=Z.length;e<r;++e){const r=d(B.majorSemiAxis,B.e2,Z[e]);if(p(L,X,n,r,s)<U){const{first:s,second:i}=A(B.majorSemiAxis,B.e2,X,n,r,2,null);if(i<=U){const s=new D,{first:i,second:a}=A(B.majorSemiAxis,B.e2,X,n,r,0,s);a<U&&(U=a,J.assign(s),H=t,o.getSegmentBuffer(e-1,W,!0))}}n.assign(r)}}}if(!Number.isFinite(U))return c();-1===H&&n("");const $=C(B.majorSemiAxis,B.e2,J);$.divThis(V);const ee=$.clone(),te=w!==w.getGCS()?w.getGCSToSRTransform():null;te&&(new g).transform(te,[$],1,[ee],!1),ee.isNAN()&&i("closestPoint2DSr.isNAN()"),a(!W.empty());const ne=W.get().getClosestCoordinate(ee,!1);ee.assign(W.get().getCoord2D(ne)),I?(new g).transform(I,[ee],1,[$],!1):$.assign(ee),a(!$.isNAN());const se=this.getNearestVertex(new f($),v,w.getGCS()),oe=m(ee,H,se.m_distance);if(T&&e.getDimension()>0){const n=l(e,t,-1,-1),s=0!==n&&3!==n;oe.m_bRightSide=s}return oe}getNearestVertex(e,t,o){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return c();switch(e.getGeometryType()){case s.enumPoint:return B(e,t,o);case s.enumMultiPoint:case s.enumPolyline:case s.enumPolygon:return F(e,t,o);default:r("")}}getNearestVertexPoint2D(e,t,n,s){return a(0),{}}getNearestVertices(e,t,o,i,a){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case s.enumPoint:{const n=B(e,t,o);if(!n.isEmpty()&&n.m_distance<i&&a>=1){const e=[];return e.push(n),e}return[]}case s.enumMultiPoint:case s.enumPolyline:case s.enumPolygon:return X(e,t,o,i,a);default:r("")}}}function B(s,o,r){const i={stack:[],error:void 0,hasError:!1};try{if(0===r.getCoordinateSystemType()&&n("Cannot use local SR"),1!==r.getCoordinateSystemType()){const e=new Array(2);e[0]=s.getXY(),e[1]=o.clone();const t=b(R,2);2!==w(r,e,2,t)&&n("Point cannot be projected to GCS");const i=r.getGCS(),a=B(new f(t[0]),t[1],i);return m(a.m_coordinate,0,a.m_distance)}const t=r.getUnit().getUnitToBaseFactor(),a=s.getXY();a.scale(t);const c=o.clone();c.scale(t);const l=P();r.querySpheroidData(l);const u=e(i,new E,!1);_.geodeticDistance(l.majorSemiAxis,l.e2,a.x,a.y,c.x,c.y,u,null,null,T.PE_LINETYPE_GEODESIC);const g=s.getXY();return m(g,0,u.val)}catch(a){i.error=a,i.hasError=!0}finally{t(i)}}function F(s,o,r,i=0){0===r.getCoordinateSystemType()&&n("Cannot use local SR");let a=s.getAttributeStreamRef(0),c=s.getPointCount();const l=r.getGCS(),u=o.clone();if(1!==r.getCoordinateSystemType()){const e=r.getSRToGCSTransform();if(j(e,[o],1,[u],null),u.isNAN())return m(R.getNAN(),-1,Number.NaN);const t=(new g).execute(s,e,null);a=t.getAttributeStreamRef(0),c=t.getPointCount()}const f=l.getUnit().getUnitToBaseFactor(),y=U(c,0);for(let e=0;e<c;++e)y[e]=e;G(c,y);const S=P();l.querySpheroidData(S);const N=u.clone();N.scale(f);const x=d(S.majorSemiAxis,S.e2,N);let h=-1,p=Number.MAX_VALUE;const A=I(S.majorSemiAxis,S.e2);let C=c;const w=new R,T=new R;for(let e=0;e<C;){if(a.queryPoint2D(2*y[e],w),w.isNAN())continue;T.assign(w),T.scale(f);const t=d(S.majorSemiAxis,S.e2,T);if(D.distance(t,x)>p){y[C-1]=q(y[e],y[e]=y[C-1]),C--;continue}const n=v(A,t,x);n<p&&(h=y[e],p=n),e++}if(0!==S.e2){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new E,!1);for(let e=0;e<C;e++){if(a.queryPoint2D(2*y[e],w),w.isNAN())continue;T.assign(w),T.scale(f);const n=d(S.majorSemiAxis,S.e2,T);D.distance(n,x)>p||(_.geodeticDistance(S.majorSemiAxis,S.e2,N.x,N.y,T.x,T.y,t,null,null,i),t.val<p&&(h=y[e],p=t.val))}}catch(V){n.error=V,n.hasError=!0}finally{t(n)}}const b=new R;return-1!==h&&b.assign(s.getXY(h)),m(b,h,p)}function O(s,o,r,i,a=0){0===i.getCoordinateSystemType()&&n("Cannot use local SR");const l=i.getGCS(),u=r.clone();if(1!==i.getCoordinateSystemType()){const e=i.getSRToGCSTransform();if(j(e,[r],1,[u],null),u.isNAN())return c();const t=b(R,o);j(e,s,o,t,null);const n=O(t,o,r,l,a);return n.isEmpty()?n:m(s[n.m_vertexIndex],n.m_vertexIndex,n.m_distance)}const g=l.getUnit().getUnitToBaseFactor(),f=U(o,0);for(let e=0;e<o;++e)f[e]=e;G(o,f);const y=P();l.querySpheroidData(y);const S=u.clone();S.scale(g);const N=d(y.majorSemiAxis,y.e2,S);let x=-1,h=Number.MAX_VALUE;const p=I(y.majorSemiAxis,y.e2);let A=o;for(let e=0;e<A;){const t=s[f[e]];if(t.isNAN())continue;const n=t.clone();n.scale(g);const o=d(y.majorSemiAxis,y.e2,n);if(D.distance(o,N)>h){f[A-1]=q(f[e],f[e]=f[A-1]),A--;continue}const r=v(p,o,N);r<h&&(x=f[e],h=r),e++}if(0!==y.e2){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new E,!1);for(let e=0;e<A;e++){const n=s[f[e]];if(n.isNAN())continue;const o=n.clone();o.scale(g);const r=d(y.majorSemiAxis,y.e2,o);D.distance(r,N)>h||(_.geodeticDistance(y.majorSemiAxis,y.e2,S.x,S.y,o.x,o.y,t,null,null,a),t.val<h&&(x=f[e],h=t.val))}}catch(w){n.error=w,n.hasError=!0}finally{t(n)}}const C=new R;return-1!==x&&C.assign(s[x]),m(C,x,h)}function X(s,o,r,i,a){const c={stack:[],error:void 0,hasError:!1};try{0===r.getCoordinateSystemType()&&n("Cannot use local SR");let t=s.getAttributeStreamRef(0),l=s.getPointCount();const u=r.getGCS(),f=o.clone();if(1!==r.getCoordinateSystemType()){const e=r.getSRToGCSTransform();if(j(e,[o],1,[f],null),f.isNAN())return[];const n=(new g).execute(s,e,null);t=n.getAttributeStreamRef(0),l=n.getPointCount()}const y=u.getUnit().getUnitToBaseFactor(),S=U(l,0);for(let e=0;e<l;++e)S[e]=e;G(l,S);const N=P();u.querySpheroidData(N);const x=f.clone();x.scale(y);const h=d(N.majorSemiAxis,N.e2,x),p=[];let A=l;const C=new R,w=new R;for(let e=0;e<A;){if(t.queryPoint2D(2*S[e],C),C.isNAN())continue;w.assign(C),w.scale(y);const n=d(N.majorSemiAxis,N.e2,w);D.distance(n,h)>i?(S[A-1]=q(S[e],S[e]=S[A-1]),A--):e++}const I=(e,t)=>e.m_distance-t.m_distance,v=e(c,new E,!1);for(let e=0;e<A;e++)t.queryPoint2D(2*S[e],C),C.isNAN()||(_.geodeticDistance(N.majorSemiAxis,N.e2,x.x,x.y,C.x*y,C.y*y,v,null,null,T.PE_LINETYPE_GEODESIC),v.val<i&&p.push(m(C,S[e],v.val)));return p.sort(I),p.slice(0,a)}catch(l){c.error=l,c.hasError=!0}finally{t(c)}}class M extends V{constructor(e){super(),this.m_first=!0,this.m_segIter=e,this.m_segIter.stripAttributes()}tock(){return!0}getRank(){return 1}next(){if(this.m_first){if(!this.m_segIter.nextPath())return null;this.m_first=!1}for(;;){if(this.m_segIter.hasNextSegment())return this.m_segIter.nextSegment().clone();if(!this.m_segIter.nextPath())break}return null}getGeometryID(){return this.m_segIter.getStartPointIndex()}}export{k as OperatorProximityGeodesic};
