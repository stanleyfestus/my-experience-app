/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{g as t,t as e,G as s,p as i,d as n,r,f as o,s as a,o as h,e as m,c as l,b as u,k as c,a as g,v as _,u as d,i as p,w as f,j as x,m as y,x as P,y as E,z as C,A as S,n as v,B as b,C as I}from"./Geometry.js";import{P as w,d as D,a as T,x as N,E as A,s as q,y as F,k as M,z as G,t as V,T as Y,A as X,i as k,B as R,C as B,b as L,c as H,D as z,F as U,G as O,H as W,f as j,r as Z,q as Q,I as K,n as J,h as $,J as tt,L as et,M as st,N as it,O as nt,Q as rt,R as ot,U as at,V as ht,W as mt,X as lt,Y as ut,Z as ct,_ as gt,l as _t,$ as dt,a0 as pt,a1 as ft,e as xt,a2 as yt,v as Pt,a3 as Et,S as Ct,a4 as St,a5 as vt,a6 as bt,a7 as It,a8 as wt,a9 as Dt,aa as Tt,ab as Nt,ac as At,ad as qt,ae as Ft,af as Mt,ag as Gt,ah as Vt,K as Yt,ai as Xt,aj as kt,ak as Rt,m as Bt,o as Lt,al as Ht,am as zt,an as Ut,ao as Ot,ap as Wt,aq as jt,ar as Zt,u as Qt,as as Kt,at as Jt,au as $t,av as te,aw as ee,ax as se,j as ie,ay as ne,az as re,aA as oe,g as ae,aB as he}from"./Transformation2D.js";import{b as me,c as le}from"./tslib.es6.js";import{G as ue,S as ce}from"./SimpleGeometryCursor.js";class ge{static construct(t,e,s,i){return new ge(t,e,s,i)}constructor(t,e,s,i){void 0===t?(this.xmin=Number.NaN,this.ymin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN):"number"==typeof t?(this.xmin=t,this.ymin=e,this.xmax=s,this.ymax=i):(this.xmin=t.xmin,this.ymin=t.ymin,this.xmax=t.xmax,this.ymax=t.ymax),this.normalize()}static constructEmpty(){return new ge(Number.NaN,Number.NaN,Number.NaN,Number.NaN)}clone(){return new ge(this)}assign(t){return this.xmin=t.xmin,this.xmax=t.xmax,this.ymin=t.ymin,this.ymax=t.ymax,this}width(){return this.xmax-this.xmin}height(){return this.ymax-this.ymin}maxDimension(){return Math.max(this.width(),this.height())}minDimension(){return Math.min(this.width(),this.height())}sqrDiagonal(){return t(0),0}diagonal(){return t(0),0}getCenterX(){return.5*(this.xmin+this.xmax)}getCenterY(){return.5*(this.ymin+this.ymax)}getCenter(){return w.construct(this.getCenterX(),this.getCenterY())}queryCenter(e){t(0)}setEmpty(){this.xmin=Number.NaN,this.ymin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN}setInfinite(){t(0)}isDegenerate(t){return!this.isEmpty()&&(this.width()<=t||this.height()<=t)}isZero(){return t(0),!1}isEmpty(){return Number.isNaN(this.xmin)||Number.isNaN(this.ymin)||Number.isNaN(this.xmax)||Number.isNaN(this.ymax)}mergeNeCoords(t,e){this.xmin>t?this.xmin=t:this.xmax<t&&(this.xmax=t),this.ymin>e?this.ymin=e:this.ymax<e&&(this.ymax=e)}mergeNe(t){this.mergeNeCoords(t.x,t.y)}mergeCoords(t,e){this.isEmpty()?(this.xmin=t,this.ymin=e,this.xmax=t,this.ymax=e):(this.xmin>t?this.xmin=t:this.xmax<t&&(this.xmax=t),this.ymin>e?this.ymin=e:this.ymax<e&&(this.ymax=e))}merge(t){this.mergeCoords(t.x,t.y)}mergeEnvelope2D(t){t.isEmpty()||(this.mergeCoords(t.xmin,t.ymin),this.mergeNeCoords(t.xmax,t.ymax))}mergePoints(t,e){for(let s=0;s<e;){if(!this.isEmpty()){for(let i=s;i<e;i++)this.mergeNe(t[i]);break}this.setCoords(t[s]),s++}}mergePointsInterleaved(t,e,s){for(let i=2*e,n=i+2*s;i<n;i+=2)this.mergeCoords(t.read(i),t.read(i+1))}inflateCoords(t,e){this.isEmpty()||(this.xmin-=t,this.xmax+=t,this.ymin-=e,this.ymax+=e,(this.xmin>this.xmax||this.ymin>this.ymax)&&this.setEmpty())}getInflatedCoords(e,s){return t(0),new ge(0,0,0,0)}inflate(t){this.inflateCoords(t,t)}getInflated(e){return t(0),new ge(0,0,0,0)}zoom(e,s){t(0)}scale(e){t(0)}equals(t,e){return!(!this.isEmpty()||!t.isEmpty())||(e?Math.abs(this.xmin-t.xmin)<=e&&Math.abs(this.ymin-t.ymin)<=e&&Math.abs(this.xmax-t.xmax)<=e&&Math.abs(this.ymax-t.ymax)<=e:this.xmin===t.xmin&&this.ymin===t.ymin&&this.xmax===t.xmax&&this.ymax===t.ymax)}setCoords(e){void 0!==e.xmin?(this.xmin=e.xmin,this.xmax=e.xmax,this.ymin=e.ymin,this.ymax=e.ymax):void 0!==e.x?(this.xmin=e.x,this.xmax=e.x,this.ymin=e.y,this.ymax=e.y):void 0!==e.pt1?(this.xmin=e.pt1.x,this.ymin=e.pt1.y,this.xmax=e.pt2.x,this.ymax=e.pt2.y,this.normalize()):void 0!==e.env2D?(this.xmin=e.env2D.xmin,this.xmax=e.env2D.xmax,this.ymin=e.env2D.ymin,this.ymax=e.env2D.ymax,this.normalize()):void 0!==e.pt?(this.xmin=e.pt.x,this.xmax=e.pt.x,this.ymin=e.pt.y,this.ymax=e.pt.y):void 0!==e.center?(this.xmin=e.center.x-.5*e.width,this.xmax=this.xmin+e.width,this.ymin=e.center.y-.5*e.height,this.ymax=this.ymin+e.height,this.normalize()):t(0),this.normalize()}queryIntervalX(t){this.isEmpty()?t.setEmpty():t.setCoords(this.xmin,this.xmax)}queryIntervalY(t){this.isEmpty()?t.setEmpty():t.setCoords(this.ymin,this.ymax)}setFromPoints(t,e){if(0===e)return void this.setEmpty();if(Array.isArray(t)){const s=t;this.setCoords(s[0]);for(let t=1;t<e;){if(!this.isEmpty()){for(let i=t;i<e;i++)this.mergeNe(s[i]);return}this.setCoords(s[t]),t++}return}const s=t;this.setCoords({x:s[0],y:s[1]});for(let i=1,n=2*e;i<n;i+=2){if(!this.isEmpty()){for(let t=i,n=2*e;t<n;t+=2)this.mergeNeCoords(s[t],s[t+1]);return}this.setCoords({x:s[i],y:s[i+1]}),i+=2}}normalize(){let t=!1;this.xmin<=this.xmax||([this.xmin,this.xmax]=[this.xmax,this.xmin],t=!0),this.ymin<=this.ymax||([this.ymin,this.ymax]=[this.ymax,this.ymin],t=!0),!t||this.xmin<=this.xmax&&this.ymin<=this.ymax||this.setEmpty()}isValid(){return this.isEmpty()||this.xmin<=this.xmax&&this.ymin<=this.ymax}getLowerLeft(){return new w(this.xmin,this.ymin)}getLowerRight(){return new w(this.xmax,this.ymin)}getUpperLeft(){return new w(this.xmin,this.ymax)}getUpperRight(){return new w(this.xmax,this.ymax)}move(t,e){this.isEmpty()||(this.xmin+=t,this.ymin+=e,this.xmax+=t,this.ymax+=e)}centerAtCoords(t,e){this.move(t-this.getCenterX(),e-this.getCenterY())}centerAt(t){this.centerAtCoords(t.x,t.y)}containsCoords(t,e){return t>=this.xmin&&t<=this.xmax&&e>=this.ymin&&e<=this.ymax}contains(t){return this.containsCoords(t.x,t.y)}containsEnvelope(t){return t.xmin>=this.xmin&&t.xmax<=this.xmax&&t.ymin>=this.ymin&&t.ymax<=this.ymax}containsExclusiveCoords(t,e){return t>this.xmin&&t<this.xmax&&e>this.ymin&&e<this.ymax}containsExclusive(t){return this.containsExclusiveCoords(t.x,t.y)}containsExclusiveEnvelope(t){return t.xmin>this.xmin&&t.xmax<this.xmax&&t.ymin>this.ymin&&t.ymax<this.ymax}isIntersecting(t){return(this.xmin<=t.xmin?this.xmax>=t.xmin:t.xmax>=this.xmin)&&(this.ymin<=t.ymin?this.ymax>=t.ymin:t.ymax>=this.ymin)}isIntersectingNe(t){return(this.xmin<=t.xmin?this.xmax>=t.xmin:t.xmax>=this.xmin)&&(this.ymin<=t.ymin?this.ymax>=t.ymin:t.ymax>=this.ymin)}intersect(t){if(this.isEmpty())return!1;if(t.isEmpty())return this.setEmpty(),!1;t.xmin>this.xmin&&(this.xmin=t.xmin),t.xmax<this.xmax&&(this.xmax=t.xmax),t.ymin>this.ymin&&(this.ymin=t.ymin),t.ymax<this.ymax&&(this.ymax=t.ymax);const e=this.xmin<=this.xmax&&this.ymin<=this.ymax;return e||this.setEmpty(),e}queryCorner(t){switch(3&t){case 0:return new w(this.xmin,this.ymin);case 1:return new w(this.xmin,this.ymax);case 2:return new w(this.xmax,this.ymax);default:return new w(this.xmax,this.ymin)}}queryCorners(t){t[0].setCoords(this.xmin,this.ymin),t[1].setCoords(this.xmin,this.ymax),t[2].setCoords(this.xmax,this.ymax),t[3].setCoords(this.xmax,this.ymin)}queryCornersReversed(t){t[0].setCoords(this.xmin,this.ymin),t[1].setCoords(this.xmax,this.ymin),t[2].setCoords(this.xmax,this.ymax),t[3].setCoords(this.xmin,this.ymax)}reaspect(e,s){t(0)}getArea(){return this.isEmpty()?0:this.width()*this.height()}getLength(){return t(0),0}clipCode(t){return(t.x<this.xmin?1:0)|(t.x>this.xmax?1:0)<<1|(t.y<this.ymin?1:0)<<2|(t.y>this.ymax?1:0)<<3}clipLine(t,e){let s=this.clipCode(t),i=this.clipCode(e);if(s&i)return 0;if(!(s|i))return 4;const n=(s?1:0)|(i?2:0);do{const n=e.x-t.x,r=e.y-t.y;if(Math.abs(n)>Math.abs(r)?s&ge.XMASK?(s&ge.XLESSXMIN?(t.y+=r*(this.xmin-t.x)/n,t.x=this.xmin):(t.y+=r*(this.xmax-t.x)/n,t.x=this.xmax),s=this.clipCode(t)):i&ge.XMASK?(i&ge.XLESSXMIN?(e.y+=r*(this.xmin-e.x)/n,e.x=this.xmin):(e.y+=r*(this.xmax-e.x)/n,e.x=this.xmax),i=this.clipCode(e)):s?(s&ge.YLESSYMIN?(t.x+=n*(this.ymin-t.y)/r,t.y=this.ymin):(t.x+=n*(this.ymax-t.y)/r,t.y=this.ymax),s=this.clipCode(t)):(i&ge.YLESSYMIN?(e.x+=n*(this.ymin-e.y)/r,e.y=this.ymin):(e.x+=n*(this.ymax-e.y)/r,e.y=this.ymax),i=this.clipCode(e)):s&ge.YMASK?(s&ge.YLESSYMIN?(t.x+=n*(this.ymin-t.y)/r,t.y=this.ymin):(t.x+=n*(this.ymax-t.y)/r,t.y=this.ymax),s=this.clipCode(t)):i&ge.YMASK?(i&ge.YLESSYMIN?(e.x+=n*(this.ymin-e.y)/r,e.y=this.ymin):(e.x+=n*(this.ymax-e.y)/r,e.y=this.ymax),i=this.clipCode(e)):s?(s&ge.XLESSXMIN?(t.y+=r*(this.xmin-t.x)/n,t.x=this.xmin):(t.y+=r*(this.xmax-t.x)/n,t.x=this.xmax),s=this.clipCode(t)):(i&ge.XLESSXMIN?(e.y+=r*(this.xmin-e.x)/n,e.x=this.xmin):(e.y+=r*(this.xmax-e.x)/n,e.x=this.xmax),i=this.clipCode(e)),s&i)return 0}while(s|i);return n}distanceFromEnvelope(t){return Math.sqrt(this.sqrDistanceEnvelope(t,null,null))}distance(t){return Math.sqrt(this.sqrDistance(t))}sqrDistanceEnvelope(t,e,s){if(!e&&!s){if(this.isEmpty()||t.isEmpty())return Number.NaN;let e,s=0,i=0;return e=this.xmin-t.xmax,e>s&&(s=e),e=this.ymin-t.ymax,e>i&&(i=e),e=t.xmin-this.xmax,e>s&&(s=e),e=t.ymin-this.ymax,e>i&&(i=e),s*s+i*i}if(this.isEmpty()||t.isEmpty())return e&&e.setNAN(),s&&s.setNAN(),Number.NaN;let i,n=0,r=0;const o=Math.max(this.xmin,t.xmin),a=Math.max(this.ymin,t.ymin);return e&&e.setCoords(o,a),s&&s.setCoords(o,a),i=this.xmin-t.xmax,i>n&&(n=i,e&&(e.x=this.xmin),s&&(s.x=t.xmax)),i=this.ymin-t.ymax,i>r&&(r=i,e&&(e.y=this.ymin),s&&(s.y=t.ymax)),i=t.xmin-this.xmax,i>n&&(n=i,e&&(e.x=this.xmax),s&&(s.x=t.xmin)),i=t.ymin-this.ymax,i>r&&(r=i,e&&(e.y=this.ymax),s&&(s.y=t.ymin)),n*n+r*r}sqrDistance(t,e){if(void 0===e){if(this.isEmpty()||t.isNAN())return Number.NaN;let e,s=0,i=0;return e=this.xmin-t.x,e>s&&(s=e),e=this.ymin-t.y,e>i&&(i=e),e=t.x-this.xmax,e>s&&(s=e),e=t.y-this.ymax,e>i&&(i=e),s*s+i*i}if(this.isEmpty()||t.isNAN())return e.setNAN(),Number.NaN;e.assign(t);let s,i=0,n=0;return s=this.xmin-t.x,s>i&&(i=s,e.x=this.xmin),s=this.ymin-t.y,s>n&&(n=s,e.y=this.ymin),s=t.x-this.xmax,s>i&&(i=s,e.x=this.xmax),s=t.y-this.ymax,s>n&&(n=s,e.y=this.ymax),i*i+n*n}sqrMaxMinDistanceEnvelope(t){if(this.isEmpty()||t.isEmpty())return Number.NaN;let e=Number.MAX_VALUE;{const s=w.sqrDistanceCoords(this.xmin,this.ymin,t.xmax,t.ymin),i=w.sqrDistanceCoords(this.xmin,this.ymin,t.xmax,t.ymax),n=w.sqrDistanceCoords(this.xmin,this.ymax,t.xmax,t.ymin),r=w.sqrDistanceCoords(this.xmin,this.ymax,t.xmax,t.ymax),o=Math.max(s,i),a=Math.max(n,r),h=Math.max(o,a);e=Math.min(h,e)}{const s=w.sqrDistanceCoords(this.xmin,this.ymin,t.xmin,t.ymax),i=w.sqrDistanceCoords(this.xmin,this.ymin,t.xmax,t.ymax),n=w.sqrDistanceCoords(this.xmax,this.ymin,t.xmin,t.ymax),r=w.sqrDistanceCoords(this.xmax,this.ymin,t.xmax,t.ymax),o=Math.max(s,i),a=Math.max(n,r),h=Math.max(o,a);e=Math.min(h,e)}{const s=w.sqrDistanceCoords(this.xmax,this.ymin,t.xmin,t.ymin),i=w.sqrDistanceCoords(this.xmax,this.ymin,t.xmin,t.ymax),n=w.sqrDistanceCoords(this.xmax,this.ymax,t.xmin,t.ymin),r=w.sqrDistanceCoords(this.xmax,this.ymax,t.xmin,t.ymax),o=Math.max(s,i),a=Math.max(n,r),h=Math.max(o,a);e=Math.min(h,e)}{const s=w.sqrDistanceCoords(this.xmin,this.ymax,t.xmin,t.ymin),i=w.sqrDistanceCoords(this.xmin,this.ymax,t.xmax,t.ymin),n=w.sqrDistanceCoords(this.xmax,this.ymax,t.xmin,t.ymin),r=w.sqrDistanceCoords(this.xmax,this.ymax,t.xmax,t.ymin),o=Math.max(s,i),a=Math.max(n,r),h=Math.max(o,a);e=Math.min(h,e)}return e}sqrMaxDistanceEnvelope(t){if(this.isEmpty()||t.isEmpty())return Number.NaN;let e=0;const s=D(w,4);this.queryCorners(s);const i=D(w,4);t.queryCorners(i);for(let n=0;n<4;n++)for(let t=0;t<4;t++){const r=w.sqrDistance(s[n],i[t]);r>e&&(e=r)}return e}sqrMaxMinDistance(t){const e=w.sqrDistance(t,this.getLowerLeft()),s=w.sqrDistance(t,this.getUpperLeft()),i=w.sqrDistance(t,this.getLowerRight()),n=w.sqrDistance(t,this.getUpperRight());let r,o=Math.max(e,s);return r=Math.max(e,i),o>r&&(o=r),r=Math.max(s,n),o>r&&(o=r),r=Math.max(i,n),o>r&&(o=r),o}sqrMinDistance(e){return t(0),0}sqrMaxDistance(e){return t(0),0}snapToBoundary(e){return t(0),!1}snapClip(t){const e=T(t.x,this.xmin,this.xmax),s=T(t.y,this.ymin,this.ymax);return w.construct(e,s)}boundaryDistance(e){return t(0),0}envelopeSide(e){return t(0),0}querySide(t,s){switch(t){case 0:s.constructFromCoords(this.xmin,this.ymin,this.xmin,this.ymax);break;case 1:s.constructFromCoords(this.xmin,this.ymax,this.xmax,this.ymax);break;case 2:s.constructFromCoords(this.xmax,this.ymax,this.xmax,this.ymin);break;case 3:s.constructFromCoords(this.xmax,this.ymin,this.xmin,this.ymin);break;default:e("query_side")}return s}isPointOnBoundary(e,s){return t(0),!1}calculateToleranceFromEnvelope(){if(this.isEmpty())return N();return(Math.abs(this.xmin)+Math.abs(this.xmax)+Math.abs(this.ymin)+Math.abs(this.ymax)+1)*N()}notEquals(e){return t(0),!1}toString(){return`[${this.xmin}, ${this.ymin}, ${this.xmax}, ${this.ymax}]`}}ge.XLESSXMIN=1,ge.YLESSYMIN=4,ge.XMASK=3,ge.YMASK=12;class _e{static constructEmpty(){return new _e(Number.NaN,Number.NaN,Number.NaN,Number.NaN,Number.NaN,Number.NaN)}constructor(t,e,s,i,n,r){this.xmin=t,this.ymin=e,this.zmin=s,this.xmax=i,this.ymax=n,this.zmax=r,this.normalize()}inflate(t){this.inflateCoords(t,t,t)}inflateCoords(e,s,i){t(0)}getEnvelope2D(){return new ge(this.xmin,this.ymin,this.xmax,this.ymax)}getEnvelopeZs(){return new A(this.zmin,this.zmax)}setEmptyZ(){this.zmin=Number.NaN,this.zmax=Number.NaN}normalize(){let t=!1;this.xmin<=this.xmax||(this.xmax=q(this.xmin,this.xmin=this.xmax),t=!0),this.ymin<=this.ymax||(this.ymax=q(this.ymin,this.ymin=this.ymax),t=!0),!t||this.xmin<=this.xmax&&this.ymin<=this.ymax?this.zmin<=this.zmax||(this.zmax=q(this.zmin,this.zmin=this.zmax),this.zmin<=this.zmax||this.setEmptyZ()):this.setEmpty()}isEmpty(){return Number.isNaN(this.xmin)||Number.isNaN(this.ymin)||Number.isNaN(this.xmax)||Number.isNaN(this.ymax)}isEmptyZ(){return Number.isNaN(this.zmin)||Number.isNaN(this.zmax)}setEmpty(){this.xmin=Number.NaN,this.ymin=Number.NaN,this.zmin=Number.NaN,this.xmax=Number.NaN,this.ymax=Number.NaN,this.zmax=Number.NaN}mergeEnv3D(t){t.isEmpty()||(this.mergeCoords(t.xmin,t.ymin,t.zmin),this.mergeCoords(t.xmax,t.ymax,t.zmax))}mergeNe(t){this.mergeNeCoords(t.x,t.y,t.z)}mergeNeCoords(t,e,s){this.xmin>t?this.xmin=t:this.xmax<t&&(this.xmax=t),this.ymin>e?this.ymin=e:this.ymax<e&&(this.ymax=e),this.zmin>s?this.zmin=s:this.zmax<s&&(this.zmax=s)}mergeCoords(t,e,s){this.isEmpty()?(this.xmin=t,this.xmax=t,this.ymin=e,this.ymax=e,this.zmin=s,this.zmax=s):(this.isEmptyZ()&&(this.zmin=s,this.zmax=s),this.mergeNeCoords(t,e,s))}setCoords(t,e,s,i,n,r){this.xmin=t,this.ymin=e,this.zmin=s,this.xmax=i,this.ymax=n,this.zmax=r,this.normalize()}sqrDistance(e,s=1){return t(0),0}sqrDistanceAndPoint(e,s,i=1){return t(0),0}sqrDistanceEnvelope3D(e,s=1){return t(0),0}sqrDistanceEnvelope3DAndPoints(e,s,i,n=1){return t(0),0}sqrMaxDistance(e,s=1){return t(0),0}}const de=[0,0,Number.NaN,0,0,0,0,0,-1,-1,0,0,0,0],pe=[2,1,1,1,3,1,2,3,2,4,1,1,2,1],fe=[1,1,1,0,2,1,1,1,0,0,0,0,0,1],xe=[1,1,1,2,0,0,0,0,2,2,4,2,2,1],ye=[4,8,4,8,1],Pe=25;function Ee(){return new Array(Pe)}let Ce=class t{getAttributeCount(){return this.m_attributeCount}getSemantics(t){return this.m_indexToSemantics[t]}getSemanticsBitArray(){return this.m_semanticsBitArray}getAttributeIndex(t){return this.m_semanticsToIndexMap[t]}static getInterpolation(t){return fe[t]}static getPersistence(t){return xe[t]}static getPersistenceSize(t){return ye[t]}static getPersistenceSizeFromSemantics(e){return t.getPersistenceSize(t.getPersistence(e))*t.getComponentCount(e)}static getComponentCount(t){return pe[t]}static maxComponentCount(){return 4}static isInteger(t){return 2===t||3===t||4===t}static isIntegerSemantics(e){return t.isInteger(t.getPersistence(e))}static isTexture(t){return 5===t||6===t||7===t}hasAttribute(t){return!!(this.m_semanticsBitArray&1<<t)}hasAttributesFrom(t){return(this.m_semanticsBitArray&t.m_semanticsBitArray)===t.m_semanticsBitArray}hasZ(){return this.hasAttribute(1)}hasM(){return this.hasAttribute(2)}hasID(){return this.hasAttribute(3)}getTotalComponentCount(){return this.m_totalComponentCount}static getDefaultValue(t){return de[t]}static isDefaultValue(t,e){return F(de[t],e)}equals(t){return this===t}getDefaultPointAttributes(){return this.m_defaultPointAttributes}getPointAttributeOffset(t){return this.m_pointAttributeOffsets[t]}constructor(e){this.m_semanticsBitArray=e,this.m_attributeCount=0,this.m_totalComponentCount=0,this.m_semanticsToIndexMap=new Int32Array(14),this.m_indexToSemantics=new Int32Array(14),this.m_pointAttributeOffsets=new Int32Array(14),this.m_defaultPointAttributes=new Array(Pe),this.m_semanticsToIndexMap.fill(-1),this.m_indexToSemantics.fill(-1);let s=0,i=1,n=14;for(;s<n;s++)e&i&&(this.m_semanticsToIndexMap[s]=this.m_attributeCount,this.m_indexToSemantics[this.m_attributeCount]=s,this.m_attributeCount++,this.m_totalComponentCount+=t.getComponentCount(s)),i<<=1;let r=0;for(s=0,n=this.getAttributeCount();s<n;s++){const e=this.getSemantics(s),i=t.getComponentCount(e),n=t.getDefaultValue(e);this.m_pointAttributeOffsets[s]=r;for(let t=0;t<i;t++)this.m_defaultPointAttributes[r]=n,r++}}};var Se=Ce;function ve(){return new Array(14)}class be{static getInstance(){return be.s_thisInstance}constructor(){this.m_map=new Map,this.m_vd2D=new Se(1),this.m_map.set(1,this.m_vd2D),this.m_vd3D=new Se(3),this.m_map.set(3,this.m_vd2D)}GetVD2D(){return this.m_vd2D}GetVD3D(){return this.m_vd3D}FindOrAdd(t){if(1===t)return this.GetVD2D();if(3===t)return this.GetVD3D();const e=this.m_map.get(t);if(e)return e;const s=new Se(t);return this.m_map.set(t,s),s}}function Ie(t){return be.getInstance().FindOrAdd(t)}function we(t,e){if(!t||!e)return e||t;const s=t.getSemanticsBitArray()|e.getSemanticsBitArray();return(s&t.getSemanticsBitArray())===s?t:(s&e.getSemanticsBitArray())===s?e:Ie(s)}function De(t,e){const s=t.getSemanticsBitArray()|1<<e;return(s&t.getSemanticsBitArray())===s?t:Ie(s)}function Te(e,s){const i=(e.getSemanticsBitArray()|1<<s)-(1<<s);return i===e.getSemanticsBitArray()?(t(0),e):Ie(i)}function Ne(){return be.getInstance().GetVD2D()}function Ae(){return be.getInstance().GetVD3D()}function qe(t,e,s){if(s.fill(-1),null!==t&&null!==e)for(let i=0,n=t.getAttributeCount();i<n;i++)s[i]=e.getAttributeIndex(t.getSemantics(i))}be.s_thisInstance=new be;class Fe{static construct(t,e,s){return new Fe(t,e,s)}constructor(t,e,s){void 0!==t?(this.x=t,this.y=e,this.z=s):this.x=this.y=this.z=Number.NaN}get 0(){return this.x}get 1(){return this.y}get 2(){return this.z}set 0(t){this.x=t}set 1(t){this.y=t}set 2(t){this.z=t}clone(){return new Fe(this.x,this.y,this.z)}assign(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}setCoords(t,e,s){return this.x=t,this.y=e,this.z=s,this}setCoordsPoint2DZ(t,e){return this.setCoords(t.x,t.y,e)}setCoordsPoint3D(t){this.x=t.x,this.y=t.y,this.z=t.z}setZero(){this.x=0,this.y=0,this.z=0}setNormalized(t){this.assign(t),this.normalizeThis()}normalizeThis(){const t=this.length();return t?(this.x/=t,this.y/=t,this.z/=t):(this.x=1,this.y=0,this.z=0),this}getUnitVector(){const t=new Fe;return t.setNormalized(this),t}sqrLength(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthXY(){return t(0),0}static sqrDistance(t,e){return M(t.x-e.x)+M(t.y-e.y)+M(t.z-e.z)}static sqrDistanceCoords(e,s,i,n,r,o){return t(0),0}static distance(t,e){return Math.sqrt(Fe.sqrDistance(t,e))}isEqual(t,e){return void 0===e&&(e=0),Math.abs(this.x-t.x)<=e&&Math.abs(this.y-t.y)<=e&&G(this.z,t.z,e)}static compareByLength(e,s,i,n){return t(0),0}isEqualCoords(e,s,i,n){return t(0),this.x===e&&this.y===s&&this.z===i}isEqualsTols(e,s,i){return t(0),!1}isEqualCoordsTols(e,s,i,n,r){return t(0),!1}static st_isEqual(e,s,i,n){return t(0),!1}equals(e,s){return t(0),!1}equalsTols(e,s,i){return t(0),!1}divThis(t){return this.x/=t,this.y/=t,this.z/=t,this}subThis(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}setSub(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}sub(t){return Fe.construct(this.x-t.x,this.y-t.y,this.z-t.z)}addThis(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}add(t){return this.clone().addThis(t)}setAdd(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}mul(t){return Fe.construct(this.x*t,this.y*t,this.z*t)}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}crossProductVector(t){const e=this.y*t.z-t.y*this.z,s=t.x*this.z-this.x*t.z,i=this.x*t.y-t.x*this.y;return new Fe(e,s,i)}setCrossProductVector(t,e){const s=t.y*e.z-e.y*t.z,i=e.x*t.z-t.x*e.z,n=t.x*e.y-e.x*t.y;return this.x=s,this.y=i,this.z=n,this}setScaled(t,e){return this.x=t*e.x,this.y=t*e.y,this.z=t*e.z,this}scaleThis(t){return this.x*=t,this.y*=t,this.z*=t,this}scaleZThis(t){return this.z*=t,this}setNAN(){return t(0),this}isNAN(){return Number.isNaN(this.x)||Number.isNaN(this.y)||Number.isNaN(this.z)}static getNAN(){return Fe.construct(Number.NaN,Number.NaN,Number.NaN)}isFinite(){return t(0),!1}isZero(){return 0===this.x&&0===this.y&&0===this.z}norm(e){return t(0),0}sqrDistanceFromCenterToSpheroidSurface(e,s){return t(0),0}distanceFromCenterToSpheroidSurface(t,e){return Math.sqrt(this.sqrDistanceFromCenterToSpheroidSurface(t,e))}static getClosestCoordinate(e,s,i,n=!1){return t(0),0}compare(e){return t(0),0}compareXYZ(e){return t(0),0}negateThis(){this.x=-this.x,this.y=-this.y,this.z=-this.z}static averageFast(e,s){return t(0),{}}static average(e,s){return t(0),{}}static size(){return Fe.dimensions}static lerp(t,e,s){const i=new Fe;return V(t,e,s,i),i}static slerp(e,s,i){return t(0),{}}static compareVectors(e,s){return t(0),0}static selectRightHandedBasisFromNormal(t,e,s){const i=t.getUnitVector(),n=i.createAPerpendicular(),r=new Fe;r.setCrossProductVector(i,n),r.normalizeThis(),e.setCoordsPoint3D(n),s.setCoordsPoint3D(r)}createAPerpendicular(){const t=[this.crossProductVector(new Fe(0,0,1)),this.crossProductVector(new Fe(1,0,0)),this.crossProductVector(new Fe(0,1,0))],e=[t[0].sqrLength(),t[1].sqrLength(),t[2].sqrLength()],s=t[e.reduce(((t,s,i)=>e[t]>e[i]?t:i),0)];return s.normalizeThis(),s}calculateAngle(e){return t(0),0}static crossDotSign(e,s,i){return t(0),0}static isBisectorRobust(e,s,i){return t(0),0}static compareZOrder(e,s){return t(0),!1}}Fe.dimensions=3;var Me=Ce;class Ge{constructor(t){if(this.m_description=null,this.x=Number.NaN,this.y=Number.NaN,this.m_attribs=null,t){if(!t.copy)return t.move?(this.m_description=t.move.m_description,t.move.m_description=null,this.m_attribs=t.move.m_attribs,t.move.m_attribs=null,this.x=t.move.x,void(this.y=t.move.y)):t.vd?(this.m_description=t.vd,void(t.attribBuffer?(this.m_attribs=t.attribBuffer,t.initDefaultValues&&this.setDefaultAttributeValues()):this.ensureAttributes())):t.pt?(this.m_description=Ne(),void this.setXY(t.pt)):void("x"in t&&("z"in t?(this.m_description=Ae(),this.ensureAttributes(),this.setXYZ(new Fe(t.x,t.y,t.z))):(this.m_description=Ne(),this.setXYCoords(t.x,t.y))));t.copy.copyTo(this)}else this.m_description=Ne()}assignCopy(t){return this.m_attribs=null,t.copyTo(this),this}assignMove(e){return t(0),this}vertexCount(){return t(0),1}getXY(){return new w(this.x,this.y)}setXY(t){this.x=t.x,this.y=t.y}setXYCoords(t,e){this.x=t,this.y=e}getXYZ(){const t=new Fe;return t.x=this.x,t.y=this.y,t.z=this.getZ(),t}setXYZ(t){this.addAttribute(1),this.x=t.x,this.y=t.y,this.m_attribs[0]=t.z}getX(){return this.x}setX(t){this.x=t}getY(){return this.y}setY(t){this.y=t}getZ(){return this.m_description.hasZ()?this.m_attribs[0]:Me.getDefaultValue(1)}setZ(t){this.addAttribute(1),this.m_attribs[0]=t}getM(){return this.getAttributeAsDbl(2,0)}setM(t){this.addAttribute(2),this.m_description.hasZ()?this.m_attribs[1]=t:this.m_attribs[0]=t}getID(){return this.getAttributeAsInt(3,0)}setID(t){this.setAttributeBasic(3,0,t)}isEqualXY(e,s){return t(0),!1}isEqualXYCoords(t,e,s){return void 0===s&&(s=0),Math.abs(t-this.x)<=s&&Math.abs(e-this.y)<=s}getAttributeAsDbl(t,e){if(0===t){if(0===e)return this.x;if(1===e)return this.y;i("")}const s=Me.getComponentCount(t);(e<0||e>=s)&&i("");const n=this.m_description.getAttributeIndex(t);return n>=0?this.m_attribs[this.m_description.getPointAttributeOffset(n)-2+e]:Me.getDefaultValue(t)}getAttributeAsInt(t,e){return Math.trunc(this.getAttributeAsDbl(t,e))}setAttributeBasic(t,e,s){if(0===t)return void(0===e?this.x=s:1===e?this.y=s:i(""));const n=Me.getComponentCount(t);(e<0||e>=n)&&i("");let r=this.m_description.getAttributeIndex(t);r<0&&(this.addAttribute(t),r=this.m_description.getAttributeIndex(t)),this.m_attribs[this.m_description.getPointAttributeOffset(r)-2+e]=s}copyAttributesFrom(e,s){t(0)}getAttributeArray(){return this.m_attribs}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}mergeVertexDescription(e){t(0)}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=De(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(e){t(0)}dropAllAttributes(){const t=Ne();t!==this.m_description&&this.assignVertexDescription(t)}getGeometryType(){return s.enumPoint}getDimension(){return 0}queryEnvelope(t){if(t instanceof ke)return t.setEmpty(),t.assignVertexDescription(this.m_description),void t.merge(this);if(t instanceof _e){if(this.isEmpty())return void t.setEmpty();const e=this.getXYZ();return t.xmin=e.x,t.ymin=e.y,t.zmin=e.z,t.xmax=e.x,t.ymax=e.y,void(t.zmax=e.z)}this.isEmpty()?t.setEmpty():(t.xmin=this.x,t.ymin=this.y,t.xmax=this.x,t.ymax=this.y)}queryLooseEnvelope(t){this.queryEnvelope(t)}queryInterval(t,e){const s=new A;if(this.isEmpty())return s.setEmpty(),s;const i=this.getAttributeAsDbl(t,e);return s.vmin=i,s.vmax=i,s}applyTransformation(e){if(!this.isEmpty()){if(e instanceof Y){const t=this.getXY();return e.transformInPlace(t),void this.setXY(t)}t(0)}}transformAttribute(e,s,i,n,r){t(0)}createInstance(){return new Ge({vd:this.m_description})}copyTo(t){if(this===t)return;t.getGeometryType()!==s.enumPoint&&e();const i=t;i.x=this.x,i.y=this.y,this.m_attribs?(i.assignVertexDescription(this.m_description),i.m_attribs=this.m_attribs.slice()):(i.releaseAttributes(),i.assignVertexDescription(this.m_description))}isEmpty(){return Number.isNaN(this.x)||Number.isNaN(this.y)}setEmpty(){this.m_description||(this.m_description=Ne(),this.releaseAttributes()),this.x=Number.NaN,this.y=Number.NaN,this.m_attribs&&X(this.m_attribs,this.m_description.getDefaultPointAttributes(),0,2,this.m_description.getTotalComponentCount()-2)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(t){return 0}equals(t,e){if(t===this)return!0;if(t.getGeometryType()!==s.enumPoint)return!1;const i=t;if(this.m_description!==i.m_description)return!1;if(this.isEmpty()!==i.isEmpty())return!1;if(this.isEmpty())return!0;if(void 0===e&&(e=0),Math.abs(this.x-i.x)>e)return!1;if(Math.abs(this.y-i.y)>e)return!1;for(let s=0,n=this.m_description.getTotalComponentCount()-2;s<n;s++)if(!G(this.m_attribs[s],i.m_attribs[s],e))return!1;return!0}getBoundary(){return null}clone(){const t=new Ge({vd:this.m_description});return this.copyTo(t),t}swap(e){t(0)}replaceNaNs(e,s){t(0)}lerp(e,s,i){return t(0),new Ge({x:0,y:0})}setDefaultAttributeValues(){const t=this.m_description.getTotalComponentCount()-2;t>0&&(this.m_attribs?X(this.m_attribs,this.m_description.getDefaultPointAttributes(),0,2,t):this.m_attribs=this.m_description.getDefaultPointAttributes().slice(2))}static sqrDistance2D(e,s){return t(0),0}getImpl(){return this}hasNonLinearSegments(){return t(0),!1}mergeVertexDescriptionImpl(e){t(0)}releaseAttributes(){this.m_attribs=null}assignVertexDescriptionImpl(t){this.m_description||(this.m_description=Ne());const e=ve();qe(t,this.m_description,e);let s=null;t.getTotalComponentCount()-2>0&&(s=t.getDefaultPointAttributes().slice(2));for(let i=1,n=t.getAttributeCount();i<n;i++){const n=e[i];if(-1!==n){const e=this.m_description.getPointAttributeOffset(n)-2,r=t.getPointAttributeOffset(i)-2,o=Me.getComponentCount(t.getSemantics(i));for(let t=0;t<o;t++)s[r+t]=this.m_attribs[e+t]}}this.m_attribs=s,this.m_description=t}ensureAttributes(){this.m_description.getTotalComponentCount()-2>0&&null===this.m_attribs&&(this.m_attribs=this.m_description.getDefaultPointAttributes().slice(2))}queryValues(t,e){}copyCommonAttributesTo(t){t.x=this.x,t.y=this.y;const e=t.getDescription();if(e===this.m_description)this.m_attribs&&X(t.m_attribs,this.m_attribs,0,0,this.m_description.getTotalComponentCount()-2);else{let s=0;for(let i=1,n=e.getAttributeCount();i<n;i++){const n=e.getSemantics(i);let r=Me.getComponentCount(n);if(this.m_description.hasAttribute(n)){let e=this.m_description.getPointAttributeOffset(this.m_description.getAttributeIndex(n))-2;for(;0!==r;)t.m_attribs[s++]=this.m_attribs[e++],r--}else{const e=Me.getDefaultValue(n);for(;0!==r;)t.m_attribs[s++]=e,r--}}}}setValues(t,e){}dbgDefaultAttribs(){}}Ge.type=s.enumPoint;var Ve=Ce;function Ye(t,e){return e*(t.getTotalComponentCount()-2)}class Xe{constructor(t){if(this.m_attributes=null,t)if(void 0!==t.xmin)this.m_envelope2D=new ge(t.xmin,t.ymin,t.xmax,t.ymax);else if(void 0!==t.env2D)this.m_envelope2D=new ge(t.env2D);else if(t.move)this.m_envelope2D=new ge(t.move.m_envelope2D),this.m_attributes=t.move.m_attributes,t.move.m_attributes=null;else{if(!t.moveEnv)throw new Error("unrecognized EnvelopeData constructor options");{const e=t.moveEnv.accessEnvelopeData();this.m_envelope2D=new ge(e.m_envelope2D),this.m_attributes=e.m_attributes,e.m_attributes=null}}else this.m_envelope2D=ge.constructEmpty()}ensureAttributes(t){const e=t.getTotalComponentCount()-2;!this.m_attributes&&e&&(this.m_attributes=new Array(2*e),this.m_attributes.fill(Number.NaN))}copyTo(e,s){const i=s,n=e.getTotalComponentCount()-2;if(i.m_description!==e&&(i.releaseAttributes_(),i.m_description=e,n&&(i.m_data.m_attributes=new Array(2*n))),n){t(this.m_attributes&&i.m_data.m_attributes);const e=2*n;X(i.m_data.m_attributes,this.m_attributes,0,0,e)}i.m_data.m_envelope2D=new ge(this.m_envelope2D)}copyToIfNotNull(t,e){e.m_envelope2D=new ge(this.m_envelope2D),e.releaseAttributes();t.getTotalComponentCount()-2&&this.m_attributes&&(e.m_attributes=this.m_attributes.slice())}releaseAttributes(){this.m_attributes=null}isEmpty(){return this.m_envelope2D.isEmpty()}transformAttribute(e,s,i,n,r){t(0)}queryInterval(t,e,s,n){if(this.isEmpty())return void n.setEmpty();if(0===e)return void(0===s?this.m_envelope2D.queryIntervalX(n):1===s?this.m_envelope2D.queryIntervalY(n):i(""));const r=Ve.getComponentCount(e);(s<0||s>=r)&&i("");const o=t.getAttributeIndex(e);if(o>=0)return n.vmin=this.m_attributes[Ye(t,0)+t.getPointAttributeOffset(o)-2+s],void(n.vmax=this.m_attributes[Ye(t,1)+t.getPointAttributeOffset(o)-2+s]);{const t=Ve.getDefaultValue(e);return void n.setCoords(t,t)}}queryEnvelope3D(t,e){const s=new A;this.queryInterval(t,1,0,s),e.setCoords(this.m_envelope2D.xmin,this.m_envelope2D.ymin,s.vmin,this.m_envelope2D.xmax,this.m_envelope2D.ymax,s.vmax)}setEmpty(t){this.m_envelope2D.setEmpty();const e=t.getTotalComponentCount()-2;e&&(this.m_attributes?this.dbgAssertSize(e):this.m_attributes=new Array(2*e),this.m_attributes.fill(Number.NaN))}dbgAssertSize(t){}}class ke{constructor(t){if(this.m_description=Ne(),void 0===t)this.m_data=new Xe;else if(void 0!==t.vd)this.m_description=t.vd,this.m_data=new Xe,this.ensureAttributes_();else if(t?.env2D)this.m_data=new Xe({env2D:t.env2D});else if(void 0!==t.xmin)this.m_data=new Xe({xmin:t.xmin,ymin:t.ymin,xmax:t.xmax,ymax:t.ymax});else if(t.copy)this.m_data=new Xe,t.copy.copyTo(this);else if(t.move)this.m_description=t.move.m_description,t.move.m_description=null,this.m_data=new Xe({move:t.move.m_data});else{if(!t.centerPoint)throw new Error("unrecognized Envelope constructor options");this.m_description=t.centerPoint.getDescription(),this.m_data=new Xe,this.ensureAttributes_(),this.setFromPoint(t.centerPoint,t.width,t.height)}}accessEnvelopeData(){return this.m_description=null,this.m_data}assignMove(t){return this===t||(this.m_description=t.m_description,t.m_description=null,this.m_data=new Xe({move:t.m_data})),this}assignCopy(t){return this===t||t.copyTo(this),this}transformAttribute(e,s,i,n,r){t(0)}vertexCount(){return t(0),0}setAttributeBasic(t,e,s){if(this.addAttribute(t),this.m_data.isEmpty())return;const i=this.queryInterval(t,e);i.vmin=s,i.vmax=s,this.setIntervalEnvelope(t,e,i)}hasNonLinearSegments(){return t(0),!0}mergeVertexDescriptionImpl(t){const e=we(this.getDescription(),t);this.assignVertexDescription(e)}asEnvelope2D(){return new ge(this.m_data.m_envelope2D)}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}getGeometryType(){return s.enumEnvelope}getDimension(){return 2}getXMin(){return this.m_data.m_envelope2D.xmin}getYMin(){return this.m_data.m_envelope2D.ymin}getXMax(){return this.m_data.m_envelope2D.xmax}getYMax(){return this.m_data.m_envelope2D.ymax}width(){return this.m_data.isEmpty()?Number.NaN:this.m_data.m_envelope2D.width()}height(){return this.m_data.isEmpty()?Number.NaN:this.m_data.m_envelope2D.height()}getCenterX(){return t(0),0}getCenterY(){return t(0),0}getCenterXY(){return this.m_data.isEmpty()?new w:this.m_data.m_envelope2D.getCenter()}getCenter(t){if(t.assignVertexDescription(this.m_description),this.m_data.isEmpty())return void t.setEmpty();const e=this.m_description.getAttributeCount();for(let s=1;s<e;s++){const e=this.m_description.getSemantics(s),i=Ve.getComponentCount(e);for(let s=0;s<i;s++){const i=.5*(this.getAttributeAsDblImpl(0,e,s)+this.getAttributeAsDblImpl(1,e,s));t.setAttributeBasic(e,s,i)}}t.setXY(this.m_data.m_envelope2D.getCenter())}setCoords(t,e,s,i){this.m_data.m_envelope2D.setCoords({xmin:t,ymin:e,xmax:s,ymax:i})}setEnvelope(t){if(t instanceof ge)this.m_data.m_envelope2D=new ge(t),this.m_data.m_envelope2D.normalize();else{this.addAttribute(1),this.m_data.m_envelope2D=t.getEnvelope2D(),this.m_data.m_envelope2D.normalize();const e=A.constructEmpty();e.setCoords(t.zmin,t.zmax),this.setInterval(1,0,e.vmin,e.vmax)}}merge(s){if(s instanceof ge)return s.isValid()||e(""),void this.m_data.m_envelope2D.mergeEnvelope2D(s);if(s instanceof ke){if(s.m_data.isEmpty())return;const t=s.getDescription();this.mergeVertexDescription(t),this.m_data.m_envelope2D.mergeEnvelope2D(s.m_data.m_envelope2D);for(let e=1,i=t.getAttributeCount();e<i;e++){const i=t.getSemantics(e),n=Ve.getComponentCount(i);for(let t=0;t<n;t++){const e=s.queryInterval(i,t),n=this.queryInterval(i,t);n.merge(e),this.setIntervalEnvelope(i,t,n)}}}else if(s instanceof Ge){const t=s;if(t.isEmpty())return;const e=t.getDescription();if(this.mergeVertexDescription(e),this.m_data.isEmpty())return void this.setFromPoint(t);this.m_data.m_envelope2D.merge(t.getXY());for(let s=1,i=e.getAttributeCount();s<i;s++){const i=e.getSemantics(s),n=Ve.getComponentCount(i);for(let e=0;e<n;e++){const s=t.getAttributeAsDbl(i,e),n=this.queryInterval(i,e);n.mergeCoordinate(s),this.setIntervalEnvelope(i,e,n)}}}else t(0)}intersect(t){if(!this.m_data.m_envelope2D.intersect(t.m_data.m_envelope2D))return this.setEmpty(),!1;const e=t.getDescription();this.mergeVertexDescription(e);for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const e=this.m_description.getSemantics(s),i=Ve.getComponentCount(e);for(let s=0;s<i;s++){const i=t.queryInterval(e,s),n=this.queryInterval(e,s);n.intersect(i),this.setIntervalEnvelope(e,s,n)}}return!0}intersectCommonAttributes(t){if(!this.m_data.m_envelope2D.intersect(t.m_data.m_envelope2D))return this.setEmpty(),!1;const e=t.getDescription();for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const i=this.m_description.getSemantics(s);if(!e.hasAttribute(i))continue;const n=Ve.getComponentCount(i);for(let e=0;e<n;e++){const s=t.queryInterval(i,e),n=this.queryInterval(i,e);n.intersect(s),this.setIntervalEnvelope(i,e,n)}}return!0}move(e,s){t(0)}centerAt(t,e){this.m_data.m_envelope2D.centerAtCoords(t,e)}centerAtPoint(t){}reaspect(e,s){t(0)}inflateCoords(t,e){this.m_data.m_envelope2D.inflateCoords(t,e)}containsCoords(e,s){return t(0),!1}contains(e){return t(0),!1}containsPoint(e){return t(0),!1}containsEnvelope(e){return t(0),!1}setIntervalEnvelope(t,e,s){if(this.addAttribute(t),this.m_data.isEmpty())return;const n=new A(s);if(n.normalize(),0===t){if(n.isEmpty())return void this.setEmpty();0===e?(this.m_data.m_envelope2D.xmin=n.vmin,this.m_data.m_envelope2D.xmax=n.vmax):1===e?(this.m_data.m_envelope2D.ymin=n.vmin,this.m_data.m_envelope2D.ymax=n.vmax):i("")}else this.setAttributeAsDblImpl(0,t,e,n.vmin),this.setAttributeAsDblImpl(1,t,e,n.vmax)}setInterval(t,e,s,i){this.setIntervalEnvelope(t,e,new A(s,i))}queryInterval(t,e){const s=new A;return this.m_data.queryInterval(this.m_description,t,e,s),s}queryEnvelope(e){e instanceof ge?e.setCoords({env2D:this.m_data.m_envelope2D}):e instanceof _e?this.m_data.queryEnvelope3D(this.m_description,e):e instanceof ke?this.copyTo(e):t(0)}applyTransformation(e){e instanceof Y?e.transformEnvInPlace(this.m_data.m_envelope2D):t(0)}createInstance(){return t(0),this}copyTo(t){t!==this&&this.m_data.copyTo(this.m_description,t)}isEmpty(){return this.m_data.isEmpty()}setEmpty(){this.m_description||(this.m_description=Ne()),this.m_data.setEmpty(this.m_description)}calculateArea2D(){return this.m_data.m_envelope2D.getArea()}calculateLength2D(){return t(0),0}calculateLength3D(e){return t(0),0}equals(t,e){if(t===this)return!0;const s=t;if(this.m_description!==s.m_description)return!1;if(this.m_data.isEmpty()!==s.m_data.isEmpty())return!1;if(this.m_data.isEmpty())return!0;if(void 0===e&&(e=0),Math.abs(this.m_data.m_envelope2D.xmin-s.m_data.m_envelope2D.xmin)>e)return!1;if(Math.abs(this.m_data.m_envelope2D.ymin-s.m_data.m_envelope2D.ymin)>e)return!1;if(Math.abs(this.m_data.m_envelope2D.xmax-s.m_data.m_envelope2D.xmax)>e)return!1;if(Math.abs(this.m_data.m_envelope2D.ymax-s.m_data.m_envelope2D.ymax)>e)return!1;for(let i=0,n=2*(this.m_description.getTotalComponentCount()-2);i<n;i++)if(!G(this.m_data.m_attributes[i],s.m_data.m_attributes[i],e))return!1;return!0}getBoundary(){return n("getBoundary not available in this context. Use the boundary operator with an envelope parameter"),null}clone(){return new ke({copy:this})}swap(e){t(0)}queryCoordinates(e){t(0)}queryCornerByVal(t,e){(t<0||t>3)&&i(""),e.assignVertexDescription(this.m_description);const s=this.getDescription().getAttributeCount();for(let i=1;i<s;i++){const s=this.m_description.getSemantics(i),n=Ve.getComponentCount(s);for(let i=0;i<n;i++)e.setAttributeBasic(s,i,this.getAttributeAsDblImpl(t%2,s,i))}e.setXY(this.m_data.m_envelope2D.queryCorner(t))}queryCorner(t,e){e.assign(this.m_data.m_envelope2D.queryCorner(t))}getDescription(){return this.m_description}mergeVertexDescription(t){this.m_description!==t&&(this.m_description&&this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=De(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Te(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){t(0)}queryLooseEnvelope(t){this.queryEnvelope(t)}replaceNaNs(e,s){t(0)}getImpl(){return this}setFromPoint(t,e,s){this.m_data.m_envelope2D.setCoords({center:t.getXY(),width:e??0,height:s??0});const i=t.getDescription();for(let n=1,r=i.getAttributeCount();n<r;n++){const e=i.getSemantics(n),s=Ve.getComponentCount(e);for(let i=0;i<s;i++){const s=t.getAttributeAsDbl(e,i);this.setInterval(e,i,s,s)}}}assignVertexDescriptionImpl(t){const e=ve();qe(t,this.m_description,e);let s=null;const i=t.getTotalComponentCount()-2,n=this.m_description?this.m_description.getTotalComponentCount()-2:0;i>0&&(s=new Array(2*i),s.fill(Number.NaN));for(let r=1;r<t.getAttributeCount();r++){const o=e[r];if(-1!==o){const e=t.getPointAttributeOffset(r)-2,a=Ve.getComponentCount(t.getSemantics(r)),h=this.m_description.getPointAttributeOffset(o)-2;X(s,this.m_data.m_attributes,e,h,a),X(s,this.m_data.m_attributes,i+e,n+h,a)}}this.releaseAttributes_(),this.m_data.m_attributes=s,this.m_description=t}getAttributeAsDblImpl(t,e,s){if(this.m_data.isEmpty()&&r(""),0===e)return t?s?this.m_data.m_envelope2D.ymax:this.m_data.m_envelope2D.xmax:s?this.m_data.m_envelope2D.ymin:this.m_data.m_envelope2D.xmin;s>=Ve.getComponentCount(e)&&i("");const n=this.m_description.getAttributeIndex(e);return n>=0?this.m_data.m_attributes[Ye(this.m_description,t)+this.m_description.getPointAttributeOffset(n)-2+s]:Ce.getDefaultValue(e)}setAttributeAsDblImpl(t,e,s,n){0===e&&(t?1===s?this.m_data.m_envelope2D.ymax=n:0===s?this.m_data.m_envelope2D.xmax=n:i(""):1===s?this.m_data.m_envelope2D.ymin=n:0===s?this.m_data.m_envelope2D.xmin=n:i(""));const r=Ve.getComponentCount(e);(s<0||s>=r)&&i(""),this.addAttribute(e);const o=this.m_description.getAttributeIndex(e);this.m_data.m_attributes[Ye(this.m_description,t)+this.m_description.getPointAttributeOffset(o)-2+s]=n}releaseAttributes_(){this.m_data.releaseAttributes()}ensureAttributes_(){this.m_data.ensureAttributes(this.m_description)}}ke.type=s.enumEnvelope;const Re=-559038737;var Be=Ce;function Le(t,s,i){switch(t){case 0:return new Ke(s,i);case 1:return new Je(s,i);case 2:return new Qe(s,i);case 3:throw new Error("64 bit int attribute stream not implemented");case 4:return new Ze(s,i);default:e("")}}function He(t,e){const s=Be.getComponentCount(t);return Le(Be.getPersistence(t),e*s,Be.getDefaultValue(t))}function ze(t,e){const s=Be.getComponentCount(t);return Le(Be.getPersistence(t),e*s)}function Ue(t,e){return new Qe(t,e)}function Oe(t,e){return new Ze(t,e)}function We(t,e){return new Je(t,e)}class je{size(){return this.m_size}checkResize(t,e){t>this.m_size&&this.resize(t,e)}resize(t,e){if((t=Math.trunc(t))===this.m_size)return;const s=!!e||Number.isNaN(e);if(t<this.m_a.length)this.m_a.length>je.s_resizeMin&&1.25*t<this.m_a.length&&(this.m_a=this.m_a.slice(0,t)),s&&t>this.m_size&&this.m_a.fill(e,this.m_size,t);else if(t>=this.m_a.length){const i=1.25*t,n=new this.m_a.constructor(i);n.set(this.m_a),this.m_a=n,s&&this.m_a.fill(e,this.m_size,t)}this.m_size=t}resizeRounded(t,e){return this.resize(t,e)}reserve(t){}read(e){return t(e>=0&&e<this.m_size),this.m_a[e]}readAsDbl(t){return this.read(t)}write(t,e){this.m_a[t]=e}writeAsDbl(t,e){this.write(t,e)}setRange(t,s,i){(s<0||i<0||i+s>this.size())&&e(),this.m_a.fill(t,s,s+i)}add(t){this.resize(this.m_size+1),this.m_a[this.m_size-1]=t}addArray(t,e){const s=this.m_size;void 0===e?(this.resize(this.m_size+t.length),this.m_a.set(t,s)):(this.resize(this.m_size+e),this.m_a.set(t.slice(0,e),s))}equals(t,e,s,i){if(this.getPersistence()!==t.getPersistence())return!1;return $e(this,t,e,s,i)}insertRange(t,e,s,i){s&&this.checkResize(i+s),this.m_a.copyWithin(t+s,t,i||this.m_size),this.m_a.fill(e,t,t+s)}readRange(t,e){return this.m_a.slice(t,t+e)}insertRangeFromStream(e,s,i,n,r,o,a){t(this.getPersistence()===s.getPersistence());const h=s;n&&this.checkResize(a+n),this.m_a.copyWithin(e+n,e,a||this.m_size),this.m_a.set(h.readRange(i,n),e),r||this.reverseRange(e,n,o)}writeRange(s,i,n,r,o,a){t(this.getPersistence()===n.getPersistence());const h=n;if((s<0||i<0||r<0)&&e(),h.size()<r+i&&e(),0===i)return;this.size()<i+s&&this.resize(i+s);const m=h.m_a.subarray(r,r+i);ts(this.m_a,s,i,m)}insertAttributes(t,e,s,i){const n=Be.getComponentCount(s);this.m_a.copyWithin(t+n,t,i||this.m_size);for(let r=0;r<n;r++)this.m_a[t+r]=e.getAttributeAsDbl(s,r)}insertAttributesFromPoints(e,s,i,n,r){t(0)}eraseRange(t,s,i){this.m_size<t+s&&e(),this.m_a.copyWithin(t,t+s),this.m_size-=s}reverseRange(t,s,i){if((i<1||s%i!=0)&&e(),this.m_a.subarray(t,t+s).reverse(),i>1)for(let e=t,n=t+s;e<n;e+=i){let t=e,s=e+i-1;for(;t<s;){const e=this.m_a[t];this.m_a[t]=this.m_a[s],this.m_a[s]=e,t++,s--}}}rotate(t,e,s){(e<t||e>s||t>s)&&i("rotate"),e!==t&&e!==s&&(this.reverseRange(t,e-t,1),this.reverseRange(e,s-e,1),this.reverseRange(t,s-t,1))}adjacentDifference(e,s,i){return t(0),0}sort(t,e,s){this.m_a.subarray(t,e).sort(s)}constructor(t){if(t.move)this.m_a=t.move.m_a,this.m_size=t.move.m_size,t.move.m_a=t.move.m_a.slice(0,0),t.move.m_size=0;else if(t.copy)this.m_size=t.copy.m_size,t.maxSize&&(this.m_size=Math.min(t.maxSize,this.m_size)),this.m_a=t.copy.m_a.slice(0,this.m_size);else{const e=Math.max(t.size,je.s_constructMin);this.m_a=new t.ctor(e),(t.defaultValue||Number.isNaN(t.defaultValue))&&this.m_a.fill(t.defaultValue),this.m_size=t.size}}}je.s_constructMin=2,je.s_resizeMin=30;class Ze extends je{setBits(t,e){this.m_a[t]|=e}clearBits(t,e){this.m_a[t]&=~e}getPersistence(){return 4}clone(){return new Ze({ctor:Int8Array,copy:this})}restrictedClone(t){return new Ze({ctor:Int8Array,copy:this,maxSize:t})}constructor(t,e){super("number"==typeof t?{ctor:Int8Array,size:t,defaultValue:e}:t)}}class Qe extends je{getPersistence(){return 2}clone(){return new Qe({ctor:Int32Array,copy:this})}restrictedClone(t){return new Qe({ctor:Int32Array,copy:this,maxSize:t})}write(e,s){t(s<=k()),super.write(e,s)}constructor(t,e){super("number"==typeof t?{ctor:Int32Array,size:t,defaultValue:e}:t)}}class Ke extends je{getPersistence(){return 0}clone(){return new Ke({ctor:Float32Array,copy:this})}restrictedClone(t){return new Ke({ctor:Float32Array,copy:this,maxSize:t})}constructor(t,e){super("number"==typeof t?{ctor:Float32Array,size:t,defaultValue:e}:t)}}class Je extends je{getPersistence(){return 1}getArray(){return this.m_a}applyTransformation(t,s,i){(1&s||s+2*i>this.size())&&e();const n=0===s?this.m_a:this.m_a.subarray(s);t.transformInterleavedPoints(n,i,n)}readPoint2D(t){const e=this.m_a[t],s=this.m_a[t+1];return new w(e,s)}queryPoint2D(t,e){return e.x=this.m_a[t],e.y=this.m_a[t+1],e}writePoint2D(t,e){this.write(t,e.x),this.write(t+1,e.y)}insert(t,e,s){if(s+2>=this.m_a.length)throw RangeError("AttributeStreamOfDbl::insert");this.m_a.copyWithin(t+2,t,s||this.m_size),this.m_a[t]=e.x,this.m_a[t+1]=e.y}insertRangeFromPoints(t,e,s,i,n,r){if(this.m_a.copyWithin(t+2*i,t,r||this.m_size),n)for(let o=s,a=t,h=0;h<i;++h,++o){const t=e[o];this.m_a[a++]=t.x,this.m_a[a++]=t.y}else for(let o=s+i-1,a=t,h=0;h<i;++h,--o){const t=e[o];this.m_a[a++]=t.x,this.m_a[a++]=t.y}}queryRange(t,s,i,n,r){if((t<0||s<0)&&e(),!n&&(r<=0||s%r!=0)&&e(),0===s)return;if(1===s)return void(i[0]=this.m_a[t]);const o=this.m_a.subarray(t,t+s);i.set(o)}writeRangeFromArray(t,s,i,n,r){if((t<0||s<0)&&e(),0===s)return;if(1===s)return void(this.m_a[t]=i[0]);let o=i;s<i.length&&(o=i.subarray(0,s)),this.m_a.set(o,t)}clone(){return new Je({ctor:Float64Array,copy:this})}restrictedClone(t){return new Je({ctor:Float64Array,copy:this,maxSize:t})}constructor(t,e){super("number"==typeof t?{ctor:Float64Array,size:t,defaultValue:e}:t)}}function $e(t,e,s,i,n){if(t.getPersistence()!==e.getPersistence())return!1;const r=t.getPersistence()<=1,o=t.size(),a=e.size();if(i>o||i>a)return!1;if(n)for(let h=s;h<i;h++){let s=t.read(h)-e.read(h);if(s<0&&(s=-s),s>n)return!1}else for(let h=s;h<i;h++){const s=t.read(h),i=e.read(h);if(s!==i){if(r&&Number.isNaN(s)&&Number.isNaN(i))continue;return!1}}return!0}function ts(t,s,i,n,r,o){if((s<0||i<0)&&e(),0===i)return;if(1===i)return void(t[s]=n[0]);let a=n;i<n.length&&(a=n.subarray(0,i)),t.set(a,s)}class es{constructor(e){this.posStream=null,this.streams=null,void 0!==e&&t(0)}assignMove(e){return t(0),this}get(t){return t>0?this.streams[t-1]:this.posStream}set(t,e){t>0?this.streams[t-1]=e:this.posStream=e}destroyAndSetSize(t){if(this.streams=null,t>1){this.streams=new Array(t-1);for(let e=0;e<t-1;++e)this.streams[e]=null}this.posStream=null}swap(t){[this.streams,t.streams]=[t.streams,this.streams],[this.posStream,t.posStream]=[t.posStream,this.posStream]}empty(){return null===this.posStream&&null===this.streams}}class ss{constructor(){this.m_minValue=-1,this.m_maxValue=-1,this.m_dy=Number.NaN,this.m_buckets=new Qe(0),this.m_bucketedIndices=new Qe(0)}static sortEx(t,e,s,i,n=32){if(s-e<=n)return void i.userSort(e,s,t);(new ss).sort(t,e,s,i,n)}sort(t,e,s,i,n=32){if(s-e<=n)return void i.userSort(e,s,t);let r=!0,o=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;for(let m=e;m<s;m++){const e=i.getValue(t.read(m));e<o&&(o=e),e>a&&(a=e)}if(this.reset(s-e,o,a,s-e)){for(let r=e;r<s;r++){const s=t.read(r),n=i.getValue(s),o=this.getBucket(n);this.m_buckets.write(o,this.m_buckets.read(o)+1),this.m_bucketedIndices.write(r-e,s)}let n=this.m_buckets.read(0);this.m_buckets.write(0,0);for(let t=1,e=this.m_buckets.size();t<e;t++){const e=this.m_buckets.read(t);this.m_buckets.write(t,n),n+=e}for(let r=e;r<s;r++){const s=this.m_bucketedIndices.read(r-e),n=i.getValue(s),o=this.getBucket(n),a=this.m_buckets.read(o);t.write(a+e,s),this.m_buckets.write(o,a+1)}r=!1}if(r)return void i.userSort(e,s,t);let h=0;for(let m=0,l=this.m_buckets.size();m<l;m++){const s=h;h=this.m_buckets.read(m),h>s&&i.userSort(e+s,e+h,t)}this.m_buckets.size()>100&&(this.m_buckets.resize(0),this.m_bucketedIndices.resize(0))}reset(t,e,s,i){if(t<2||s===e)return!1;const n=Math.min(ss.c_maxBuckets,t);return this.m_buckets.resize(n),this.m_buckets.setRange(0,0,this.m_buckets.size()),this.m_minValue=e,this.m_maxValue=s,this.m_bucketedIndices.resize(i),this.m_dy=(s-e)/(n-1),!0}getBucket(t){return Math.trunc((t-this.m_minValue)/this.m_dy)}getBucketCount(){return this.m_buckets.size()}}ss.c_maxBuckets=65536;class is{constructor(t){this.m_buffer=null,this.m_firstFree=-1,this.m_last=0,this.m_size=0,this.m_capacity=0,this.m_bufferSize=0,this.m_stride=0,this.m_stride=t,this.m_realStride=t,this.m_blockSize=Math.trunc(is.st_realBlockSize/this.m_realStride)}dbgdelete_(t){return this.m_buffer[t>>is.st_blockPower][1+(t&is.st_blockMask)]=is.st_deadVertex,!0}deleteElement(t){(t>>is.st_blockPower)*this.m_blockSize*this.m_realStride+(t&is.st_blockMask)<this.m_last*this.m_realStride?(this.m_buffer[t>>is.st_blockPower][t&is.st_blockMask]=this.m_firstFree,this.m_firstFree=t):this.m_last--,this.m_size--}getField(t,e){return this.m_buffer[t>>is.st_blockPower][(t&is.st_blockMask)+e]}setField(t,e,s){this.m_buffer[t>>is.st_blockPower][(t&is.st_blockMask)+e]=s}getStride(){return this.m_stride}newElement(){let t=this.m_firstFree;if(-1===t){if(this.m_last===this.m_capacity){const t=0!==this.m_capacity?Math.trunc(2*(this.m_capacity+1)):1;this.grow(t)}t=(this.m_last/this.m_blockSize<<is.st_blockPower)+this.m_last%this.m_blockSize*this.m_realStride,this.m_last++}else this.m_firstFree=this.m_buffer[t>>is.st_blockPower][t&is.st_blockMask];this.m_size++;const e=this.m_buffer[t>>is.st_blockPower],s=t&is.st_blockMask;for(let i=0;i<this.m_stride;i++)e[s+i]=-1;return t}elementToIndex(t){return(t>>is.st_blockPower)*this.m_blockSize+(t&is.st_blockMask)/this.m_realStride}deleteAll(t){this.m_firstFree=-1,this.m_last=0,this.m_size=0,t&&(this.m_buffer=null,this.m_capacity=0)}size(){return this.m_size}setCapacity(t){t>this.m_capacity&&this.grow(t)}capacity(){return this.m_capacity}swap(t,e){const s=this.m_buffer[t>>is.st_blockPower],i=this.m_buffer[e>>is.st_blockPower],n=t&is.st_blockMask,r=e&is.st_blockMask;for(let o=0;o<this.m_stride;o++){const t=s[n+o];s[n+o]=i[r+o],i[r+o]=t}}swapField(t,e,s){const i=this.m_buffer[t>>is.st_blockPower],n=this.m_buffer[e>>is.st_blockPower],r=(t&is.st_blockMask)+s,o=(e&is.st_blockMask)+s,a=i[r];i[r]=n[o],n[o]=a}static impossibleIndex2(){return-2}static impossibleIndex3(){return-3}static isValidElement(t){return t>=0}ensureBufferBlocksCapacity(t){if(this.m_buffer.length<t){const e=new Array(t);for(let t=0;t<this.m_buffer.length;t++)e[t]=this.m_buffer[t];this.m_buffer=e}}grow(t){null===this.m_buffer&&(this.m_bufferSize=0,this.m_buffer=new Array(8));const e=Math.trunc((t+this.m_blockSize-1)/this.m_blockSize);if(this.ensureBufferBlocksCapacity(e),1===e){let e=0;const s=t*this.m_realStride;for(;s>is.st_sizes[e];)e++;const i=new Int32Array(is.st_sizes[e]);1===this.m_bufferSize?(i.set(this.m_buffer[0]),this.m_buffer[0]=i):(this.m_buffer[this.m_bufferSize]=i,this.m_bufferSize++),this.m_capacity=Math.trunc(i.length/this.m_realStride)}else{if(1===this.m_bufferSize&&this.m_buffer[0].length<is.st_realBlockSize){const t=new Int32Array(is.st_realBlockSize);t.set(this.m_buffer[0]),this.m_buffer[0]=t,this.m_capacity=this.m_blockSize}for(;this.m_bufferSize<e;)this.m_buffer[this.m_bufferSize++]=new Int32Array(is.st_realBlockSize),this.m_capacity+=this.m_blockSize}}}function ns(t,e){return{element:t,box:e.clone()}}is.st_realBlockSize=16384,is.st_blockMask=16383,is.st_blockPower=14,is.st_sizes=[16,32,64,128,256,512,1024,2048,4096,8192,16384],is.st_deadVertex=-2125315821;class rs{constructor(t,e,s){this.m_extent=new ge,this.m_dataExtent=new ge,this.m_childExtents=[new ge,new ge,new ge,new ge],this.m_elementNodes=new is(4),this.m_data=[],this.m_freeData=[],this.m_root=-1,this.m_height=8,void 0===s&&(s=!1),this.m_quadTreeNodes=new is(s?11:10),this.m_bStoreDuplicates=s,this.reset_(t,e)}reset(e,s){t(0)}insert(t,e){if(-1===this.m_root&&this.createRoot_(),this.m_bStoreDuplicates){const s=this.insertDuplicates_(t,e,0,this.m_extent,this.m_root,!1,-1);return-1!==s&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:e}):this.m_dataExtent.mergeEnvelope2D(e)),s}const s=this.insert_(t,e,0,this.m_extent,this.m_root,!1,-1);return-1!==s&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:e}):this.m_dataExtent.mergeEnvelope2D(e)),s}insertEx(t,e,s){if(-1===this.m_root&&this.createRoot_(),this.m_bStoreDuplicates){const s=this.insertDuplicates_(t,e,0,this.m_extent,this.m_root,!1,-1);return-1!==s&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:e}):this.m_dataExtent.mergeEnvelope2D(e)),s}let i;i=-1===s?this.m_root:this.getQuad_(s);const n=this.getHeight(i),r=this.getExtent(i),o=this.insert_(t,e,n,r,i,!1,-1);return-1!==o&&(this.m_dataExtent.isEmpty()?this.m_dataExtent.setCoords({env2D:e}):this.m_dataExtent.mergeEnvelope2D(e)),o}removeElement(e){t(0)}getElement(t){return this.getElementValue_(this.getData_(t))}getElementAtIndex(e){return t(0),0}getElementExtent(t){const e=this.getData_(t);return this.getBoundingBoxValue_(e).clone()}getElementExtentAtIndex(e){return t(0),{}}getDataExtent(){return this.m_dataExtent.clone()}getQuadTreeExtent(){return t(0),{}}getHeight(t){return this.m_quadTreeNodes.getField(t,6)>>rs.m_heightBitShift}getMaxHeight(){return this.m_height}getExtent(t){const e=new ge;if(e.setCoords({env2D:this.m_extent}),t===this.m_root)return e;const s=[];let i=t;do{s.push(this.getQuadrant_(i)),i=this.getParent_(i)}while(i!==this.m_root);const n=s.length;for(let r=0;r<n;r++){const t=s.at(-1);s.pop(),0===t?(e.xmin=.5*(e.xmin+e.xmax),e.ymin=.5*(e.ymin+e.ymax)):1===t?(e.xmax=.5*(e.xmin+e.xmax),e.ymin=.5*(e.ymin+e.ymax)):2===t?(e.xmax=.5*(e.xmin+e.xmax),e.ymax=.5*(e.ymin+e.ymax)):(e.xmin=.5*(e.xmin+e.xmax),e.ymax=.5*(e.ymin+e.ymax))}return e}getQuad(t){return this.getQuad_(t)}getElementCount(){return-1===this.m_root?0:this.getSubTreeElementCount_(this.m_root)}getSubTreeElementCount(t){return this.getSubTreeElementCount_(t)}getContainedSubTreeElementCount(t){return this.m_bStoreDuplicates?this.getContainedSubTreeElementCount_(t):this.getSubTreeElementCount_(t)}getIntersectionCount(t,e,s){if(-1===this.m_root)return 0;const i=new ge;i.setCoords({env2D:t}),i.inflateCoords(e,e);const n=[],r=[];n.push(this.m_root),r.push(this.m_extent.clone());const o=D(ge,4);let a=0;for(;n.length>0;){let t=!1;const e=n.at(-1),h=r.at(-1);if(n.pop(),r.pop(),i.containsEnvelope(h)){if(a+=this.getSubTreeElementCount(e),s>0&&a>=s)return s}else if(i.isIntersecting(h)){for(let t=this.getFirstElement_(e);-1!==t;t=this.getNextElement_(t)){const e=this.getData_(t);if(this.getBoundingBoxValue_(e).isIntersecting(i)&&(a++,s>0&&a>=s))return s}t=this.getHeight(e)+1<=this.m_height}if(t){rs.setChildExtents_(h,o);for(let t=0;t<4;t++){const s=this.getChild_(e,t);if(-1!==s&&this.getSubTreeElementCount_(s)>0){i.isIntersecting(o[t])&&(n.push(s),r.push(o[t].clone()))}}}}return a}hasData(t,e){return this.getIntersectionCount(t,e,1)>=1}getIterator(t,e){return new os(this,t,e)}getIteratorForQT(){return new os(this)}getSortedIterator(t,e){return new as(this.getIterator(t,e))}getSortedIteratorForQT(){return new as(this.getIteratorForQT())}visitLeavesNearest(e,s,i,n){t(0)}reset_(t,s){(s<0||s>127)&&e("invalid height"),this.m_height=s,this.m_extent.setCoords({env2D:t}),this.m_dataExtent.setEmpty(),this.m_root=-1}insert_(t,e,s,i,n,r,o){if(!i.containsEnvelope(e))return 0===s?-1:this.insert_(t,e,0,this.m_extent,this.m_root,r,o);if(!r)for(let l=n;-1!==l;l=this.getParent_(l))this.setSubTreeElementCount_(l,this.getSubTreeElementCount_(l)+1);const a=new ge;a.setCoords({env2D:i});let h,m=n;for(h=s;h<this.m_height&&this.canPushDown_(m);h++){rs.setChildExtents_(a,this.m_childExtents);let t=!1;for(let s=0;s<4;s++)if(this.m_childExtents[s].containsEnvelope(e)){t=!0;let e=this.getChild_(m,s);-1===e&&(e=this.createChild_(m,s)),this.setSubTreeElementCount_(e,this.getSubTreeElementCount_(e)+1),m=e,a.setCoords({env2D:this.m_childExtents[s]});break}if(!t)break}return this.insertAtQuad_(t,e,h,a,m,r,n,o,-1)}insertDuplicates_(t,e,s,i,n,r,o){if(!r){if(!i.containsEnvelope(e))return-1;this.setSubTreeElementCount_(n,this.getSubTreeElementCount_(n)+1),this.setContainedSubTreeElementCount_(n,this.getContainedSubTreeElementCount_(n)+1)}const a=Math.max(e.width(),e.height());let h=-1;const m=[],l=[],u=[];m.push(n),l.push(i.clone()),u.push(s);const c=D(ge,4);for(;m.length>0;){let s=!1;const i=m.at(-1),g=l.at(-1),_=u.at(-1);if(m.pop(),l.pop(),u.pop(),_+1<this.m_height&&this.canPushDown_(i)){a<=Math.max(g.width(),g.height())/2&&(s=!0)}if(s){rs.setChildExtents_(g,c);let t=!1;for(let s=0;s<4;s++)if(t=c[s].containsEnvelope(e),t){let t=this.getChild_(i,s);-1===t&&(t=this.createChild_(i,s)),m.push(t),l.push(c[s].clone()),u.push(_+1),this.setSubTreeElementCount_(t,this.getSubTreeElementCount_(t)+1),this.setContainedSubTreeElementCount_(t,this.getContainedSubTreeElementCount_(t)+1);break}if(!t)for(let s=0;s<4;s++){if(c[s].isIntersecting(e)){let t=this.getChild_(i,s);-1===t&&(t=this.createChild_(i,s)),m.push(t),l.push(c[s].clone()),u.push(_+1),this.setSubTreeElementCount_(t,this.getSubTreeElementCount_(t)+1)}}}else h=this.insertAtQuad_(t,e,_,g,i,r,n,o,h),r=!1}return 0}insertAtQuad_(t,e,s,i,n,r,o,a,h){this.getFirstElement_(n);const m=this.getLastElement_(n);let l=-1;if(r){if(n===o)return a;this.disconnectElementHandle_(a),l=a}else-1===h?(l=this.createElement_(),this.setDataValues_(this.getData_(l),t,e)):l=this.createElementFromDuplicate_(h);return this.setQuad_(l,n),-1!==m?(this.setPrevElement_(l,m),this.setNextElement_(m,l)):this.setFirstElement_(n,l),this.setLastElement_(n,l),this.setLocalElementCount_(n,this.getLocalElementCount_(n)+1),this.canFlush_(n)&&this.flush_(s,i,n),l}static setChildExtents_(t,e){const s=.5*(t.xmin+t.xmax),i=.5*(t.ymin+t.ymax);e[0].setCoords({xmin:s,ymin:i,xmax:t.xmax,ymax:t.ymax}),e[1].setCoords({xmin:t.xmin,ymin:i,xmax:s,ymax:t.ymax}),e[2].setCoords({xmin:t.xmin,ymin:t.ymin,xmax:s,ymax:i}),e[3].setCoords({xmin:s,ymin:t.ymin,xmax:t.xmax,ymax:i})}disconnectElementHandle_(t){const e=this.getQuad_(t),s=this.getFirstElement_(e),i=this.getLastElement_(e),n=this.getPrevElement_(t),r=this.getNextElement_(t);s===t?(-1!==r?this.setPrevElement_(r,-1):this.setLastElement_(e,-1),this.setFirstElement_(e,r)):i===t?(this.setNextElement_(n,-1),this.setLastElement_(e,n)):(this.setPrevElement_(r,n),this.setNextElement_(n,r)),this.setPrevElement_(t,-1),this.setNextElement_(t,-1),this.setLocalElementCount_(e,this.getLocalElementCount_(e)-1)}canFlush_(t){return this.getLocalElementCount_(t)===rs.m_flushingCount&&!this.hasChildren_(t)}flush_(t,e,s){let i;const n=new ge;let r=this.getFirstElement_(s),o=-1,a=-1;do{a=this.getData_(r),i=this.getElementValue_(a),n.setCoords({env2D:this.getBoundingBoxValue_(a)}),o=this.getNextElement_(r),this.m_bStoreDuplicates?this.insertDuplicates_(i,n,t,e,s,!0,r):this.insert_(i,n,t,e,s,!0,r),r=o}while(-1!==r)}canPushDown_(t){return this.getLocalElementCount_(t)>=rs.m_flushingCount||this.hasChildren_(t)}hasChildren_(t){return-1!==this.getChild_(t,0)||-1!==this.getChild_(t,1)||-1!==this.getChild_(t,2)||-1!==this.getChild_(t,3)}createChild_(t,e){const s=this.m_quadTreeNodes.newElement();return this.setChild_(t,e,s),this.setSubTreeElementCount_(s,0),this.setLocalElementCount_(s,0),this.setParent_(s,t),this.setHeightAndQuadrant_(s,this.getHeight_(t)+1,e),this.m_bStoreDuplicates&&this.setContainedSubTreeElementCount_(s,0),s}createRoot_(){this.m_root=this.m_quadTreeNodes.newElement(),this.setSubTreeElementCount_(this.m_root,0),this.setLocalElementCount_(this.m_root,0),this.setHeightAndQuadrant_(this.m_root,0,0),this.m_bStoreDuplicates&&this.setContainedSubTreeElementCount_(this.m_root,0)}createElement_(){const t=this.m_elementNodes.newElement();let e;return this.m_freeData.length>0?(e=this.m_freeData.at(-1),this.m_freeData.pop()):(e=this.m_data.length,this.m_data.length=e+1),this.setData_(t,e),t}createElementFromDuplicate_(t){const e=this.m_elementNodes.newElement(),s=this.getData_(t);return this.setData_(e,s),e}freeElementAndBoxNode_(e){t(0)}getChild_(t,e){return this.m_quadTreeNodes.getField(t,e)}setChild_(t,e,s){this.m_quadTreeNodes.setField(t,e,s)}getFirstElement_(t){return this.m_quadTreeNodes.getField(t,4)}setFirstElement_(t,e){this.m_quadTreeNodes.setField(t,4,e)}getLastElement_(t){return this.m_quadTreeNodes.getField(t,5)}setLastElement_(t,e){this.m_quadTreeNodes.setField(t,5,e)}getQuadrant_(t){return this.m_quadTreeNodes.getField(t,6)&rs.m_quadrantMask}getHeight_(t){return this.m_quadTreeNodes.getField(t,6)>>rs.m_heightBitShift}setHeightAndQuadrant_(t,e,s){const i=e<<rs.m_heightBitShift|s;this.m_quadTreeNodes.setField(t,6,i)}getLocalElementCount_(t){return this.m_quadTreeNodes.getField(t,7)}setLocalElementCount_(t,e){this.m_quadTreeNodes.setField(t,7,e)}getSubTreeElementCount_(t){return this.m_quadTreeNodes.getField(t,8)}setSubTreeElementCount_(t,e){this.m_quadTreeNodes.setField(t,8,e)}getParent_(t){return this.m_quadTreeNodes.getField(t,9)}setParent_(t,e){this.m_quadTreeNodes.setField(t,9,e)}getContainedSubTreeElementCount_(t){return this.m_quadTreeNodes.getField(t,10)}setContainedSubTreeElementCount_(t,e){this.m_quadTreeNodes.setField(t,10,e)}getData_(t){return this.m_elementNodes.getField(t,0)}setData_(t,e){this.m_elementNodes.setField(t,0,e)}getPrevElement_(t){return this.m_elementNodes.getField(t,1)}getNextElement_(t){return this.m_elementNodes.getField(t,2)}setPrevElement_(t,e){this.m_elementNodes.setField(t,1,e)}setNextElement_(t,e){this.m_elementNodes.setField(t,2,e)}getQuad_(t){return this.m_elementNodes.getField(t,3)}setQuad_(t,e){this.m_elementNodes.setField(t,3,e)}getElementValue_(t){return this.m_data[t].element}getBoundingBoxValue_(t){return this.m_data[t].box}setDataValues_(t,e,s){this.m_data[t]=ns(e,s)}}rs.m_quadrantMask=3,rs.m_heightBitShift=2,rs.m_flushingCount=5;class os{constructor(t,e,s){this.m_bLinear=!1,this.m_queryStart=new w,this.m_queryEnd=new w,this.m_queryBox=new ge,this.m_tolerance=0,this.m_currentElementHandle=-1,this.m_nextElementHandle=-1,this.m_quadsStack=[],this.m_extentsStack=[],this.m_childExtents=[new ge,new ge,new ge,new ge],this.m_quadTree=t,e&&this.resetIterator(e,s)}resetIterator(t,e){if(void 0===e&&(e=0),t instanceof ge)return this.m_quadsStack.length=0,this.m_extentsStack.length=0,this.m_currentElementHandle=-1,this.m_queryBox.setCoords({env2D:t}),this.m_queryBox.inflateCoords(e,e),this.m_tolerance=Number.NaN,void(-1!==this.m_quadTree.m_root&&this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)?(this.m_quadsStack.push(this.m_quadTree.m_root),this.m_extentsStack.push(this.m_quadTree.m_extent.clone()),this.m_nextElementHandle=this.m_quadTree.getFirstElement_(this.m_quadTree.m_root),this.m_bLinear=!1):this.m_nextElementHandle=-1);if(this.m_quadsStack.length=0,this.m_extentsStack.length=0,this.m_currentElementHandle=-1,t.queryLooseEnvelope(this.m_queryBox),this.m_queryBox.inflateCoords(e,e),-1!==this.m_quadTree.m_root&&this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)){const i=t.getGeometryType();if(this.m_bLinear=i===s.enumLine,this.m_bLinear){const s=t;this.m_queryStart.assign(s.getStartXY()),this.m_queryEnd.assign(s.getEndXY()),this.m_tolerance=e}else this.m_tolerance=Number.NaN;this.m_quadsStack.push(this.m_quadTree.m_root),this.m_extentsStack.push(this.m_quadTree.m_extent.clone()),this.m_nextElementHandle=this.m_quadTree.getFirstElement_(this.m_quadTree.m_root)}else this.m_nextElementHandle=-1}next(){if(0===this.m_quadsStack.length)return-1;this.m_currentElementHandle=this.m_nextElementHandle;const t=new w,e=new w,s=new ge;let i=!1;for(;!i;){for(;-1!==this.m_currentElementHandle;){const n=this.m_quadTree.getData_(this.m_currentElementHandle);if(s.setCoords({env2D:this.m_quadTree.getBoundingBoxValue_(n)}),s.isIntersecting(this.m_queryBox)){if(!this.m_bLinear){i=!0;break}if(t.setCoordsPoint2D(this.m_queryStart),e.setCoordsPoint2D(this.m_queryEnd),s.inflateCoords(this.m_tolerance,this.m_tolerance),s.clipLine(t,e)>0){i=!0;break}}this.m_currentElementHandle=this.m_quadTree.getNextElement_(this.m_currentElementHandle)}if(-1===this.m_currentElementHandle){const s=this.m_quadsStack.at(-1),i=this.m_extentsStack.at(-1);rs.setChildExtents_(i,this.m_childExtents),this.m_quadsStack.pop(),this.m_extentsStack.pop();for(let n=0;n<4;n++){const i=this.m_quadTree.getChild_(s,n);if(-1!==i&&this.m_quadTree.getSubTreeElementCount(i)>0&&this.m_childExtents[n].isIntersecting(this.m_queryBox))if(this.m_bLinear){t.setCoordsPoint2D(this.m_queryStart),e.setCoordsPoint2D(this.m_queryEnd);const s=new ge;s.setCoords({env2D:this.m_childExtents[n]}),s.inflateCoords(this.m_tolerance,this.m_tolerance),s.clipLine(t,e)>0&&(this.m_quadsStack.push(i),this.m_extentsStack.push(this.m_childExtents[n].clone()))}else this.m_quadsStack.push(i),this.m_extentsStack.push(this.m_childExtents[n].clone())}if(0===this.m_quadsStack.length)return-1;this.m_currentElementHandle=this.m_quadTree.getFirstElement_(this.m_quadsStack.at(-1))}}return this.m_nextElementHandle=this.m_quadTree.getNextElement_(this.m_currentElementHandle),this.m_currentElementHandle}clone(){return t(0),{}}}class as{constructor(t){this.m_bucketSort=new ss,this.m_sortedHandles=new Qe(0),this.m_index=-1,this.m_quadTreeIteratorImpl=t}resetIterator(t,e){this.m_quadTreeIteratorImpl.resetIterator(t,e),this.m_sortedHandles.resize(0),this.m_index=-1}next(){if(-1===this.m_index){let t=-1;for(;-1!==(t=this.m_quadTreeIteratorImpl.next());)this.m_sortedHandles.add(t);const e=this,s={userSort(t,s,i){i.sort(t,s,((t,s)=>e.m_quadTreeIteratorImpl.m_quadTree.getElement(t)-e.m_quadTreeIteratorImpl.m_quadTree.getElement(s)))},getValue:t=>e.m_quadTreeIteratorImpl.m_quadTree.getElement(t)};this.m_bucketSort.sort(this.m_sortedHandles,0,this.m_sortedHandles.size(),s)}return this.m_index===this.m_sortedHandles.size()-1?-1:(this.m_index++,this.m_sortedHandles.read(this.m_index))}clone(){return t(0),{}}}class hs{constructor(t=!1){this.m_bNotifyOnActions=t}onDelete(t){}onSet(t){}onEndSearch(t){}onAddUniqueElementFailed(t){}onDeleteImpl(t,e){this.m_bNotifyOnActions&&this.onDelete(t.getElement(e))}onSetImpl(t,e){this.m_bNotifyOnActions&&this.onSet(t.getElement(e))}onAddUniqueElementFailedImpl(t){this.m_bNotifyOnActions&&this.onAddUniqueElementFailed(t)}onEndSearchImpl(t){this.m_bNotifyOnActions&&this.onEndSearch(t)}}class ms{static st_nullNode(){return-1}constructor(){this.m_defaultTreap=-1,this.m_random=124234251,this.m_comparator=null,this.m_treapData=new is(7),this.m_treapCount=0,this.m_maxDepthEver=0,this.m_bBalancing=!0}setComparator(t){this.m_comparator=t}getComparator(){return this.m_comparator}disableBalancing(){this.m_bBalancing=!1}enableBalancing(){this.m_bBalancing||(t(this.m_treapCount<=1),this.rebalance(-1),this.m_bBalancing=!0)}isAutoBalancing(){return this.m_bBalancing}rebalance(t){if(this.m_bBalancing)return;if(-1===t&&(t=this.m_defaultTreap),0===this.size(t))return;const e=[];for(let s=this.getFirst(t);-1!==s;s=this.getNext(s))e.push(s),this.setParent_(s,-1),this.setRight_(s,-1),this.setLeft_(s,-1);this.setRoot_(-1,t),this.setFirst_(-1,t),this.setLast_(-1,t),this.setSize_(0,t),this.m_bBalancing=!0;for(const s of e)this.addBiggestElement_(s,t);this.m_bBalancing=!1}setCapacity(t){this.m_treapData.setCapacity(t)}createTreap(t){const e=this.m_treapData.newElement();return this.setSize_(0,e),this.setTreapData_(t,e),this.m_treapCount++,e}deleteTreap(t){this.m_treapData.deleteElement(t),this.m_treapCount--}addElement(t,e=-1){return-1===e&&(this.m_defaultTreap===ms.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),e=this.m_defaultTreap),this.addElement_(t,0,e)}addUniqueElement(t,e=-1){return-1===e&&(this.m_defaultTreap===ms.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),e=this.m_defaultTreap),this.addElement_(t,1,e)}addBiggestElement(t,e=-1){-1===e&&(this.m_defaultTreap===ms.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),e=this.m_defaultTreap);const s=this.newNode_(t);return this.addBiggestElement_(s,e),s}addElementAtPosition(t,e,s,i,n,r=-1){if(-1===r&&(this.m_defaultTreap===ms.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),r=this.m_defaultTreap),this.getRoot_(r)===ms.st_nullNode()){const t=this.newNode_(s);return this.setRoot_(t,r),this.addToList_(-1,t,r),t}let o,a,h,m,l;if(n?(o=e!==ms.st_nullNode()?this.m_comparator.compare(this,s,e):-1,a=t!==ms.st_nullNode()?this.m_comparator.compare(this,s,t):1):(o=-1,a=1),i&&(0===o||0===a)){this.m_comparator.onAddUniqueElementFailedImpl(s);const i=0===o?e:t;return this.setDuplicateElement_(i,r),-1}l=e!==ms.st_nullNode()&&t!==ms.st_nullNode()?this.m_random>R(this.m_random)>>1:e!==ms.st_nullNode(),l?(m=o,h=e):(m=a,h=t);let u=-1,c=-1,g=!0;for(;;){if(m<0){const t=this.getLeft(h);if(t===ms.st_nullNode()){c=h,u=this.newNode_(s),this.setLeft_(h,u),this.setParent_(u,h);break}h=t}else{const t=this.getRight(h);if(t===ms.st_nullNode()){c=this.getNext(h),u=this.newNode_(s),this.setRight_(h,u),this.setParent_(u,h);break}h=t}g&&(m*=-1,g=!1)}return this.bubbleUp_(u),this.getParent(u)===ms.st_nullNode()&&this.setRoot_(u,r),this.addToList_(c,u,r),u}replaceElementAtPosition(t,e,s,i,n=-1){if(i){const i=this.getNext(t);let r=-1;i!==ms.st_nullNode()&&(r=this.m_comparator.compare(this,e,i));const o=this.getPrev(t);let a=-1;if(o!==ms.st_nullNode()&&(a=this.m_comparator.compare(this,e,o)),s&&(0===r||0===a)){this.m_comparator.onAddUniqueElementFailedImpl(e);const t=0===r?i:o;return n===ms.st_nullNode()&&(this.m_defaultTreap===ms.st_nullNode()&&(this.m_defaultTreap=this.createTreap(-1)),n=this.m_defaultTreap),this.setDuplicateElement_(t,n),-1}}return this.setElement_(t,e),t}getDuplicateElement(t=-1){return-1===t?this.getDuplicateElement_(this.m_defaultTreap):this.getDuplicateElement_(t)}deleteNode(t,e=-1){this.m_comparator&&this.m_comparator.onDeleteImpl(this,t),-1===e&&(e=this.m_defaultTreap),this.m_bBalancing?this.deleteNode_(t,e):this.unbalancedDelete_(t,e)}search(t,e=-1){let s=this.getRoot(e);for(;s!==ms.st_nullNode();){const e=this.m_comparator.compare(this,t,s);if(!e)return s;s=e<0?this.getLeft(s):this.getRight(s)}return this.m_comparator.onEndSearchImpl(t),ms.st_nullNode()}searchLowerBound(t,e=-1){let s=this.getRoot(e),i=-1;for(;s!==ms.st_nullNode();){const e=t.compare(this,s);if(!e)return s;e<0?s=this.getLeft(s):(i=s,s=this.getRight(s))}return i}searchUpperBound(t,e=-1){let s=this.getRoot(e),i=-1;for(;s!==ms.st_nullNode();){const e=t.compare(this,s);if(!e)return s;e<0?(i=s,s=this.getLeft(s)):s=this.getRight(s)}return i}getElement(t){return this.m_treapData.getField(t,3)}getLeft(t){return this.m_treapData.getField(t,0)}getRight(t){return this.m_treapData.getField(t,1)}getParent(t){return this.m_treapData.getField(t,2)}getNext(t){return this.m_treapData.getField(t,6)}getPrev(t){return this.m_treapData.getField(t,5)}getFirst(t=-1){return-1===t?this.getFirst_(this.m_defaultTreap):this.getFirst_(t)}getLast(t=-1){return-1===t?this.getLast_(this.m_defaultTreap):this.getLast_(t)}getTreapData(t=-1){return-1===t?this.getTreapData_(this.m_defaultTreap):this.getTreapData_(t)}setElement(t,e){null!==this.m_comparator&&this.m_comparator.onSetImpl(this,t),this.setElement_(t,e)}getRoot(t=-1){return-1===t?this.getRoot_(this.m_defaultTreap):this.getRoot_(t)}clear(){this.m_treapData.deleteAll(!1),this.m_defaultTreap=ms.st_nullNode(),this.m_treapCount=0,this.m_maxDepthEver=0}addToList_(t,e,s){let i;-1!==t?(i=this.getPrev(t),this.setPrev_(t,e)):i=this.getLast_(s),this.setPrev_(e,i),-1!==i&&this.setNext_(i,e),this.setNext_(e,t),t===this.getFirst_(s)&&this.setFirst_(e,s),-1===t&&this.setLast_(e,s),this.setSize_(this.getSize_(s)+1,s)}size(t=-1){return-1===t?this.getSize_(this.m_defaultTreap):this.getSize_(t)}getMaxDepth(t=-1){return this.getMaxDepthHelper_(this.getRoot(t))}getMaxDepthEver(){return this.m_maxDepthEver}static st_isValidNode(t){return is.isValidElement(t)}dbgCheck_(e){t(0)}getPriority_(t){return this.m_treapData.getField(t,4)}bubbleDown_(t){let e=this.getLeft(t),s=this.getRight(t);const i=this.getPriority_(t);for(;e!==ms.st_nullNode()||s!==ms.st_nullNode();){const n=e!==ms.st_nullNode()?this.getPriority_(e):L(),r=s!==ms.st_nullNode()?this.getPriority_(s):L();if(i<=Math.min(n,r))return;n<=r?this.rotateRight_(e):this.rotateLeft_(t),e=this.getLeft(t),s=this.getRight(t)}}bubbleUp_(t){if(!this.m_bBalancing)return;const e=this.getPriority_(t);let s=this.getParent(t);for(;s!==ms.st_nullNode()&&this.getPriority_(s)>e;)this.getLeft(s)===t?this.rotateRight_(t):this.rotateLeft_(s),s=this.getParent(t)}rotateLeft_(t){const e=t,s=this.getRight(t);let i;this.setParent_(s,this.getParent(e)),this.setParent_(e,s),i=this.getLeft(s),this.setRight_(e,i),i!==ms.st_nullNode()&&this.setParent_(i,e),this.setLeft_(s,e),i=this.getParent(s),i!==ms.st_nullNode()&&(this.getLeft(i)===e?this.setLeft_(i,s):this.setRight_(i,s))}rotateRight_(t){const e=this.getParent(t),s=t;let i;this.setParent_(s,this.getParent(e)),this.setParent_(e,s),i=this.getRight(s),this.setLeft_(e,i),i!==ms.st_nullNode()&&this.setParent_(i,e),this.setRight_(s,e),i=this.getParent(s),i!==ms.st_nullNode()&&(this.getLeft(i)===e?this.setLeft_(i,s):this.setRight_(i,s))}setParent_(t,e){this.m_treapData.setField(t,2,e)}setLeft_(t,e){this.m_treapData.setField(t,0,e)}setRight_(t,e){this.m_treapData.setField(t,1,e)}setPriority_(t,e){this.m_treapData.setField(t,4,e)}setPrev_(t,e){this.m_treapData.setField(t,5,e)}setNext_(t,e){this.m_treapData.setField(t,6,e)}setRoot_(t,e){this.m_treapData.setField(e,0,t)}setFirst_(t,e){this.m_treapData.setField(e,1,t)}setLast_(t,e){this.m_treapData.setField(e,2,t)}setDuplicateElement_(t,e){this.m_treapData.setField(e,3,t)}setSize_(t,e){this.m_treapData.setField(e,4,t)}setTreapData_(t,e){this.m_treapData.setField(e,5,t)}getRoot_(t){return-1===t?ms.st_nullNode():this.m_treapData.getField(t,0)}getFirst_(t){return-1===t?ms.st_nullNode():this.m_treapData.getField(t,1)}getLast_(t){return-1===t?ms.st_nullNode():this.m_treapData.getField(t,2)}getDuplicateElement_(t){return-1===t?ms.st_nullNode():this.m_treapData.getField(t,3)}getSize_(t){return-1===t?0:this.m_treapData.getField(t,4)}getTreapData_(t){return this.m_treapData.getField(t,5)}newNode_(t){const e=this.m_treapData.newElement();return this.setPriority_(e,this.generatePriority_()),this.setElement_(e,t),e}freeNode_(t,e){t!==ms.st_nullNode()&&this.m_treapData.deleteElement(t)}generatePriority_(){return this.m_random=R(this.m_random),this.m_random&L()>>1}maxPriority(){return t(0),0}getMaxDepthHelper_(t){return t===ms.st_nullNode()?0:1+Math.max(this.getMaxDepthHelper_(this.getLeft(t)),this.getMaxDepthHelper_(this.getRight(t)))}addElement_(t,e,s){if(this.getRoot(s)===ms.st_nullNode()){const e=this.newNode_(t);return this.setRoot_(e,s),this.addToList_(-1,e,s),this.m_maxDepthEver=Math.max(this.m_maxDepthEver,1),e}let i=this.getRoot_(s),n=-1,r=-1,o=1;for(;;){const a=-1===e?1:this.m_comparator.compare(this,t,i);if(a<0){const e=this.getLeft(i);if(e===ms.st_nullNode()){r=i,n=this.newNode_(t),this.setLeft_(i,n),this.setParent_(n,i);break}i=e}else{if(1===e&&0===a)return this.m_comparator.onAddUniqueElementFailedImpl(t),this.setDuplicateElement_(i,s),-1;const o=this.getRight(i);if(o===ms.st_nullNode()){r=this.getNext(i),n=this.newNode_(t),this.setRight_(i,n),this.setParent_(n,i);break}i=o}o++}return this.bubbleUp_(n),this.getParent(n)===ms.st_nullNode()&&this.setRoot_(n,s),this.addToList_(r,n,s),this.m_maxDepthEver=Math.max(o,this.m_maxDepthEver),n}removeFromList_(t,e){const s=this.getPrev(t),i=this.getNext(t);-1!==s?this.setNext_(s,i):this.setFirst_(i,e),-1!==i?this.setPrev_(i,s):this.setLast_(s,e),this.setSize_(this.getSize_(e)-1,e)}unbalancedDelete_(t,e){this.removeFromList_(t,e);let s=this.getLeft(t),i=this.getRight(t),n=this.getParent(t),r=t;if(-1!==s&&-1!==i){let o;this.m_random=R(this.m_random),o=this.m_random>L()>>1?this.getNext(t):this.getPrev(t);const a=this.getParent(o)===t;this.m_treapData.swapField(t,o,0),this.m_treapData.swapField(t,o,1),this.m_treapData.swapField(t,o,2),-1!==n?this.getLeft(n)===t?this.setLeft_(n,o):this.setRight_(n,o):this.setRoot_(o,e),a?(s===o?(this.setLeft_(o,t),this.setParent_(i,o)):i===o&&(this.setRight_(o,t),this.setParent_(s,o)),this.setParent_(t,o),n=o):(this.setParent_(s,o),this.setParent_(i,o),n=this.getParent(t),r=o),s=this.getLeft(t),i=this.getRight(t),-1!==s&&this.setParent_(s,t),-1!==i&&this.setParent_(i,t)}const o=-1!==s?s:i;-1===n?this.setRoot_(o,e):this.getLeft(n)===r?this.setLeft_(n,o):this.setRight_(n,o),-1!==o&&this.setParent_(o,n),this.freeNode_(t,e)}deleteNode_(t,e){this.setPriority_(t,L());let s=ms.st_nullNode(),i=ms.st_nullNode();const n=this.getRoot_(e),r=n===t;if(r&&(s=this.getLeft(n),i=this.getRight(n),s===ms.st_nullNode()&&i===ms.st_nullNode()))return this.removeFromList_(n,e),this.freeNode_(n,e),void this.setRoot_(ms.st_nullNode(),e);this.bubbleDown_(t);const o=this.getParent(t);o!==ms.st_nullNode()&&(this.getLeft(o)===t?this.setLeft_(o,ms.st_nullNode()):this.setRight_(o,ms.st_nullNode())),this.removeFromList_(t,e),this.freeNode_(t,e),r&&this.setRoot_(s===ms.st_nullNode()||this.getParent(s)!==ms.st_nullNode()?i:s,e)}setElement_(t,e){this.m_treapData.setField(t,3,e)}addBiggestElement_(t,e){if(this.getRoot_(e)===ms.st_nullNode())return this.setRoot_(t,e),void this.addToList_(-1,t,e);const s=this.getLast_(e);this.setRight_(s,t),this.setParent_(t,s),this.bubbleUp_(t),this.getParent(t)===ms.st_nullNode()&&this.setRoot_(t,e),this.addToList_(-1,t,e)}}class ls{constructor(t){this.m_lists=new is(6),this.m_listOfLists=ls.st_nullNode(),void 0===t?(this.m_listNodes=new is(3),this.m_bStoreListIndexWithNode=!1):(this.m_listNodes=new is(t?4:3),this.m_bStoreListIndexWithNode=t)}freeNode_(t){this.m_listNodes.deleteElement(t)}newNode_(){return this.m_listNodes.newElement()}freeList_(e){t(0)}newList_(){return this.m_lists.newElement()}setPrev_(t,e){this.m_listNodes.setField(t,1,e)}setNext_(t,e){this.m_listNodes.setField(t,2,e)}setData_(e,s){t(0)}setList_(t,e){return this.m_listNodes.setField(t,3,e)}setListSize_(t,e){this.m_lists.setField(t,4,e)}setNextList_(e,s){t(0)}setPrevList_(t,e){this.m_lists.setField(t,2,e)}createList(t){const e=this.newList_();return this.m_lists.setField(e,3,this.m_listOfLists),this.m_lists.setField(e,4,0),this.m_lists.setField(e,5,t),this.m_listOfLists!==ls.st_nullNode()&&this.setPrevList_(this.m_listOfLists,e),this.m_listOfLists=e,e}deleteList(t){this.clear(t);const e=this.m_lists.getField(t,2),s=this.m_lists.getField(t,3);return e!==ls.st_nullNode()?this.setNextList_(e,s):this.m_listOfLists=s,s!==ls.st_nullNode()&&this.setPrevList_(s,e),this.freeList_(t),s}reserveLists(e){t(0)}getListData(t){return this.m_lists.getField(t,5)}getList(e){return t(0),0}setListData(t,e){this.m_lists.setField(t,5,e)}addElement(t,e){return this.insertElement(t,-1,e)}insertElement(t,e,s){const i=this.newNode_();let n=-1;e!==ls.st_nullNode()&&(n=this.getPrev(e),this.setPrev_(e,i)),this.setNext_(i,e),n!==ls.st_nullNode()&&this.setNext_(n,i);if(e===this.m_lists.getField(t,0)&&this.m_lists.setField(t,0,i),e===ls.st_nullNode()){const e=this.m_lists.getField(t,1);this.setPrev_(i,e),-1!==e&&this.setNext_(e,i),this.m_lists.setField(t,1,i)}return this.setData(i,s),this.setListSize_(t,this.getListSize(t)+1),this.m_bStoreListIndexWithNode&&this.setList_(i,t),i}deleteElement(t,e){const s=this.getPrev(e),i=this.getNext(e);return s!==ls.st_nullNode()?this.setNext_(s,i):this.m_lists.setField(t,0,i),i!==ls.st_nullNode()?this.setPrev_(i,s):this.m_lists.setField(t,1,s),this.freeNode_(e),this.setListSize_(t,this.getListSize(t)-1),i}reserveNodes(t){this.m_listNodes.setCapacity(t)}getData(t){return this.m_listNodes.getField(t,0)}getElement(t){return this.getData(t)}setData(t,e){this.m_listNodes.setField(t,0,e)}getNext(t){return this.m_listNodes.getField(t,2)}getPrev(t){return this.m_listNodes.getField(t,1)}getFirst(t){return this.m_lists.getField(t,0)}getLast(t){return this.m_lists.getField(t,1)}static st_nullNode(){return-1}clear(t){if(void 0!==t){let e=this.getLast(t);for(;e!==ls.st_nullNode();){const t=e;e=this.getPrev(t),this.freeNode_(t)}return this.m_lists.setField(t,0,-1),this.m_lists.setField(t,1,-1),void this.setListSize_(t,0)}for(let e=this.getFirstList();-1!==e;)e=this.deleteList(e)}isEmpty(e){return t(0),!1}getNodeCount(){return this.m_listNodes.size()}getListCount(){return this.m_lists.size()}getListSize(t){return this.m_lists.getField(t,4)}getFirstList(){return this.m_listOfLists}getNextList(t){return this.m_lists.getField(t,3)}}class us extends hs{constructor(t){super(),this.m_intervalTree=t}compare(t,e,s){const i=t.getElement(s),n=this.m_intervalTree.getValue_(e),r=this.m_intervalTree.getValue_(i);return n<r?-1:n===r?cs.isLeft_(e)&&cs.isRight_(i)?-1:cs.isLeft_(i)&&cs.isRight_(e)?1:0:1}}class cs{constructor(t){this.m_bEnvelopesRef=!1,this.m_intervals=[],this.m_envelopesRef=null,this.m_intervalNodes=new is(3),this.m_intervalHandles=[],this.m_endIndicesUnique=[],this.m_cCount=-1,this.m_root=-1,this.m_bSortIntervals=!1,this.m_bConstructing=!1,this.m_bConstructionEnded=!1,this.m_bOfflineDynamic=t,this.m_tertiaryNodes=new is(this.m_bOfflineDynamic?5:4),this.m_secondaryTreaps=new ms,this.m_secondaryTreaps.setComparator(new us(this)),this.m_secondaryLists=new ls}addEnvelopesRef(t){this.reset_(!0,!0),this.m_bEnvelopesRef=!0,this.m_envelopesRef=t,this.m_bConstructing=!1,this.m_bConstructionEnded=!0,this.m_bOfflineDynamic||(this.insertIntervalsStatic_(),this.m_cCount=this.m_envelopesRef.length)}startConstruction(){this.reset_(!0,!1)}addInterval(t){this.m_bConstructing||h(""),this.m_intervals.push(t.clone())}addIntervalCoords(e,s){t(0)}endConstruction(){this.m_bConstructing||h(""),this.m_bConstructing=!1,this.m_bConstructionEnded=!0,this.m_bOfflineDynamic||(this.insertIntervalsStatic_(),this.m_cCount=this.m_intervals.length)}insert(t){if(this.m_bOfflineDynamic&&this.m_bConstructionEnded||h(""),-1===this.m_root){const t=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length;if(this.m_bSortIntervals){const e=new Qe(0);this.querySortedEndPointIndices_(e),this.m_endIndicesUnique.length=0,this.querySortedDuplicatesRemoved_(e),this.m_intervalHandles.length=t,this.m_intervalHandles.fill(-1),this.m_bSortIntervals=!1}else this.m_intervalHandles.fill(-1,0,t);this.m_root=this.createRoot_()}const e=this.insertIntervalEnd_(t<<1,this.m_root),s=this.getSecondaryFromInterval_(e),i=this.m_secondaryTreaps.addElement(1+(t<<1),s);this.setRightEnd_(e,i),this.m_intervalHandles[t]=e,this.m_cCount++}remove(t){this.m_bOfflineDynamic&&this.m_bConstructionEnded||h("");const s=this.m_intervalHandles[t];let i;-1===s&&e("the interval does not exist in the interval tree"),this.m_intervalHandles[t]=-1,this.m_cCount--;let n=this.getSecondaryFromInterval_(s),r=-1;r=this.m_secondaryTreaps.getTreapData(n),this.m_secondaryTreaps.deleteNode(this.getLeftEnd_(s),n),this.m_secondaryTreaps.deleteNode(this.getRightEnd_(s),n),i=this.m_secondaryTreaps.size(n),0===i&&(this.m_secondaryTreaps.deleteTreap(n),this.setSecondaryToTertiary_(r,-1)),this.m_intervalNodes.deleteElement(s);let o=this.getPptr_(r),a=this.getLptr_(r),m=this.getRptr_(r);for(;!(i>0||r===this.m_root||-1!==a&&-1!==m);)r===this.getLptr_(o)?-1!==a?(this.setLptr_(o,a),this.setPptr_(a,o),this.setLptr_(r,-1),this.setPptr_(r,-1)):-1!==m?(this.setLptr_(o,m),this.setPptr_(m,o),this.setRptr_(r,-1),this.setPptr_(r,-1)):(this.setLptr_(o,-1),this.setPptr_(r,-1)):-1!==a?(this.setRptr_(o,a),this.setPptr_(a,o),this.setLptr_(r,-1),this.setPptr_(r,-1)):-1!==m?(this.setRptr_(o,m),this.setPptr_(m,o),this.setRptr_(r,-1),this.setPptr_(r,-1)):(this.setRptr_(o,-1),this.setPptr_(r,-1)),this.m_tertiaryNodes.deleteElement(r),r=o,n=this.getSecondaryFromTertiary_(r),i=-1!==n?this.m_secondaryTreaps.size(n):0,a=this.getLptr_(r),m=this.getRptr_(r),o=this.getPptr_(r)}size(){return this.m_cCount}getIteratorQuery(e,s){return e instanceof A?new gs(this,e,s):(t(0),{})}getIterator(){return new gs(this)}querySortedEndPointIndices_(t){const e=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length;for(let s=0;s<2*e;s++)t.add(s);this.sortEndIndices_(t,0,2*e)}querySortedDuplicatesRemoved_(t){let e=Number.NaN;for(let s=0;s<t.size();s++){const i=t.read(s),n=this.getValue_(i);n!==e&&(this.m_endIndicesUnique.push(i),e=n)}}insertIntervalsStatic_(){const t=this.m_bEnvelopesRef?this.m_envelopesRef.length:this.m_intervals.length,e=new Qe(0);this.querySortedEndPointIndices_(e),this.m_endIndicesUnique.length=0,this.querySortedDuplicatesRemoved_(e),this.m_intervalNodes.setCapacity(t),this.m_secondaryLists.reserveNodes(2*t);const s=H(t,-1);this.m_root=this.createRoot_();for(let i=0;i<e.size();i++){const t=e.read(i);let n=s[t>>1];if(-1!==n){const e=this.getSecondaryFromInterval_(n);this.setRightEnd_(n,this.m_secondaryLists.addElement(e,t))}else n=this.insertIntervalEnd_(t,this.m_root),s[t>>1]=n}}createRoot_(){const t=this.calculateDiscriminantIndex1_(0,this.m_endIndicesUnique.length-1);return this.createTertiaryNode_(t)}insertIntervalEnd_(t,e){let s=-1,i=e,n=-1,r=-1,o=0,a=this.m_endIndicesUnique.length-1,h=0;const m=t>>1;let l=Number.NaN,u=Number.NaN,c=!0;const g=this.getMin_(m),_=this.getMax_(m);let d=-1;for(;c;){h=o+(a-o>>1),d=this.calculateDiscriminantIndex1_(o,a);const e=this.getDiscriminantFromIndex1_(d);if(_<e){if(-1!==i)if(d===this.getDiscriminantIndex1_(i))s=i,l=e,i=this.getLptr_(i),u=-1!==i?this.getDiscriminant_(i):Number.NaN;else if(u>e){const t=this.createTertiaryNode_(d);e<l?this.setLptr_(s,t):this.setRptr_(s,t),this.setRptr_(t,i),this.m_bOfflineDynamic&&(this.setPptr_(t,s),this.setPptr_(i,t)),s=t,l=e,i=-1,u=Number.NaN}a=h;continue}if(g>e){if(-1!==i)if(d===this.getDiscriminantIndex1_(i))s=i,l=e,i=this.getRptr_(i),u=-1!==i?this.getDiscriminant_(i):Number.NaN;else if(u<e){const t=this.createTertiaryNode_(d);e<l?this.setLptr_(s,t):this.setRptr_(s,t),this.setLptr_(t,i),this.m_bOfflineDynamic&&(this.setPptr_(t,s),this.setPptr_(i,t)),s=t,l=e,i=-1,u=Number.NaN}o=h+1;continue}let m=-1;m=-1===i||d!==this.getDiscriminantIndex1_(i)?this.createTertiaryNode_(d):i,n=this.getSecondaryFromTertiary_(m),-1===n&&(n=this.createSecondary_(m),this.setSecondaryToTertiary_(m,n));const p=this.addEndIndex_(n,t);r=this.createIntervalNode_(),this.setSecondaryToInterval_(r,n),this.setLeftEnd_(r,p),-1!==i&&d===this.getDiscriminantIndex1_(i)||(e<l?this.setLptr_(s,m):this.setRptr_(s,m),this.m_bOfflineDynamic&&this.setPptr_(m,s),-1!==i&&(u<e?this.setLptr_(m,i):this.setRptr_(m,i),this.m_bOfflineDynamic&&this.setPptr_(i,m))),c=!1;break}return r}createTertiaryNode_(t){const e=this.m_tertiaryNodes.newElement();return this.setDiscriminantIndex1_(e,t),e}createSecondary_(t){return this.m_bOfflineDynamic?this.m_secondaryTreaps.createTreap(t):this.m_secondaryLists.createList(t)}createIntervalNode_(){return this.m_intervalNodes.newElement()}reset(){this.m_bOfflineDynamic&&this.m_bConstructionEnded||h(""),this.reset_(!1,this.m_bEnvelopesRef)}reset_(t,e){t?(this.m_bEnvelopesRef=!1,this.m_envelopesRef=null,this.m_bSortIntervals=!0,this.m_bConstructing=!0,this.m_bConstructionEnded=!1,this.m_endIndicesUnique.length=0,e?(this.m_intervals.length=0,this.m_bEnvelopesRef=!0):this.m_intervals.length=0):this.m_bSortIntervals=!1,this.m_bOfflineDynamic?this.m_secondaryTreaps.clear():this.m_secondaryLists.clear(),this.m_intervalNodes.deleteAll(!1),this.m_tertiaryNodes.deleteAll(!1),this.m_root=-1,this.m_cCount=0}getDiscriminant_(t){const e=this.getDiscriminantIndex1_(t);return this.getDiscriminantFromIndex1_(e)}getDiscriminantFromIndex1_(t){if(-1===t)return Number.NaN;if(t>0){const e=t-2,s=this.m_endIndicesUnique[e],i=this.m_endIndicesUnique[e+1];return.5*(this.getValue_(s)+this.getValue_(i))}const e=-t-2,s=this.m_endIndicesUnique[e];return this.getValue_(s)}calculateDiscriminantIndex1_(t,e){let s;if(t<e){s=t+(e-t>>1)+2}else s=-(t+2);return s}setDiscriminantIndex1_(t,e){this.m_tertiaryNodes.setField(t,0,e)}setSecondaryToTertiary_(t,e){this.m_tertiaryNodes.setField(t,1,e)}setLptr_(t,e){this.m_tertiaryNodes.setField(t,2,e)}setRptr_(t,e){this.m_tertiaryNodes.setField(t,3,e)}setPptr_(t,e){this.m_tertiaryNodes.setField(t,4,e)}setSecondaryToInterval_(t,e){this.m_intervalNodes.setField(t,0,e)}addEndIndex_(t,e){let s=-1;return s=this.m_bOfflineDynamic?this.m_secondaryTreaps.addElement(e,t):this.m_secondaryLists.addElement(t,e),s}setLeftEnd_(t,e){this.m_intervalNodes.setField(t,1,e)}setRightEnd_(t,e){this.m_intervalNodes.setField(t,2,e)}getFirst_(t){return this.m_bOfflineDynamic?this.m_secondaryTreaps.getFirst(t):this.m_secondaryLists.getFirst(t)}getLast_(t){return this.m_bOfflineDynamic?this.m_secondaryTreaps.getLast(t):this.m_secondaryLists.getLast(t)}static isLeft_(t){return!(1&t)}static isRight_(t){return!(1&~t)}getDiscriminantIndex1_(t){return this.m_tertiaryNodes.getField(t,0)}getSecondaryFromTertiary_(t){return this.m_tertiaryNodes.getField(t,1)}getLptr_(t){return this.m_tertiaryNodes.getField(t,2)}getRptr_(t){return this.m_tertiaryNodes.getField(t,3)}getPptr_(t){return this.m_tertiaryNodes.getField(t,4)}getSecondaryFromInterval_(t){return this.m_intervalNodes.getField(t,0)}getLeftEnd_(t){return this.m_intervalNodes.getField(t,1)}getRightEnd_(t){return this.m_intervalNodes.getField(t,2)}getMin_(t){return this.m_bEnvelopesRef?this.m_envelopesRef[t].xmin:this.m_intervals[t].vmin}getMax_(t){return this.m_bEnvelopesRef?this.m_envelopesRef[t].xmax:this.m_intervals[t].vmax}sortEndIndices_(t,e,s){const i=this,n={userSort(t,e,s){i.sortEndIndicesHelper_(s,t,e)},getValue:t=>i.getValue_(t)};(new ss).sort(t,e,s,n)}sortEndIndicesHelper_(t,e,s){t.sort(e,s,((t,e)=>{const s=this.getValue_(t),i=this.getValue_(e);return s<i||s===i&&cs.isLeft_(t)&&cs.isRight_(e)?-1:1}))}getValue_(t){if(!this.m_bEnvelopesRef){const e=this.m_intervals[t>>1];return cs.isLeft_(t)?e.vmin:e.vmax}const e=this.m_envelopesRef[t>>1];return cs.isLeft_(t)?e.xmin:e.xmax}checkValidation_(){return t(0),!1}checkValidationHelper_(e){return t(0),0}}class gs{constructor(t,e,s){this.m_query=A.constructEmpty(),this.m_tertiaryHandle=-1,this.m_nextTertiaryHandle=-1,this.m_forkedHandle=-1,this.m_currentEndHandle=-1,this.m_nextEndHandle=-1,this.m_tertiaryStack=[],this.m_functionIndex=0,this.m_intervalTree=t,this.m_functionStack=new Array(2),this.m_functionStack[0]=this.nullFunc_,this.m_functionStack[1]=this.nullFunc_,void 0!==e&&this.resetIterator(e,s)}nullFunc_(){return t(0),!1}resetIterator(t,e){if("number"==typeof t){const s=new A;s.setCoords(t,t),this.resetIterator(s,e)}else void 0===e&&(e=0),this.m_query.vmin=t.vmin-e,this.m_query.vmax=t.vmax+e,this.m_tertiaryStack.length=0,this.m_functionIndex=0,this.m_functionStack[0]=this.initialize_}next(){if(this.m_intervalTree.m_bConstructionEnded||h(""),this.m_functionIndex<0)return-1;for(;this.m_fi=this.m_functionStack[this.m_functionIndex],this.m_fi(););return-1!==this.m_currentEndHandle?this.getCurrentEndIndex_()>>1:-1}initialize_(){return this.m_tertiaryHandle=-1,this.m_nextTertiaryHandle=-1,this.m_forkedHandle=-1,this.m_currentEndHandle=-1,this.m_intervalTree.m_tertiaryNodes.size()>0?(this.m_functionStack[0]=this.pIn_,this.m_nextTertiaryHandle=this.m_intervalTree.m_root,!0):(this.m_functionIndex=-1,!1)}pIn_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,-1===this.m_tertiaryHandle)return this.m_functionIndex=-1,this.m_currentEndHandle=-1,!1;const t=this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);if(this.m_query.vmax<t){const t=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),-1!==t&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(t),this.m_functionStack[++this.m_functionIndex]=this.left_),!0}if(t<this.m_query.vmin){const t=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),-1!==t&&(this.m_nextEndHandle=this.m_intervalTree.getLast_(t),this.m_functionStack[++this.m_functionIndex]=this.right_),!0}this.m_functionStack[this.m_functionIndex]=this.pL_,this.m_forkedHandle=this.m_tertiaryHandle;const e=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),-1!==e&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(e),this.m_functionStack[++this.m_functionIndex]=this.all_),!0}pL_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,-1===this.m_tertiaryHandle)return this.m_functionStack[this.m_functionIndex]=this.pR_,this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_forkedHandle),!0;if(this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle)<this.m_query.vmin){const t=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),-1!==t&&(this.m_nextEndHandle=this.m_intervalTree.getLast_(t),this.m_functionStack[++this.m_functionIndex]=this.right_),!0}const t=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),-1!==t&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(t),this.m_functionStack[++this.m_functionIndex]=this.all_);const e=this.m_intervalTree.getRptr_(this.m_tertiaryHandle);return-1!==e&&this.m_tertiaryStack.push(e),!0}pR_(){if(this.m_tertiaryHandle=this.m_nextTertiaryHandle,-1===this.m_tertiaryHandle)return this.m_functionStack[this.m_functionIndex]=this.pT_,!0;const t=this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);if(this.m_query.vmax<t){const t=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return this.m_nextTertiaryHandle=this.m_intervalTree.getLptr_(this.m_tertiaryHandle),-1!==t&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(t),this.m_functionStack[++this.m_functionIndex]=this.left_),!0}const e=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);this.m_nextTertiaryHandle=this.m_intervalTree.getRptr_(this.m_tertiaryHandle),-1!==e&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(e),this.m_functionStack[++this.m_functionIndex]=this.all_);const s=this.m_intervalTree.getLptr_(this.m_tertiaryHandle);return-1!==s&&this.m_tertiaryStack.push(s),!0}pT_(){if(0===this.m_tertiaryStack.length)return this.m_functionIndex=-1,this.m_currentEndHandle=-1,!1;this.m_tertiaryHandle=this.m_tertiaryStack.at(-1),this.m_tertiaryStack.pop();const t=this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);return-1!==t&&(this.m_nextEndHandle=this.m_intervalTree.getFirst_(t),this.m_functionStack[++this.m_functionIndex]=this.all_),-1!==this.m_intervalTree.getLptr_(this.m_tertiaryHandle)&&this.m_tertiaryStack.push(this.m_intervalTree.getLptr_(this.m_tertiaryHandle)),-1!==this.m_intervalTree.getRptr_(this.m_tertiaryHandle)&&this.m_tertiaryStack.push(this.m_intervalTree.getRptr_(this.m_tertiaryHandle)),!0}left_(){return this.m_currentEndHandle=this.m_nextEndHandle,-1!==this.m_currentEndHandle&&cs.isLeft_(this.getCurrentEndIndex_())&&this.m_intervalTree.getValue_(this.getCurrentEndIndex_())<=this.m_query.vmax?(this.m_nextEndHandle=this.getNext_(),!1):(this.m_functionIndex--,!0)}right_(){return this.m_currentEndHandle=this.m_nextEndHandle,-1!==this.m_currentEndHandle&&cs.isRight_(this.getCurrentEndIndex_())&&this.m_intervalTree.getValue_(this.getCurrentEndIndex_())>=this.m_query.vmin?(this.m_nextEndHandle=this.getPrev_(),!1):(this.m_functionIndex--,!0)}all_(){return this.m_currentEndHandle=this.m_nextEndHandle,-1!==this.m_currentEndHandle&&cs.isLeft_(this.getCurrentEndIndex_())?(this.m_nextEndHandle=this.getNext_(),!1):(this.m_functionIndex--,!0)}getNext_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getNext(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getNext(this.m_currentEndHandle)}getPrev_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getPrev(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getPrev(this.m_currentEndHandle)}getCurrentEndIndex_(){return this.m_intervalTree.m_bOfflineDynamic?this.m_intervalTree.m_secondaryTreaps.getElement(this.m_currentEndHandle):this.m_intervalTree.m_secondaryLists.getData(this.m_currentEndHandle)}}class _s{constructor(){this.m_tolerance=0,this.m_sweepIndexRed=-1,this.m_sweepIndexBlue=-1,this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_intervalTreeRed=null,this.m_intervalTreeBlue=null,this.m_iteratorRed=null,this.m_iteratorBlue=null,this.m_envelopesRed=[],this.m_envelopesBlue=[],this.m_elementsRed=[],this.m_elementsBlue=[],this.m_sortedEndIndicesRed=new Qe(0),this.m_sortedEndIndicesBlue=new Qe(0),this.m_queuedListRed=-1,this.m_queuedListBlue=-1,this.m_queuedEnvelopes=new ls,this.m_queuedIndicesRed=[],this.m_queuedIndicesBlue=[],this.m_bAddRed=!1,this.m_bAddBlue=!1,this.m_bAddRedRed=!1,this.m_bDone=!0,this.m_function=this.nullFunc_,this.reset_()}startConstruction(){this.reset_(),this.m_bAddRedRed=!0,this.m_elementsRed.length=0,this.m_envelopesRed.length=0}addEnvelope(t,e){this.m_bAddRedRed||h(""),this.m_elementsRed.push(t),this.m_envelopesRed.push(new ge(e))}endConstruction(){this.m_bAddRedRed||h(""),this.m_bAddRedRed=!1,this.m_envelopesRed.length>0&&(this.m_function=this.initialize_,this.m_bDone=!1)}startRedConstruction(){this.reset_(),this.m_bAddRed=!0,this.m_elementsRed.length=0,this.m_envelopesRed.length=0}addRedEnvelope(t,e){this.m_bAddRed||h(""),this.m_elementsRed.push(t),this.m_envelopesRed.push(e.clone())}endRedConstruction(){this.m_bAddRed||h(""),this.m_bAddRed=!1,this.m_envelopesRed.length>0&&this.m_envelopesBlue.length>0&&(this.m_function===this.nullFunc_||this.m_function===this.initializeBlue_?this.m_function=this.initializeRedBlue_:this.m_function!==this.initializeRedBlue_&&(this.m_function=this.initializeRed_),this.m_bDone=!1)}startBlueConstruction(){this.reset_(),this.m_bAddBlue=!0,this.m_elementsBlue.length=0,this.m_envelopesBlue.length=0}addBlueEnvelope(t,e){this.m_bAddBlue||h(""),this.m_elementsBlue.push(t),this.m_envelopesBlue.push(e.clone())}endBlueConstruction(){this.m_bAddBlue||h(""),this.m_bAddBlue=!1,this.m_envelopesRed.length>0&&this.m_envelopesBlue.length>0&&(this.m_function===this.nullFunc_||this.m_function===this.initializeRed_?this.m_function=this.initializeRedBlue_:this.m_function!==this.initializeRedBlue_&&(this.m_function=this.initializeBlue_),this.m_bDone=!1)}next(){if(this.m_bDone)return!1;for(;this.m_function(););return!this.m_bDone}getHandleA(){return this.m_envelopeHandleA}getHandleB(){return this.m_envelopeHandleB}setTolerance(t){this.m_tolerance=t}getEnvelope(e){return t(0),{}}getElement(t){return this.m_elementsRed[t]}getRedEnvelope(t){return this.m_envelopesRed[t]}getBlueEnvelope(t){return this.m_envelopesBlue[t]}getRedElement(t){return this.m_elementsRed[t]}getBlueElement(t){return this.m_elementsBlue[t]}isTop_(t){return!(1&~t)}isBottom_(t){return!(1&t)}reset_(){this.m_bAddRed=!1,this.m_bAddBlue=!1,this.m_bAddRedRed=!1,this.m_sweepIndexRed=-1,this.m_sweepIndexBlue=-1,this.m_queuedListRed=-1,this.m_queuedListBlue=-1,this.m_bDone=!0}initialize_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new cs(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),null===this.m_iteratorRed&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),this.m_sortedEndIndicesRed.resize(0);for(let t=0;t<2*this.m_envelopesRed.length;t++)this.m_sortedEndIndicesRed.add(t);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,2*this.m_envelopesRed.length,!0),this.m_sweepIndexRed=2*this.m_envelopesRed.length,this.m_function=this.sweep_,!0}initializeRed_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new cs(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),null===this.m_iteratorRed&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),this.m_sortedEndIndicesRed.resize(0);for(let t=0;t<2*this.m_envelopesRed.length;t++)this.m_sortedEndIndicesRed.add(t);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,this.m_sortedEndIndicesRed.size(),!0),this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),-1!==this.m_queuedListRed&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),this.m_function=this.sweepRedBlue_,this.resetBlue_()}initializeBlue_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeBlue||(this.m_intervalTreeBlue=new cs(!0)),this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue),null==this.m_iteratorBlue&&(this.m_iteratorBlue=this.m_intervalTreeBlue.getIterator()),this.m_sortedEndIndicesBlue.resize(0);for(let t=0;t<2*this.m_envelopesBlue.length;t++)this.m_sortedEndIndicesBlue.add(t);return this.sortYEndIndices_(this.m_sortedEndIndicesBlue,0,this.m_sortedEndIndicesBlue.size(),!1),this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),-1!==this.m_queuedListBlue&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_function=this.sweepRedBlue_,this.resetRed_()}initializeRedBlue_(){if(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_envelopesRed.length<10||this.m_envelopesBlue.length<10)return this.m_sweepIndexRed=this.m_envelopesRed.length,this.m_function=this.sweepRedBlueBruteForce_,!0;this.m_intervalTreeRed||(this.m_intervalTreeRed=new cs(!0)),this.m_intervalTreeBlue||(this.m_intervalTreeBlue=new cs(!0)),this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed),this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue),null===this.m_iteratorRed&&(this.m_iteratorRed=this.m_intervalTreeRed.getIterator()),null===this.m_iteratorBlue&&(this.m_iteratorBlue=this.m_intervalTreeBlue.getIterator()),this.m_sortedEndIndicesRed.resize(0),this.m_sortedEndIndicesBlue.resize(0);for(let t=0;t<2*this.m_envelopesRed.length;t++)this.m_sortedEndIndicesRed.add(t);for(let t=0;t<2*this.m_envelopesBlue.length;t++)this.m_sortedEndIndicesBlue.add(t);return this.sortYEndIndices_(this.m_sortedEndIndicesRed,0,this.m_sortedEndIndicesRed.size(),!0),this.sortYEndIndices_(this.m_sortedEndIndicesBlue,0,this.m_sortedEndIndicesBlue.size(),!1),this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),-1!==this.m_queuedListRed&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),-1!==this.m_queuedListBlue&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_function=this.sweepRedBlue_,!0}sweep_(){const t=this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed),e=t>>1;if(this.isBottom_(t))return this.m_intervalTreeRed.remove(e),0!==this.m_sweepIndexRed||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);const s=A.construct(this.m_envelopesRed[e].xmin,this.m_envelopesRed[e].xmax);return this.m_iteratorRed.resetIterator(s,this.m_tolerance),this.m_envelopeHandleA=e,this.m_function=this.iterate_,!0}sweepBruteForce_(){return-1==--this.m_sweepIndexRed?(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1):(this.m_envelopeHandleA=this.m_sweepIndexRed,this.m_sweepIndexBlue=this.m_sweepIndexRed,this.m_function=this.iterateBruteForce_,!0)}sweepRedBlueBruteForce_(){return-1==--this.m_sweepIndexRed?(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1):(this.m_envelopeHandleA=this.m_sweepIndexRed,this.m_sweepIndexBlue=this.m_envelopesBlue.length,this.m_function=this.iterateRedBlueBruteForce_,!0)}sweepRedBlue_(){const t=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed-1),e=this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue-1),s=this.getAdjustedValue_(t,!0),i=this.getAdjustedValue_(e,!1);return s>i?this.sweepRed_():s<i?this.sweepBlue_():this.isTop_(t)?this.sweepRed_():this.isTop_(e)?this.sweepBlue_():this.sweepRed_()}sweepRed_(){const t=this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed),e=t>>1;if(this.isBottom_(t))return-1!==this.m_queuedListRed&&-1!==this.m_queuedIndicesRed[e]?(this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed,this.m_queuedIndicesRed[e]),this.m_queuedIndicesRed[e]=-1):this.m_intervalTreeRed.remove(e),0!==this.m_sweepIndexRed||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);if(-1!==this.m_queuedListBlue&&this.m_queuedEnvelopes.getListSize(this.m_queuedListBlue)>0){let t=this.m_queuedEnvelopes.getFirst(this.m_queuedListBlue);for(;-1!==t;){const e=this.m_queuedEnvelopes.getData(t);this.m_intervalTreeBlue.insert(e),this.m_queuedIndicesBlue[e]=-1;const s=this.m_queuedEnvelopes.getNext(t);this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue,t),t=s}}if(this.m_intervalTreeBlue.size()>0){const t=A.construct(this.m_envelopesRed[e].xmin,this.m_envelopesRed[e].xmax);this.m_iteratorBlue.resetIterator(t,this.m_tolerance),this.m_envelopeHandleA=e,this.m_function=this.iterateBlue_}else-1===this.m_queuedListRed&&(this.m_queuedIndicesRed.length=this.m_envelopesRed.length,this.m_queuedIndicesRed.fill(-1),this.m_queuedListRed=this.m_queuedEnvelopes.createList(1)),this.m_queuedIndicesRed[e]=this.m_queuedEnvelopes.addElement(this.m_queuedListRed,e),this.m_function=this.sweepRedBlue_;return!0}sweepBlue_(){const t=this.m_sortedEndIndicesBlue.read(--this.m_sweepIndexBlue),e=t>>1;if(this.isBottom_(t))return-1!==this.m_queuedListBlue&&-1!==this.m_queuedIndicesBlue[e]?(this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue,this.m_queuedIndicesBlue[e]),this.m_queuedIndicesBlue[e]=-1):this.m_intervalTreeBlue.remove(e),0!==this.m_sweepIndexBlue||(this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1,this.m_bDone=!0,!1);if(-1!==this.m_queuedListRed&&this.m_queuedEnvelopes.getListSize(this.m_queuedListRed)>0){let t=this.m_queuedEnvelopes.getFirst(this.m_queuedListRed);for(;-1!==t;){const e=this.m_queuedEnvelopes.getData(t);this.m_intervalTreeRed.insert(e),this.m_queuedIndicesRed[e]=-1;const s=this.m_queuedEnvelopes.getNext(t);this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed,t),t=s}}if(this.m_intervalTreeRed.size()>0){const t=A.construct(this.m_envelopesBlue[e].xmin,this.m_envelopesBlue[e].xmax);this.m_iteratorRed.resetIterator(t,this.m_tolerance),this.m_envelopeHandleB=e,this.m_function=this.iterateRed_}else-1===this.m_queuedListBlue&&(this.m_queuedIndicesBlue.length=this.m_envelopesBlue.length,this.m_queuedIndicesBlue.fill(-1),this.m_queuedListBlue=this.m_queuedEnvelopes.createList(0)),this.m_queuedIndicesBlue[e]=this.m_queuedEnvelopes.addElement(this.m_queuedListBlue,e),this.m_function=this.sweepRedBlue_;return!0}iterate_(){if(this.m_envelopeHandleB=this.m_iteratorRed.next(),-1!==this.m_envelopeHandleB)return!1;const t=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed)>>1;return this.m_intervalTreeRed.insert(t),this.m_function=this.sweep_,!0}iterateRed_(){if(this.m_envelopeHandleA=this.m_iteratorRed.next(),-1!==this.m_envelopeHandleA)return!1;this.m_envelopeHandleA=-1,this.m_envelopeHandleB=-1;const t=this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue)>>1;return this.m_intervalTreeBlue.insert(t),this.m_function=this.sweepRedBlue_,!0}iterateBlue_(){if(this.m_envelopeHandleB=this.m_iteratorBlue.next(),-1!==this.m_envelopeHandleB)return!1;const t=this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed)>>1;return this.m_intervalTreeRed.insert(t),this.m_function=this.sweepRedBlue_,!0}iterateBruteForce_(){if(-1==--this.m_sweepIndexBlue)return this.m_function=this.sweepBruteForce_,!0;const t=this.m_envelopesRed[this.m_sweepIndexRed].clone(),e=this.m_envelopesRed[this.m_sweepIndexBlue];return t.inflateCoords(this.m_tolerance,this.m_tolerance),!t.isIntersecting(e)||(this.m_envelopeHandleB=this.m_sweepIndexBlue,!1)}iterateRedBlueBruteForce_(){if(-1==--this.m_sweepIndexBlue)return this.m_function=this.sweepRedBlueBruteForce_,!0;const t=this.m_envelopesRed[this.m_sweepIndexRed].clone(),e=this.m_envelopesBlue[this.m_sweepIndexBlue];return t.inflateCoords(this.m_tolerance,this.m_tolerance),!t.isIntersecting(e)||(this.m_envelopeHandleB=this.m_sweepIndexBlue,!1)}resetRed_(){return this.m_sweepIndexRed=this.m_sortedEndIndicesRed.size(),this.m_intervalTreeRed.size()>0&&this.m_intervalTreeRed.reset(),-1!==this.m_queuedListRed&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListRed),this.m_queuedIndicesRed.length=0,this.m_queuedListRed=-1),this.m_bDone=!1,!0}resetBlue_(){return this.m_sweepIndexBlue=this.m_sortedEndIndicesBlue.size(),this.m_intervalTreeBlue.size()>0&&this.m_intervalTreeBlue.reset(),-1!==this.m_queuedListBlue&&(this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue),this.m_queuedIndicesBlue.length=0,this.m_queuedListBlue=-1),this.m_bDone=!1,!0}nullFunc_(){return t(0),!1}sortYEndIndices_(t,e,s,i){const n=this,r={userSort(t,e,s){n.sortYEndIndicesHelper_(s,t,e,i)},getValue:t=>n.getAdjustedValue_(t,i)};(new ss).sort(t,e,s,r)}sortYEndIndicesHelper_(t,e,s,i){t.sort(e,s,((t,e)=>{const s=this.getAdjustedValue_(t,i),n=this.getAdjustedValue_(e,i);return s<n||s===n&&this.isBottom_(t)&&this.isTop_(e)?-1:1}))}getAdjustedValue_(t,e){const s=.5*this.m_tolerance;if(e){const e=this.m_envelopesRed[t>>1];return this.isBottom_(t)?e.ymin-s:e.ymax+s}const i=this.m_envelopesBlue[t>>1];return this.isBottom_(t)?i.ymin-s:i.ymax+s}}var ds=Ce;class ps{constructor(t,e){this.tolerance=void 0!==t?t:Number.NaN,this.resolution=void 0!==e?e:Number.NaN}add(t){return new ps(this.tolerance+t,this.resolution)}scale(t){return new ps(this.tolerance*t,this.resolution*t)}total(){return this.tolerance+this.resolution}}function fs(t,e,s,i,n){const r=i*i,o=t.sub(e),a=s.sub(e),h=o.sqrLength(),m=a.sqrLength();if(h<=r||m<=r)return!0;const l=M(o.crossProduct(a));if(l<=r*h||l<=r*m){return o.dotProduct(a)>=0}return!1}function xs(t,e,s){return i=>0===s?(i+t)*e:1*(i-t*e)/e}function ys(t,e){const s=new ge;return t.queryLooseEnvelope(s),s.mergeEnvelope2D(e),s}function Ps(t,e){const s=ge.constructEmpty();t.queryLooseEnvelope(s);const i=ge.constructEmpty();return e.queryLooseEnvelope(i),s.mergeEnvelope2D(i),s}function Es(t,e,s){const i=ge.constructEmpty();i.setFromPoints(t,e);return Ds(0,null,i.calculateToleranceFromEnvelope(),s,!1)}function Cs(t,e,s){return Ds(0,t,e.calculateToleranceFromEnvelope(),s,!1)}function Ss(t,e,s){return Ds(1,t,e.calculateToleranceFromEnvelope(),s,!1)}function vs(t,e,s){return Ss(t,e.queryInterval(1,0),s)}function bs(t,e,s){const i=ge.constructEmpty();return e.queryEnvelope(i),Cs(t,i,s)}function Is(t,e,s=!1){return Ds(0,t,e.calculateToleranceFromEnvelope(),s,!0).total()}function ws(t,e,s){const i=ge.constructEmpty();return e.queryEnvelope(i),Is(t,i,s)}function Ds(t,e,s,i,n){const r=new ps(0,0);if(null!==e&&(r.tolerance=e.getTolerance(t),(!n||i)&&null!==e)){const s=e.getResolution(t);r.resolution=s,i&&(r.resolution*=2)}i&&(s*=4,r.tolerance*=1.01,r.resolution*=1.01);return r.total()<s?new ps(s,0):r}function Ts(t){return Math.sqrt(2)*(2*t.tolerance+t.resolution)}function Ns(t){return Math.sqrt(2)*(t.tolerance+t.resolution)}function As(t){return t>=3}function qs(t,e){const s=[0];return t.getImpl().getIsSimple(e,s)>=3}function Fs(t,e){t.getImpl().setIsSimple(3,e)}function Ms(t,e,s,i){if(M(e.x-t.x)+M(e.y-t.y)<=s*s){const s=t.z,n=e.z;return G(s,n,i)}return!1}function Gs(t){return t>=4}function Vs(t,e){return t===s.enumPolygon?As(e):e>=1}function Ys(t,e,s){const i=ge.constructEmpty(),n=ge.constructEmpty();t.queryLooseEnvelope(i),e.queryLooseEnvelope(n),i.inflateCoords(s,s),n.inflateCoords(s,s);const r=ge.constructEmpty();r.setCoords({env2D:i}),r.intersect(n);const o=t.querySegmentIterator(),a=e.querySegmentIterator(),h=ge.constructEmpty(),m=ge.constructEmpty(),l=new _s;l.setTolerance(s);let u=!1;for(l.startRedConstruction();o.nextPath();)for(;o.hasNextSegment();){o.nextSegment().queryLooseEnvelope(h),h.isIntersecting(r)&&(u=!0,l.addRedEnvelope(o.getStartPointIndex(),h))}if(l.endRedConstruction(),!u)return null;let c=!1;for(l.startBlueConstruction();a.nextPath();)for(;a.hasNextSegment();){a.nextSegment().queryLooseEnvelope(m),m.isIntersecting(r)&&(c=!0,l.addBlueEnvelope(a.getStartPointIndex(),m))}return l.endBlueConstruction(),c?l:null}function Xs(t,e,s,i,n){t.getGeometryType(),e.getGeometryType();const r=ge.constructEmpty(),o=ge.constructEmpty();t.queryLooseEnvelope(r),e.queryLooseEnvelope(o),r.inflateCoords(s,s),o.inflateCoords(s,s);const a=ge.constructEmpty();a.setCoords({env2D:r}),a.intersect(o);const h=new _s;h.setTolerance(s);let m=!1;h.startRedConstruction();for(let u=0,c=t.getPathCount();u<c;u++)t.queryLoosePathEnvelope(u,r),r.isIntersecting(a)&&(m=!0,h.addRedEnvelope(u,r));if(h.endRedConstruction(),!m)return null;let l=!1;h.startBlueConstruction();for(let u=0,c=e.getPathCount();u<c;u++)e.queryLoosePathEnvelope(u,o),o.isIntersecting(a)&&(l=!0,h.addBlueEnvelope(u,o));return h.endBlueConstruction(),l?h:null}function ks(t,e,s){const i=ge.constructEmpty(),n=ge.constructEmpty();t.queryLooseEnvelope(i),e.queryEnvelope(n),i.inflateCoords(s,s),n.inflateCoords(s,s);const r=ge.constructEmpty();r.setCoords({env2D:i}),r.intersect(n);const o=t.querySegmentIterator(),a=new _s;a.setTolerance(s);let h=!1;for(a.startRedConstruction();o.nextPath();)for(;o.hasNextSegment();){o.nextSegment().queryLooseEnvelope(i),i.isIntersecting(r)&&(h=!0,a.addRedEnvelope(o.getStartPointIndex(),i))}if(a.endRedConstruction(),!h)return null;let m=!1;a.startBlueConstruction();for(let l=0,u=e.getPointCount();l<u;l++){const t=e.getXY(l);r.contains(t)&&(m=!0,a.addBlueEnvelope(l,ge.construct(t.x,t.y,t.x,t.y)))}return a.endBlueConstruction(),m?a:null}function Rs(t,e,s){const i=ge.constructEmpty(),n=ge.constructEmpty();t.queryEnvelope(i),e.queryEnvelope(n),i.inflateCoords(s,s),n.inflateCoords(s,s);const r=ge.constructEmpty();r.setCoords({env2D:i}),r.intersect(n);const o=new _s;o.setTolerance(s);let a=!1;o.startRedConstruction();const h=new w;for(let u=0,c=t.getPointCount();u<c;u++)t.queryXY(u,h),r.contains(h)&&(a=!0,o.addRedEnvelope(u,ge.construct(h.x,h.y,h.x,h.y)));if(o.endRedConstruction(),!a)return null;let m=!1;o.startBlueConstruction();const l=new w;for(let u=0,c=e.getPointCount();u<c;u++)e.queryXY(u,l),r.contains(l)&&(m=!0,o.addBlueEnvelope(u,ge.construct(l.x,l.y,l.x,l.y)));return o.endBlueConstruction(),m?o:null}function Bs(t){const e=new ge;return t.queryLooseEnvelope(e),e.inflateCoords(1,1),Ls(t,e)}function Ls(t,e,s){const i=new ge;if(t.queryLooseEnvelope(i),i.isEmpty())return null;t.getGeometryType();const n=new rs(i,8);let r=-1;const o=new ge;let a=!1;do{for(let s=0,h=t.getPathCount();s<h;s++)if(t.queryLoosePathEnvelope(s,o),o.isIntersecting(e)){if(r=n.insertEx(s,o,r),-1===r){a&&m("build_quad_tree_for_paths"),i.assign(t.calculateEnvelope2D(!1)),a=!0,n.reset(i,8);break}a=!1}}while(a);return n}function Hs(t,e){if(!e){const e=new ge;t.queryLooseEnvelope(e);const s=new rs(e,8);let i=-1;const n=new ge,r=t.querySegmentIterator();let o=!1;for(;r.nextPath();)for(;r.hasNextSegment();){const a=r.nextSegment(),h=r.getStartPointIndex();if(a.queryLooseEnvelope(n),i=s.insertEx(h,n,i),-1===i){o&&m(""),e.assign(t.calculateEnvelope2D(!1)),o=!0,s.reset(e,8),r.resetToFirstPath();break}}return s}const s=new ge;t.queryLooseEnvelope(s);const i=new rs(s,8);let n=-1;const r=new ge,o=t.querySegmentIterator();let a=!1;for(;o.nextPath();)for(;o.hasNextSegment();){const h=o.nextSegment(),l=o.getStartPointIndex();if(h.queryLooseEnvelope(r),r.isIntersecting(e)&&(n=i.insertEx(l,r,n),-1===n)){a&&m(""),s.assign(t.calculateEnvelope2D(!1)),a=!0,i.reset(s,8),o.resetToFirstPath();break}}return i}function zs(e,s){if(s){const t=new rs(s,8),i=new w,n=new ge;let r=!1;for(let o=0;o<e.getPointCount();o++){if(i.setCoordsPoint2D(e.getXY(o)),!s.contains(i))continue;n.setCoords({pt:i});-1!==t.insert(o,n)||(r&&m(""),r=!0,t.reset(e.calculateEnvelope2D(),8),o=-1)}return t}return t(0),null}function Us(t,e,s,i,n){let r=!1;const o=n.vmin,a=n.vmax;for(let h=s;h<e;h+=i){const e=t.read(h);e<o?(r=!0,t.write(h,o)):e>a&&(r=!0,t.write(h,a))}return r}function Os(t,e,i,n){if(!t.hasAttribute(i))return!1;const r=t.getGeometryType();if(r===s.enumGeometryCollection){const s=t,r=s.getGeometryCount();let o=0;for(let t=0;t<r;++t){o|=Os(s.getGeometry(t),e,i,n)?1:0}return!!o}if(o(r)){const s=t,r=ds.getPersistence(i),o=ds.getComponentCount(i),a=s.getPointCount();if(1===r){const t=Us(s.getAttributeStreamRef(i),a*o,n,o,e);return t&&s.notifyModified(),t}if(2===r){const t=Us(s.getAttributeStreamRef(i),a*o,n,o,e);return t&&s.notifyModified(),t}m("snap_coordinate not implemented")}if(r===s.enumEnvelope){const s=t,r=s.queryInterval(i,n);let o=!1;return r.vmin<e.vmin&&(o=!0,r.vmin=e.vmin),r.vmax>e.vmax&&(o=!0,r.vmax=e.vmax),o&&s.setIntervalEnvelope(i,n,r),o}if(r===s.enumPoint){const s=t;let r=s.getAttributeAsDbl(i,n),o=!1;return r<e.vmin&&(o=!0,r=e.vmin),r>e.vmax&&(o=!0,r=e.vmax),o&&s.setAttributeBasic(i,n,r),o}if(l(r)){const s=t;let r=s.getStartAttributeAsDbl(i,n),o=!1;return r<e.vmin&&(o=!0,r=e.vmin),r>e.vmax&&(o=!0,r=e.vmax),o&&s.setStartAttribute(i,n,r),r=s.getEndAttributeAsDbl(i,n),r<e.vmin&&(o=!0,r=e.vmin),r>e.vmax&&(o=!0,r=e.vmax),o&&s.setEndAttribute(i,n,r),o}m("snap_coordinate not implemented")}function Ws(t,s,i,n,r){(s<0||i<0||n<1||s+n*(i-1)+1>t.size())&&e("Index out of bound");for(let e=s,o=s+n*(i-1)+1;e<o;e+=n)t.writeAsDbl(e,r(t.readAsDbl(e)))}function js(t,e){let s=R(t);const i=e.length/k();for(let n=0;n<e.length;++n){const t=Math.trunc(s*i);s=R(s);const n=Math.trunc(s*i),r=e[t];e[t]=e[n],e[n]=r}}function Zs(t,e,s){if(0===t.length)return;let i=0,n=0;for(++n;n!==t.length;++n)e(t[i],t[n])||(s(i,n),i=n);s(i,n)}function Qs(t,e,s,i,n){z(t,e,i-e,((t,e)=>n(t,e)?-1:1))}function Ks(t,e,s){if(!(s<=e))for(;e<s;)t[s]=q(t[e],t[e]=t[s]),e++,s--}function Js(t,e,s,i){Ks(t,e,s-1),Ks(t,s,i-1),t.reverse()}function $s(e,s,i){const n=e.getDescription().getTotalComponentCount();t(n<=i),e.setX(s[0]),e.setY(s[1]),X(e.getAttributeArray(),s,0,2,n-2)}var ti=Ce;const ei="can not assign an empty point to a vertex";class si{constructor(t){if(this.m_accelerators=null,void 0!==t&&t.move)this.m_description=t.move.m_description,t.move.m_description=Ne(),this.m_vertexAttributes=t.move.m_vertexAttributes,t.move.m_vertexAttributes=new es,this.m_envelopeData=t.move.m_envelopeData,t.move.m_envelopeData=new Xe,this.m_pointCount=t.move.m_pointCount,this.m_reservedPointCount=t.move.m_reservedPointCount,this.m_flags=t.move.m_flags,this.m_bFillRule=t.move.m_bFillRule,this.m_bPathStarted=t.move.m_bPathStarted,this.m_bPolygon=t.move.m_bPolygon,this.m_simpleTolerance=t.move.m_simpleTolerance;else{const e=void 0!==t&&t.vd?t.vd:Ne();this.m_description=e,this.m_vertexAttributes=new es,this.m_envelopeData=new Xe,this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_flags=4063,this.m_bFillRule=this.m_bPathStarted=this.m_bPolygon=!1,this.m_simpleTolerance=0,void 0!==t&&t.copy&&t.copy.copyTo(this)}}equalsBase(t,e){if(!o(t.getGeometryType()))return!1;const s=t;if(this===s)return!0;if(!this.m_description.equals(s.getDescription()))return!1;if(this.isEmptyImpl()!==s.isEmptyImpl())return!1;if(this.isEmptyImpl())return!0;const i=this.getPointCount();if(i!==s.getPointCount())return!1;for(let n=0;n<this.m_description.getAttributeCount();n++){const t=this.m_description.getSemantics(n),r=this.getAttributeStreamRef(t),o=s.getAttributeStreamRef(t),a=ti.getComponentCount(t);if(!r.equals(o,0,i*a,e))return!1}if(e){if(!this.equalsImplTol(t,e))return!1}else if(!this.equalsImpl(t))return!1;return!0}vertexCount(){return t(0),0}transformAttribute(t,e,s,i,n){this.addAttribute(t),this.isEmpty()||0===s&&1===i||(Ws(this.getAttributeStreamRef(t),e,this.getPointCount(),ti.getComponentCount(t),xs(s,i,n)),this.notifyModified())}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}mergeVertexDescriptionImpl(t){const e=we(this.getDescription(),t);this.assignVertexDescription(e)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=De(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Te(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=Ne();t!==this.m_description&&this.assignVertexDescription(t)}getAttributeStreamRef(t){this.throwIfEmpty(),this.m_description.hasAttribute(t)||e("AttributeStream : Geometry does not have the attribute");const s=this.m_description.getAttributeIndex(t);return this.m_vertexAttributes.get(s)}setAttributeStreamRef(t,s){s||e("stream"),s&&ti.getPersistence(t)!==s.getPersistence()&&e(""),this.addAttribute(t);const i=this.m_description.getAttributeIndex(t);this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_vertexAttributes.set(i,s),this.notifyModifiedFlags(2001)}notifyModifiedFlags(t){65535===t&&(this.m_reservedPointCount=-1,this.notifyModifiedAllImpl()),this.setDirtyFlagProtected(t,!0),this.clearAccelerators(),32&t&&this.verifyAllStreamsAfterSizeChange()}notifyModified(){this.notifyModifiedFlags(2001)}getPointCount(){return this.m_pointCount}getPointByVal(t,e){const s=e;s.assignVertexDescription(this.m_description);for(let i=0;i<this.m_description.getAttributeCount();i++){const e=this.m_description.getSemantics(i);for(let n=0,r=ti.getComponentCount(e);n<r;n++){const o=this.m_vertexAttributes.get(i).readAsDbl(r*t+n);s.setAttributeBasic(e,n,o)}}}setPointByVal(t,s){const i=s;i.isEmpty()&&e(ei);const n=i.getDescription();n!==this.m_description&&this.mergeVertexDescription(n);const r=this.m_vertexAttributes.get(0);r.write(2*t,i.getX()),r.write(2*t+1,i.getY());for(let e=1,o=this.m_description.getAttributeCount();e<o;e++){const s=this.m_description.getSemantics(e),n=ti.getComponentCount(s);for(let r=0;r<n;r++){const o=i.getAttributeAsDbl(s,r);this.m_vertexAttributes.get(e).writeAsDbl(t*n+r,o)}}this.notifyModifiedFlags(2001)}setPointByValFromArray(e,s,i,n){t(0)}getPointByValAsArray(e,s,i,n){t(0)}isEmpty(){return this.isEmptyImpl()}isEmptyImpl(){return 0===this.m_pointCount}getAttributeAsDbl(t,e,s){const n=ti.getComponentCount(t);s>=n&&i("");const r=this.m_description.getAttributeIndex(t);return r>=0?this.m_vertexAttributes.get(r).readAsDbl(e*n+s):ti.getDefaultValue(t)}queryAttributeAsDbl(t,e,s,n){const r=ti.getComponentCount(t);n<r&&i("");const o=this.m_description.getAttributeIndex(t);if(o>=0){const t=e*r,i=this.m_vertexAttributes.get(o);for(let e=0;e<r;e++)s[e]=i.readAsDbl(t+e)}else{const e=ti.getDefaultValue(t);for(let t=0;t<r;t++)s[t]=e}}getAttributeAsInt(t,e,s){return Math.trunc(this.getAttributeAsDbl(t,e,s))}queryAttributeAsInt(e,s,i,n){t(0)}setAttribute(t,e,s,n){const r=ti.getComponentCount(t);s>=r&&i(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001),this.m_vertexAttributes.get(o).writeAsDbl(e*r+s,n)}setAttributeFromArray(t,e,s,n){(e<0||e>=this.m_pointCount)&&i("");const r=ti.getComponentCount(t);n!==r&&i(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001);const a=this.m_vertexAttributes.get(o);for(let i=0;i<r;++i)a.writeAsDbl(e*r+i,s[i])}getXY(t){return this.m_vertexAttributes.get(0).readPoint2D(2*t)}queryXY(t,e){return this.m_vertexAttributes.get(0).queryPoint2D(2*t,e)}setXY(t,e){this.m_vertexAttributes.get(0).writePoint2D(2*t,e),this.notifyModifiedFlags(2001)}setXYCoords(t,e,s){const i=this.m_vertexAttributes.get(0);i.write(2*t,e),i.write(2*t+1,s),this.notifyModifiedFlags(2001)}getXYZ(t){const e=this.m_vertexAttributes.get(0),s=Fe.getNAN();return s.x=e.read(2*t),s.y=e.read(2*t+1),this.m_description.hasAttribute(1)?s.z=this.m_vertexAttributes.get(1).read(t):s.z=ti.getDefaultValue(1),s}setXYZ(t,e){this.addAttribute(1),this.notifyModifiedFlags(2001);const s=this.m_vertexAttributes.get(0);s.write(2*t,e.x),s.write(2*t+1,e.y);this.m_vertexAttributes.get(1).write(t,e.z)}queryEnvelope(t){t instanceof ge||t instanceof _e?this.updateEnvelope(t):(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t))}queryLooseEnvelope(t){this.updateLooseEnvelope(t)}queryInterval(t,e){const s=A.constructEmpty();return this.isEmptyImpl()||(this.updateAllDirtyIntervals(!0),this.m_envelopeData.queryInterval(this.m_description,t,e,s)),s}setAttributeBasic(t,e,s){this.setAttributeImpl(t,e,s)}setAttributeImpl(t,e,s){if(this.addAttribute(t),this.isEmpty())return;let i=!1;const n=ti.getComponentCount(t),r=this.getAttributeStreamRef(t),o=Number.isNaN(s);if(1===r.getPersistence()){const t=r;for(let r=e,a=this.m_pointCount*n;r<a;r+=n){const e=t.read(r);(o||e===s)&&Number.isNaN(e)||(t.write(r,s),i=!0)}}else for(let a=e,h=this.m_pointCount*n;a<h;a+=n){r.readAsDbl(a)!==s&&(r.writeAsDbl(a,s),i=!0)}i&&this.notifyModifiedFlags(2001)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;let s=!1;const i=ti.getComponentCount(t),n=this.getAttributeStreamRef(t);for(let r=0;r<i;r++)if(1===n.getPersistence()){const t=n;for(let n=0,r=this.m_pointCount*i;n<r;n++){const i=t.read(n);Number.isNaN(i)&&(t.write(n,e),s=!0)}}else for(let t=0,o=this.m_pointCount*i;t<o;t++){const i=n.readAsDbl(t);Number.isNaN(i)&&(n.writeAsDbl(t,e),s=!0)}s&&this.notifyModifiedFlags(2001)}calculateLength3D(e){return t(0),0}setEnvelopeForImport(t){this.m_description.equals(t.getDescription())||e(""),this.m_envelopeData=new Xe({moveEnv:t}),this.setDirtyFlagProtected(192,!1)}copyTo(t){t.getGeometryType()!==this.getGeometryType()&&e(""),this!==t&&this.copyToUnchecked(t,!1)}queryCoordinates(t,s,i,n){let r=n<0?this.m_pointCount:n;if(r=Math.min(r,i+s),(i<0||r<i||this.m_pointCount>0&&i>=this.m_pointCount)&&e(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);for(let e=2*i,a=2*r,h=0;e<a;e+=2,h++)o.queryPoint2D(e,t[h]);return r}queryCoordinates3D(t,s,i,n){let r=n<0?this.m_pointCount:n;if(r=Math.min(r,i+s),(i<0||r<i||this.m_pointCount>0&&i>=this.m_pointCount)&&e(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);let a=null;const h=ti.getDefaultValue(1),m=this.m_description.hasAttribute(1);m&&(a=this.getAttributeStreamRef(1));let l=0;for(let e=i;e<r;e++,l++)t[l].x=o.read(2*e),t[l].y=o.read(2*e+1),t[l].z=m?a.read(e):h;return r}clearAndSetDirtyFlagProtected(t,e){let s=0;const i=t&~e,n=e|i;s=this.m_flags,(s&n)!==e&&(this.m_flags=s&~i|e)}getIsSimple(t,e){e[0]=0;let s=-1;const i=this.m_flags,n=this.m_simpleTolerance;if(!(1&i)){s=(14&i)>>1,e[0]=n,n<t&&(s=-1)}return s}setIsSimple(e,i,n=!1){if(2===e?t(this.getGeometryType()===s.enumPolyline):1===e?t(this.getGeometryType()===s.enumMultiPoint||this.getGeometryType()===s.enumPolyline):3===e&&t(this.getGeometryType()===s.enumPolygon),-1===e)this.setDirtyFlagProtected(17,!0);else{let t=e<<1;n||(t|=16);const s=31;this.clearAndSetDirtyFlagProtected(s,t),this.m_simpleTolerance!==i&&(this.m_simpleTolerance=i)}}attributeStreamIsAllocated(t){this.throwIfEmpty();const e=this.m_description.getAttributeIndex(t);return e>=0&&null!==this.m_vertexAttributes.get(e)}capacity(){return-1===this.m_reservedPointCount&&0===this.m_pointCount?0:this.m_reservedPointCount}getDescriptionImpl(){return this.m_description}copyToUnchecked(e,i=!1){i&&this.hasDirtyFlag(32)&&a("Cannot do shallow clone on unprepared geometry");const n=e,r=this.getGeometryType(),o=n.getGeometryType();t(r===o||r===s.enumPolygon&&o===s.enumPolyline,"failure in copyToUnchcked"),n.clearAccelerators(),n.m_description=this.m_description,n.m_vertexAttributes.destroyAndSetSize(0),n.m_envelopeData.releaseAttributes();const h=this.m_description.getAttributeCount(),m=new es;if(!this.m_vertexAttributes.empty()){m.destroyAndSetSize(h);for(let t=0;t<h;t++)if(this.m_vertexAttributes.get(t))if(i)m.set(t,this.m_vertexAttributes.get(t));else{const e=ti.getComponentCount(this.m_description.getSemantics(t));m.set(t,this.m_vertexAttributes.get(t).restrictedClone(this.getPointCount()*e))}}if(this.m_envelopeData.copyToIfNotNull(this.m_description,n.m_envelopeData),n.m_flags=this.m_flags,n.m_simpleTolerance=this.m_simpleTolerance,r!==o){const t=[0];n.getIsSimple(0,t)>=3?n.setIsSimple(1,t[0]):n.setIsSimple(-1,0)}n.m_vertexAttributes.swap(m),m.destroyAndSetSize(0),n.m_pointCount=this.m_pointCount,n.hasDirtyFlag(32)?(t(!i),n.m_reservedPointCount=-1):n.m_reservedPointCount=n.m_pointCount;try{this.copyToImpl(n,i)}catch(l){throw n.setEmpty(),l}n.verifyAllStreamsAfterSizeChange()}buildRasterizedGeometryAccelerator(t,e){return!1}getAccelerators(){return this.m_accelerators}clearAccelerators(){this.m_accelerators&&this.m_accelerators.release(),this.m_accelerators=null}ensureUniqueAccelerators(){if(this.m_accelerators&&!this.m_accelerators.uniqueUse()){const t=this.m_accelerators.clone();this.m_accelerators.release(),this.m_accelerators=t}}interpolateTwoVertices(e,s,n,r){(e<0||e>=this.m_pointCount)&&i(""),(s<0||s>=this.m_pointCount)&&i(""),r.assignVertexDescription(this.m_description);const o=new Array(ti.maxComponentCount()),a=new Array(ti.maxComponentCount()),h=Ee();let m=0;for(let i=0;i<this.m_description.getAttributeCount();i++){const r=this.m_description.getSemantics(i),l=ti.getInterpolation(r),u=ti.getComponentCount(r),c=ti.getDefaultValue(r);this.queryAttributeAsDbl(r,e,o,u),this.queryAttributeAsDbl(r,s,a,u),t(m+u<=Pe),B(l,o,a,h,m,u,n,c),m+=u}$s(r,h,m)}getShortestDistance(t,e){return w.distance(this.getXY(t),this.getXY(e))}getShortestSqrDistance(t,e){return w.sqrDistance(this.getXY(t),this.getXY(e))}resizeImpl(t){if(t<0&&e(),(t=Math.ceil(t))===this.m_pointCount)return;this.m_pointCount=t;const s=this.m_pointCount<=this.m_reservedPointCount?2001:4095;this.notifyModifiedFlags(s)}verifyPointIndex(e){t(0)}assignVertexDescriptionImpl(t){if(!this.m_vertexAttributes.empty()){const e=ve();qe(t,this.m_description,e);const s=new es;s.destroyAndSetSize(t.getAttributeCount());for(let i=0;i<t.getAttributeCount();i++){const t=e[i];-1!==t?s.set(i,this.m_vertexAttributes.get(t)):this.m_reservedPointCount=-1}s.swap(this.m_vertexAttributes)}this.m_description=t,this.m_envelopeData.releaseAttributes(),this.notifyModifiedFlags(4095)}hasDirtyFlag(t){return!!(this.m_flags&t)}setDirtyFlagProtected(t,e){e?this.m_flags|=t:this.m_flags&=~t}notifyModifiedAllImpl(){}verifyAllStreamsAfterSizeChange(){this.hasDirtyFlag(32)&&this.verifyAllStreamsAfterSizeChangeImpl()}verifyAllStreamsAfterSizeChangeImpl(){if(this.hasDirtyFlag(32)){if(this.m_reservedPointCount<this.m_pointCount){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_reservedPointCount=Number.MAX_SAFE_INTEGER;let t=0;t=this.m_pointCount<4?3:this.m_pointCount<=128?2*this.m_pointCount:(4*this.m_pointCount+2)/3;for(let e=0;e<this.m_description.getAttributeCount();e++){const s=this.m_description.getSemantics(e);let i=0;if(null!==this.m_vertexAttributes.get(e)){const n=ti.getComponentCount(s);i=this.m_vertexAttributes.get(e).size()/n,i<this.m_pointCount&&(this.m_vertexAttributes.get(e).resize(t*n,ti.getDefaultValue(s)),i=t)}else this.m_vertexAttributes.set(e,He(s,t)),i=t;i<this.m_reservedPointCount&&(this.m_reservedPointCount=i)}}this.verifyStreamsAfterSizeChangeExtraImpl(),this.setDirtyFlagProtected(32,!1)}}verifyStreamsAfterSizeChangeExtraImpl(){}updateAllDirtyIntervals(t){if(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128)){if(this.isEmpty())return this.hasDirtyFlag(192)&&this.m_envelopeData.setEmpty(this.m_description),void this.setDirtyFlagProtected(192,!1);const e=this.updateXYImpl(t),s=new ke({vd:this.m_description});s.setEnvelope(e);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),i=ti.getComponentCount(e),n=this.m_vertexAttributes.get(t);for(let t=0;t<i;t++){const r=new A;r.setEmpty();for(let e=0;e<this.m_pointCount;e++){const s=n.readAsDbl(e*i+t);r.mergeCoordinate(s)}s.setIntervalEnvelope(e,t,r)}}(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128))&&(this.m_envelopeData=new Xe({moveEnv:s}),this.clearDirtyIntervalsFlag(t))}}updateXYImpl(t){const e=ge.constructEmpty(),s=this.m_vertexAttributes.get(0);return e.mergePointsInterleaved(s,0,this.m_pointCount),e}updateEnvelope3D(e){t(0)}updateLooseEnvelope(t){this.updateAllDirtyIntervals(!1),t instanceof ge?t.assign(this.m_envelopeData.m_envelope2D):this.m_envelopeData.queryEnvelope3D(this.m_description,t)}updateEnvelope(t){this.updateAllDirtyIntervals(!0),t.assign(this.m_envelopeData.m_envelope2D)}setEmptyImpl(){this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_vertexAttributes.destroyAndSetSize(0),this.notifyModifiedFlags(4095)}clearDirtyIntervalsFlag(t){this.setDirtyFlagProtected(192,!1)}reserveImpl(t,s){if(t<0&&e(""),0===t)return;let i=t=Math.ceil(t);if(this.m_reservedPointCount<i){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),s?(null===this.m_vertexAttributes.get(0)&&this.m_vertexAttributes.set(0,ze(0,0)),this.m_vertexAttributes.get(0).resizeRounded(2*i),i=this.m_vertexAttributes.get(0).size()>>1):null===this.m_vertexAttributes.get(0)?this.m_vertexAttributes.set(0,ze(0,i)):this.m_vertexAttributes.get(0).resize(2*i);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),s=ti.getComponentCount(e);null!==this.m_vertexAttributes.get(t)?this.m_vertexAttributes.get(t).resize(i*s):this.m_vertexAttributes.set(t,ze(e,i))}this.reserveImplImpl(i,s),this.m_reservedPointCount=i}}reserveRounded(t){t<0&&e(),t=Math.ceil(t),this.reserveImpl(t,!0)}reserveImplImpl(t,e){}throwIfEmpty(){this.isEmptyImpl()&&r("")}}class ii extends si{constructor(t){super(t),t&&(t.points?this.addPoints2D(t.points,t.pointsSize,0,-1):t.point&&this.add(t.point))}assignCopy(e){return t(0),this}assignMove(e){return t(0),this}insertPoint2D(e,s){t(0)}insertPoint(e,s){t(0)}insertPoints(e,s,i){t(0)}insertPoints2D(e,s,i){t(0)}removePoints(e,s){t(0)}removePoint(t){for(let e=0,s=this.m_description.getAttributeCount();e<s;e++)if(this.m_vertexAttributes.get(e)){const s=this.m_description.getSemantics(e),i=Ce.getComponentCount(s);this.m_vertexAttributes.get(e).eraseRange(i*t,i,i*this.m_pointCount)}this.m_pointCount--,this.m_reservedPointCount>0&&this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}calculateEnvelope2D(){return t(0),new ge(0,0,0,0)}resizeNoInit(t){this.resizeImpl(t)}resizeAndInitNonPositionAttributes(t){const e=this.m_pointCount;if(this.resizeImpl(t),this.m_pointCount>e)for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const t=this.m_description.getSemantics(s),i=Ce.getDefaultValue(t),n=Ce.getComponentCount(t);this.m_vertexAttributes.get(s).insertRange(n*e,i,n*(this.m_pointCount-e),n*e)}}queryCoordinates3D(e,s,i,n){return t(0),0}queryAttributeAsInt(e,s,i,n){t(0)}add(t){t.isEmpty()&&e(ei),this.resizeAndInitNonPositionAttributes(this.m_pointCount+1),this.setPointByVal(this.m_pointCount-1,t)}addXY(t,e){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const s=new w(t,e);this.setXY(this.m_pointCount-1,s)}addXYZ(t,e,s){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const i=new Fe;i.setCoords(t,e,s),this.setXYZ(this.m_pointCount-1,i)}addPoint2D(t){this.addXY(t.x,t.y)}addPoint3D(t){this.addXYZ(t.x,t.y,t.z)}addPoints(t,s,i){this===t&&e("Multi_point_impl.add");const n=i<0?t.getPointCount():i;if((s<0||s>t.getPointCount()||n<s)&&e(""),s===n)return;const r=t.getDescription();this.mergeVertexDescription(r);const o=n-s,a=this.m_pointCount;this.resizeNoInit(this.m_pointCount+o);for(let e=0,h=this.m_description.getAttributeCount();e<h;e++){const i=this.m_description.getSemantics(e),n=Ce.getComponentCount(i),h=this.getAttributeStreamRef(i);if(r.hasAttribute(i)){const e=t.getAttributeStreamRef(i);h.insertRangeFromStream(a*n,e,s*n,o*n,!0,1,a*n)}else{const t=Ce.getDefaultValue(i);h.insertRange(a*n,t,o*n,a*n)}}}addPoints2D(t,s,i,n){let r=s;const o=n<0?r:n;if((r<0||i<0||i>r||o<i)&&e(""),i===o)return;r=o-i;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+r);const h=this.getAttributeStreamRef(0);for(let e=0;e<r;++e)h.writePoint2D(2*(a+e),t[i+e]);this.notifyModifiedFlags(2001)}addPoints3D(e,s,i,n){t(0)}getGeometryType(){return s.enumMultiPoint}getDimension(){return 0}createInstance(){return new ii({vd:this.getDescription()})}setEmpty(){this.setEmptyImpl()}applyTransformation(e){if(this.isEmpty())return;if(e.isIdentity())return;const s=this.m_vertexAttributes.get(0);e instanceof Y?s.applyTransformation(e,0,this.m_pointCount):t(0),this.notifyModifiedFlags(2001)}calculateArea2D(){return t(0),0}calculateLength2D(){return t(0),0}calculateLength3D(e){return t(0),0}equals(t,e){return t.getGeometryType()===s.enumMultiPoint&&this.equalsBase(t,e)}queryEnvelope(e){e instanceof ke?(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,e)):e instanceof ge?this.updateEnvelope(e):t(0)}getImpl(){return this}getBoundary(){return null}reserve(t){this.reserveImpl(t)}clone(){const t=this.createInstance();return this.copyTo(t),t}swap(e){t(0)}buildQuadTreeAccelerator(t){return!1}getHashCodeImpl(){return t(0),0}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}copyToImpl(t,e){}}ii.type=s.enumMultiPoint;class ni{constructor(){this.envAabb=ge.constructEmpty(),this.envRot=ge.constructEmpty()}static constructEmpty(){return new ni}width(){return this.envAabb.width()}height(){return this.envAabb.height()}maxDim(){return Math.max(this.width(),this.height())}isEmpty(){return t(0),!1}setEmpty(){this.envAabb.setEmpty(),this.envRot.setEmpty()}setCoords(t){this.envAabb.setCoords(t),this.envRot.setCoords({x:ri(t),y:oi(t)})}setFromPoints(t,e){this.setEmpty(),this.mergePoints(t,e)}mergePoint2D(e){t(0)}mergeNe(t){this.envAabb.mergeNe(t),this.envRot.mergeNeCoords(ri(t),oi(t))}mergeCoords(e,s){t(0)}mergeW(e){t(0)}mergeE2D(e){t(0)}mergePoints(t,e){this.envAabb.mergePoints(t,e);for(let s=0;s<e;){if(!this.envRot.isEmpty()){for(let i=s;i<e;i++){const e=ri(t[i]),s=oi(t[i]);this.envRot.mergeNeCoords(e,s)}break}{const e=ri(t[s]),i=oi(t[s]);this.envRot.setCoords({x:e,y:i}),s++}}}isIntersectingPoint2D(t){return!(!this.envAabb.contains(t)||!this.envRot.containsCoords(ri(t),oi(t)))}isIntersectingW(t){return this.envAabb.isIntersecting(t.envAabb)&&this.envRot.isIntersecting(t.envRot)}containsW(t){return!(!this.envAabb.containsEnvelope(t.envAabb)||!this.envRot.containsEnvelope(t.envRot))}containsPoint2D(t){return this.isIntersectingPoint2D(t)}intersectW(t){const e=this.envAabb.intersect(t.envAabb),s=this.envRot.intersect(t.envRot);return e&&!s&&this.envAabb.setEmpty(),s&&!e&&this.envRot.setEmpty(),e&&s}inflate(t){this.envAabb.inflateCoords(t,t);const e=t*U();this.envRot.inflateCoords(e,e),e<0&&ni.st_reduceEmpty(this)}sqrMaxMinDistance(e){return t(0),0}sqrMinDistance(e){return t(0),0}sqrMaxDistance(e){return t(0),0}getEnvelope2D(){return t(0),new ge(this.envAabb)}static st_reduceEmpty(t){const e=t.envAabb.isEmpty(),s=t.envRot.isEmpty();e&&!s?t.envRot.setEmpty():s&&!e&&t.envAabb.setEmpty()}}function ri(t){return t.x-t.y}function oi(t){return t.x+t.y}class ai{isIdentity(){return t(0),!0}}class hi{constructor(t){this.m_factor=1,this.m_wkid=0,this.m_peUnit=null,t&&(this.m_peUnit=t,this.m_factor=t.getUnitFactor(),this.m_wkid=t.getCode(),this.m_wkid<0&&(this.m_wkid=0))}getName(){return this.m_peUnit.getName()}getID(){return this.m_wkid}getConversionFactor(t){return this.getUnitType()!==t.getUnitType()&&e("unit type mismatch"),this.getUnitToBaseFactor()/t.getUnitToBaseFactor()}getUnitToBaseFactor(){return this.m_factor}getHashCode(){return O(W(this.getUnitType()),W(this.getUnitToBaseFactor()))}equals(t){return!!t&&(this.getUnitType()===t.getUnitType()&&this.getUnitToBaseFactor()===t.getUnitToBaseFactor()&&this.getID()===t.getID()&&this.getName()===t.getName())}static isValidWkid(t){return!1}}class mi extends ue{constructor(t,e){super(),this.m_index=-1,this.gc=t,this.dim=e}next(){for(;;){if(this.m_index>=this.gc.getGeometryCount())return null;if(this.m_index++,this.m_index===this.gc.getGeometryCount())return null;const t=this.gc.getGeometry(this.m_index);if(-1===this.dim||1<<t.getDimension()&this.dim)return t}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class li{constructor(e){this.m_geoms=[],this.m_description=Ne(),e&&(e.vd?this.m_description=e.vd:e.copy?e.copy.copyTo(this):t(0))}assignCopy(e){return t(0),this}assignMove(e){return t(0),this}getGeometryCount(){return this.m_geoms.length}reserve(e){t(0)}addGeometry(t){if(t.getGeometryType()===s.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else this.m_geoms.push(t.clone()),this.mergeVertexDescription(t.getDescription())}addGeometryMove(e){t(0)}addCursor(e){t(0)}getGeometry(t){return(t<0||t>=this.m_geoms.length)&&e("Geometry_collection.get_geometry"),this.m_geoms[t]}modifiedElementIndex(e){t(0)}modifiedElement(e){t(0)}getGeometryType(){return s.enumGeometryCollection}getDimension(){let t=0;for(const e of this.m_geoms)t=Math.max(t,e.getDimension());return t}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}assignVertexDescriptionImpl(t){for(const e of this.m_geoms)e.assignVertexDescription(t);this.m_description=t}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=De(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(e){t(0)}dropAllAttributes(){t(0)}queryInterval(e,s){return t(0),new A(0,0)}queryEnvelope(e){t(0)}queryLooseEnvelope(e){t(0)}isEmpty(){return 0===this.m_geoms.length}setEmpty(){t(0)}applyTransformation(e){if(e instanceof Y)for(const t of this.m_geoms)t.applyTransformation(e);t(0)}transformAttribute(e,s,i,n,r){t(0)}createInstance(){return new li({vd:this.getDescription()})}copyTo(t){t.getGeometryType()!==s.enumGeometryCollection&&e("");const i=t;if(i!==this){i.m_geoms.length=0,i.assignVertexDescription(this.m_description);for(const t of this.m_geoms)i.m_geoms.push(t.clone())}}calculateArea2D(){return t(0),0}calculateLength2D(){return t(0),0}calculateLength3D(e){return t(0),0}getBoundary(){return t(0),this}clone(){return new li({copy:this})}equals(t,e){if(t===this)return!0;if(t.getGeometryType()!==s.enumGeometryCollection)return!1;const i=t;if(this.m_description!==i.m_description)return!1;if(this.m_geoms.length!==i.m_geoms.length)return!1;for(let s=0;s<this.m_geoms.length;++s)if(!this.m_geoms[s].equals(i.m_geoms[s],e))return!1;return!0}swap(e){t(0)}setAttributeBasic(e,s,i){t(0)}replaceNaNs(e,s){t(0)}getImpl(){return this}vertexCount(){return t(0),0}hasNonLinearSegments(){return t(0),!1}mergeVertexDescriptionImpl(t){const e=we(this.getDescription(),t);this.assignVertexDescription(e)}}function ui(t,e=-1){return new mi(t,e)}li.type=s.enumGeometryCollection;class ci{assign(t){this.m_reason=t.m_reason,this.m_vertexIndex1=t.m_vertexIndex1,this.m_vertexIndex2=t.m_vertexIndex2}constructor(t,e,s){void 0!==t?(this.m_reason=t,this.m_vertexIndex1=e,this.m_vertexIndex2=s):(this.m_reason=0,this.m_vertexIndex1=-1,this.m_vertexIndex2=-2)}clear(){t(0)}}class gi{constructor(t){if(this.m_geom=this.m_sr=null,t){if(t.move)return this.m_geom=t.move.m_geom,t.move.m_geom=null,this.m_sr=t.move.m_sr,void(t.move.m_sr=null);if(t.copy)return this.m_geom=t.copy.m_geom?t.copy.m_geom.clone():null,void(this.m_sr=t.copy.m_sr);t.geom&&(this.m_geom=t.geom),t.sr&&(this.m_sr=t.sr)}}assignCopy(e){return t(0),this}assignMove(e){return t(0),this}getGeometry(){return this.m_geom}getSpatialReference(){return this.m_sr}setGeometry(t){this.m_geom=t}setSpatialReference(t){this.m_sr=t}getHashCode(){return t(0),0}equals(e,s){return t(0),!1}clone(){return t(0),this}hasGeom(){return!!this.m_geom}}const _i={330:104878,500:104879,1300:104899,1450:104986,2230:104988,3800:104978,5e3:104919,6200:104906,8200:104909,9500:104927,9600:104977,1e4:[104911,104936],11e3:104941,11080:104872,11100:104907,12e3:104920,12400:104995,13e3:104948,14e3:[104923,104989],15e3:[104913,104954],15100:104976,16e3:[104926,104931],18e3:[104922,104982],21e3:104947,21500:104877,27e3:[104950,104957],29e3:104964,3e4:104921,31e3:104949,33e3:104946,4e4:[104914,104967],40600:104897,41900:104937,42e3:104951,43100:104993,49300:104924,50100:104939,54e3:104955,58200:104981,59500:104930,74e3:104961,77e3:104956,79e3:104962,83500:104910,85e3:104917,88800:104934,89200:104985,96e3:104997,104e3:104963,106500:104898,11e4:104938,133e3:104932,135e3:104983,17e4:104965,198200:104987,198630:104935,208e3:104966,235800:104952,249400:104929,252100:104980,255e3:104973,47e4:104972,529800:104942,531e3:104996,56e4:104928,561400:104979,578900:104945,584700:104959,593e3:104970,606e3:104999,718e3:104933,745700:104984,761400:104953,763500:104994,764e3:104940,788900:104958,1188300:104998,1195e3:104969,1352600:104968,1560800:104874,1562090:104915,1737400:104903,1821460:104918,1821490:104876,2409300:104912,2410300:104873,2439400:104974,2439700:104900,2575e3:104943,2631200:104875,2632345:104916,3393400:104904,3396190:[104905,104971],6051e3:104901,6051800:104902,637e4:104128,6370997:[4052,37008],6371e3:4035,6371007:4047,6371228:[4053,10346],6376045:[8042,8043],6376523:[4027,4901,4902],6376896:37007,6378135:[4122,4322,4324,4720,4985,4987],6378136:[4740,4923,7678,7680,9474,9475,104017,104018],6378137:[3823,3824,3888,3889,4017,4019,4023,4031,4040,4046,4055,4074,4075,4080,4081,4121,4126,4130,4133,4140,4141,4148,4151,4152,4163,4166,4167,4170,4171,4172,4173,4176,4180,4189,4190,4258,4269,4283,4318,4319,4326,4463,4466,4469,4470,4480,4482,4483,4490,4557,4558,4612,4617,4619,4624,4627,4659,4661,4667,4669,4670,4674,4686,4687,4693,4694,4702,4737,4742,4747,4749,4750,4755,4756,4757,4758,4759,4761,4762,4763,4764,4765,4883,4885,4887,4889,4893,4895,4898,4907,4909,4921,4925,4927,4929,4931,4933,4935,4937,4939,4941,4943,4945,4947,4949,4951,4953,4955,4957,4959,4961,4963,4965,4967,4971,4975,4977,4979,4981,4983,4989,4997,4999,5012,5013,5245,5246,5251,5252,5263,5264,5323,5324,5340,5342,5353,5354,5359,5360,5364,5365,5370,5371,5372,5373,5380,5381,5392,5393,5488,5489,5545,5546,5592,5593,5885,5886,6134,6135,6310,6311,6318,6319,6321,6322,6324,6325,6364,6365,6667,6668,6705,6706,6782,6783,6980,6982,6983,6987,6989,6990,7034,7035,7036,7037,7038,7039,7040,7041,7042,7072,7073,7084,7085,7086,7087,7133,7135,7136,7138,7139,7372,7373,7657,7659,7661,7663,7665,7685,7686,7797,7798,7816,7843,7844,7880,7881,7885,7886,7900,7901,7902,7903,7904,7905,7906,7907,7908,7909,7910,7911,7912,7915,7917,7919,7921,7923,7925,7927,7929,7931,8085,8086,8231,8232,8235,8237,8239,8240,8244,8246,8248,8249,8251,8252,8254,8255,8399,8403,8426,8427,8449,8542,8544,8545,8684,8685,8698,8699,8817,8818,8860,8888,8899,8900,8901,8902,8906,8907,8916,8918,8920,8922,8924,8926,8928,8930,8932,8934,8936,8938,8940,8942,8944,8946,8948,8949,8972,8973,8974,8975,8976,8977,8978,8979,8980,8981,8982,8983,8984,8985,8986,8987,8988,8989,8990,8991,8992,8993,8994,8995,8996,8997,8998,8999,9e3,9002,9003,9005,9006,9008,9009,9011,9012,9013,9014,9016,9017,9018,9019,9053,9054,9055,9056,9057,9059,9060,9061,9062,9063,9064,9065,9066,9067,9068,9069,9071,9072,9074,9075,9139,9140,9147,9148,9152,9153,9183,9184,9293,9294,9299,9308,9309,9332,9333,9364,9372,9379,9380,9384,9453,9469,9470,9546,9547,9695,9696,9701,9702,9739,9754,9755,9758,9763,9776,9777,9778,9779,9781,9782,9783,9784,9866,9871,9939,9964,9969,9974,9989,9990,10175,10177,10178,10185,10191,10196,10204,10209,10214,10219,10224,10229,10237,10272,10277,10283,10284,10298,10299,10300,10304,10305,10307,10309,10310,10311,10312,10327,10328,10413,10414,10468,10474,10475,10570,10571,10605,10606,10623,10628,20033,20040,20041,20045,20046,104009,104010,104011,104012,104013,104014,104015,104016,104019,104020,104021,104022,104024,104027,104028,104050,104100,104107,104108,104110,104111,104114,104115,104116,104117,104118,104119,104120,104121,104122,104123,104124,104129,104133,104134,104137,104141,104142,104143,104144,104145,104179,104180,104181,104182,104183,104184,104185,104186,104199,104223,104257,104258,104259,104260,104286,104287,104602,104613,104644,104645,104646,104647,104653,104804,104896,104991],6378140:4610,6378145:[4025,4276,4760,4891,37001],6378150:37003,6378155:[37004,37207],6378160:[3821,4003,4021,4036,4202,4203,4237,4238,4291,4618,4708,5527,37231,104023,104136],6378166:37002,6378200:[4020,4229,4286,4303,4706],6378245:[4024,4147,4164,4178,4179,4191,4200,4205,4214,4284,4317,4555,4676,4677,4678,4991,4993,5560,5561,37257,104135],6378270:[4732,37005,37229],6378273:[4054,10345],6378300:[4029,4168,4174],6378388:[4022,4123,4153,4154,4158,4159,4160,4161,4165,4181,4182,4183,4184,4185,4192,4194,4195,4196,4199,4204,4207,4208,4215,4218,4221,4224,4225,4230,4231,4233,4235,4236,4247,4248,4249,4254,4255,4259,4264,4265,4271,4272,4274,4285,4287,4288,4292,4297,4309,4311,4313,4316,4472,4475,4611,4614,4615,4616,4621,4622,4623,4625,4626,4628,4629,4630,4631,4632,4633,4636,4637,4639,4641,4642,4643,4644,4645,4646,4658,4660,4662,4663,4664,4665,4668,4672,4673,4684,4688,4689,4690,4691,4692,4698,4704,4705,4707,4709,4710,4711,4712,4714,4715,4716,4718,4719,4721,4722,4724,4725,4727,4728,4729,4730,4733,4734,4735,4739,4741,4753,4754,4802,4803,4806,4809,4810,4823,4824,4900,5524,6883,8428,8430,8431,9248,9251,9253,9403,9893,10158,10249,10252,37201,37204,37205,37212,37213,37214,37215,37216,37217,37218,37219,37221,37222,37224,37226,37227,37230,37232,37233,37234,37235,37237,37238,37241,37242,37245,37246,37247,37249,37250,37251,37253,37259,104104,104106,104125,104126,104127,104130,104138,104248],6378523:104786,24764e3:104960,25559e3:104944,60268e3:104925,71492e3:104908,6957e5:104975,6377397.155:[3819,3906,4004,4120,4124,4125,4149,4150,4156,4162,4211,4219,4257,4262,4280,4289,4294,4295,4301,4306,4308,4312,4314,4613,4666,4745,4746,4801,4804,4805,4808,4813,4814,4815,4818,4820,4904,5132,5228,5229,5681,5830,8351,9267,10268,37255,104101,104102,104105,104131,104648,104696,104697,104990,104992],6377563.396:[4001,4188,4277,4278,4279],6377340.189:[4002,4299,4300],6377492.018:[4005,4273,4817],6377483.865280418:[4006,4293],6378293.645208759:[4007,4157,4302,4738,5464],6378206.4:[4008,4127,4128,4129,4135,4136,4137,4138,4139,4169,4216,4242,4253,4267,4608,4609,4638,4675,4683,4695,4717,4723,4726,4995,5451,5467,37220,37239,37243,37252,37260,104e3,104109,104112,104113,104132],6378450.047:[4009,4268],6378300.789:[4010,4281],6378249.2:[4011,4014,4155,4193,4206,4213,4223,4226,4227,4228,4252,4261,4266,4275,4282,4296,4304,4310,4315,4671,4807,4811,4816,4821,37223,37225,104139,104140,104261,104304],6378249.145:[4012,4013,4132,4134,4142,4143,4175,4197,4198,4201,4209,4210,4212,4220,4222,4232,4234,4246,4250,4251,4256,4260,4263,4270,4305,4307,4600,4601,4602,4603,4604,4605,4606,4607,4620,4679,4680,4696,4697,4699,4700,4701,4703,4713,4731,4736,4743,4744,4812,4819,6881,6882,6892,6894,8694,37206,37208,37211,37228,37240,37254,104025,104026,104103,104305],6377276.345:[4015,4131,4144,4239,4240,4244,4682,5233,6207,37202,104256,104664,104693],6377298.556:[4016,4298],6377304.063:[4018,4245],6378298.3:[4028,4903],6378136.2:4032,6378136.3:4033,6378249.144808011:[4034,4241],20922931.8:[4042,4243],6377301.243:[4044,4145,37203],6377299.151:[4045,4146],6377019.27:[4657,10256,10260,10265],6378306.3696:[4748,4752],6377295.664:[4751,37006],6378136.5:[7682,7683],6371008.7714:104047,6378418.941:[104700,104726,104760],6378586.581:[104701,104743],6378505.809:104702,6378544.823:104703,6378490.569:104704,6378470.757:[104705,104776],6378403.701:[104706,104750],6378434.181:[104707,104724,104739,104764],6378454.907:104708,6378400.653:104709,6378567.378:104710,6378546.957:[104711,104717,104780],6378476.853:[104712,104736],6378411.321:[104713,104728],6378647.541:[104714,104715],6378514.953:[104716,104782],6378421.989:[104718,104770],6378481.425:[104719,104753,104774,104781],6378518.001:[104720,104725],6378521.049:[104721,104723,104731,104745,104748],6378464.661:104722,6378436.619:104727,6378574.389:[104729,104730],6378472.281:[104732,104756],6378498.189:[104733,104746],6378449.421:[104734,104766],6378525.621:[104735,104754],6378466.185:104737,6378496.665:104738,6378643.579:104740,6378559.758:104741,6378414.369:[104742,104763,104772],6378441.801:104744,6378502.761:[104747,104759,104773,104775],6378617.061:104749,6378624.681:[104751,104765],6378468.623:104752,6378445.763:[104755,104758,104761],6378670.401:104757,6378438.753:104762,6378543.909:104767,6378605.783:104768,6378540.861:104769,6378443.325:[104771,104784],6378548.481:104777,6378463.746:104778,6378426.561:104779,6378453.688:104783,6378530.193:104785,6378376.271:[104800,104828],6378471.92:104801,6378472.931:104802,6378411.351:104803,6378380.991:104805,6378414.96:104806,6378345.09:[104807,104819,104844,104870],6378412.542:104808,6378470.401:104809,6378376.331:104810,6378379.031:104811,6378407.621:104812,6378376.811:[104813,104827],6378313.92:104814,6378414.93:104815,6378413.021:104816,6378380.381:104817,6378530.851:104818,6378591.521:104820,6378378.881:104821,6378408.481:[104822,104832],6378375.601:[104823,104838],6378408.041:104824,6378655.071:104825,6378409.151:104826,6378315.7:[104829,104840,104845,104851],6378285.86:[104830,104835,104859],6378379.301:104831,6378560.121:104833,6378531.821:104834,6378500.6:104836,6378376.041:104837,6378406.601:104839,6378438.991:104841,6378345.42:104842,6378593.86:104843,6378381.271:[104846,104847],6378413.671:104848,6378344.377:104849,6378563.891:104850,6378408.091:104852,6378377.671:104853,6378472.751:104854,6378412.511:104855,6378407.281:104856,6378534.451:104857,6378406.051:104858,6378532.921:104860,6378380.091:104861,6378408.941:104862,6378624.171:104863,6378377.411:104864,6378474.591:104865,6378407.141:104866,6378376.871:104867,6378375.251:104868,6378405.971:104869,6378437.651:104871};function di(){for(const t in _i)delete _i[t]}class pi{constructor(){this.x=ot.getNAN(),this.y=ot.getNAN()}static getNAN(){return new pi}static constructPoint2D(t){const e=new pi;return e.x.set(t.x),e.y.set(t.y),e}static constructCoords(t,e){const s=new pi;return s.x.set(t),s.y.set(e),s}static constructCoordsE(t,e){const s=new pi;return s.setCoordsE(t,e),s}get 0(){return this.x.clone()}set 0(t){this.x.setE(t)}get 1(){return this.y.clone()}set 1(t){this.y.setE(t)}clone(){return(new pi).setE(this)}setCoords(t,e){return this.x.set(t),this.y.set(e),this}setCoordsE(t,e){return this.x.setE(t),this.y.setE(e),this}set(t){return this.x.set(t.x),this.y.set(t.y),this}setE(t){return this.x.setE(t.x),this.y.setE(t.y),this}setWithEps(t,e){return this.x.setWithEps(t.x,e),this.y.setWithEps(t.y,e),this}getUnitVector(){const t=this.clone();return t.normalize(),t}sqrLength(){return this.x.sqr().addE(this.y.sqr())}length(){return this.sqrLength().sqrt()}mulE(t){const e=new pi;return e.setCoordsE(this.x.mulE(t),this.y.mulE(t)),e}mul(t){const e=new pi;return e.setCoordsE(this.x.mul(t),this.y.mul(t)),e}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}divE(t){return this.clone().divThisE(t)}divThisE(t){return this.x.divThisE(t),this.y.divThisE(t),this}normalize(){const t=this.length();0===t.value()?(this.x=It.clone(),this.y=wt.clone()):(this.x.divThisE(t),this.y.divThisE(t))}addE(t){return this.clone().addThisE(t)}addThisE(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this}subE(t){return this.clone().subThisE(t)}subThisE(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this}static distance(t,e){return t.subE(e).length()}negateThis(){return this.x.negateThis(),this.y.negateThis(),this}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)}isZero(){return this.x.isZero()&&this.y.isZero()}isTrueZero(){return!this.x.value()&&!this.y.value()}rotateDirect(t,e){const s=this.x.mulE(t).subThisE(this.y.mulE(e)),i=this.x.mulE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(i),this}rotateReverse(t,e){const s=this.x.mulE(t).addThisE(this.y.mulE(e)),i=this.x.negate().mulThisE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(i),this}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y))}crossProduct(t){return this.x.mulE(t.y).subE(this.y.mulE(t.x))}value(){return w.construct(this.x.value(),this.y.value())}}class fi{constructor(){this.a11=new ot(1),this.a12=new ot(0),this.a21=new ot(0),this.a22=new ot(1)}clone(){const t=new fi;return t.a11.setE(this.a11),t.a12.setE(this.a12),t.a21.setE(this.a21),t.a22.setE(this.a22),t}assign(t){return this.a11.setE(t.a11),this.a12.setE(t.a12),this.a21.setE(t.a21),this.a22.setE(t.a22),this}mulThis(t){const e=this.a11.mulE(t.a11).addThisE(this.a12.mulE(t.a21)),s=this.a11.mulE(t.a12).addThisE(this.a12.mulE(t.a22)),i=this.a21.mulE(t.a11).addThisE(this.a22.mulE(t.a21)),n=this.a21.mulE(t.a12).addThisE(this.a22.mulE(t.a22));return this.a11=e,this.a12=s,this.a21=i,this.a22=n,this}mulLeftThis(t){const e=t.clone();return this.assign(e.mulThis(this)),this}det(){return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21))}invertThis(){const t=this.det();if(0!==t.value()){const e=this.a22.divE(t),s=this.a12.negate().divThisE(t),i=this.a21.negate().divThisE(t),n=this.a11.divE(t);this.a11=e,this.a12=s,this.a21=i,this.a22=n}else this.setZero();return!t.isZero()}transposeThis(){return this.a21=q(this.a12,this.a12=this.a21),this}transformPoint(e){return t(0),new pi}eigenValues(e){return t(0),0}eigenVectors(e,s){return t(0),0}eigenSymmetric(t,e){const s=this.a12.clone();s.addThisE(this.a21),s.mulThisByPower2(.5);let i=new ot(1),n=new ot(0);if(s.isZero())t[0].setE(this.a11),t[1].setE(this.a22);else{const e=new ot(1);if(this.a11.ne(this.a22)){const r=this.a11.subE(this.a22).divE(s);r.mulThisByPower2(.5);const o=r.sqr();e.setE(r),e.absThis(),e.subThisE(o.add(1).sqrtThis()),r.gt(wt)&&e.negateThis();const a=e.sqr().addThis(1).sqrtThis().invThis();n=e.mulE(a),i.setE(a);const h=e.mulE(s);t[0]=this.a11.addE(h),t[1]=this.a22.subE(h)}else i=new ot(1/Math.sqrt(2)),n=i.clone(),t[0]=this.a11.addE(s),t[1]=this.a22.subE(s)}e[0].x=i.toDouble(),e[0].y=n.toDouble(),e[1].x=n.negate().toDouble(),e[1].y=i.toDouble(),Math.abs(t[0].toDouble())>Math.abs(t[1].toDouble())&&(t[1]=q(t[0],t[0]=t[1]),e[1]=q(e[0],e[0]=e[1]))}setZero(){this.a11.set(0),this.a21.set(0),this.a12.set(0),this.a22.set(0)}}var xi=Ce;function yi(t,e){const s=t.getStartXY();if(s.equals(e.getStartXY()))return!0;if(s.equals(e.getEndXY()))return!0;const i=t.getEndXY();return!!i.equals(e.getStartXY())||!!i.equals(e.getEndXY())}function Pi(t,e){let s=t.calculateLowerLength2D();return!(s>e)&&(!!t.isLine()||(s=t.calculateUpperLength2D(),s<=e||0!==e&&t.calculateLength2D()<=e))}function Ei(t,e){const s=t.getEndXY().sub(t.getStartXY()).length(),i=t.calculateUpperLength2D()-s<=e[0];return e[0]*=.1,i}function Ci(e,s,i,n,r,o,a,h){let m=e.calculateUpperLength2D(),l=s.calculateUpperLength2D(),u=e,c=s,g=!1;m>l&&(c=q(u,u=c),n=q(i,i=n),l=q(m,m=l),g=!0);const _=0===i;{a[0]=_?1:0;const t=u.getCoord2D(a[0]);h[0]=c.getClosestCoordinate(t,!1);const e=c.getCoord2D(h[0]);if(w.distance(t,e)<=r){const e=[.5,.75,.25,.1,.9];let s=!0;for(let i=0;i<e.length;i++)if(t.assign(u.getCoord2D(e[i])),!c.isCloserThanDistance(t,new A(0,1),r)){s=!1;break}if(s)return g&&(h[0]=q(a[0],a[0]=h[0])),1}}if(m<=3*r)return 0;let d=T(Math.max(r/m,.1),0,.5),p=.01*r,f=0,x=0,y=d,P=-1,E=0,C=1/32;for(let S=0;;S++){t(S<4095);const e=_?d:1-d,s=u.getCoord2D(e),i=c.getClosestCoordinate(s,!1);if(i===n)return E;const m=c.getCoord2D(i),l=w.distance(s,m);if(0===S&&(P=l),l<=p?(C=.5,x=l,f=d):(y=d,P=l),Math.abs(x-P)>.1*p&&y-f>1e-16)d=_t(f,y,C);else{if(a[E]=e,h[E]=i,g&&(h[E]=q(a[E],a[E]=h[E])),1===o||1===E)return 1===E&&a[0]>a[1]&&(a[1]=q(a[0],a[0]=a[1]),h[1]=q(h[0],h[0]=h[1])),E+1;E++,f=y,x=P,y=.8,P=-1,d=.8,C=1/32,p=10*r,S=0}}}function Si(t,e,s,i,n,r,o,a,h){if(ht(s,0,1)&&ht(i,0,1)){if(0===w.distance(t.getCoord2D(s),e.getCoord2D(i))){const h=1e-12,m=new pi,l=st();if(t.queryDerivative(new ot(s,l),m),m.isTrueZero()){const e=1===s?-h:h;t.queryDerivative(new ot(s,l).add(e),m)}1===s&&m.negateThis();const u=new pi;if(e.queryDerivative(new ot(i,l),u),u.isTrueZero()){const t=1===s?-h:h;e.queryDerivative(new ot(i,l).add(t),u)}1===i&&u.negateThis(),m.isZero()||m.normalize(),u.isZero()||u.normalize();const c=m.dotProduct(u),g=m.crossProduct(u);g.scaleError(3);const _=()=>{{const s=t.calculateUpperLength2D(),i=e.calculateUpperLength2D();return Math.min(.01*n/Math.min(s,i),1e-10)}};if(c.ge(wt)&&(g.isZero()||Math.abs(g.value())<_())){return Ci(t,e,s,i,n,r,o,a)}}}return 0}function vi(e,s,i){if(t(e.isCurve()||s.isCurve()),e.getStartXY().equals(s.getStartXY())){if(Si(e,s,0,0,i,2,[0,0],[0,0]))return!0}if(e.getEndXY().equals(s.getEndXY())){if(Si(e,s,1,1,i,2,[0,0],[0,0]))return!0}if(e.getStartXY().equals(s.getEndXY())){if(Si(e,s,0,1,i,2,[0,0],[0,0]))return!0}if(e.getEndXY().equals(s.getStartXY())){if(Si(e,s,1,0,i,2,[0,0],[0,0]))return!0}return!1}function bi(t,e){t.m_XStart=e.x,t.m_YStart=e.y}function Ii(t,e,s){t.m_XStart=e,t.m_YStart=s}function wi(t,e){t.m_XEnd=e.x,t.m_YEnd=e.y}function Di(t,e,s){t.m_XEnd=e,t.m_YEnd=s}function Ti(t,e,s){e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified())}function Ni(t,e,s){t.m_description.hasZ()||t.addAttribute(1),e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified()),t.m_attributes[(t.m_description.getTotalComponentCount()-2)*e]=s.z}function Ai(t,e,s){s.assignVertexDescription(t.m_description);const i=0===e?t.m_XStart:t.m_XEnd,n=0===e?t.m_YStart:t.m_YEnd;s.setXYCoords(i,n);for(let r=1;r<t.m_description.getAttributeCount();r++){const i=t.m_description.getSemantics(r);for(let n=0,r=xi.getComponentCount(i);n<r;n++){const r=Fi(t,e,i,n);s.setAttributeBasic(i,n,r)}}}function qi(t,e,s){s.isEmpty()&&r(""),Ti(t,e,s.getXY());const i=s.getDescription();i!==t.m_description&&t.mergeVertexDescription(i);for(let n=1,r=i.getAttributeCount();n<r;n++){const r=i.getSemantics(n),o=xi.getComponentCount(r);for(let i=0;i<o;i++){Mi(t,e,r,i,s.getAttributeAsDbl(r,i))}}}function Fi(t,e,s,n){if((e<0||e>1)&&i(""),0===s)return(n<0||n>=2)&&i(""),0===e?0===n?t.m_XStart:t.m_YStart:0===n?t.m_XEnd:t.m_YEnd;const r=xi.getComponentCount(s);(n<0||n>=r)&&i("");const o=t.m_description.getAttributeIndex(s);return o>=0?t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(o)-2+n]:xi.getDefaultValue(s)}function Mi(t,e,s,n,r){if((e<0||e>1)&&i(""),0===s)return 0===e?0===n?t.m_XStart=r:1===n?t.m_YStart=r:i(""):1===e?0===n?t.m_XEnd=r:1===n?t.m_YEnd=r:i(""):i(""),void t.endPointModified();const o=xi.getComponentCount(s);(n<0||n>=o)&&i("");let a=t.m_description.getAttributeIndex(s);a<0&&(t.addAttribute(s),a=t.m_description.getAttributeIndex(s)),t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(a)-2+n]=r}function Gi(t,e){if(t===e)return;e.isEmpty()&&r("");const s=e.getDescription();s!==t.m_description&&t.mergeVertexDescription(s);for(let i=1,n=s.getAttributeCount();i<n;i++){const n=s.getSemantics(i),r=xi.getComponentCount(n);for(let s=0;s<r;s++){let i=Fi(e,0,n,s);Mi(t,0,n,s,i),i=Fi(e,1,n,s),Mi(t,1,n,s,i)}}}function Vi(t,e){const s=ve();qe(e,t.m_description,s);let i=null;const n=e.getTotalComponentCount()-2,r=t.m_description?t.m_description.getTotalComponentCount()-2:0;if(n>0&&(i=new Array(2*n),X(i,e.getDefaultPointAttributes(),0,2,n),X(i,e.getDefaultPointAttributes(),n,2,n),null!==t.m_description))for(let o=1;o<e.getAttributeCount();o++){const a=s[o];if(-1!==a){const s=t.m_description.getPointAttributeOffset(a)-2,h=e.getPointAttributeOffset(o)-2,m=xi.getComponentCount(e.getSemantics(o));for(let e=0;e<m;++e)i[h]=t.m_attributes[s],i[n+h]=t.m_attributes[r+s]}}t.m_attributes=i,t.m_description=e}function Yi(t){return t.absNorm()*N()}function Xi(t,e){return Math.max(t.absNorm(),e.absNorm())*N()}function ki(t,e,s){const i=new ni;t.queryEnvelopeW(A.unit(),i);const n=new ni;return e.queryEnvelopeW(A.unit(),n),n.inflate(s),!i.isIntersectingW(n)}function Ri(t,e,s){const i=jt(t,s),n=jt(e,s);i.sort(((t,e)=>t.compare(e))),n.sort(((t,e)=>t.compare(e)));for(let r=0;r<3;r++){if(i[r].compare(n[r])<0)return-1;if(0!==i[r].compare(n[r]))return 1}return 0}var Bi=Ce;class Li{constructor(e){if(e.copy){if(this.m_XStart=e.copy.m_XStart,this.m_YStart=e.copy.m_YStart,this.m_XEnd=e.copy.m_XEnd,this.m_YEnd=e.copy.m_YEnd,this.m_description=e.copy.m_description,this.m_attributes=null,this.m_description){this.m_description.getTotalComponentCount()-2&&(this.m_attributes=e.copy.m_attributes.slice())}}else{if(e.move)return this.m_description=e.move.m_description,e.move.m_description=null,this.m_attributes=e.move.m_attributes,e.move.m_attributes=null,this.m_XStart=e.move.m_XStart,this.m_YStart=e.move.m_YStart,this.m_XEnd=e.move.m_XEnd,void(this.m_YEnd=e.move.m_YEnd);if(void 0!==e.XStart)return this.m_XStart=e.XStart,this.m_YStart=e.YStart,this.m_XEnd=e.XEnd,this.m_YEnd=e.YEnd,this.m_attributes=null,this.m_description=e.vd?e.vd:Ne(),void(e.vd&&this.setDefaultAttributeValues());if(void 0!==e.ZStart)return this.m_XStart=e.XStart,this.m_YStart=e.YStart,this.m_XEnd=e.XEnd,this.m_YEnd=e.YEnd,this.m_description=e.vd?e.vd:Ae(),void(e.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=e.ZStart,this.m_attributes[this.m_description.getTotalComponentCount()-2]=e.ZEnd):this.m_attributes=[e.ZStart,e.ZEnd]);if(e.start)return this.m_XStart=e.start.x,this.m_YStart=e.start.y,this.m_XEnd=e.end.x,this.m_YEnd=e.end.y,this.m_attributes=null,void(this.m_description=Ne());if(e.start3D)return this.m_XStart=e.start3D.x,this.m_YStart=e.start3D.y,this.m_XEnd=e.end3D.x,this.m_YEnd=e.end3D.y,this.m_description=e.vd?e.vd:Ae(),void(e.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=e.start3D.z,this.m_attributes[this.m_description.getTotalComponentCount()-2]=e.end3D.z):this.m_attributes=[e.start3D.z,e.end3D.z]);t(0),this.m_XStart=this.m_YStart=this.m_XEnd=this.m_YEnd=Number.NaN}}setDefaultAttributeValues(){const t=this.m_description.getTotalComponentCount()-2;t>0&&(null===this.m_attributes&&(this.m_attributes=H(2*t,Number.NaN)),X(this.m_attributes,this.m_description.getDefaultPointAttributes(),0,2,t),X(this.m_attributes,this.m_description.getDefaultPointAttributes(),t,2,t))}absNormXYZ(t){return n("not implemented"),0}snapControlPoints3D(){return n("not implemented"),!1}setCoordsForIntersector3D(t,e,s){n("not implemented")}transformAttribute(t,e,s,i,r){n("")}mergeVertexDescriptionImpl(t){const e=we(this.getDescription(),t);this.assignVertexDescription(e)}changeEndPoints(t,e){const s=t.getXY(),i=e.getXY();this.changeEndPoints2D(s,i);let n=t.getDescription();n!==this.getDescription()&&this.mergeVertexDescription(n),n=e.getDescription(),n!==this.getDescription()&&this.mergeVertexDescription(n);for(let r=1,o=n.getAttributeCount();r<o;r++){const s=n.getSemantics(r),i=Bi.getComponentCount(s);for(let n=0;n<i;n++){Mi(this,0,s,n,t.getAttributeAsDbl(s,n));Mi(this,1,s,n,e.getAttributeAsDbl(s,n))}}}getStartXY(){return new w(this.m_XStart,this.m_YStart)}setStartXY(t){this.m_XStart=t.x,this.m_YStart=t.y,this.endPointModified()}setStartXYCoords(t,e){this.m_XStart=t,this.m_YStart=e,this.endPointModified()}getStartXYZ(){return t(0),new Fe(0,0,0)}setStartXYZ(e){t(0)}setStartXYZCoords(t,e,s){Ni(this,0,Fe.construct(t,e,s))}queryStart(t){Ai(this,0,t)}setStart(t){qi(this,0,t)}setStart2D(t){this.setStartXY(t)}getStartAttributeAsDbl(t,e){return Fi(this,0,t,e)}getStartAttributeAsInt(e,s){return t(0),0}setStartAttribute(t,e,s){Mi(this,0,t,e,s)}setStartAttributesFromPoint(e,s){t(0)}setEndAttributesFromPoint(e,s){t(0)}getStartX(){return this.m_XStart}getStartY(){return this.m_YStart}getStartZ(){return t(0),0}getEndX(){return this.m_XEnd}getEndY(){return this.m_YEnd}getEndZ(){return t(0),0}getEndXY(){return new w(this.m_XEnd,this.m_YEnd)}setEndXY(t){this.m_XEnd=t.x,this.m_YEnd=t.y,this.endPointModified()}setEndXYCoords(t,e){this.m_XEnd=t,this.m_YEnd=e,this.endPointModified()}getEndXYZ(){return t(0),new Fe(0,0,0)}setEndXYZ(e){t(0)}setEndXYZCoords(t,e,s){Ni(this,1,Fe.construct(t,e,s))}queryEnd(t){Ai(this,1,t)}setEnd(t){qi(this,1,t)}setEnd2D(t){this.setEndXY(t)}getEndAttributeAsDbl(t,e){return Fi(this,1,t,e)}getEndAttributeAsInt(e,s){return t(0),Math.trunc(0)}setEndAttribute(t,e,s){Mi(this,1,t,e,s)}getDimension(){return 1}copyTo(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&e("");const s=t;s.assignVertexDescription(this.m_description),s.m_attributes&&X(s.m_attributes,this.m_attributes,0,0,2*(this.m_description.getTotalComponentCount()-2)),s.m_XStart=this.m_XStart,s.m_YStart=this.m_YStart,s.m_XEnd=this.m_XEnd,s.m_YEnd=this.m_YEnd,this.copyToImpl(s)}isEmpty(){return this.isEmptyImpl()}isClosed(){return this.m_XStart===this.m_XEnd&&this.m_YStart===this.m_YEnd}setEmpty(){}calculateArea2D(){return 0}queryInterval(t,e){const s=A.constructEmpty();return s.vmin=Fi(this,0,t,e),s.vmax=s.vmin,s.mergeNeCoordinate(Fi(this,1,t,e)),s}calculateLength3D(e){return t(0),0}getCoord3D(e){return t(0),{}}getCoord2D(t){const e=w.getNAN();return this.queryCoord2D(t,e),e}queryCoord3D(e,s){t(0)}getCoordZ(e){return t(0),0}queryCoord(t,e){e.assignVertexDescription(this.m_description),e.setXY(this.getCoord2D(t));for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const i=this.m_description.getSemantics(s),n=Bi.getComponentCount(i);for(let s=0;s<n;s++){const n=this.getAttributeAsDbl(t,i,s);e.setAttributeBasic(i,s,n)}}}isCloserThanDistance(t,e,s){const i=ge.constructEmpty();this.queryLooseEnvelopeOnInterval(e,i);if(i.distance(t)>s)return!1;const n=this.getClosestCoordinateOnInterval(t,e,s);return!Number.isNaN(n)&&w.distance(t,this.getCoord2D(n))<=s}isMonotoneQuickAndDirty(){return!1}isTrue3D(){return!1}getReversed(){const t=this.clone();return t.reverse(),t}reverse(){this.m_XEnd=q(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=q(this.m_YStart,this.m_YStart=this.m_YEnd),this.reverseImpl();for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t);for(let t=0,s=Bi.getComponentCount(e);t<s;t++){const s=Fi(this,0,e,t);Mi(this,0,e,t,Fi(this,1,e,t)),Mi(this,1,e,t,s)}}return this.afterCompletedModification(),this}isEmptyImpl(){return!1}isCircular(){return!1}distance(e,s,i,n){if(!s&&this.isIntersecting(e,0,!1)){if(null!==i||null!==n){const s=new Array(9),r=new Array(9),o=this.intersect(e,null,s,r,0);t(o<=9),0===o&&m(""),null!==i&&(i[0]=s[0]),null!==n&&(n[0]=r[0])}return 0}let r,o=Number.MAX_VALUE,a=-1,h=o;return r=this.getStartXY(),a=e.getClosestCoordinate(r,!1),r.subThis(e.getCoord2D(a)),h=r.length(),h<o&&(o=h,null!==n&&(n[0]=a),null!==i&&(i[0]=0)),r=this.getEndXY(),a=e.getClosestCoordinate(r,!1),r.subThis(e.getCoord2D(a)),h=r.length(),h<o&&(o=h,null!==n&&(n[0]=a),null!==i&&(i[0]=1)),r=e.getStartXY(),a=this.getClosestCoordinate(r,!1),r.subThis(this.getCoord2D(a)),h=r.length(),h<o&&(o=h,null!==i&&(i[0]=a),null!==n&&(n[0]=0)),r=e.getEndXY(),a=this.getClosestCoordinate(r,!1),r.subThis(this.getCoord2D(a)),h=r.length(),h<o&&(o=h,null!==i&&(i[0]=a),null!==n&&(n[0]=1)),o}calculateSubLengthFromStart(t){return this.tToLength(t)}calculateSubLength(t,e){return e===t?0:this.tToLength(e)-this.tToLength(t)}static recalculateParentT(t,e,s){return _t(t,e,s)}moveTo(t){const e=this.isClosed(),s=new Y;s.setShift(t.sub(this.getStartXY())),this.applyTransformation(s),e?this.changeEndPoints2D(t,t):this.changeEndPoints2D(t,this.getEndXY())}moveTo3D(e){t(0)}getDescription(){return this.m_description}assignVertexDescription(t){Vi(this,t)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=De(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Te(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=Ne();t!==this.m_description&&this.assignVertexDescription(t)}swap(e){t(0)}equals(t,e){if(this.getGeometryType()!==t.getGeometryType())return!1;const s=void 0===e;s&&(e=0);const i=t;if(this===i)return!0;if(this.m_description!==i.m_description)return!1;if(Math.abs(this.m_XStart-i.m_XStart)>e||Math.abs(this.m_XEnd-i.m_XEnd)>e||Math.abs(this.m_YStart-i.m_YStart)>e||Math.abs(this.m_YEnd-i.m_YEnd)>e)return!1;for(let n=0,r=2*(this.m_description.getTotalComponentCount()-2);n<r;n++)if(!G(this.m_attributes[n],i.m_attributes[n],e))return!1;return s?this.equalsImpl(i):this.equalsImplTol(i,e)}getImpl(){return this}setAttributeBasic(t,s,i){if(this.addAttribute(t),0===t&&this.isCurve()){(s<0||s>1)&&e("");const t=new Y,n=0===s?i:0,r=1===s?i:0;t.setShiftCoords(n,r),0===s?t.xx=0:t.yy=0,this.applyTransformation(t)}else this.setStartAttribute(t,s,i),this.setEndAttribute(t,s,i)}replaceNaNs(e,s){t(0)}}Li.s_maxMonotonicPartParams=8;class Hi extends Li{constructor(t){super(t)}}class zi extends Hi{isTrue3D(){return!0}constructor(t){super(t)}}function Ui(t,e,s){Oi(e,t.getStartXY(),t.getEndXY(),s)}function Oi(t,e,s,i){lt(e,s,t,i)}function Wi(t,e){return _t(t.m_XStart,t.m_XEnd,e)}function ji(t,e){return _t(t.m_YStart,t.m_YEnd,e)}function Zi(t,e,s){const i=pi.constructPoint2D(t.getStartXY()),n=pi.constructPoint2D(t.getEndXY());s.setCoordsE(n.x.subE(i.x),n.y.subE(i.y))}function Qi(t,e,s){e.value()<=.5?Dt(2,pi.constructPoint2D(t.getStartXY()),pi.constructPoint2D(t.getEndXY()),e,s):Tt(2,pi.constructPoint2D(t.getStartXY()),pi.constructPoint2D(t.getEndXY()),e,s)}function Ki(t,e,s){t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,t.afterCompletedModification()}function Ji(t){if(t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart){t.m_XEnd=q(t.m_XStart,t.m_XStart=t.m_XEnd),t.m_YEnd=q(t.m_YStart,t.m_YStart=t.m_YEnd);for(let e=0,s=t.m_description.getTotalComponentCount()-2;e<s;e++)t.m_attributes[e+s]=q(t.m_attributes[e],t.m_attributes[e]=t.m_attributes[e+s])}}function $i(t,e,s,i){let n=0;if((t.m_XStart===e.m_XStart&&t.m_YStart===e.m_YStart||t.m_XStart===e.m_XEnd&&t.m_YStart===e.m_YEnd)&&(n++,!i))return 1;if(t.m_XEnd===e.m_XStart&&t.m_YEnd===e.m_YStart||t.m_XEnd===e.m_XEnd&&t.m_YEnd===e.m_YEnd){if(n++,2===n)return 2;if(!i)return 1}return e.isIntersectingPoint(t.getStartXY(),s,!0)||e.isIntersectingPoint(t.getEndXY(),s,!0)||t.isIntersectingPoint(e.getStartXY(),s,!0)||t.isIntersectingPoint(e.getEndXY(),s,!0)?4:i&&n?0:sn(t,e)?4:0}function tn(t,e,s,i,n,r,o,a){null!==i&&(i.length=2),null!==n&&(n.length=2),null!==s&&(s.length=2);const h=en(t,e,2,s,i,n,r,o,a);return i&&(i.length=h),n&&(n.length=h),s&&(s.length=h),h}function en(t,e,s,i,n,r,o,a,h){const m=rn(t,e.getStartXY(),o,!1),l=rn(t,e.getEndXY(),o,!1),u=rn(e,t.getStartXY(),o,!1),c=rn(e,t.getEndXY(),o,!1);let g=0,_=0;if(!Number.isNaN(m)){let s=!1;a&&ht(m,0,1)&&t.getCoord2D(m).isEqualPoint2D(e.getStartXY())&&(g++,s=!0),s||(n&&(n[_]=m),r&&(r[_]=0),i&&(i[_]=w.construct(e.m_XStart,e.m_YStart)),_++)}if(!Number.isNaN(l)){let o=!1;a&&ht(l,0,1)&&t.getCoord2D(l).isEqualPoint2D(e.getEndXY())&&(g++,o=!0),o||(s>_&&(n&&(n[_]=l),r&&(r[_]=1),i&&(i[_]=w.construct(e.m_XEnd,e.m_YEnd))),_++)}if(2!==_&&!Number.isNaN(u)&&!(0===m&&0===u||0===l&&1===u)){let o=!1;a&&ht(u,0,1)&&e.getCoord2D(u).isEqualPoint2D(t.getStartXY())&&(g++,o=!0),o||(s>_&&(n&&(n[_]=0),r&&(r[_]=u),i&&(i[_]=w.construct(t.m_XStart,t.m_YStart))),_++)}if(2!==_&&!Number.isNaN(c)&&!(1===m&&0===c||1===l&&1===c)){let o=!1;a&&ht(c,0,1)&&e.getCoord2D(c).isEqualPoint2D(t.getEndXY())&&(g++,o=!0),o||(s>_&&(n&&(n[_]=1),r&&(r[_]=c),i&&(i[_]=w.construct(e.m_XEnd,e.m_YEnd))),_++)}if(_>0)return h&&(r=q(n,n=r)),2===_&&s>=2&&n&&n[0]>n[1]&&(n[1]=q(n[0],n[0]=n[1]),r&&(r[1]=q(r[0],r[0]=r[1])),i&&(i[1]=q(i[0],i[0]=i[1]))),_;if(g>0)return 0;const d=ln(t,e,o);return Number.isNaN(d.x)?0:(i&&(i[0]=t.getCoord2D(d.x)),n&&(n[0]=d.x),r&&(r[0]=d.y),1)}function sn(t,e){const s=on(t,e.m_XStart,e.m_YStart),i=on(t,e.m_XEnd,e.m_YEnd);if(s<0&&i<0||s>0&&i>0)return!1;const n=on(e,t.m_XStart,t.m_YStart),r=on(e,t.m_XEnd,t.m_YEnd);if(n<0&&r<0||n>0&&r>0)return!1;return mn(t)>mn(e)?hn(t,e):hn(e,t)}function nn(t,e){const s={bIntersect:!1,t1:Number.NaN,t2:Number.NaN},i=t.m_XEnd-t.m_XStart,n=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,o=e.m_YEnd-e.m_YStart,a=r*n-i*o;if(0===a)return s;const h=e.m_XStart-t.m_XStart,m=e.m_YStart-t.m_YStart,l=r*m-h*o,u=i*m-h*n,c=1/a;return s.t1=l*c,s.t2=u*c,s.bIntersect=!0,s}function rn(t,e,s,i){const n=w.getNAN(),r=w.getNAN();let o=!1;t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart?(n.setCoords(t.m_XEnd,t.m_YEnd),r.setCoords(t.m_XStart,t.m_YStart),o=!0):(n.setCoords(t.m_XStart,t.m_YStart),r.setCoords(t.m_XEnd,t.m_YEnd));const a=o?1:0,h=o?0:1,m=w.getNAN();m.setSub(e,n);let l=m.length(),u=3*l*st();if(l<=Math.max(s,u))return i&&0===l?Number.NaN:a;if(m.setSub(e,r),l=m.length(),u=3*l*st(),l<=Math.max(s,u))return i&&0===l?Number.NaN:h;m.setCoords(r.x-n.x,r.y-n.y);const c=m.length();if(c>0){const t=1/c;m.scale(t);const i=w.getNAN();i.setSub(e,n);const l=i.dotProduct(m),u=8*i.dotProductAbs(m)*st();m.leftPerpendicularThis();const g=i.dotProduct(m),_=8*i.dotProductAbs(m)*st(),d=Math.max(s,u);if(l<-d||l>c+d)return Number.NaN;const p=Math.max(s,_);if(Math.abs(g)<=p){let i=l*t;i=T(i,0,1);const m=w.getNAN();if(Oi(i,n,r,m),w.distance(m,e)<=s){if(i<.5){if(w.distance(m,n)<=s&&w.distance(e,n)<=s)return a}else if(w.distance(m,r)<=s&&w.distance(e,r)<=s)return h;return o?1-i:i}}}return Number.NaN}function on(t,e,s){const i=w.getNAN();i.setCoords(e,s),i.subThis(t.getStartXY());const n=w.getNAN();n.setSub(t.getEndXY(),t.getStartXY());const r=n.crossProduct(i),o=4*st()*(Math.abs(n.x*i.y)+Math.abs(n.y*i.x));return r>o?-1:r<-o?1:0}function an(t,e,s,i){const n=i?t.m_XStart:t.m_XEnd,r=i?t.m_YStart:t.m_YEnd,o=w.getNAN();o.x=e.getEndX()-n,o.y=e.getEndY()-r;if(s.dotProduct(o)>3*st()*s.dotProductAbs(o)){o.x=e.getStartX()-n,o.y=e.getStartY()-r;return s.dotProduct(o)<=3*st()*s.dotProductAbs(o)}return!0}function hn(t,e){const s=w.getNAN();return s.x=t.m_XEnd-t.m_XStart,s.y=t.m_YEnd-t.m_YStart,!!an(t,e,s,!1)&&(s.negateThis(),!!an(t,e,s,!0))}function mn(t){const e=t.m_XStart-t.m_XEnd,s=t.m_YStart-t.m_YEnd;return e*e+s*s}function ln(t,e,s){const i=t.m_XEnd-t.m_XStart,n=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,o=e.m_YEnd-e.m_YStart,a=r*n-i*o;if(0===a)return w.getNAN();const h=4*st()*(Math.abs(r*n)+Math.abs(i*o)),m=e.m_XStart-t.m_XStart,l=e.m_YStart-t.m_YStart,u=r*l-m*o,c=4*st()*(Math.abs(r*l)+Math.abs(m*o)),g=u/a,_=Math.abs(a),d=(c*_+h*Math.abs(u))/(a*a)+st()*Math.abs(g);if(g<-d||g>1+d)return w.getNAN();const p=i*l-m*n,f=p/a,x=(4*st()*(Math.abs(i*l)+Math.abs(m*n))*_+h*Math.abs(p))/(a*a)+st()*Math.abs(f);if(f<-x||f>1+x)return w.getNAN();let y=T(g,0,1),P=T(f,0,1);const E=w.getNAN();Ui(t,y,E);const C=w.getNAN();if(Ui(e,P,C),!s||w.distance(E,C)>s){const i=w.getNAN();lt(E,C,.5,i),y=t.getClosestCoordinate(i,!1),P=e.getClosestCoordinate(i,!1);const n=w.getNAN();Ui(t,y,n);const r=w.getNAN();Ui(e,P,r),n.subThis(r);const o=n.length(),a=(t.absNorm()+e.absNorm())*N();if(o>Math.max(s,a))return w.getNAN()}return new w(y,P)}class un{constructor(t){if(this.m_segFlagStream=null,this.m_xyStream=null,this.m_bCirculator=!1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_parent=t.parent,this.m_buffer=new this.m_parent.m_segmentBufferCTor,this.m_description=t.parent.getDescription(),this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),void 0!==t.pointIndex){(t.pointIndex<0||t.pointIndex>=t.parent.getPointCount())&&i("");const e=t.parent.getPathIndexFromPointIndex(t.pointIndex);this.m_currentPathIndex=e,this.m_nextPathIndex=e+1,this.m_nextSegmentIndex=t.pointIndex-t.parent.getPathStart(e),this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex)}else if(void 0!==t.pathIndex){(t.pathIndex<0||t.pathIndex>=t.parent.getPathCount()||t.segmentIndex<0)&&i("");const e=t.parent.isClosedPath(t.pathIndex)?0:1;t.segmentIndex>=t.parent.getPathSize(t.pathIndex)-e&&i(""),this.m_nextSegmentIndex=t.segmentIndex,this.m_currentPathIndex=t.pathIndex,this.m_nextPathIndex=this.m_nextSegmentIndex+1,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex)}this.prepare(),this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1,this.m_bStripAttributes=!1,this.m_prevPathIndex=-1,this.m_prevSegmentIndex=-1,this.m_bNeedsUpdate=!1,this.m_currentPathIndex>-1&&(this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex))}stripAttributes(){this.m_bStripAttributes=!0}clone(){return t(0),this}prepare(){this.m_bCirculator=!1,this.m_parent.isEmptyImpl()?(this.m_segFlagStream=null,this.m_xyStream=null):(this.m_segFlagStream=this.m_parent.getSegmentFlagsStreamRef(),this.m_xyStream=this.m_parent.getAttributeStreamRef(0))}nextPath(){return this.m_currentPathIndex=this.m_nextPathIndex,!(this.m_currentPathIndex>=this.m_parent.getPathCount())&&(this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.m_nextPathIndex++,!0)}previousPath(){return 0!==this.m_nextPathIndex&&(this.m_nextPathIndex--,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),this.m_currentPathIndex=this.m_nextPathIndex,this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.resetToLastSegment(),!0)}getSegmentCount(t){return this.m_parent.isEmptyImpl()?0:this.m_parent.getSegmentCountPath(t)}resetToFirstPath(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}resetToLastPath(){this.m_nextPathIndex=this.m_parent.getPathCount(),this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1}resetToPath(t){(t<0||t>this.m_parent.getPathCount())&&i(""),this.m_nextPathIndex=t,this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}isLastPath(){return this.m_currentPathIndex===this.m_parent.getPathCount()-1}isFirstSegmentInPath(){return 0===this.m_currentSegmentIndex}isLastSegmentInPath(){return this.m_currentSegmentIndex===this.m_segmentCount-1}resetToFirstSegment(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0}resetToLastSegment(){this.m_nextSegmentIndex=this.m_segmentCount,this.m_currentSegmentIndex=-1}resetTo(t){this.m_parent!==t.m_parent&&h(""),this.m_currentSegmentIndex=t.m_currentSegmentIndex,this.m_nextSegmentIndex=t.m_nextSegmentIndex,this.m_currentPathIndex=t.m_currentPathIndex,this.m_nextPathIndex=t.m_nextPathIndex,this.m_segmentCount=t.m_segmentCount,this.m_bCirculator=t.m_bCirculator,this.m_pathBegin=t.m_pathBegin,this.m_bCurrentPathClosed=t.m_bCurrentPathClosed,this.m_bStripAttributes=t.m_bStripAttributes,this.m_description=t.m_description}resetToVertex(t,e){if(this.m_currentPathIndex>=0&&this.m_currentPathIndex<this.m_parent.getPathCount()){const e=this.getPathBegin();if(t>=e&&t<this.m_parent.getPathEnd(this.m_currentPathIndex))return this.m_currentSegmentIndex=-1,void(this.m_nextSegmentIndex=t-e)}let s;s=e>=0&&e<this.m_parent.getPathCount()&&t>=this.m_parent.getPathStart(e)&&t<this.m_parent.getPathEnd(e)?e:this.m_parent.getPathIndexFromPointIndex(t),this.m_nextPathIndex=s+1,this.m_currentPathIndex=s,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=t-this.m_parent.getPathStart(s),this.m_segmentCount=this.getSegmentCount(s),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex)}hasNextSegment(){return this.m_nextSegmentIndex<this.m_segmentCount}hasPreviousSegment(){return this.m_nextSegmentIndex>0}nextSegment(){return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&i("Segment_iterator_impl::next_segment"),this.m_nextSegmentIndex++),this.m_buffer.get()}previousSegment(){return this.m_bCirculator?this.m_nextSegmentIndex=(this.m_segmentCount+this.m_nextSegmentIndex-1)%this.m_segmentCount:(0===this.m_nextSegmentIndex&&i(""),this.m_nextSegmentIndex--),this.m_nextSegmentIndex!==this.m_currentSegmentIndex&&this.updateSegment(),this.m_buffer.get()}nextCurve(){if(!this.m_parent.hasNonLinearSegments())return this.resetToLastSegment(),null;let t=0;for(;;){if(this.m_nextSegmentIndex===this.m_segmentCount||t===this.m_segmentCount)return null;const e=this.getPathBegin()+this.m_nextSegmentIndex;if(1!==(31&this.m_segFlagStream.read(e))){this.updateSegment();break}this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:this.m_nextSegmentIndex++,t++}return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&i(""),this.m_nextSegmentIndex++),this.m_buffer.get()}getPathBegin(){return this.m_pathBegin}getPathIndex(){return this.m_currentPathIndex}getStartPointIndex(){return this.getPathBegin()+this.m_currentSegmentIndex}getEndPointIndex(){return this.isClosingSegment()?this.getPathBegin():this.getStartPointIndex()+1}updateSegment(){(this.m_nextSegmentIndex<0||this.m_nextSegmentIndex>=this.m_segmentCount||this.m_currentPathIndex<0)&&i(""),this.m_currentSegmentIndex=this.m_nextSegmentIndex,this.m_parent.getSegmentFromPath(this.m_currentPathIndex,this.m_currentSegmentIndex,this.m_buffer,this.m_bStripAttributes)}isClosingSegment(){return this.m_bCurrentPathClosed&&this.m_currentSegmentIndex===this.m_segmentCount-1}isCurve(){if(null!==this.m_segFlagStream){return 1!==(31&this.m_segFlagStream.read(this.m_currentSegmentIndex))}return!1}isPathClosed(){return this.m_bCurrentPathClosed}setCirculator(t){this.m_bCirculator=t}getImpl(){return this}}class cn{constructor(t){this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null,this.m_refCount=1,t&&t.copyTo(this)}assignCopy(e){return t(0),this}getRasterizedGeometry(){return this.m_rasterizedGeometry}copyTo(e){e!==this&&(t(e.uniqueUse()),e.m_quadTree=this.m_quadTree,e.m_quadTreeForPaths=this.m_quadTreeForPaths,e.m_rasterizedGeometry=this.m_rasterizedGeometry)}clone(){const t=new cn;return this.copyTo(t),t}uniqueUse(){return 1===this.m_refCount}addRef(){++this.m_refCount}release(){0==--this.m_refCount&&(this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null)}setRasterizedGeometry(e){t(this.uniqueUse())}setQuadTree(e){t(this.uniqueUse()),this.m_quadTree=e}setQuadTreeForPaths(e){t(this.uniqueUse()),this.m_quadTreeForPaths=e}getQuadTree(){return this.m_quadTree}getQuadTreeForPaths(){return this.m_quadTreeForPaths}}function gn(t){return!(t.isEmpty()||t.getGeometryType()!==s.enumPolyline&&t.getGeometryType()!==s.enumPolygon)&&!(t.getPointCount()<20)}function _n(t){return!(t.isEmpty()||t.getGeometryType()!==s.enumPolyline&&t.getGeometryType()!==s.enumPolygon)&&!(t.getPointCount()<20)}function dn(t,e){return t.readPoint2D(e+4)}function pn(t){const e=t.getGeometryType();return e===s.enumEllipticArc?10:e===s.enumBezier?4:e===s.enumRationalBezier2?5:e===s.enumBezier2?2:void m("")}function fn(t){const e=31&t;return 4===e?10:2===e?4:8===e?5:16===e?2:0}function xn(e,s,i,n){const r=4*st()*(Math.abs(s.vmin)+Math.abs(s.vmax)),o=st();if(1===e.getMaxDerivative()){t(i>0);const o=bn(e,0,s,st(),r);return n[0]=o.root,o.cRoots}let a,h=[];const m=new A(s.vmin-r,s.vmax+r);h.push(new w(m.vmin,m.vmax));let l=0;for(let t=e.getMaxDerivative()-1;t>=0;t--){a=h,h=[];for(let m=0,u=a.length;m<u;m++){if(a[m][0]<a[m][1]){let u,c,g;if(t===e.getMaxDerivative()-1?({root:u,funcAtRoot:c,cRoots:g}=bn(e,t,A.construct(a[m][0],a[m][1]),o,.5*r)):({root:u,funcAtRoot:c,cRoots:g}=In(e,t,A.construct(a[m][0],a[m][1]),o,.5*r)),1===g){if(0===t){if(l<i){if(a[m][0]<=s.vmin&&a[m][1]>=s.vmin&&u!==s.vmin){0===e.getValue(0,s.vmin)&&(u=s.vmin)}if(a[m][0]<=s.vmax&&a[m][1]>=s.vmax&&u!==s.vmax){0===e.getValue(0,s.vmax)&&(u=s.vmax)}n[l]=s.snapClip(u),l>0?n[l]-n[l-1]>r&&l++:l++}}else{const t=w.getNAN();t[0]=a[m][0],t[1]=u,h.push(t);const e=w.getNAN();e[0]=u,e[1]=a[m][1],h.push(e)}continue}}h.push(a[m])}}return l}function yn(t,e,s,i){const n=new ot,r=Tn(new ot(t),new ot(e),s,n);return i[0]=n.value(),r}function Pn(t,e,s,i,n,r){const o=D(ot,2),a=Nn(new ot(t),new ot(e),new ot(s),i,n,o);return r[0]=o[0].value(),r[1]=o[1].value(),a}function En(t,e,s,i,n,r,o){const a=D(ot,3),h=An(new ot(t),new ot(e),new ot(s),new ot(i),n,r,a);return o[0]=a[0].value(),o[1]=a[1].value(),o[2]=a[2].value(),h}function Cn(t,e,s,i,n,r,o,a){return vn(t,e,s,i,n,r,o,a)}function Sn(t,e,s,i,n,r){return Dn(t,e,s,i,n,r)}function vn(t,e,s,i,n,r,o,a){const h=new Array(s*s);h.fill(0),X(a,i,0,0,s);const m=new Array(s),l=new Array(s),u=new Array(s);let c=t(a,s,e);const g=100;let _=0;for(_=0;_<g;_++){const i=c;for(let t=0;t<s;++t)l[t]=a[t];if(_%s==0){h.fill(0);for(let t=0;t<s;t++)h[t*s+t]=1}let o=0,g=0;for(let l=0;l<s;++l){for(let t=0;t<s;++t)m[t]=h[l*s+t];const i=c;c=wn(t,e,a,m,n,r,s);const u=i-c;u>o&&(g=l,o=u)}for(let t=0;t<s;t++)m[t]=a[t]-l[t],u[t]=a[t]+(a[t]-l[t]);const d=t(u,s,e);if(d<i){if(2*(i-2*c+d)*M(i-c-o)<M(i-d)*o){c=wn(t,e,a,m,n,r,s);for(let t=0;t<s;++t)h[g*s+t]=h[(s-1)*s+t],h[(s-1)*s+t]=m[t]}}if(i<=c)return t(a,s,e)}return c}function bn(t,e,s,i,n){const r={root:0,funcAtRoot:0,cRoots:0};let o=s.vmin,a=s.vmax,h=0,l=Number.MAX_VALUE,u=t.getValue(e,o),c=t.getValue(e,a),g=0,_=0,d=0;if(u>=0&&c>=0||u<=0&&c<=0)return Math.abs(u)<Math.abs(c)?(r.funcAtRoot=u,r.root=o,r.cRoots=0===u?1:0,r):(r.funcAtRoot=c,r.root=a,r.cRoots=0===c?1:0,r);Math.abs(u)<Math.abs(c)&&(a=q(o,o=a),c=q(u,u=c)),h=o,g=u;let p=!0,f=0;for(;0!==c&&Math.abs(o-a)>i*Math.abs(a)+n;f++){let s=f>64;if(!s){_=u!==g&&c!==g?o*c*g/((u-c)*(u-g))+a*u*g/((c-u)*(c-g))+h*u*c/((g-u)*(g-c)):a-c*(a-o)/(c-u);const t=(3*o+a)/4;if(s=!(_>t&&_<a||_>a&&_<t),!s){const t=i*Math.abs(a)+n;if(p){const e=Math.abs(a-h);s=Math.abs(_-a)>=.5*e||e<t}else{const e=Math.abs(h-l);s=Math.abs(_-a)>=.5*e||e<t}}}if(s?(_=(o+a)/2,p=!0):p=!1,d=t.getValue(e,_),0===d)return r.root=_,r.funcAtRoot=d,r.cRoots=1,r;if(!s){const s=o-_,i=_-a;if(Math.abs(s)>10*Math.abs(i)){let s=a+3*i;for(let i=0;i<2;i++){const i=t.getValue(e,s);Q(u)*Q(i)>0?(o=s,u=i):s=_t(o,a,.75)}}else if(Math.abs(i)>10*Math.abs(s)){let i=o-3*s;for(let s=0;s<2;++s){const s=t.getValue(e,i);Q(c)*Q(s)>0?(a=i,c=s):i=_t(o,a,.25)}}}l=h,h=a,g=c,Q(u)*Q(d)<0?(a=_,c=d):(o=_,u=d),Math.abs(u)<Math.abs(c)&&(a=q(o,o=a),c=q(u,u=c)),128===f&&m("Root_finder iterations exceeded")}return r.root=a,r.funcAtRoot=c,r.cRoots=1,r}function In(t,e,s,i,n){const r={root:0,funcAtRoot:0,cRoots:0};let o=s.vmin,a=t.getValue(e,o),h=s.vmax,l=t.getValue(e,h);if(a>=0&&l>=0||a<=0&&l<=0)return Math.abs(a)<Math.abs(l)?(r.funcAtRoot=a,r.root=o,r.cRoots=0===a?1:0,r):(r.funcAtRoot=l,r.root=h,r.cRoots=0===l?1:0,r);l<0&&(l=q(a,a=l),h=q(o,o=h));let u=.5*(o+h),c=Math.abs(h-o),g=c,_=t.getValue(e,u),d=t.getValue(e+1,u);const p=1,f=4;let x=f;const y=2;let P=1,E=0,C=0,S=p;const v=32;let b=0;for(;++b<100;){let s;b>v||0===d||S===y&&E>1||S===p&&x<f?(S=p,P>1&&P--):(S=y,C>1&&Math.abs(2*_)>Math.abs(c*d)&&P++),c=g;let i=!1;if(S===p)do{if(C>2){const t=16*Math.abs(c);if(.5*Math.abs(o-h)>t){const e=Math.min(o,h),i=Math.max(o,h);if(u===e){s=u,u=e+t,g=u-s;break}if(u===i){s=u,u=i-t,g=u-s;break}}}g=.5*(h-o),s=u,u=o+g,i=o===u||h===u}while(0);else for(;;){g=P*_/d,s=u,u-=g,i=u===s;const t=Math.min(o,h),e=Math.max(o,h);if(u<t){if(P>1){u=s,P--;continue}g=s-t,u=t}else if(u>e){if(P>1){u=s,P--;continue}g=s-e,u=e}break}if(i||Math.abs(g)<n){s!==u&&(_=t.getValue(e,u));break}_=t.getValue(e,u),d=t.getValue(e+1,u);const r=o,m=h;_<0?(a=_,o=u):(l=_,h=u),S===y&&(o===r&&h===m||C>1&&Math.abs(g)>=.5001*Math.abs(c))?E++:E=0,S===p?(x++,C=0):(x=0,C++)}return 100===b&&m("Root_finder iterations exceeded"),r.root=u,r.funcAtRoot=_,r.cRoots=1,r}function wn(t,e,s,i,n,r,o){const a=i.slice(0,o);let h=0;for(let f=0;f<o;f++)h+=i[f]*i[f];if(h=Math.sqrt(h),h>0)for(let f=0;f<o;f++)a[f]/=h;let m=Number.NEGATIVE_INFINITY,l=Number.POSITIVE_INFINITY;{const t=new Array(o);for(let e=0;e<o;e++)t[e]=e;t.sort(((t,e)=>{const s=Math.abs(a[t]),i=Math.abs(a[e]);return s<i?-1:s>i?1:0}));for(let e=0;e<o;e++){const i=t[e];if(0===a[i])continue;let o=(n[i]-s[i])/a[i],h=(r[i]-s[i])/a[i];h<o&&(h=q(o,o=h)),o>m&&(m=o),h<l&&(l=h)}}let u=0;const c=(Math.abs(m)+Math.abs(l))*st()*100,g=new Array(o),_=a.slice();function d(i,n){for(let t=0,e=o;t<e;t++)g[t]=s[t]+i*_[t];return t(g,o,e)}c>0&&(u=Sn(d,null,m,0,l,c));const p=d(u);for(let f=0,x=o;f<x;f++)s[f]=T(g[f],n[f],r[f]);return p}function Dn(t,e,s,i,n,r){const o=kt();let a=i,h=t(a,e),m=s,l=n,u=t(m,e),c=t(l,e);h>u&&(h=u,a=m),h>c&&(h=c,a=l);let g=m,_=l,d=u,p=c;d>p&&(d=q(p,p=d),_=q(g,g=_));let f=a-g,x=g-_;const y=.5*Math.min(r,l-m),P=2*y,E=100;let C,S=0;for(C=0;C<E&&!(l-m<=P);++C){const s=m+.5*(l-m);let i=S>0;if(!i&&Math.abs(x)<=y&&(i=!0,S=3),!i){const t=a-g,e=a-_,s=t*(h-p);let n=e*(h-d),r=e*n-t*s;n=2*(n-s),n>0&&(r=-r),n=Math.abs(n),0===n||Math.abs(r)>=Math.abs(n*x/2)||r<=n*(m-a)||r>=n*(l-a)?(i=!0,S=3):(x=f,f=r/n)}i&&(x=a>=s?m-a:l-a,f=o*x,S--);let n=a+f;n<m+y?n=m+y:n>l-y&&(n=l-y);const r=t(n,e);r<h?(n>=a?(m=a,u=h):(l=a,c=h),_=g,g=a,a=n,p=d,d=h,h=r):(n<a?(m=n,u=r):(l=n,c=r),r<=d||g===a?(_=g,g=n,p=d,d=r):(r<=p||_===a||_===g)&&(_=n,p=r))}return a}function Tn(t,e,s,i){return t.isZero()?e.isZero()?-1:0:(i.setE(e.clone().negateThis().divThisE(t)),s.containsCoordinate(i.value())?1:0)}function Nn(t,e,s,i,n,r){if(0===t.value()){if(n)return r[0].set(1),i.containsCoordinate(r[0].value())?1:0;return Tn(e,s,i,r[0])}if(n){let e=2;return r[0].set(1),r[1].setE(s).divThisE(t),r[1].eq(r[0])&&(r[1].set(1),e=1),i.containsCoordinate(r[1].value())||(e=1),i.containsCoordinate(r[0].value())||(e--,r[0].setE(r[1])),2===e&&r[0].value()>r[1].value()&&(r[1]=q(r[0],r[0]=r[1])),e}const o=e.clone().sqrThis().subThisE(t.clone().mulThisE(s).mulThisE(Nt));if(o.lt(wt))return 0;const a=new ot(e.value()>=0?1:-1),h=o.clone().sqrtThis(),m=new ot(-.5).mulThisE(e.clone().addThisE(a.clone().mulThisE(h)));let l=0;r[0].setE(m.divE(t));const u=new ot(r[0].value()),c=new ot(t.value()).mulE(u).addE(new ot(e.value()).mulE(u).addE(new ot(s.value())));return c.isZero()||Xn(r[0],t,e,s,r[0]),i.containsCoordinate(r[0].value())&&l++,0!==h.value()&&0!==m.value()?(r[l].assign(s.divE(m)),u.set(r[l].value()),c.assign(new ot(t.value()).mulE(u).addE(new ot(e.value()).mulE(u).addE(new ot(s.value())))),c.isZero()||Xn(r[l],t,e,s,r[l]),i.containsCoordinate(r[l].value())&&l++,2===l&&r[0].value()>r[1].value()&&(r[1]=q(r[0],r[0]=r[1])),l):l}function An(t,e,s,i,n,r,o){if(0===t.value()){return Nn(e,s,i,n,r,o)}if(r){let s=1;o[0].set(1);const r=o.slice(s),a=Nn(t,e.addE(t),i.negate(),n,!1,r);if(a>0){s+=a;for(let t=1;t<s;t++)o[t].eq(It)&&(o[s-1]=q(o[t],o[t]=o[s-1]),s--)}const h=o.slice(0,s);h.sort(((t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0));for(let t=0;t<s;++t)o[t]=h[t];return s}return kn(t,e,s,i,n,o)}function qn(t,s,i,n,r,o){return(o<s||s<0)&&e("nth_degree_real_roots"),Rn(t,s,i,n,r)}function Fn(t,e,s,i){return{coef0:t.clone(),coef1:e.clone(),coef2:s.clone(),coef3:i.clone(),calcF(t){return this.coef0.clone().mulThis(t).addThisE(this.coef1).mulThis(t).addThisE(this.coef2).mulThis(t).addThisE(this.coef3)},calcDF(t){return this.coef0.clone().mulThis(3).mulThis(t).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(t).addThisE(this.coef2)},estimateError(t){const e=Math.abs(t),s=((this.coef0.eps()*e+this.coef1.eps())*e+this.coef2.eps())*e+this.coef3.eps()+this.calcF(t).eps(),i=this.coef0.clone().mulThis(t).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(t).addThisE(this.coef2);if(i.isZero()){const e=this.coef0.clone().mulThis(t).mulThis(6).addThisE(this.coef1.clone().mulThis(2));if(e.isZero()){const t=this.coef0.clone().mulThis(6);return Math.pow(6*s/Math.abs(t.value()),1/3)}return Math.sqrt(2*s/Math.abs(e.value()))}return s/Math.abs(i.value())}}}class Mn{updateCoefs(t){if(this.lastDeriv1===t)return this.curCoefs=this.derivCoefs1,void(this.lastUsed=1);if(this.lastDeriv2===t)return this.curCoefs=this.derivCoefs2,void(this.lastUsed=2);let e;1===this.lastUsed?(e=this.derivCoefs2,this.lastDeriv2=t,this.lastUsed=2):(e=this.derivCoefs1,this.lastDeriv1=t,this.lastUsed=1),e.length=this.truePower-t+1;for(let s=0,i=this.truePower-t;s<=i;++s){e[s]=this.coefs[s+t].clone();let i=s+t,n=i--;for(let e=1;e<t;e++)n*=i--;e[s].mulThis(n)}this.curCoefs=e}constructor(t,e,s,i){this.derivCoefs1=[],this.derivCoefs2=[],this.lastDeriv1=-1,this.lastDeriv2=-1,this.lastUsed=-1,this.curCoefs=null,this.coefs=t,this.power=e,this.truePower=0;for(let n=e;n>=1;n--)if(0!==this.coefs[n].value()){this.truePower=n;break}}getMaxDerivative(){return this.truePower+1}getValue(t,e){let s=this.coefs;0===t?s=this.coefs:(this.updateCoefs(t),s=this.curCoefs);const i=new Yt(0);let n=1;for(let r=0,o=this.truePower-t;r<=o;++r)i.pe(n*s[r].value()),n*=e;return i.getResult()}getError(t){const e=Math.abs(t),s=new Yt(0),i=new ot(1),n=new ot(0);for(let o=0,a=this.power;o<=a;++o)n.addThisE(this.coefs[o].mulE(i)),s.pe(i.value()*this.coefs[o].eps()),i.mulThis(e);s.pe(n.eps());let r=1;for(let o=1;o<=this.truePower;++o){r*=o,this.updateCoefs(o);const e=new ot(1),i=new ot(0);for(let s=0,n=this.truePower-o;s<=n;++s)i.addThisE(this.curCoefs[s].mulE(e)),e.mulThis(t);if(!i.isZero())return Math.pow(r*s.getResult()/Math.abs(i.value()),1/o)}return 0}}function Gn(t,e,s,i,n,r){let o=t,a=e,h=a-o;if(!r){let s=i.calcF(t).value(),n=i.calcF(e).value();if((s>0||s>n)&&(a=q(o,o=a),n=q(s,s=n)),s>=0||n<=0)return!1}let m,l=!1,u=s,c=0;for(;c<100;c++){const t=i.calcF(u);if(m=i.calcDF(u),m.isZero())return!1;if(!t.value()||c>3&&t.isZero()){l=!0;break}r||(t.value()<0?o=u:a=u);const e=t.value()/m.value(),s=u-e;r||(s>=o&&s<=a||s>=a&&s<=o)&&Math.abs(e)<=.5*h?(u=s,h=Math.abs(e)):(h=Math.abs(.5*(a-o)),u=.5*(o+a))}return!!l&&(n.set(u,i.estimateError(u)),!0)}function Vn(t,e,s,i,n,r,o,a){return Gn(t,e,s.value(),Fn(i,n,r,o),a,!1)}class Yn{constructor(t,e,s){this.coefs=D(ot,3),this.coefs[0].setE(t),this.coefs[1].setE(e),this.coefs[2].setE(s)}calcF(t){const e=new ot(t);return this.coefs[0].mulE(e).addE(this.coefs[1]).mulE(e).addE(this.coefs[2])}calcDF(t){const e=new ot(t);return ot.st_mulByPower2(this.coefs[0],2).mulE(e).addE(this.coefs[1])}estimateError(t){const e=Math.abs(t),s=(this.coefs[0].eps()*e+this.coefs[1].eps())*e+this.coefs[2].eps()+this.calcF(t).eps(),i=new ot(2).mulE(this.coefs[0]).mul(t).addE(this.coefs[1]);if(i.isZero()){const t=this.coefs[0].value();return Math.sqrt(s/Math.abs(t))}return s/Math.abs(i.value())}}function Xn(t,e,s,i,n){return Gn(0,0,t.value(),new Yn(e,s,i),n,!0)}function kn(t,e,s,i,n,r){const o=D(ot,3);let a=0;const h=e.negate().divThisE(t.clone().mulThis(3));n.containsCoordinate(h.value())&&(o[0].setE(h),a=1);const l=D(ot,2),u=Nn(t.mul(3),e.mul(2),s,n,!1,l);if(u<0)return i.isZero()?-1:0;for(let m=0;m<u;m++)n.containsCoordinate(l[m].value())&&o[a++].setE(l[m]);z(o,0,a,((t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0));const c=D(ot,5);c[0].set(n.vmin);for(let m=0;m<a;m++)c[1+m].setE(o[m]);c[1+a].set(n.vmax);const g=a+2;let _=1,d=0;{const n=c[0].clone();if(t.clone().mulThisE(n).addThisE(e).mulThisE(n).addThisE(s).mulThisE(n).addThisE(i).isZero()){const o=Fn(t,e,s,i);n.setError(o.estimateError(n.value())),r[d]=n,d++,_++}}for(let p=_;p<g;p++){const o=c[p].clone(),a=t.clone().mulThisE(o).addThisE(e).mulThisE(o).addThisE(s).mulThisE(o).addThisE(i).isZero();if(a||!c[p].eq(c[p-1])){if(a||Vn(c[p-1].value(),c[p].value(),c[p-1].clone().addThisE(c[p]).divThisByPower2(2),t,e,s,i,o)){if(d>0&&o.eq(r[d-1]))continue;if(d>=3&&m("cubic_polynomial_solver_too_many_roots"),a){const n=Fn(t,e,s,i);o.setError(n.estimateError(o.value()))}r[d]=o,d++}if(c[p].value()===n.vmax)break;a&&p++}}return d}function Rn(t,e,s,i,n,r){const o=new Mn(t,e,s,st());let a=0;if(2===o.truePower)a=Nn(t[2],t[1],t[0],s,i,n);else if(1===o.truePower)a=Tn(t[1],t[0],s,n[0]);else{if(0===o.truePower)return t[0].value()?0:-1;{const t=[];t.length=e,a=xn(o,s,e,t);for(let e=0;e<a;e++)n[e].set(t[e])}}for(let h=0;h<a;h++)n[h].setError(o.getError(n[h].value()));return a}var Bn=Ce;class Ln extends Hi{constructor(e){void 0===e||it(e,"vd")?(super({vd:e?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new w(0,0)):e.from?(super({XStart:e.from.x,YStart:e.from.y,XEnd:e.to.x,YEnd:e.to.y,...e.vd}),this.m_cp=e.cp.clone()):e.points?(super({XStart:e.points[0].x,YStart:e.points[0].y,XEnd:e.points[2].x,YEnd:e.points[2].y,...e.vd}),this.m_cp=e.points[1].clone()):e.copy?(super(e),this.m_cp=e.copy.m_cp.clone()):(t(0),super({XStart:0,YStart:0,XEnd:0,YEnd:0,...e.vd}),this.m_cp=new w(0,0))}getBoundary(){return lm(this)}assignMove(e){return t(0),this}assignCopy(t){return this!==t&&t.copyTo(this),this}construct(t,e,s){this.setStartXY(t),this.m_cp.assign(e),this.setEndXY(s),Pr(this)}constructPoints(t){this.setStartXY(t[0]),this.m_cp.assign(t[1]),this.setEndXY(t[2]),Pr(this)}getGeometryType(){return s.enumBezier2}queryEnvelope(e){if(e instanceof ge){if(e.setCoords(this.getStartXY()),e.mergeNe(this.getEndXY()),e.contains(this.m_cp))return;const t=qr(this);if(null!==t){const s=new w;for(const i of t.specialPoints)this.queryCoord2D(i,s),e.mergeNe(s)}else{const t=[];Cr(this,t);const s=new w;for(const i of t)this.queryCoord2D(i,s),e.mergeNe(s)}}else t(0)}applyTransformation(e){if(e instanceof Y){const t=D(w,3);return this.queryControlPoints(t),e.transformPoints2D(t,3,t),this.setStartXY(t[0]),this.m_cp.assign(t[1]),this.setEndXY(t[2]),void this.afterCompletedModification()}t(0)}createInstance(){return new Ln({vd:this.m_description})}calculateLength2D(){return Sr(this,1,!1)}calculateLowerLength2D(){return w.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return w.distance(this.getStartXY(),this.m_cp)+w.distance(this.getEndXY(),this.m_cp)}queryCoord2D(t,e){this.queryCoord2DExtended(t,e,!1)}queryCoord2DExtended(t,e,s){const i=D(w,3);this.queryControlPoints(i),no(i,t,e,s)}queryCoord2DE(t,e){ro()}getCoordX(t){if(t<0||t>1){const e=new w;return this.queryCoord2DExtended(t,e,!0),e.x}if(t<=.5){const e=nt(this.getStartX(),this.m_cp.x,t),s=nt(this.m_cp.x,this.getEndX(),t);return nt(e,s,t)}{const e=rt(this.getStartX(),this.m_cp.x,t),s=rt(this.m_cp.x,this.getEndX(),t);return rt(e,s,t)}}getCoordY(t){if(t<0||t>1){const e=new w;return this.queryCoord2DExtended(t,e,!0),e.y}if(t<=.5){const e=nt(this.getStartX(),this.m_cp.x,t),s=nt(this.m_cp.x,this.getEndX(),t);return nt(e,s,t)}{const e=rt(this.getStartY(),this.m_cp.y,t),s=rt(this.m_cp.y,this.getEndY(),t);return rt(e,s,t)}}cut(t,e,s){const i=new SE;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createQuadraticBezier();if(this.cutBezierIgnoreAttributes(t,e,n),i)return;n.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),i=Bn.getComponentCount(s);for(let e=0;e<i;e++){const i=this.getAttributeAsDbl(t,s,e);n.setStartAttribute(s,e,i)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),i=Bn.getComponentCount(s);for(let t=0;t<i;t++){const i=this.getAttributeAsDbl(e,s,t);n.setEndAttribute(s,t,i)}}}}queryDerivative(t,e){oo()}cutBezierIgnoreAttributes(t,s,i){if((t<0||s>1||t>s)&&e("Quadratic_bezier.cut_bezier_ignore_attributes"),0===t&&1===s)return i.setStartXY(this.getStartXY()),i.m_cp.assign(this.m_cp),void i.setEndXY(this.getEndXY());const n=D(w,3);this.queryControlPoints(n),zr(n,t,s,n),i.constructPoints(n)}splitBezierIgnoreAttributes(e,s,i){t(0)}getAttributeAsDbl(e,s,i){return t(0),0}getClosestCoordinate(t,e){return Mr(this,t,A.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return Mr(this,t,e,!1)}getYMonotonicParts(e,s){return t(0),0}getMonotonicParts(s,i){s.length<2&&e("");const n=Er(this);let r=0;if(2===n.specialPointsCount())return 0;t(s.length>=n.specialPointsCount()-1);for(let t=1,e=n.specialPointsCount();t<e;++t)this.queryCut(n.specialPoints[t-1],n.specialPoints[t],s[r],i),r++;for(let t=0;t<r;++t){Rr(s[t].get())}return r}intersectionWithAxis2D(t,e,s,i){const n=D(ot,3),r=D(ot,2),o=new A(0,1);let a=0;if(t){if(n[0]=new ot(this.getStartY()).sub(e),n[1]=new ot(this.m_cp.y).subE(new ot(this.getStartY())).mulThisByPower2(2),n[2]=new ot(this.getStartY()).add(this.getEndY()).subE(new ot(this.m_cp.y).mulThisByPower2(2)),a=Nn(n[2],n[1],n[0],o,!1,r),s)for(let h=0;h<a;h++)s[h]=this.getCoordX(r[h].value())}else if(n[0]=new ot(this.getStartX()).sub(e),n[1]=new ot(this.m_cp.x).subE(new ot(this.getStartX())).mulThisByPower2(2),n[2]=new ot(this.getStartX()).add(this.getEndX()).subE(new ot(this.m_cp.x).mulThisByPower2(2)),a=Nn(n[2],n[1],n[0],o,!1,r),s)for(let h=0;h<a;h++)s[h]=this.getCoordY(r[h].value());if(i)for(let h=0;h<a;h++)i[h]=r[h].value();else s&&at(s,a);return a}intersectionOfYMonotonicWithAxisX(e,s){if(this.m_YStart===this.m_YEnd)return e===this.m_YStart?s:Number.NaN;if(e===this.m_YStart)return this.m_XStart;if(e===this.m_YEnd)return this.m_XEnd;const i=[0,0],n=this.intersectionWithAxis2D(!0,e,i,null);return t(2!==n),-1===n?s:i[0]}isCurve(){return!0}isLine(){return!1}isDegenerate(t){return Pi(this,t)}isDegenerate3D(e,s){return t(0),!1}queryLooseEnvelope(e){t(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=new ge;this.queryEnvelope(t);const s=new A;return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=D(w,4);this.queryControlPoints(s),zr(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),i=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):i&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return Sr(this,t,!0)}lengthToT(t){return Dr(this,t)}calculateWeightedAreaCentroid2D(t){const e=D(w,3);to(this,e);const s=e[2],i=e[1],n=new w,r=s.y*i.x-s.x*i.y;n.x=-(4*s.x+5*i.x)*r/60,n.y=-(4*s.y+5*i.y)*r/60;const o=Tr(this);return n.x+=(e[0].x-t.x)*o,n.y+=(e[0].y-t.y)*o,n}calculateWeightedCentroid2D(){const t=new w;return this.isDegenerate(0)?(t.setCoords(0,0),t):Ar(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(Lr(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}setControlPoints(e){t(0)}getTangent(e){return t(0),w.getNAN()}getDerivative(e){return t(0),w.getNAN()}getCurvature(e){return t(0),0}isIntersecting(e,s,i){return t(0),!1}isIntersectingPoint(e,s,i){return t(0),!1}isIntersectingPoint3D(e,s,i,n,r=1){return t(0),!1}queryAttributeAsDbl(e,s,i,n){t(0)}isMonotoneQuickAndDirty(){return!1}getMonotonicPartParams(e,s){return t(0),0}normalizeAfterEndpointChange(){return!1}orientBottomUp(){t(0)}isDegenerateToLineHelper(t){const e=[t];if(!Ei(this,e))return!1;const s=this.getEndXY().sub(this.getStartXY()),i=s.length(),n=this.getControlPoint1();n.sub(this.getStartXY());return!(Math.abs(n.crossProduct(s))/i>e[0])}copyIgnoreAttributes(e){t(0)}calculateArea2DHelper(){return Tr(this)}absNorm(){return Or(this)}queryEnvelopeW(t,e){const s=D(w,3);this.queryControlPoints(s),Xr(s,t,e)}setSegmentFromCoords(e,s){t(0)}snapControlPoints(e){return t(0),!1}writeInBufferStream(t,e){const s=new Float64Array(2);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(2);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_cachedValues=null}needsSnapControlPoints(e){return t(0),!1}calculateSpecialPointsForCracking(e,s){return t(0),0}ensureXYMonotone(){return t(0),!1}setCoordsForIntersector(t,e,s){Ur(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),Fr(e,qr(this))}reverseImpl(){}equalsImplTol(e,s){return t(0),!1}equalsImpl(t){const e=t;return!!this.m_cp.equals(e.m_cp)}getHashCodeImpl(){return t(0),0}swapImpl(e){t(0)}afterCompletedModification(){Pr(this)}intersect(t,e,s,i,n){return dE(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){return Vr(this,t,e.length,e,s)}intersect_(e,s,i,n){return t(0),0}endPointModified(){Pr(this)}clearEndPointModified(){t(0)}}Ln.type=s.enumBezier2;class Hn{constructor(e){return e.coefsT?(this.m_zeroCtor=e.zeroCtor,this.m_elements=e.coefsT.map((t=>t.clone())),t(this.m_elements.length===e.power+1),void this.updatePower()):e.coef0?(this.m_zeroCtor=e.zeroCtor,void(this.m_elements=[e.coef0.clone()])):e.copy?(this.m_zeroCtor=e.copy.m_zeroCtor,void(this.m_elements=e.copy.m_elements.map((t=>t.clone())))):(this.m_zeroCtor=e.zeroCtor,void(this.m_elements=[new this.m_zeroCtor]))}construct(t,e){return this.m_elements=t.map((t=>t.clone())),this.updatePower(),this}construct0(t){return this.m_elements.length=0,this.m_elements.push(t.clone()),this.updatePower(),this}assignCopy(t){return this.m_elements=t.m_elements.map((t=>t.clone())),this.updatePower(),this}assignMove(t){return this.m_elements=t.m_elements,t.m_elements=[],this.updatePower(),this}power(){return this.m_elements.length-1}addElement(t){this.m_elements.push(t.clone())}fmSubThis(e,s){return t(0),this}addThis(t){const e=Math.min(this.power(),t.power());for(let i=0;i<=e;++i)this.m_elements[i].addThis(t.m_elements[i]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let i=e+1;i<=s;++i)this.m_elements[i]=t.m_elements[i];return this.updatePower(),this}add0(t){return this.m_elements[0].addThis(t),this.updatePower(),this}addNumber0(e){return t(0),this}sub(t){const e=Math.min(this.power(),t.power());for(let i=0;i<=e;++i)this.m_elements[i].subThis(t.m_elements[i]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let i=e+1;i<=s;++i)this.m_elements[i]=t.m_elements[i].clone(),this.m_elements[i].negateThis();return this.updatePower(),this}sub0(e){return t(0),this}subNumber0(e){return t(0),this}subShifted(t,e){const s=this.power(),i=t.power()+e,n=Math.min(this.power(),i);let r=0;for(let o=e;o<=n;++o)this.m_elements[o].subThis(t.m_elements[r]),r++;if(i<=s)return this.updatePower(),this;this.m_elements.length=i+1;for(let o=s+1;o<this.m_elements.length;++o)this.m_elements[o]=new this.m_zeroCtor;for(let o=n+1;o<=i;++o)this.m_elements[o].subThis(t.m_elements[r++]);return this.updatePower(),this}subShiftedWithCoef(t,e,s){const i=this.power(),n=t.power()+s,r=Math.min(this.power(),n);let o=0;for(let a=s;a<=r;++a)this.m_elements[a].fmSubThis(t.m_elements[o],e),o++;if(n<=i)return this.updatePower(),this;this.m_elements.length=n+1;for(let a=i+1;a<this.m_elements.length;++a)this.m_elements[a]=new this.m_zeroCtor;for(let a=r+1;a<=n;++a)this.m_elements[a].fmSubThis(t.m_elements[o++],e);return this.updatePower(),this}mulThis(t){if(this.constructor===t.constructor){const e=t,s=[];for(let t=0,i=this.power();t<=i;t++)for(let n=0,r=e.power();n<=r;n++){const i=this.m_elements[t].clone();i.mulThis(e.m_elements[n]),t+n<s.length?s[t+n].addThis(i):s.push(i)}this.m_elements=s}else for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulElementThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulNumber0(e){return t(0),this}mulBigint0(e){return t(0),this}mulBigIntThis(e){return t(0),this}mulInt320(e){return t(0),this}div0(e){return t(0),this}absThis(){return t(0),this}div(t,e,s){if(this.power()<t.power())return s.assignCopy(this),void e.setZero();s.setZero(),e.setZero();const i=t.getElement(t.power()),n=this.clone();let r=n.power();const o=n.power()-t.power();let a=o;for(e.m_elements=D(e.m_zeroCtor,o+1);;){if(r<t.power()){s.assignMove(n);break}if(r===n.power()){const s=n.getElement(n.power());s.divThis(i),n.subShiftedWithCoef(t,s,n.power()-t.power()),e.m_elements[a]=s.clone()}a--,r--}s.updatePower(),e.updatePower()}divThis(e){return t(0),this}subThis(t){const e=Math.min(this.power(),t.power());for(let i=0;i<=e;++i)this.m_elements[i].subThis(t.m_elements[i]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let i=e+1;i<=s;++i)this.m_elements[i]=t.m_elements[i].clone(),this.m_elements[i].negateThis();return this.updatePower(),this}sub0This(t){return this.m_elements[0].subThis(t),this.updatePower(),this}subFrom(e,s){t(0)}isZero(){return 0===this.power()&&this.m_elements[0].isZero()}negateThis(){for(let t=this.m_elements.length-1;t>=0;t--)this.m_elements[t].negateThis();return this}getElement(t){return this.m_elements[t].clone()}setElement(t,e){return this.m_elements[t]=e.clone(),this}evaluate(t){const e=this.power(),s=this.m_elements[e].clone();for(let i=e-1;i>=0;--i)s.mulThis(t),s.addThis(this.m_elements[i]);return s}equals(t){if(this===t)return!0;if(this.power()!==t.power())return!1;for(let e=this.m_elements.length-1;e>=0;e--)if(!this.m_elements[e].equals(t.m_elements[e]))return!1;return!0}updatePower(){for(let t=this.m_elements.length-1;t>0&&this.m_elements[t].isZero();t--)this.m_elements.pop();return this}setZero(){return this.m_elements.length=1,this.m_elements[0]=new this.m_zeroCtor,this.updatePower(),this}derivative(t){if(this.power()<t)return this.clone().setZero();if(0===t)return this.clone();const e=new this.constructor({coefsT:this.m_elements.slice(t),power:this.power()-t});for(let s=t,i=this.power();s<=i;s++){let i=BigInt(s);for(let e=s-1,n=s-t;e>n;--e)i*=BigInt(e);e.m_elements[s-t].mulBigIntThis(i)}return e.updatePower(),e}derivative1This(){if(this.m_elements.length>1){this.m_elements=this.m_elements.slice(1);for(let t=1,e=this.power();t<=e;t++)this.m_elements[t].mulThis(At.constructInt32(t+1))}else this.m_elements.length=0,this.m_elements.push(new this.m_zeroCtor);return this}limitPrecisionThis(t){for(let e=this.power();e>=0;--e)this.m_elements[e].limitPrecisionThis(t);return this.updatePower(),this}hiBitIndex(){return this.m_elements.reduce(((t,e)=>{const s=e.hiBitIndex();return t<s?s:t}),0)}shiftRight(t){return this.m_elements.splice(0,t),this.updatePower(),this}static evaluateCoefs(t,e,s){const i=t.power();s.construct0(t.getElement(0).evaluate(e));for(let n=1;n<=i;++n)s.addElement(t.getElement(n).evaluate(e));s.updatePower()}}class zn extends Hn{constructor(t){super(void 0===t?{zeroCtor:At}:{...t,zeroCtor:At})}clone(){return new zn({copy:this})}absEvaluate(t){const e=this.power(),s=this.m_elements[e].clone();s.absThis();const i=t.clone();i.absThis();for(let n=e-1;n>=0;--n)s.mulThis(i),s.addThis(this.m_elements[n].abs());return s}}class Un extends Hn{constructor(t){super(void 0===t?{zeroCtor:zn}:{...t,zeroCtor:zn})}clone(){return new Un({copy:this})}constructFromMPValues(t,e){this.m_elements.length=0;for(let s=0;s<=e;++s)this.m_elements.push(new zn({coef0:t[s]}));return this.updatePower(),this}}function On(){return{polypoly1:new Un,polypoly2:new Un,polyX2:new zn,polyY2:new zn,polyX2Deriv:new zn,polyY2Deriv:new zn,polypolyX1:new Un,polypolyY1:new Un,polypolyX1Deriv:new Un,polypolyY1Deriv:new Un,lazyPolypolyD1:new Un,lazyPolypolyD1Deriv:new Un,lazyPolyD2:new zn,lazyPolyD2Deriv:null,polypoly11:new Un,polypoly12:new Un,tempPp:new Un,tempPp1:new Un,tempPp2:new Un,tempP:new zn,tempP1:new zn,tempP2:new zn}}function Wn(e,s,i,n,r,o,a,h,l,u,c,g,_,d,p,f,x,y=!1){const P=On();P.polyX2.construct(a,h),P.polyY2.construct(l,u),P.polypolyX1.constructFromMPValues(e,s),P.polypolyY1.constructFromMPValues(i,n),P.polypoly11.assignCopy(P.polypolyX1),P.polypoly12.assignCopy(P.polypolyY1),c&&(P.lazyPolyD2.construct(c,g),P.polypoly11.mulElementThis(P.lazyPolyD2),P.polypoly12.mulElementThis(P.lazyPolyD2)),r?(P.lazyPolypolyD1.constructFromMPValues(r,o),P.lazyPolypolyD1Deriv=new Un({copy:P.lazyPolypolyD1}),P.lazyPolypolyD1Deriv.derivative1This(),P.tempPp.assignCopy(P.lazyPolypolyD1),P.tempPp.mulElementThis(P.polyX2),P.polypoly11.subThis(P.tempPp),P.tempPp.assignCopy(P.lazyPolypolyD1),P.tempPp.mulElementThis(P.polyY2),P.polypoly12.subThis(P.tempPp)):(P.polypoly11.sub0This(P.polyX2),P.polypoly12.sub0This(P.polyY2)),P.polypolyX1Deriv.assignCopy(P.polypolyX1),P.polypolyX1Deriv.derivative1This(),P.polypolyY1Deriv.assignCopy(P.polypolyY1),P.polypolyY1Deriv.derivative1This(),r&&(P.polypolyX1Deriv.mulThis(P.lazyPolypolyD1),P.tempPp2.assignCopy(P.lazyPolypolyD1Deriv),P.tempPp2.mulThis(P.polypolyX1),P.polypolyX1Deriv.subThis(P.tempPp2),P.polypolyY1Deriv.mulThis(P.lazyPolypolyD1),P.tempPp2.assignCopy(P.lazyPolypolyD1Deriv),P.tempPp2.mulThis(P.polypolyY1),P.polypolyY1Deriv.subThis(P.tempPp2)),P.polyX2Deriv.assignCopy(P.polyX2),P.polyX2Deriv.derivative1This(),P.polyY2Deriv.assignCopy(P.polyY2),P.polyY2Deriv.derivative1This(),c&&(t(null===P.lazyPolyD2Deriv),P.lazyPolyD2Deriv=new zn({copy:P.lazyPolyD2}),P.lazyPolyD2Deriv.derivative1This(),P.polyX2Deriv.mulThis(P.lazyPolyD2),P.tempP1.assignCopy(P.lazyPolyD2Deriv),P.tempP1.mulThis(P.polyX2),P.polyX2Deriv.subThis(P.tempP1),P.polyY2Deriv.mulThis(P.lazyPolyD2),P.tempP1.assignCopy(P.lazyPolyD2Deriv),P.tempP1.mulThis(P.polyY2),P.polyY2Deriv.subThis(P.tempP1)),P.polypoly1.assignCopy(P.polypoly11),P.polypoly1.mulElementThis(P.polyX2Deriv),P.tempPp.assignCopy(P.polypoly12),P.tempPp.mulElementThis(P.polyY2Deriv),P.polypoly1.addThis(P.tempPp),P.polypoly2.assignCopy(P.polypolyX1Deriv),P.polypoly2.mulElementThis(P.polyY2Deriv),P.tempPp.assignCopy(P.polypolyY1Deriv),P.tempPp.mulElementThis(P.polyX2Deriv),P.polypoly2.subThis(P.tempPp);let E=[];const C=[];x||(x=[]),f||(f=[]),ir(P.polypoly11,P.polypoly12,P.tempP);let S=57,v=.25*Number.EPSILON;const b=[];let I=nr(P.tempP,_,p,v,S,b);if(I<0)return-1;for(let t=0;t<I;t++){zn.evaluateCoefs(P.polypoly11,At.constructDouble(b[t]),P.tempP1);const e=[];let s=nr(P.tempP1,_,d,v,S,e);if(0!==s)if(zn.evaluateCoefs(P.polypoly12,At.constructDouble(b[t]),P.tempP2),s<0){s=nr(P.tempP2,_,d,v,S,e),s<0&&m("mp_curve_proximity");for(let i=0;i<s;i++)C.push(j(e[i],b[t]))}else{const i=P.tempP2.absEvaluate(Zt);i.mulThis(At.constructDouble(1e-12));for(let n=0;n<s;n++){const s=P.tempP2.evaluate(At.constructDouble(e[n]));s.absThis(),s.lt(i)&&C.push(j(e[n],b[t]))}}}I=C.length,ir(P.polypoly1,P.polypoly2,P.tempP),S=57,v=.25*Number.EPSILON;const w=[];let D=nr(P.tempP,_,p,v,S,w);D<0&&(D=0);for(let t=0;t<D;t++){zn.evaluateCoefs(P.polypoly1,At.constructDouble(w[t]),P.tempP1);const e=[];let s=nr(P.tempP1,_,d,v,S,e);if(0!==s)if(zn.evaluateCoefs(P.polypoly2,At.constructDouble(w[t]),P.tempP2),s<0){if(s=nr(P.tempP2,_,d,v,S,e),s<0)continue;for(let i=0;i<s;i++)E.push(j(e[i],w[t]))}else{const i=P.tempP2.absEvaluate(Zt);i.mulThis(At.constructDouble(1e-12));for(let n=0;n<s;n++){const s=P.tempP2.evaluate(At.constructDouble(e[n]));s.absThis(),s.lt(i)&&E.push(j(e[n],w[t]))}}}if(D=E.length,0===I&&0===D)return 0;E=E.concat(C),E.sort(((t,e)=>y?Ft(t.second,e.second):Ft(t.first,e.first)));const T=Qt(E,((t,e)=>t.first===e.first&&t.second===e.second));E=E.slice(0,T),f.length=0,x.length=0;for(const t of E)f.push(t.first),x.push(t.second);return t(f.length===x.length),x.length}function jn(t,e,s,i,n,r,o){if(0===t.power())return t.isZero()?-1:0;const a=t.evaluate(At.constructInt32(1)).isZero();if(1===t.power()){const s=Kn(t.getElement(1),t.getElement(0),e,r.at(0));return r[0].limitPrecisionThis(i),1!==s?0:(r[0].limitPrecisionThis(i),1)}if(2===t.power()){return Jn(t.getElement(2),t.getElement(1),t.getElement(0),i,e,a,r)}if(3===t.power()){return $n(t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),i,e,a,r)}if(4===t.power()){return tr(t.getElement(4),t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),i,e,a,r)}return mr(t,e,s,i,a,n,r,o)}function Zn(){return{polyIntersect:new zn,polyX1:new zn,polyY1:new zn,polyX1Deriv:new zn,polyY1Deriv:new zn,lazyPolyD1:new zn,lazyPolyD1Deriv:new zn,tempP:new zn,tempP1:new zn,tempP2:new zn,polypoly1Proximity:new Un,polypoly2Proximity:new Un}}function Qn(t,e,s,i,n,r,o,a,h,m,l){const u=Zn();u.polyX1.construct(t,e),u.polyY1.construct(s,i),u.polyX1Deriv.assignCopy(u.polyX1),u.polyX1Deriv.derivative1This(),u.polyY1Deriv.assignCopy(u.polyY1),u.polyY1Deriv.derivative1This(),u.polyIntersect.assignCopy(u.polyX1),u.polyIntersect.mulThis(u.polyX1),u.polyIntersect.mulElementThis(o[0]),u.tempP.assignCopy(u.polyY1),u.tempP.mulThis(u.polyY1),u.tempP.mulElementThis(o[1]),u.polyIntersect.addThis(u.tempP),u.polyIntersect.add0(o[2]);{const n=o[0].clone(),r=n.clone();r.sqrThis();const a=o[1].clone(),h=a.clone();h.sqrThis();const m=o[2].clone(),l=n.clone();l.subThis(a),u.polyX1.construct(t,e),u.polyX1Deriv.assignCopy(u.polyX1),u.polyX1Deriv.derivative1This(),u.polyY1.construct(s,i),u.polyY1Deriv.assignCopy(u.polyY1),u.polyY1Deriv.derivative1This(),u.tempP.assignCopy(u.polyX1),u.tempP.mulThis(u.polyX1),u.tempP.mulElementThis(h),u.tempP.mulElementThis(m),u.polypoly1Proximity.construct0(u.tempP),u.tempP.assignCopy(u.polyX1),u.tempP.mulThis(a.mul(l).mul(m).ldexpThis(1)),u.polypoly1Proximity.addElement(u.tempP),u.tempP.assignCopy(u.polyX1),u.tempP.mulThis(u.polyX1),u.tempP.mulElementThis(n.mul(h)),u.tempP1.assignCopy(u.polyY1),u.tempP1.mulThis(u.polyY1),u.tempP1.mulElementThis(r.mul(a)),u.tempP.addThis(u.tempP1),u.tempP.add0(l.mul(l).mul(m)),u.polypoly1Proximity.addElement(u.tempP),u.tempP.assignCopy(u.polyX1),u.tempP.mulElementThis(l.mul(n).mul(a).ldexpThis(1)),u.polypoly1Proximity.addElement(u.tempP),u.tempP.construct0(n.mul(l).mul(l)),u.polypoly1Proximity.addElement(u.tempP),u.polypoly1Proximity.updatePower(),u.tempP.construct0(qt),u.polypoly2Proximity.construct0(u.tempP),u.tempP.assignCopy(u.polyX1),u.tempP.mulThis(u.polyX1Deriv),u.tempP1.assignCopy(u.polyY1),u.tempP1.mulThis(u.polyY1Deriv),u.tempP.addThis(u.tempP1),u.tempP.mulElementThis(n.mul(a)),u.polypoly2Proximity.addElement(u.tempP),u.tempP.assignCopy(u.polyX1Deriv),u.tempP.mulElementThis(l.mul(n)),u.polypoly2Proximity.addElement(u.tempP),u.polypoly2Proximity.updatePower()}const c=[],g=[];l||(l=[]);let _=2*u.polyIntersect.power()+58;const d=.5*Number.EPSILON,p=nr(u.polyIntersect,a,h,d,_,g);if(p<0)return-1;ir(u.polypoly1Proximity,u.polypoly2Proximity,u.tempP),_=2*u.tempP.power()+58;let f=nr(u.tempP,a,h,d,_,c);if(f<0&&(f=0),0===p&&0===f)return 0;const x=c.concat(g);l.length=x.length,X(l,x,0,0,x.length),J(l);const y=Qt(l,((t,e)=>0===Ft(t,e)));return l.length=y,l.length}function Kn(t,e,s,i){return t.isZero()?e.isZero()?-1:0:(i.setThis(e),i.negateThis(),i.divThis(t),s.isEmpty()||s.containsCoordinate(i.value())?1:0)}function Jn(t,e,s,i,n,r,o){if(t.isZero()){if(r)return o[0].setInt32(1),n.containsCoordinate(1)?1:0;return Kn(e,s,n,o[0])}if(r){let e=2;return o[0].setInt32(1),s.equals(t)?(o[1].setInt32(1),e=1):o[1].setThis(s.div(t)),n.containsCoordinate(o[1].value())||(e=1),n.containsCoordinate(o[0].value())||(e--,o[0].setThis(o[1])),2===e&&o[0].value()>o[1].value()&&(o[1]=q(o[0],o[0]=o[1])),e}const a=e.clone();a.sqrThis();const h=t.clone();if(h.mulThis(s).ldexpThis(2).negateThis().addThis(a),h.LZ())return 0;const m=i+2,l=At.sqrt(h,m),u=l.clone();e.LZ()&&u.negateThis(),u.addThis(e).limitPrecisionThis(m).ldexpThis(-1).negateThis();let c=0;return o[0].setThis(u).divThis(At.constructAssign(t,m)).limitPrecisionThis(i),(n.isEmpty()||n.containsCoordinate(o[0].value()))&&c++,l.isZero()||u.isZero()||(o[c].setThis(s).divThis(u).limitPrecisionThis(i),(n.isEmpty()||n.containsCoordinate(o[c].value()))&&c++,2===c&&o[0].gt(o[1])&&(o[1]=q(o[0],o[0]=o[1]))),c}function $n(e,s,i,n,r,o,a,h){if(e.isZero()){return Jn(s,i,n,r,o,a,h)}const m=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)h[t].equals(h[0])&&(h[s-1]=q(h[t],h[t]=h[s-1]),s--);e=s}return z(h,0,e,((t,e)=>t.compare(e))),e};if(n.isZero()){let t=0;o.containsCoordinate(0)&&(h[0].setInt32(0),t=1);return m(Jn(e,s,i,r,o,a,h.slice(1)),t)}if(a){let t=0;o.containsCoordinate(1)&&(h[0].setInt32(1),t=1);const i=s.add(e),a=n.negate(),l=e.add(i).add(a).isZero();return m(Jn(e,i,a,r,o,l,h.slice(t)),t)}const l=new At,u=new At,c=new At,g=s.clone();if(g.isZero())u.setThis(i),u.divThis(e),c.setThis(n),u.divThis(e);else{g.divThis(e).divDoubleThis(3).negateThis();const t=s.clone();t.sqrThis();const r=e.clone();r.sqrThis(),u.setThis(e),u.mulThis(i).mulDoubleThis(3).subThis(t).divThis(r).divDoubleThis(3),c.setThis(t),c.mulThis(s),c.ldexpThis(1),l.setThis(e),l.mulThis(s).mulThis(i).mulDoubleThis(9),c.subThis(l),l.setThis(r),l.mulThis(n).mulDoubleThis(27),c.addThis(l),c.divThis(r).divThis(e).divDoubleThis(27)}if(u.isZero()){const t=c.clone();return t.negateThis(),t.isZero()?(h[0].setThis(g),ur(o,r,h,1)):(h[0].setThis(At.cubicRoot(c,r).add(g)),ur(o,r,h,1))}const _=c.clone();if(_.sqrThis().ldexpThis(-2),l.setThis(u.clone()),l.sqrThis().mulThis(u).divDoubleThis(27),_.addThis(l),_.isZero())return h[0].setThis(c),h[0].mulDoubleThis(3).divThis(u),h[1].setThis(h[0]),h[1].negateThis(),h[1].ldexpThis(-1),h[0].addThis(g),h[1].addThis(g),ur(o,r,h,2);if(_.GZ())return _.setThis(At.sqrt(_,r+8)),l.setThis(c),l.ldexpThis(-1).negateThis(),l.addThis(_),h[0].setThis(At.cubicRoot(l,r+8)),l.setThis(c),l.ldexpThis(-1).negateThis(),l.subThis(_),h[0].addThis(At.cubicRoot(l,r+8)),h[0].addThis(g),ur(o,r,h,1);l.setThis(u),l.divDoubleThis(3).negateThis(),t(l.GEZ());const d=At.sqrt(l,r+8),p=d.clone();p.negateThis(),p.addThis(g),d.addThis(g);const f=At.constructDouble(o.isEmpty()?-Number.MAX_VALUE:o.vmin),x=At.constructDouble(o.isEmpty()?Number.MAX_VALUE:o.vmax),y=new zn({zeroCtor:At});y.construct0(n),y.addElement(i),y.addElement(s),y.addElement(e);const P=new zn({copy:y});P.derivative1This();let E=0;const C=D(At,4);C[E++].setThis(f),p.gt(f)&&p.lt(x)&&C[E++].setThis(p),d.gt(f)&&d.lt(x)&&C[E++].setThis(d),C[E++].setThis(x);const S=3*r;let v=52,b=Number.EPSILON;for(;v<S;)2*v<=S?(b*=b,v*=2):(b*=Number.EPSILON,v+=52);v+=2;let I=0,w=!1;for(let t=1;t<E;t++){if(ar(y,P,C[t-1],C[t],b,v,h[0])){I=1,w=t+1<E;break}}if(!I)return 0;if(w){const e=new zn({zeroCtor:At,coef0:h[0]});e.negateThis(),e.addElement(Zt);const s=new zn({zeroCtor:At}),i=new zn({zeroCtor:At});y.div(e,s,i),t(2===s.power()),t(0===i.power());const n=Jn(s.getElement(2),s.getElement(1),s.getElement(0),r,o,!1,h.slice(1));t(n>=0&&n<=2),I+=n}return ur(o,r,h,I)}function tr(t,e,s,i,n,r,o,a,h){if(t.isZero())return $n(e,s,i,n,r,o,a,h);const m=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)h[t].equals(h[0])&&(h[s-1]=q(h[t],h[t]=h[s-1]),s--);e=s}return z(h,0,e,((t,e)=>t.compare(e))),e};if(n.isZero()){let n=0;o.containsCoordinate(0)&&(h[0].setInt32(0),n=1);return m($n(t,e,s,i,r,o,a,h.slice(n)),n)}const l=new zn({zeroCtor:At,coef0:n});if(l.addElement(i),l.addElement(s),l.addElement(e),l.addElement(t),a){let t=0;o.containsCoordinate(1)&&(h[0].setInt32(1),t=1);const e=new zn({zeroCtor:At,coef0:At.constructInt32(-1)});e.addElement(At.constructInt32(1));const s=new zn({zeroCtor:At}),i=new zn({zeroCtor:At});l.div(e,s,i);return m($n(3===s.power()?s.getElement(3):qt.clone(),s.power()>=2?s.getElement(2):qt.clone(),s.power()>=1?s.getElement(1):qt.clone(),s.getElement(0),r,o,s.evaluate(Zt).isZero(),h.slice(t)),t)}if(l.getElement(0).isZero()){let t=0;for(o.containsCoordinate(0)&&(t=1,h[0].setDouble(0));l.getElement(0).isZero()&&l.power()>0;)l.shiftRight(1);const e=$n(3===l.power()?l.getElement(3):qt.clone(),l.power()>=2?l.getElement(2):qt.clone(),l.power()>=1?l.getElement(1):qt.clone(),l.getElement(0),r,o,!1,h.slice(t));return e>0&&(t+=e),z(h,0,t,((t,e)=>t.compare(e))),t}let u=52,c=Number.EPSILON;for(;u<r;)2*u<=r?(c*=c,u*=2):(c*=Number.EPSILON,u+=52);u+=2;const g=lr(l),_=At.constructDouble(Math.max(Math.abs(o.vmax),Math.abs(o.vmin)));return c=(g.lt(_)?g:_).mul(At.constructDouble(c)).toDouble(),mr(l,o,c,u,a,!1,h,4)}function er(t,e){let s=t,i=e;i.power()>s.power()&&(i=q(s,s=i));const n=s.power()-i.power(),r=new zn({copy:s.getElement(s.power())});s.mulThis(i.getElement(i.power()));for(let o=0,a=s.power();o<a;o++)if(o>=n){const t=new zn({copy:i.getElement(o-n)});t.mulThis(r);const e=s.getElement(o).sub(t);s.setElement(o,e)}s.setElement(s.power(),s.getElement(s.power()).setZero()),s.updatePower(),sr(s)}function sr(t){let e=0;for(;e<t.power()&&t.getElement(e).isZero();)e++;return e>0&&(t.shiftRight(e),!0)}function ir(t,e,s){const i=t.clone(),n=e.clone();for(sr(i),sr(n);0!==i.power()||0!==n.power();)er(i,n);s.assignMove(i.getElement(0))}function nr(t,e,s,i,n,r){r.length=0;const o=t.power(),a=D(At,2*o+4),h=jn(t,s||A.unit(),i,n,!1,a,a.length);if(h>0){r.length=0;for(let t=0;t<h;t++){const e=a[t].value();t>0&&e<=r.at(-1)||r.push(e)}return r.length}return h}function rr(e,s,i){if(t(i>=1),0===e.power())return e.isZero()?-1:0;const n=e.getElement(0);return n.negateThis(),n.divThis(e.getElement(1)),s[0].setThis(n),1}function or(e,s,i,n){if(e.power()<2)return rr(e,i,n);t(n>=1);let r=e.getElement(1);r.mulThis(e.getElement(1));const o=e.getElement(0);if(o.mulThis(e.getElement(2)),o.ldexpThis(2),r.subThis(o),r.LZ())return 0;if(r.isZero()){const t=e.getElement(1);return t.negateThis(),t.divThis(e.getElement(2)),t.ldexpThis(-1),t.limitPrecisionThis(s),i[0].setThis(t),1}t(n>=2),r=At.sqrt(r,s+8);const a=e.getElement(1);a.negateThis();const h=a.clone();h.subThis(r),h.divThis(e.getElement(2)),h.ldexpThis(-1),h.limitPrecisionThis(s);const m=a.clone();return m.addThis(r),m.divThis(e.getElement(2)),m.ldexpThis(-1),m.limitPrecisionThis(s),h.lt(m)?(i[0].setThis(h),i[1].setThis(m)):(i[1].setThis(h),i[0].setThis(m)),2}function ar(t,e,s,i,n,r,o){let a=s.clone(),h=i.clone();a.limitPrecisionThis(r),h.limitPrecisionThis(r);let l=t.evaluate(a);l.limitPrecisionThis(r+2);let u=t.evaluate(h);if(u.limitPrecisionThis(r+2),l.GEZ()&&u.GEZ()||l.LEZ()&&u.LEZ())return l.absLessAbs(u)?(o=a,l.isZero()):(o=h,u.isZero());const c=u.LZ();c&&(u=q(l,l=u),h=q(a,a=h));const g=c?h:a,_=c?a:h,d=a.add(h).ldexpThis(-1);d.limitPrecisionThis(r);const p=h.sub(a);p.limitPrecisionThis(r),p.absThis();const f=p.clone();let x=t.evaluate(d),y=e.evaluate(d);const P=new zn({copy:t}),E=new zn({copy:e});{const s=Math.max(t.hiBitIndex(),e.hiBitIndex()),i=Zt.clone();i.ldexpThis(-(r+2));for(let n=64;n<s;){P.limitPrecisionThis(n),E.limitPrecisionThis(n);const r=P.evaluate(d),o=E.evaluate(d),a=r.sub(x),h=o.sub(y);if(a.divThis(x).absThis().lt(i)&&(y.isZero()||h.divThis(y).absThis().lt(i)))break;P.assignCopy(t),E.assignCopy(e),n=Math.min(n+64,s)}x.limitPrecisionThis(r+2),y.limitPrecisionThis(r+2)}const C=1,S=4;let v=S;const b=2;let I=1,w=0,D=0,T=C;const N=32,A=At.constructDouble(.25*n),F=At.constructDouble(.5001);let M=0;const G=300;for(;++M<G;){if(M>N&&w>0||y.isZero()||T===b&&w>1||T===C&&v<S)T=C,I>1&&I--;else if(T=b,D>1){const t=p.mul(y);t.absThis(),t.ldexpThis(-3),t.absLessAbs(x)&&I++}p.setThis(f);const t=new At;let e=!1;if(T===C)do{if(D>2){const e=p.clone();if(e.absThis(),e.ldexpThis(4),_.sub(g).ldexpThis(-1).gt(e)){if(d.equals(g)){t.setThis(d),d.setThis(g.add(e)),d.limitPrecisionThis(r),f.setThis(d.sub(t));break}if(d.equals(_)){t.setThis(d),d.setThis(_.sub(e)),d.limitPrecisionThis(r),f.setThis(d.sub(t));break}}}f.setThis(h.sub(a)),f.ldexpThis(-1),f.limitPrecisionThis(r),t.setThis(d),d.setThis(a.add(f)),d.limitPrecisionThis(r),d.lt(g)?d.setThis(g):d.gt(_)&&d.setThis(_),e=a.equals(d)||h.equals(d)}while(0);else for(;;){if(f.setThis(x.div(y)),f.limitPrecisionThis(r),1!==I&&f.mulDoubleThis(I),t.setThis(d),d.subThis(f),d.limitPrecisionThis(r),e=d.equals(t),d.lt(g)){if(I>1){d.setThis(t),I--;continue}f.setThis(t.sub(g)),d.setThis(g)}else if(d.gt(_)){if(I>1){d.setThis(t),I--;continue}f.setThis(t.sub(_)),d.setThis(_)}break}if(e||f.absLessAbs(A)){t.equals(d)||(x=P.evaluate(d),x.limitPrecisionThis(r+2));break}x=P.evaluate(d),x.limitPrecisionThis(r+2),y=E.evaluate(d),y.limitPrecisionThis(r+2);const s=a.clone(),i=h.clone();x.LZ()?(l.setThis(x),a.setThis(d)):(u.setThis(x),h.setThis(d)),T===b&&(a.equals(s)&&h.equals(i)||D>1&&!f.absLessAbs(F.mul(p)))?w++:w=0,T===C?(v++,D=0):(v=0,D++)}return M>=G&&m("Root_finder iterations exceeded"),o.setThis(d),!0}function hr(t,e,s,i,n){const r=t.evaluate(s);if(r.isZero())return!0;const o=At.constructDouble(.5*i),a=s.clone();a.subThis(o);const h=t.evaluate(a),m=s.clone();m.addThis(o);const l=t.evaluate(m);if(h.LZ()&&l.GZ()||h.GZ()&&l.LZ())return!0;if(r.GZ()?h.LEZ()||l.LEZ():h.GEZ()||l.GEZ())return!0;const u=h.LEZ()&&l.LEZ(),c=h.GEZ()&&l.GEZ();let g=!1;return u?r.gt(h)&&r.gt(l)&&(g=!0):c&&r.lt(h)&&r.lt(l)&&(g=!0),!!g&&r.absThis().lt(At.constructDouble(1e-17))}function mr(e,s,i,n,r,o,a,h){t(i>0),t(h>=e.power());const m=a,l=[];let u=[];const c=new zn({zeroCtor:e.m_zeroCtor}),g=new zn({zeroCtor:e.m_zeroCtor}),_=new zn({zeroCtor:e.m_zeroCtor}),d=At.constructDouble(i),p=At.constructDouble(s.vmin),f=At.constructDouble(s.vmax),x=p.sub(d),y=f.add(d),P=lr(e),E=P.clone();if(E.negateThis(),x.lt(E))x.setThis(E.sub(d));else if(x.gt(P))return 0;if(y.gt(P))y.setThis(P.add(d));else if(y.lt(E))return 0;let C=e,S=null;if(r){const t=new zn({coef0:At.constructInt32(-1)});t.addElement(Zt),S=new zn,C=S;const s=new zn,i=new zn;for(e.div(t,s,i),S.assignCopy(s);C.evaluate(Zt).isZero();)C.div(t,s,i),S.assignCopy(s)}let v=!1;if(C.power()>0&&C.getElement(0).isZero())for(v=!0,S||(S=new zn({copy:C}),C=S);C.getElement(0).isZero();)S.shiftRight(1);let b=n+2*C.power()+2,I=i/Math.pow(2,C.power()+2),w=b;if(qt.gt(x)&&qt.lt(y))for(let t=0,q=C.power();t<q;t++)if(C.getElement(t).isZero()){l.push(qt.clone());break}for(let q=C.power()-1;q>0;q--)if(I*=2,b-=2,w-=2,C.power()-q!=1)if(C.power()-q!=2){g.assignMove(_),_.assignMove(C.derivative(q-1));let t=[];for(let e=0,s=u.length;e<s;++e)if(u[e].first.lte(u[e].second)){const s=new At;if(ar(g,c,u[e].first,u[e].second,I,b,s)){l.push(s);let i=s.sub(d);i.limitPrecisionThis(w),t.push(j(u[e].first,i)),i=s.add(d),i.limitPrecisionThis(w),t.push(j(i,u[e].second))}else t.push(u[e])}u=t,t=[],c.assignMove(g)}else{g.assignMove(C.derivative(q));const e=or(g,b,m,h);t(e>=0&&e<=2);for(let t=0;t<e;t++)m[t].gt(x)&&m[t].lt(y)&&!m[t].isZero()&&l.push(m[t].clone());if(l.length>1&&l.sort(((t,e)=>t.compare(e))),l.length>0){let t=l[0].sub(d);t.limitPrecisionThis(w),u.push(j(x.clone(),t));let e=1===l.length?y.clone():l[1].sub(d);t=l[0].add(d),t.limitPrecisionThis(w),e.limitPrecisionThis(w),u.push(j(t,e)),l.length>1&&(e=2===l.length?y.clone():l[2].sub(d),e.limitPrecisionThis(w),t=l[1].add(d),t.limitPrecisionThis(w),u.push(j(t,e)),l.length>2&&(t=l[2].add(d),t.limitPrecisionThis(w),u.push(j(t,y.clone()))))}else u.push(j(x.clone(),y.clone()));c.assignCopy(g),_.assignMove(C.derivative(q-1))}else{g.assignMove(C.derivative(q));1===rr(g,m,h)&&(m[0].gt(x)&&m[0].lt(y)&&!m[0].isZero()&&l.push(m[0].clone()),c.assignMove(g),_.assignMove(C.derivative(q-1)))}l.sort(((t,e)=>t.compare(e))),0===u.length&&(c.assignMove(C.derivative(C.power())),c.isZero()||u.push(j(x.clone(),y.clone())));let D=0,T=0,N=0;const A=new At;for(;;){if(T<u.length){if(u[T].first.gt(u[T].second)){T++;continue}let t=!1;if(N<l.length&&l[N].lt(u[T].first)&&(t=!0),!t){ar(C,c,u[T].first,u[T].second,i,n,A)&&(A.lt(p)?m[D++].setThis(p):A.gt(f)?m[D++].setThis(f):m[D++].setThis(A)),T++;continue}}if(!(N<l.length))break;0!==N&&l[N-1].equals(l[N])||hr(C,c,l[N],i)&&(A.setThis(l[N]),A.lt(p)?A.setThis(p):A.gt(f)&&A.setThis(f),0!==D&&m[D].equals(A)||m[D++].setThis(A)),N++}return v&&qt.gt(x)&&qt.lt(y)&&(m[D++].setThis(qt),z(m,0,D,((t,e)=>t.compare(e)))),r&&Zt.gt(x)&&Zt.lt(y)&&(m[D++].setThis(Zt),z(m,0,D,((t,e)=>t.compare(e)))),D}function lr(t){const e=t.getElement(t.power());e.limitPrecisionThis(53);const s=qt.clone();for(let i=0,n=t.power();i<n;i++){const n=t.getElement(i);n.limitPrecisionThis(53),n.divThis(e).absThis(),n.gt(s)&&s.setThis(n)}return s.addThis(Zt),s.mulThis(At.constructDouble(1+100*Number.EPSILON)),s}function ur(t,e,s,i){let n=i;if(!t.isEmpty()){n=0;for(let e=0;e<i;++e)t.containsCoordinate(s[e].value())&&(n!==e&&s[n].setThis(s[e]),n++)}n>1&&(s[0].gt(s[1])&&(s[1]=q(s[0],s[0]=s[1])),n>2&&(s[0].gt(s[2])&&(s[2]=q(s[0],s[0]=s[2])),s[1].gt(s[2])&&(s[2]=q(s[1],s[1]=s[2]))));for(let r=0;r<n;++r)s[r].limitPrecisionThis(e);return n}function cr(t,e,s,i,n,r){return dr(t,e,s,r,i,n)}function gr(t,e,s,i,n,r){let o=n;if(i)return r[0]=1,o=.5*(e-t)*(s(t)+s(e)),o;const a=r[0],h=(e-t)/a,m=t,l=new Yt(0);for(let u=1;u<=r[0];++u){const t=(u-.5)*h;l.add(s(m+t))}return o=.5*(o+(e-t)*l.getResult()/a),r[0]*=2,o}function _r(t,e,s,i,n,r,o){let a=0,h=Math.abs(n-s[t]);const m=H(e,Number.NaN),l=H(e,Number.NaN);for(let _=0;_<e;++_){const e=Math.abs(n-s[t+_]);e<h&&(a=_,h=e),m[_]=i[t+_],l[_]=i[t+_]}let u=0,c=0,g=0;r[0]=i[t+a],a--;for(let _=1;_<e;_++){for(let i=0;i<e-_;i++){if(c=s[t+i]-n,g=s[t+i+_]-n,u=c-g,0===u)return!1;const e=(m[i+1]-l[i])/u;m[i]=c*e,l[i]=g*e}if(2*(a+1)<e-_){const t=a+1;o[0]=m[t]}else{const t=a;o[0]=l[t],a--}r[0]+=o[0]}return!0}function dr(t,s,i,n,r,o){if(i<s&&e("xTo < xFrom"),i===s)return 0;const a=[0];let h=Number.MAX_VALUE;const l=[Number.MAX_VALUE];let u=0;const c=32,g=H(c+1,Number.NaN),_=H(c+1,Number.NaN),d=[0];g[0]=1;let p=0,f=0;for(let e=0;e<c;e++){if(u=gr(s,i,n,0===e,u,d),_[e]=u,e+1>=t){_r(e+1-t,t,g,_,0,a,l)||m("polynomial_interpolation");const s=r*Math.abs(a[0])+o,i=Math.abs(h-a[0]);if(i<=s&&Math.abs(l[0])<=s){if(p++,p>1&&(i<=.1*f||0===f||p>2))return a[0]}else p=0;f=i,h=a[0]}_[e+1]=_[e],g[e+1]=.25*g[e]}return a[0]}class pr{static constructPoint2D(t){return new pr(At.constructDouble(t.x),At.constructDouble(t.y))}constructor(t,e){if(void 0===t)return this.x=(new At).setNAN(),void(this.y=(new At).setNAN());this.x=t.clone(),this.y=e.clone()}assignPoint2D(t){return this.x.setDouble(t.x),this.y.setDouble(t.y),this}setCoords(t,e){return this.x.setThis(t),this.y.setThis(e),this}asPoint2D(){return new w(this.x.value(),this.y.value())}crossProduct(t){return this.x.mul(t.y).sub(this.y.mul(t.x))}leftPerpendicularThis(){const t=this.x.clone();this.x=this.y.clone().negate(),this.y=t}clone(){return new pr(this.x,this.y)}dotProduct(t){return this.x.mul(t.x).add(this.y.mul(t.y))}add(t){return new pr(this.x.add(t.x),this.y.add(t.y))}sub(t){return new pr(this.x.sub(t.x),this.y.sub(t.y))}sqrLength(){return this.x.sqr().addThis(this.y.sqr())}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mul(t){return this.clone().mulThis(t)}}class fr{constructor(){this.area=Number.NaN,this.centroid_x=Number.NaN,this.centroid_y=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}let xr=class{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-Sr(this.b,e,!1):0}getError(e){return t(0),0}};function yr(t,e,s,i,n){let r=!0;const o=D(w,3);t.queryControlPoints(o);let a=r?0:1,h=o[1][a]-o[0][a],m=o[2][a]-o[0][a];const l=cr(5,e,s,i,n,(t=>{let e;if(t<=.5){const s=nt(0,h,t),i=nt(h,m,t);e=nt(s,i,t)}else{const s=rt(0,h,t),i=rt(h,m,t);e=rt(s,i,t)}return e*wr(o,1,t).length()}));r=!1,a=r?0:1,h=o[1][a]-o[0][a],m=o[2][a]-o[0][a];const u=cr(5,e,s,i,n,(t=>{let e;if(t<=.5){const s=nt(0,h,t),i=nt(h,m,t);e=nt(s,i,t)}else{const s=rt(0,h,t),i=rt(h,m,t);e=rt(s,i,t)}return e*wr(o,1,t).length()}));return new w(l,u)}function Pr(t){t.m_cachedValues=null}function Er(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new fr;return Cr(t,e.specialPoints),Fr(t,e),e}function Cr(t,e){const s=D(w,3);t.queryControlPoints(s);const i=D(ot,8);i[0].set(0);let n=1;{const t=D(ot,3);eo(s,t,!1);const e=D(ot,2),r=new A(0,1);let o=Tn(t[2].mul(2),t[1],r,e[0]);o<0&&(o=0);for(let s=0;s<o;s++)ht(e[s].value(),0,1)||(i[n]=e[s],n++)}{const t=D(ot,3);so(s,t,!1);const e=D(ot,2),r=new A(0,1);let o=Tn(t[2].mul(2),t[1],r,e[0]);o<0&&(o=0);for(let s=0;s<o;s++)ht(e[s].value(),0,1)||(i[n]=e[s],n++)}if(i[n].set(1),n++,n>2){z(i,0,n,((t,e)=>t.value()-e.value()));let t=0,e=i[0].value(),s=1;for(let r=1;r<n;r++)i[r].eq(i[r-1])?(e+=i[r].value(),s++):(s>1&&(e/=s,i[t].set(e)),t++,i[t]=i[r],e=i[r].value(),s=1);t++,n=t}i[0].set(0),i[n-1].set(1),e.length=n;for(let r=0;r<n;r++)e[r]=i[r].value()}function Sr(t,e,s){const i=D(w,3);return t.queryControlPoints(i),vr(i,e,s)}function vr(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+vr(t,1,!1)}if(1===e)return br(t);const i=D(w,3);return Hr(t,e,i,null),br(i)}function br(e){if(e[0].equals(e[1]))return w.distance(e[2],e[0]);if(e[1].equals(e[2]))return w.distance(e[0],e[2]);const s=w.distance(e[0],e[1])+w.distance(e[2],e[1]),i=w.distance(e[0],e[2]);if(s-i<=s*Number.EPSILON)return i;const n=1,r=D(w,3);$r(e,r,!0);const o=4*(M(r[2].x)+M(r[2].y)),a=2*(r[2].x*r[1].x+r[2].y*r[1].y),h=M(r[1].x)+M(r[1].y);if(1e-14*(Math.abs(a)+Math.abs(h))>=Math.abs(o)){if(1e-14*Math.abs(h)>=Math.abs(a)){return Math.sqrt(h)*n}t(0);return 2/(3*a)*(Math.pow(a*n+h,1.5)-Math.pow(h,1.5))}const m=a/o,l=h/o,u=l-m*m,c=n+m;if(0===u){if(m>=0&&c>=0||m<=0&&c<=0){return Math.abs(.5*Math.sqrt(o)*(c*c-m*m))}return.5*Math.sqrt(o)*(c*c+m*m)}const g=Math.sqrt(u+c*c),_=Math.sqrt(l);return.5*Math.sqrt(o)*(c*g-m*_+u*Math.log(Math.abs((c+g)/(m+_))))}function Ir(e,s){return t(0),w.getNAN()}function wr(t,e,s){{const e=t[1].sub(t[0]).mul(1-s).add(t[2].sub(t[1]).mul(s));return e.mulThis(2),e}}function Dr(t,e,s){const i=Sr(t,1,!1);if(e<=0)return e;if(e>=i)return e-i+1;const n=[0];return 1!==xn(new xr(t,e),A.unit(),1,n)&&m(""),n[0]}function Tr(t){const e=D(w,3);return t.queryControlPoints(e),Nr(e)}function Nr(t){return-t[1].sub(t[0]).crossProduct(t[2].sub(t[0]))/3}function Ar(t){const e=w.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}function qr(t){return t.m_cachedValues}function Fr(t,e){t.m_cachedValues=e}function Mr(t,e,s,i,n){f(A.unit().contains(s),"QuadraticBezierHelper::getClosestCoordinateSegment");const r=D(w,3);t.queryControlPoints(r);let o=Number.MAX_VALUE;const a=[0],h=Gr(r,e,a);if(s.containsCoordinate(a[0]))o=w.distance(e,h);else{a[0]=s.vmin,no(r,a[0],h),o=w.distance(h,e);const t=new w;no(r,s.vmax,t);const i=w.distance(t,e);o>i&&(h.setCoordsPoint2D(t),a[0]=s.vmax,o=i)}if(!i)return a[0];if(s.vmin<=0){const i=new w;t.queryCoord2DExtended(-1,i,!0);const n=new w;t.queryCoord2D(s.vmin,n);const r=new CE({start:i,end:n}),m=r.getClosestCoordinate(e,!0);if(m<1){const t=r.getCoord2D(m),s=w.distance(t,e);s<o&&(o=s,a[0]=m-1,h.assign(t))}}if(s.vmin>=1){const i=new w;t.queryCoord2DExtended(2,i,!0);const n=new w;t.queryCoord2D(s.vmax,n);const r=new CE({start:n,end:i}),m=r.getClosestCoordinate(e,!0);if(m>0){const t=r.getCoord2D(m),s=w.distance(t,e);s<o&&(o=s,a[0]=1+m,h.assign(t))}}return a[0]}function Gr(t,e,s){const i=t[2].sub(t[1]).sub(t[1].sub(t[0])),n=t[1].sub(t[0]),r=t[0].sub(e),o=r.dotProduct(n),a=r.dotProduct(i)+2*n.dotProduct(n),h=3*n.dotProduct(i),m=i.dotProduct(i),l=new Array(3),u=En(m,h,a,o,A.unit(),!1,l),c=t[0].clone();let g=0,_=w.sqrDistance(t[0],e),d=w.sqrDistance(t[2],e);d<_&&(g=1,c.assign(t[2]),_=d);for(let p=0;p<u;p++){const s=new w;no(t,l[p],s),d=w.sqrDistance(s,e),d<_&&(_=d,c.assign(s),g=l[p])}return s&&(s[0]=g),c}function Vr(t,e,s,i,n,r){const o=new ni;if(Yr(t,A.unit(),o),o.inflate(n),!o.isIntersectingPoint2D(e))return 0;const a=new w,h=Mr(t,e,A.unit(),!1);t.queryCoord2D(h,a);return w.distance(a,e)<=n?(i&&(i[0]=h),1):0}function Yr(t,e,s){const i=D(w,3);t.queryControlPoints(i),Xr(i,e,s)}function Xr(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,3);const i=D(w,3);zr(t,e.vmin,e.vmax,i),s.setFromPoints(i,3)}function kr(t,e,s){s.setEmpty();const i=[];i.push(new A(0,1));const n=.5*Math.max(e.width(),e.height());for(;i.length;){const r=i.at(-1);i.pop();const o=new ni;if(Xr(t,r,o),o.isIntersectingW(e)){const t=Math.max(o.width(),o.height());if(e.containsW(o)||t<=n||r.width()<1e-12)s.merge(r);else{const t=r.getCenter();i.push(A.construct(r.vmin,t)),i.push(A.construct(t,r.vmax))}}}}function Rr(t){const e=D(w,3);t.queryControlPoints(e);const s=Br(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function Br(t){let e=!1;for(let s=0;s<2;s++){const i=mt(t[0][s],t[2][s]);i>0?(mt(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),mt(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):i<0?(mt(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),mt(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function Lr(t,s,i){void 0===i&&(i=s,s=0);const n=new w;if(s<0||i>1)return n.setNAN(),n;if(s>i&&e("calculate_sub_weighted_centroid"),s===i||t.isDegenerate(0))return n.setCoords(0,0),n;const r=Er(t),o=Yi(t),a=Math.min(o/t.calculateUpperLength2D(),1e-7);let h=s,m=0;for(let e=1,l=r.specialPointsCount();e<l;e++)if(s<r.specialPoints[e]){m=e-1;break}n.setCoords(0,0);for(let e=m+1,l=r.specialPointsCount();e<l;e++){const s=Math.min(r.specialPoints[e],i),m=yr(t,h,s,a,o);if(n.addThis(m),h=s,i<=r.specialPoints[e])break}return n.add(t.getStartXY().mul(t.calculateLength2D()))}function Hr(t,e,s,i){(new w).setCoordsPoint2D(t[0]);(new w).setCoordsPoint2D(t[1]);(new w).setCoordsPoint2D(t[2]);const n=new w,r=new w,o=new w;if(lt(t[0],t[1],e,n),lt(t[1],t[2],e,r),lt(n,r,e,o),s&&(s[0].assign(t[0]),s[1].assign(n),s[2].assign(o)),i){const e=t[2];i[0].assign(o),i[1].assign(r),i[2].assign(e)}}function zr(t,e,s,i){if(e===s){const s=new w;return no(t,e,s),i[0]=s,i[1]=s,void(i[2]=s)}const n=D(w,3);Hr(t,s,n,null),Hr(n,e/s,null,n),no(t,e,n[0]),no(t,s,n[2]),i[0].setCoordsPoint2D(n[0]),i[1].setCoordsPoint2D(n[1]),i[2].setCoordsPoint2D(n[2])}function Ur(t,e,s,i){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const n=!!i&&t.isMonotoneQuickAndDirty(),r=new Y,o=D(w,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new w;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=D(w,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformInPlace(t.m_cp):lt(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),n&&Rr(t)}function Or(t){return t.getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp.norm(1)}function Wr(e,s,i,n,r){return t(0),0}function jr(e,s,i,n,r){return t(0),0}function Zr(e,s,i,n,r){return t(0),0}function Qr(e,s,i,n,r,o,a,h,m,l){if(null!=r&&(r.length=0),null!==o&&(o.length=0),null!==n&&(n.length=0),i.isDegenerate(0)){const t=[0,0],e=s.intersectPoint(i.getStartXY(),t,a);if(e>0){if(null!==r)for(let s=0;s<e;s++)r.push(t[s]);if(null!==o)for(let t=0;t<e;t++)o.push(0);if(null!==n)for(let i=0;i<e;i++){const e=new w;s.queryCoord2D(t[i],e),n.push(e)}}return e}const u=Xi(s,i);if(a=Math.max(a,u),s.isDegenerateToLineHelper(u)){const t=new CE({start:s.getStartXY(),end:s.getEndXY()}),e=tn(t,i,n,r,o,a,h,l);if(r)for(let i=0;i<e;++i){const e=t.getCoord2D(r[i]);r[i]=s.getClosestCoordinate(e,!1)}return e}if(ki(s,i,a))return 0;const c=pr.constructPoint2D(i.getStartXY()),g=pr.constructPoint2D(i.getEndXY()).sub(c),_=g.clone();_.leftPerpendicularThis();const d=pr.constructPoint2D(s.m_cp).sub(pr.constructPoint2D(s.getStartXY())),p=pr.constructPoint2D(s.getEndXY()).sub(pr.constructPoint2D(s.m_cp));let f=d.dotProduct(_).toDouble(),x=p.sub(d).dotProduct(_).toDouble();const y=H(12,Number.NaN),P=H(12,Number.NaN);let E=yn(x,f,A.unit(),y);E<0&&(y[0]=0,y[1]=1,E=2);let C,S=0;for(let t=0,D=S;t<E;++t){const e=s.getCoord2D(y[t+D]);P[S]=i.getClosestCoordinate(e,!1),w.distance(e,i.getCoord2D(P[S]))<=a&&(y[S]=y[t+D],S++)}const v=D(w,3);s.queryControlPoints(v);{const t=D(pr,3);if(io(v,t,!1),t[0]=t[0].sub(c),g.x.abs().gte(g.y.abs())){const e=g.y.div(g.x);x=t[2].y.sub(t[2].x.mul(e)).toDouble(),f=t[1].y.sub(t[1].x.mul(e)).toDouble(),C=t[0].y.sub(t[0].x.mul(e)).toDouble()}else{const e=g.x.div(g.y);x=t[2].x.sub(t[2].y.mul(e)).toDouble(),f=t[1].x.sub(t[1].y.mul(e)).toDouble(),C=t[0].x.sub(t[0].y.mul(e)).toDouble()}}const b=s.getEndXY().equals(i.getStartXY())||s.getEndXY().equals(i.getEndXY()),I=[0,0];E=Pn(x,f,C,A.unit(),b,I);for(let t=0,D=S;t<E;++t){y[t+D]=I[t];const e=s.getCoord2D(y[t+D]);P[S]=i.getClosestCoordinate(e,!1),w.distance(e,i.getCoord2D(P[S]))<=a&&(y[S]=y[t+D],S++)}t(S<y.length+4),E=s.intersectPoint(i.getStartXY(),I,a);for(let t=0;t<E;t++)y[S]=I[t],P[S++]=0;E=s.intersectPoint(i.getEndXY(),I,a);for(let t=0;t<E;t++)y[S]=I[t],P[S++]=1;E=i.intersectPoint(s.getStartXY(),I,a);for(let t=0;t<E;t++)P[S]=I[t],y[S++]=0;E=i.intersectPoint(s.getEndXY(),I,a);for(let t=0;t<E;t++)P[S]=I[t],y[S++]=0;return 0===S?0:xE(e,s,i,y,P,S,n,r,o,a,h,m,l)}function Kr(t,e,s,i,n,r,o,a,h,m){if(fP(s)){return Qr(t,e,new CE({start:s.getStartXY(),end:s.getEndXY()}),i,n,r,o,a,h,m)}const l=Xi(e,s);if(ki(e,s,o=Math.max(o,l)))return 0;const u=[],c=[],g=D(w,3);{e.queryControlPoints(g);const t=D(w,3),i=new Y;s.canonicToWorldTransformation(i);const n=new Y;n.setInvert(i),n.transformPoints2D(g,3,t);const r=D(pr,3);io(t,r);const a=[r[0].x,r[1].x,r[2].x],h=[r[0].y,r[1].y,r[2].y],m=D(At,3);m[0].setDouble(s.getSemiMinorAxis()),m[0].sqrThis(),m[1].setDouble(s.getSemiMajorAxis()),m[1].sqrThis(),m[2]=m[0],m[2].mul(m[1]),m[2].negate();const l=Qn(a,2,h,2,null,0,m,!0,A.unit(),A.unit(),u);if(l>0){let t=0;for(let i=0;i<l;i++){const n=new w;e.queryCoord2D(u[i],n);const r=s.getClosestCoordinate(n,!1),a=new w;s.queryCoord2D(r,a),w.distance(n,a)<=o&&(u[t]=u[i],c.push(r),t++)}u.length=t}}const _=[0,1];for(let d=0;d<2;d++){const t=0===d?s.getStartXY():s.getEndXY(),e=[0];Gr(g,t,e);const i=new w;no(g,e[0],i),w.distance(t,i)<=o&&(u.push(e[0]),c.push(_[d]))}for(let d=0;d<2;d++){const t=[0,2];{const e=s.getClosestCoordinate(g[t[d]],!1),i=new w;s.queryCoord2D(e,i),w.distance(g[t[d]],i)<=o&&(u.push(_[d]),c.push(e))}}return xE(t,e,s,u,c,u.length,i,n,r,o,a,h,m)}function Jr(t,e,s,i,n,r,o,a,h,m){const l=D(w,3);e.queryControlPoints(l);const u=D(w,3);if(s.queryControlPoints(u),Ri(l,u,3)<0)return Jr(t,s,e,i,r,n,o,a,h,!m);const c=Xi(e,s);if(ki(e,s,o=Math.max(o,c)))return 0;if(ho(e,s,i,n,r,o,a,h,m))return 2;const g=new A(0,1),_=new A(0,1);{const t=new ni;Xr(l,A.unit(),t);const e=new ni;Xr(u,A.unit(),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*o),e.inflate(3*o),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(kr(l,t,g),kr(u,t,_),g.isEmpty()||_.isEmpty())return 0;zr(l,g.vmin,g.vmax,l),zr(u,_.vmin,_.vmax,u)}}const d=PE(l,2,u,2,o);if(0===d)return 0;const p=[],f=[];if(-1===d){const t=D(pr,3);io(l,t);const e=[t[0].x,t[1].x,t[2].x],s=[t[0].y,t[1].y,t[2].y],i=D(pr,3);io(u,i);const n=Wn(e,2,s,2,null,0,[i[0].x,i[1].x,i[2].x],2,[i[0].y,i[1].y,i[2].y],2,null,0,!0,A.unit(),A.unit(),p,f,m);if(n>0){let t=0;for(let e=0;e<n;e++){const s=new w,i=new w;no(u,f[e],i),no(l,p[e],s),w.distance(s,i)<=o&&(p[t]=p[e],f[t]=f[e],t++)}p.length=t,f.length=t}}for(let x=0;x<2;x++){const t=0===x?l:u,e=0===x?u:l;for(let s=0;s<2;s++){const i=0===s?0:2,n=[0];Gr(e,t[i],n);const r=new w;no(e,n[0],r),w.distance(t[i],r)<=o&&(0===x?(p.push(0===i?0:1),f.push(n[0])):(f.push(0===i?0:1),p.push(n[0])))}}if(0===p.length)return 0;if(!g.equalsRange(0,1))for(let x=0;x<p.length;++x)p[x]=Ln.recalculateParentT(g.vmin,g.vmax,p[x]);if(!_.equalsRange(0,1))for(let x=0;x<f.length;++x)f[x]=Ln.recalculateParentT(_.vmin,_.vmax,f[x]);return xE(t,e,s,p,f,p.length,i,n,r,o,a,h,m)}function $r(t,e,s=!1){const i=t[1].sub(t[0]);e[1].assign(i.mul(2)),e[2].assign(t[2].sub(t[1]).sub(i)),s?e[0].setCoords(0,0):e[0].assign(t[0])}function to(t,e,s=!1){const i=D(w,3);t.queryControlPoints(i),$r(i,e,s)}function eo(t,e,s=!1){const i=0,n=new ot(t[1][i]).subE(new ot(t[0][i]));e[1]=n.mul(2),e[2]=new ot(t[2][i]).subE(new ot(t[1][i])).subE(n),s?e[0].set(0):e[0].set(t[0][i])}function so(t,e,s=!1){const i=1,n=new ot(t[1][i]).subE(new ot(t[0][i]));e[1]=n.mul(2),e[2]=new ot(t[2][i]).subE(new ot(t[1][i])).subE(n),s?e[0].set(0):e[0].set(t[0][i])}function io(t,e,s=!1){const i=pr.constructPoint2D(t[1]),n=i.sub(pr.constructPoint2D(t[0]));e[1]=n.mul(At.constructInt32(2)),e[2]=pr.constructPoint2D(t[2]).sub(i).sub(n),e[0]=s?new pr(qt,qt):pr.constructPoint2D(t[0])}function no(t,e,s,i){if(i){if(e<0){return void Ui(new CE({start:t[0],end:t[0].add(Ir().getUnitVector())}),e,s)}if(e>1){return void Ui(new CE({start:t[2],end:t[2].add(Ir().getUnitVector())}),e-1,s)}}if(e<=.5){const i=t[1].clone(),n=new w;ut(2,t[0],i,e,n);const r=new w;ut(2,i,t[2],e,r);const o=new w;ut(2,n,r,e,o),s.assign(o)}else{const i=t[1].clone(),n=new w;ct(2,t[0],i,e,n);const r=new w;ct(2,i,t[2],e,r);const o=new w;ct(2,n,r,e,o),s.assign(o)}}function ro(e,s,i){t(0)}function oo(e,s,i){t(0)}function ao(t,e){e[0].assign(t[0]),e[3].assign(t[2]),lt(t[0],t[1],2/3,e[1]),lt(t[1],t[2],1/3,e[2])}function ho(t,e,s,i,n,r,o,a,h){const m=D(w,3);t.queryControlPoints(m);const l=D(w,3);if(e.queryControlPoints(l),m[0].equals(l[0])){if(m[1].equals(l[1])&&m[2].equals(l[2]))return s&&(s.length=0,s.push(m[0]),s.push(m[2])),i&&(i.length=0,i.push(0),i.push(1)),n&&(n.length=0,n.push(0),n.push(1)),!0;if(!m[0].equals(l[2]))return!1}return!!(m[0].equals(l[2])&&m[1].equals(l[1])&&m[2].equals(l[0]))&&(i&&(i.length=0,i.push(0),i.push(1),h&&(i[1]=q(i[0],i[0]=i[1]))),n&&(n.length=0,n.push(1),n.push(0),h&&(n[1]=q(n[0],n[0]=n[1]))),s&&(s.length=0,s.push(m[0]),s.push(m[2]),h&&(s[1]=q(s[0],s[0]=s[1]))),!0)}var mo=Ce;class lo extends Hi{constructor(e){e&&e.cp?(super({start:e.cp[0],end:e.cp[3],vd:e.vd}),this.m_cp=D(w,2),this.m_cp[0].assign(e.cp[1]),this.m_cp[1].assign(e.cp[2])):void 0===e||it(e,"vd")?(super({vd:e?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=D(w,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)):e.from?(super({start:e.from,end:e.to,vd:e.vd}),this.m_cp=D(w,2),this.m_cp[0].assign(e.cp1),this.m_cp[1].assign(e.cp2)):(super({XStart:0,YStart:0,XEnd:0,YEnd:0,vd:e.vd}),t(0),this.m_cp=D(w,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)),this.m_cachedValues=0}getBoundary(){return lm(this)}assignMove(e){return t(0),this}assignCopy(e){return t(0),this}construct(t,e,s,i){this.m_XStart=t.x,this.m_YStart=t.y,this.m_XEnd=i.x,this.m_YEnd=i.y,this.m_cp[0].assign(e),this.m_cp[1].assign(s),this.afterCompletedModification()}constructPoints(t){this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.m_cp[0].assign(t[1]),this.m_cp[1].assign(t[2]),this.afterCompletedModification()}constructFromQuadratic(t){const e=D(w,4);ao(t,e),this.constructPoints(e)}constructFromQuadraticSegment(t){this.dropAllAttributes(),this.assignVertexDescription(t.getDescription()),this.m_XStart=t.getStartX(),this.m_YStart=t.getStartY(),this.m_XEnd=t.getEndX(),this.m_YEnd=t.getEndY(),gt(2,t.getStartXY(),t.getControlPoint1(),2/3,this.m_cp[0]),gt(2,t.getControlPoint1(),t.getEndXY(),1/3,this.m_cp[1]),this.afterCompletedModification(),Gi(this,t)}getGeometryType(){return s.enumBezier}queryEnvelope(e){if(!(e instanceof ge))return void t(0);if(e.setCoords(this.getStartXY()),e.mergeNe(this.getEndXY()),e.contains(this.m_cp[0])&&e.contains(this.m_cp[1]))return;const s=$a(this);if(null!==s){const t=new w;for(const i of s.specialPoints)this.queryCoord2D(i,t),e.mergeNe(t);return}const i=D(ot,8),n=D(w,4);this.queryControlPoints(n);const r=Uh(n,i),o=new w;for(let t=1;t<r-1;t++)this.queryCoord2D(i[t].value(),o),e.mergeNe(o)}applyTransformation(e){if(e instanceof Y){const t=D(w,4);return this.queryControlPoints(t),e.transformPoints2D(t,4,t),this.setStartXY(t[0]),this.m_cp[0].assign(t[1]),this.m_cp[1].assign(t[2]),this.setEndXY(t[3]),void eh(this)}t(0)}createInstance(){return new lo({vd:this.m_description})}calculateLength2D(){return Za(this,1,!1)}calculateLowerLength2D(){return w.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return w.distance(this.getStartXY(),this.m_cp[0])+w.distance(this.m_cp[0],this.m_cp[1])+w.distance(this.getEndXY(),this.m_cp[1])}calculateUpperLength2D_(){return t(0),0}queryCoord2D(t,e){return this.queryCoord2DExtends(t,e,!0)}queryCoord2DExtends(t,e,s){const i=D(w,4);this.queryControlPoints(i),xh(i,t,e,s)}queryCoord2DE(t,e){Ph(this,t,e)}getCoordX(t){if(t<0||t>1){const e=new w;return this.queryCoord2DExtends(t,e,!0),e.x}const e=_t(this.getStartX(),this.m_cp[0].x,t),s=_t(this.m_cp[0].x,this.m_cp[1].x,t),i=_t(this.m_cp[1].x,this.getEndX(),t),n=_t(e,s,t),r=_t(s,i,t);return _t(n,r,t)}getCoordY(t){if(t<0||t>1){const e=new w;return this.queryCoord2DExtends(t,e,!0),e.y}const e=_t(this.getStartY(),this.m_cp[0].y,t),s=_t(this.m_cp[0].y,this.m_cp[1].y,t),i=_t(this.m_cp[1].y,this.getEndY(),t),n=_t(e,s,t),r=_t(s,i,t);return _t(n,r,t)}cut(t,e,s){const i=new SE;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createCubicBezier();if(this.cutBezierIgnoreAttributes(t,e,n),i)return;n.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),i=mo.getComponentCount(s);for(let e=0;e<i;e++){const i=this.getAttributeAsDbl(t,s,e);n.setStartAttribute(s,e,i)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),i=mo.getComponentCount(s);for(let t=0;t<i;t++){const i=this.getAttributeAsDbl(e,s,t);n.setEndAttribute(s,t,i)}}}}queryDerivative(t,e){Ch(this,t,e)}cutBezierIgnoreAttributes(t,s,i){(t<0||s>1||t>s)&&e("Cubic_bezier.cut_bezier_ignore_attributes");const n=D(w,4);this.queryControlPoints(n);const r=D(w,4);fh(n,t,s,r),i.setControlPoints(r)}splitBezierIgnoreAttributes(t,s,i){this===s&&this===i&&e("Cubic_bezier.split_bezier_ignore_attributes");const n=D(w,4);this.queryControlPoints(n);const r=D(w,4),o=D(w,4);ph(n,t,r,o),s&&s.setControlPoints(r),i&&i.setControlPoints(o)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const i=this.getStartAttributeAsDbl(e,s),n=this.getEndAttributeAsDbl(e,s),r=this.calculateLength2D(),o=r>0?this.tToLength(t)/r:0,a=mo.getInterpolation(e);return dt(a,i,n,o,mo.getDefaultValue(e))}getClosestCoordinate(t,e){const s=[Number.NaN];return kh(this,t,A.unit(),e,-1,1,s),s[0]}getClosestCoordinateOnInterval(t,e,s=-1){const i=[Number.NaN];return 0===kh(this,t,e,!1,s,1,i)?Number.NaN:i[0]}getYMonotonicParts(e,s=!1){return t(0),0}getMonotonicParts(s,i){s.length<2&&e("");const n=Ja(this);if(2===n.specialPointsCount()&&this.isMonotoneQuickAndDirty())return 0;let r=0;t(s.length>=n.specialPointsCount()-1);for(let t=1,e=n.specialPointsCount();t<e;++t)this.queryCut(n.specialPoints[t-1],n.specialPoints[t],s[r],i),r++;for(let t=0;t<r;++t){ch(s[t].get())}return r}intersectionWithAxis2D(t,e,s,i){const n=D(w,4);return this.queryControlPoints(n),Oh(n,t,e,s,i)}intersectionOfYMonotonicWithAxisX(e,s){if(this.m_YStart===this.m_YEnd)return e===this.m_YStart?s:Number.NaN;if(e===this.m_YStart)return this.m_XStart;if(e===this.m_YEnd)return this.m_XEnd;const i=[0,0],n=this.intersectionWithAxis2D(!0,e,i,null);return t(2!==n),-1===n?s:i[0]}isCurve(){return!0}isDegenerate(t){return Pi(this,t)}isDegenerate3D(e,s){return t(0),!1}queryLooseEnvelope(e){if(e instanceof ge)return e.setCoords({pt:this.getStartXY()}),e.mergeNe(this.m_cp[0]),e.mergeNe(this.m_cp[1]),void e.mergeNe(this.getEndXY());t(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=ge.constructEmpty();this.queryEnvelope(t);const s=A.constructEmpty();return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=D(w,4);this.queryControlPoints(s),fh(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp[0].isEqual(this.m_XStart,this.m_YStart),i=this.m_cp[0].isEqual(this.m_XEnd,this.m_YEnd),n=this.m_cp[1].isEqual(this.m_XStart,this.m_YStart),r=this.m_cp[1].isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp[0].setCoordsPoint2D(t):i&&this.m_cp[0].setCoordsPoint2D(e),r?this.m_cp[1].setCoordsPoint2D(e):n&&this.m_cp[1].setCoordsPoint2D(t),this.normalizeAfterEndpointChange()}tToLength(t){return Za(this,t,!0)}lengthToT(t){return Qa(this,t)}calculateWeightedAreaCentroid2D(t){const e=D(w,4);Ha(this,e);const s=e[3],i=e[2],n=e[1],r=new w;r.x=(5*s.x*s.x*(7*i.y+16*n.y)+s.x*(-35*s.y*i.x+40*i.x*i.y-80*s.y*n.x+140*i.x*n.y+112*n.x*n.y)-2*(s.y*(20*i.x*i.x+70*i.x*n.x+56*n.x*n.x)-7*(4*i.x+5*n.x)*(-i.y*n.x+i.x*n.y)))/840,r.y=(-5*s.y*s.y*(7*i.x+16*n.x)+s.y*(5*s.x*(7*i.y+16*n.y)-4*(10*i.x*i.y+35*i.y*n.x+28*n.x*n.y))+2*(-7*(4*i.y+5*n.y)*(i.y*n.x-i.x*n.y)+s.x*(20*i.y*i.y+70*i.y*n.y+56*n.y*n.y)))/840;const o=uh(this);return r.x+=(e[0].x-t.x)*o,r.y+=(e[0].y-t.y)*o,r}calculateWeightedCentroid2D(){const t=new w;return this.isDegenerate(0)?(t.setCoords(0,0),t):La(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(Ka(this,1)),t)}getControlPoint1(){return this.m_cp[0].clone()}setControlPoint1(t){this.m_cp[0].setCoordsPoint2D(t),this.afterCompletedModification()}getControlPoint2(){return this.m_cp[1].clone()}setControlPoint2(t){this.m_cp[1].setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp[0]),t[2].assign(this.m_cp[1]),t[3].assign(this.getEndXY())}setControlPoints(t){for(let s=0;s<4;s++)t[s].isNAN()&&e("NAN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp[0].setCoordsPoint2D(t[1]),this.m_cp[1].setCoordsPoint2D(t[2]),this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.afterCompletedModification()}getTangent(t){const e=D(w,4);return this.queryControlPoints(e),Eh(e,t)}getDerivative(e){return t(0),w.getNAN()}getCurvature(t){const e=lh(this,1,t),s=lh(this,2,t),i=e.sqrLength();if(0===i)return Number.NaN;e.divThis(Math.sqrt(i));return e.crossProduct(s)/i}isIntersectingPoint(t,e,s){if(s&&(t.equals(this.getStartXY())||t.equals(this.getEndXY())))return!1;const i=new ge;if(this.queryLooseEnvelope(i),i.inflateCoords(e,e),!i.contains(t))return!1;const n=this.getClosestCoordinate(t,!1),r=new w;this.queryCoord2D(n,r);return w.distance(r,t)<=e}isIntersectingPoint3D(e,s,i,n,r=1){return t(0),!1}queryAttributeAsDbl(e,s,i,n){t(0)}isMonotoneQuickAndDirty(){const t=D(w,4);return this.queryControlPoints(t),_h(t)}getMonotonicPartParams(s,i){const n=Ja(this),r=n.specialPointsCount();if(t(Li.s_maxMonotonicPartParams>=r),!i)return n.specialPointsCount();s<r&&e("");for(let t=0;t<r;t++)i[t]=n.specialPoints[t];return r}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=q(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=q(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=q(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cp[1]=q(this.m_cp[0],this.m_cp[0]=this.m_cp[1]),this.m_cachedValues=null}}findMinDeriv(){const t=new ot;return rh(this,t),t.value()}queryConvexHull2D(e){return t(0),0}isLine(){return!1}isDegenerateToLineHelper(e){return t(0),!1}copyIgnoreAttributes(t){const e=D(w,4);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return uh(this)}absNorm(){return Rh(this)}queryEnvelopeW(t,e){Gh(this,t,e)}setSegmentFromCoords(t,e){Lh(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(4);return this.writeInBuffer_(s),t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}writeInBuffer_(t){return t[0]=this.m_cp[0].x,t[1]=this.m_cp[0].y,t[2]=this.m_cp[1].x,t[3]=this.m_cp[1].y,4}readFromBufferStream(t,e){const s=new Float64Array(4);t.queryRange(e,s.length,s,!0,1),this.readFromBuffer_(s)}readFromBuffer_(t){this.m_cp=D(w,2),this.m_cp[0].x=t[0],this.m_cp[0].y=t[1],this.m_cp[1].x=t[2],this.m_cp[1].y=t[3],this.m_cachedValues=null}snapControlPoints(t){const e=D(w,4);this.queryControlPoints(e);const s=(e,s,i)=>{let n=!1;if(w.sqrDistance(e,i)<=t){n=!e.equals(i),e.setCoordsPoint2D(i);w.sqrDistance(s,i)<=t&&(n||=!s.equals(i),s.setCoordsPoint2D(i))}return n},i=s(e[1],e[2],e[0]),n=s(e[2],e[1],e[3]);return(i||n)&&this.setControlPoints(e),i||n}needsSnapControlPoints(t){if(!t)return!1;const e=D(w,4);this.queryControlPoints(e);const s=(e,s,i)=>{let n=!1;if(w.sqrDistance(e,i)<=t){n=!e.equals(i),e.setCoordsPoint2D(i);w.sqrDistance(s,i)<=t&&(n||=!s.equals(i),s.setCoordsPoint2D(i))}return n},i=s(e[1],e[2],e[0]),n=s(e[2],e[1],e[3]);return i||n}calculateSpecialPointsForCracking(t,e){return jh(this,t,e)}ensureXYMonotone(){return ch(this)}setCoordsForIntersector(t,e,s){sh(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp[0].assign(this.m_cp[0]),e.m_cp[1].assign(this.m_cp[1]),th(e,$a(this))}reverseImpl(){this.m_cp[1]=q(this.m_cp[0],this.m_cp[0]=this.m_cp[1])}equalsImpl(t){const e=t,s=0,i=1;return!!this.m_cp[0].equals(e.m_cp[s])&&!!this.m_cp[1].equals(e.m_cp[i])}equalsImplTol(t,e){const s=t,i=0,n=1;return!!this.m_cp[0].isEqualPoint2D(s.m_cp[i],e)&&!!this.m_cp[1].isEqualPoint2D(s.m_cp[n],e)}getHashCodeImpl(){return t(0),0}swapImpl(e){t(0)}afterCompletedModification(){eh(this)}isIntersecting(t,e,s){return 0!==uE(!1,this,t,e,s)}intersect(t,e,s,i,n){return dE(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){return Mh(this,t,e,s)}intersect_(e,s,i,n){return t(0),0}endPointModified(){eh(this)}clearEndPointModified(){t(0)}}lo.type=s.enumBezier;const uo=[[.33998104358485626,.6521451548625461],[.8611363115940526,.34785484513745385]],co=[[.1834346424956498,.362683783378362],[.525532409916329,.31370664587788727],[.7966664774136267,.22238103445337448],[.9602898564975363,.10122853629037626]],go=[[.09501250983763744,.1894506104550685],[.2816035507792589,.18260341504492358],[.45801677765722737,.16915651939500254],[.6178762444026438,.14959598881657674],[.755404408355003,.12462897125553388],[.8656312023878318,.09515851168249279],[.9445750230732326,.062253523938647894],[.9894009349916499,.027152459411754096]],_o=[[.04830766568773832,.0965400885147278],[.1444719615827965,.09563872007927486],[.23928736225213706,.09384439908080457],[.33186860228212767,.09117387869576389],[.42135127613063533,.08765209300440381],[.5068999089322294,.08331192422694675],[.5877157572407623,.07819389578707031],[.6630442669302152,.0723457941088485],[.7321821187402897,.06582222277636185],[.7944837959679424,.058684093478535544],[.84936761373257,.050998059262376175],[.8963211557660521,.04283589802222668],[.9349060759377397,.03427386291302143],[.9647622555875064,.02539206530926206],[.9856115115452684,.01627439473090567],[.9972638618494816,.007018610009470096]],po=[[.024350292663424433,.048690957009139724],[.07299312178779904,.04857546744150343],[.12146281929612056,.048344762234802954],[.16964442042399283,.04799938859645831],[.21742364374000708,.04754016571483031],[.2646871622087674,.04696818281621002],[.31132287199021097,.046284796581314416],[.3572201583376681,.04549162792741814],[.4022701579639916,.044590558163756566],[.4463660172534641,.04358372452932345],[.48940314570705296,.04247351512365359],[.5312794640198946,.04126256324262353],[.571895646202634,.03995374113272034],[.6111553551723933,.038550153178615626],[.6489654712546573,.03705512854024005],[.6852363130542333,.035472213256882386],[.7198818501716109,.033805161837141606],[.7528199072605319,.03205792835485155],[.7839723589433414,.030234657072402478],[.8132653151227975,.028339672614259483],[.8406292962525803,.02637746971505466],[.8659993981540928,.024352702568710874],[.8893154459951141,.022270173808383253],[.9105221370785028,.02013482315353021],[.9295691721319396,.017951715775697343],[.9464113748584028,.015726030476024718],[.9610087996520538,.013463047896718643],[.973326827789911,.011168139460131128],[.983336253884626,.008846759826363947],[.9910133714767443,.006504457968978363],[.9963401167719553,.004147033260562468],[.9993050417357722,.001783280721696433]],fo=[[.012223698960615764,.024446180196262518],[.03666379096873349,.024431569097850044],[.06108196960413957,.02440235563384958],[.08546364050451549,.024358557264690626],[.10979423112764375,.024300200167971867],[.13405919946118777,.02422731922281525],[.15824404271422493,.024139957989019287],[.18233430598533718,.024038168681024052],[.2063155909020792,.023922012136703457],[.23017356422666,.023791557781003402],[.2538939664226943,.023646883584447616],[.2774626201779044,.02348807601653591],[.3008654388776772,.02331522999406276],[.32408843502441337,.023128448824387027],[.3471177285976355,.022927844143686846],[.369939555349859,.02271353585023646],[.39254027503326744,.022485652032744968],[.414906379552275,.022244328893799764],[.43702450103710416,.02198971066846049],[.4588814198335522,.021721949538052076],[.48046407240417205,.02144120553920846],[.5017595591361445,.02114764646822135],[.5227551520511755,.02084144778075115],[.5434383024128103,.02052279248696007],[.5637966482266181,.020191871042130043],[.5838180216287631,.01984888123283086],[.6034904561585486,.019494028058706602],[.6228021939105849,.019127523609950944],[.6417416925623075,.01874958694054471],[.660297632272646,.01836044393733134],[.6784589224477192,.017960327185008687],[.6962147083695144,.017549475827117706],[.7135543776835874,.01712813542311138],[.7304675667419088,.016696557801589205],[.746944166797062,.016255000909785187],[.7629743300440948,.015803728659399347],[.7785484755064119,.015343010768865144],[.7936572947621933,.014873122602147314],[.8082917575079137,.014394345004166847],[.8224431169556439,.013906964132951985],[.8361029150609068,.013411271288616333],[.8492629875779689,.012907562739267348],[.8619154689395485,.012396139543950923],[.8740527969580318,.01187730737274028],[.8856677173453972,.011351376324080417],[.8967532880491582,.010818660739503076],[.9073028834017568,.010279479015832158],[.9173101980809605,.009734153415006806],[.9267692508789478,.009183009871660874],[.9356743882779164,.00862637779861675],[.9440202878302202,.008064589890486059],[.9518019613412644,.0074979819256347285],[.9590147578536999,.006926892566898814],[.9656543664319652,.006351663161707189],[.9717168187471366,.005772637542865698],[.9771984914639074,.00519016183267633],[.9820961084357185,.004604584256702955],[.9864067427245862,.004016254983738642],[.9901278184917344,.0034255260409102157],[.9932571129002129,.0028327514714579912],[.9957927585349812,.0022382884309626186],[.997733248625514,.0016425030186690294],[.9990774599773758,.0010458126793403489],[.9998248879471319,.00044938096029209035]];function xo(t,e,s,i){const n=.5*(i-s),r=s+n,o=new Yt(0);for(let a=0,h=Math.trunc(t/2);a<h;++a){let s,i;switch(t){case 4:s=uo[a][0],i=uo[a][1];break;case 8:s=co[a][0],i=co[a][1];break;case 16:s=go[a][0],i=go[a][1];break;case 32:s=_o[a][0],i=_o[a][1];break;case 64:s=po[a][0],i=po[a][1];break;case 128:s=fo[a][0],i=fo[a][1];break;default:throw new Error("Quadrature_integral: invalid n")}const h=Kt(-n,s,r),m=Kt(n,s,r);o.pe(e(h)*i),o.pe(e(m)*i)}return o.getResult()*n}class yo{constructor(){this.length=Number.NaN,this.area=Number.NaN,this.centroidX=Number.NaN,this.centroidY=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}function Po(e,s,i,n,r,o,a,h){for(;;){const m=w.distance(s[0],s[2]),l=w.distance(s[0],s[1])+w.distance(s[1],s[2]);if(l-m<=r+n*l)return e+_t(m,l,.5);const u=D(w,4),c=t=>{No(s,i,1,t,u);return u[1].length()};if(0===a&&h<8){t(h<8);let m=c(0),u=c(1);o[0]+=2,m>u&&(u=q(m,m=u),s[2]=q(s[0],s[0]=s[2]),i[2]=q(i[0],i[0]=i[2]));let g=m/(m+u),_=1,d=l;for(;g<1/32&&d>=r+n*d;){_/=4;const t=c(_);o[0]++,g=m/(t+m);const e=new w;if(wa(s,i,.5*_,e),d=w.distance(e,s[0]),d<=r){const t=new w;wa(s,i,_,t),d+=w.distance(t,e)}}if(1!==_){const t=D(w,3),m=[0,0,0];ha(s,i,_,s,i,t,m),e=Po(e,t,m,n,r,o,0,h+1),a++,h++;continue}}let g=!1;const _=8;o[0]+=_;const d=xo(_,c,0,1),p=16;o[0]+=p;const f=xo(p,c,0,1);if(g=Math.abs(d-f)>r+n*l,!g)return e+f;if(a<8&&h<9){const t=D(w,3),m=[0,0,0];ha(s,i,.5,s,i,t,m),e=Po(e,t,m,n,r,o,a+1,h+1),a++,h++;continue}const x=32;o[0]+=x;const y=xo(x,c,0,1);if(g=Math.abs(f-y)>r+n*l,!g)return e+y;const P=64;o[0]+=P;const E=xo(P,c,0,1);if(g=Math.abs(y-E)>r+n*l,!g)return e+E;const C=128;o[0]+=C;const S=xo(C,c,0,1);return g=Math.abs(E-S)>r+n*l,e+S}}function Eo(t,e,s,i,n){if(s===e)return 0;const r=D(w,3),o=[0,0,0];t.queryControlPoints(r),t.queryWeights(o);const a=[0,0,0],h=D(w,3);ma(r,o,e,s,h,a);return Po(0,h,a,i,n,[0],0,0)}let Co=class{constructor(t,e,s){this.controlPoints=jt(t,3),this.weights=[0,0,0],X(this.weights,e,0,0,3),this.point=s.clone()}getMaxDerivative(){return 3}getValue(t,e){if(0===t){const t=new w;wa(this.controlPoints,this.weights,e,t);const s=D(w,4);No(this.controlPoints,this.weights,1,e,s);return 2*t.sub(this.point).dotProduct(s[1])}if(1===t){const t=new w;wa(this.controlPoints,this.weights,e,t);const s=D(w,4);No(this.controlPoints,this.weights,2,e,s);return 2*(t.sub(this.point).dotProduct(s[2])+s[1].dotProduct(s[1]))}if(2===t){const t=new w;wa(this.controlPoints,this.weights,e,t);const s=D(w,4);No(this.controlPoints,this.weights,3,e,s);return 2*(t.sub(this.point).dotProduct(s[3])+3*s[1].dotProduct(s[2]))}return 0}getError(e){return t(0),0}};function So(t,e,s,i){const n=ta(0,0,0,0,w.getNAN()),r=new Array(18),o=D(w,3);t.queryControlPoints(o),o[2].subThis(e),o[1].subThis(e),o[0].subThis(e);const a=[0,0,0];t.queryWeights(a);const h=[1,Ta(a),1],m=Aa(a,s),l=Aa(a,i),u=xn(new Co(o,h,new w(0,0)),A.construct(m,l),18,r);wa(o,h,m,n.pt),n.t=m,n.d=w.distance(n.pt,new w(0,0));const c=new w;wa(o,h,l,c);const g=w.distance(c,new w(0,0));g<n.d&&(n.d=g,n.t=l,n.pt.assign(c));for(let _=0;_<u;_++){wa(o,h,r[_],c);const t=w.distance(c,new w(0,0));t<n.d&&(n.d=t,n.t=Na(a,r[_]),n.pt.assign(c))}return n}function vo(t,e,s,i,n){let r=!0;const o=D(w,4),a=cr(5,e,s,i,n,(e=>{To(t,1,e,o);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*o[1].length()}));r=!1;const h=cr(5,e,s,i,n,(e=>{To(t,1,e,o);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*o[1].length()}));return new w(a,h)}function bo(t){t.m_cachedValues=null}function Io(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new yo,s=D(w,3);t.queryControlPoints(s);const i=[0,0,0];return t.queryWeights(i),wo(s,i,e.specialPoints),Ko(t,e),e}function wo(t,e,s){if(0===e[1])return s.length=2,s[0]=0,void(s[1]=1);const i=D(ot,8);i[0].set(0);let n=1;{const s=new ot(t[1].x).subThis(t[0].x).mulThis(e[1]).mulThis(e[0]),r=new ot(t[2].x).subThis(t[0].x).mulThis(e[2]).mulThis(e[0]),o=s.subE(r).addThisE(new ot(t[2].x).subThis(t[1].x).mulThis(e[2]).mulThis(e[1]));r.subThisE(s.mul(2));const a=D(ot,2);let h=Nn(o,r,s,new A(0,1),!1,a);h<0&&(h=0);for(let t=0;t<h;t++)ht(a[t].value(),0,1)||(i[n]=a[t],n++)}{const s=new ot(t[1].y).subThis(t[0].y).mulThis(e[1]).mulThis(e[0]),r=new ot(t[2].y).subThis(t[0].y).mulThis(e[2]).mulThis(e[0]),o=s.subE(r).addThisE(new ot(t[2].y).subThis(t[1].y).mulThis(e[2]).mulThis(e[1]));r.subThisE(s.mul(2));const a=D(ot,2);let h=Nn(o,r,s,new A(0,1),!1,a);h<0&&(h=0);for(let t=0;t<h;t++)ht(a[t].value(),0,1)||(i[n]=a[t],n++)}if(i[n].set(1),n++,n>2){z(i,0,n,((t,e)=>Ft(t.value(),e.value())));let t=0,e=i[0].value(),s=1;for(let r=1;r<n;r++)i[r].eq(i[r-1])?(e+=i[r].value(),s++):(s>1&&(e/=s,i[t].set(e)),t++,i[t]=i[r],e=i[r].value(),s=1);t++,n=t}i[0].set(0),i[n-1].set(1),s.length=n;for(let r=0;r<n;r++)s[r]=i[r].value()}function Do(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+Do(t,1,!1)}if(t.isDegenerate(0))return 0;const i=1===e,n=Io(t);if(i&&!Number.isNaN(n.length))return n.length;const r=Wo(t),o=r/t.calculateUpperLength2D();let a=0,h=0;for(let m=1,l=n.specialPointsCount();m<l;m++){const s=n.specialPoints[m];if(a+=Eo(t,h,Math.min(e,s),o,r),e<=s)break;h=s}return i&&(n.length=a),a}function To(t,e,s,i){const n=D(w,3);t.queryControlPoints(n);const r=[0,0,0];t.queryWeights(r),No(n,r,e,s,i)}function No(t,e,s,i,n){const r=[t[0],t[1],t[2]],o=[e[0],e[1],e[2]],a=D(w,4);Ao(r,o,s,i,a);for(let h=0;h<=s;h++)n[h].setCoords(a[h].x,a[h].y)}function Ao(e,s,i,n,r){t(i>0);const o=[e[0].clone(),e[1].clone(),e[2].clone()];if(!o[0].isZero()){for(let t=1;t<3;++t)o[t].subThis(o[0]);o[0].setCoords(0,0)}const a=qo(o,s,0,n),h=Mo(s,0,n),l=a.divide(h);if(r[0].assign(l),0===i)return;const u=[s[1]*s[0],s[2]*s[0]*.5,s[1]*s[2]],c=[e[1].sub(e[0]),e[2].sub(e[0]),e[2].sub(e[1])],g=h*h,_=qo(c,u,0,n).mul(2).divide(g);if(r[1].assign(_),1===i)return;const d=Mo(s,1,n),p=2*h*d,f=qo(c,u,1,n).mul(2).sub(_.mul(p)).divide(g);if(r[2].assign(f),2===i)return;const x=qo(c,u,2,n).mul(2),y=2*(d*d+h*Mo(s,2,n)),P=x.sub(f.mul(p).mul(2)).sub(_.mul(y)).divide(g);r[3].assign(P),3!==i&&m("")}function qo(t,e,s,i){if(0===s){if(i<=.5){const s=new w;ut(2,t[0].mul(e[0]),t[1].mul(e[1]),i,s);const n=new w;ut(2,t[1].mul(e[1]),t[2].mul(e[2]),i,n);const r=new w;return ut(2,s,n,i,r),r}{const s=new w;ct(2,t[0].mul(e[0]),t[1].mul(e[1]),i,s);const n=new w;ct(2,t[1].mul(e[1]),t[2].mul(e[2]),i,n);const r=new w;return ct(2,s,n,i,r),r}}if(1===s){const s=t[1].mul(e[1]),n=s.sub(t[0].mul(e[0])).mul(1-i).add(t[2].mul(e[2]).sub(s).mul(i));return n.mulThis(2),n}if(2===s){const s=t[1].mul(e[1]),i=t[2].mul(e[2]).sub(s).sub(s.sub(t[0].mul(e[0])));return i.mulThis(2),i}m("")}function Fo(t,e,s,i){if(i.toDouble()<=.5){const s=new pi;Dt(2,t[0].mulE(e[0]),t[1].mulE(e[1]),i,s);const n=new pi;Dt(2,t[1].mulE(e[1]),t[2].mulE(e[2]),i,n);const r=new pi;return Dt(2,s,n,i,r),r}{const s=new pi;Tt(2,t[0].mulE(e[0]),t[1].mulE(e[1]),i,s);const n=new pi;Tt(2,t[1].mulE(e[1]),t[2].mulE(e[2]),i,n);const r=new pi;return Tt(2,s,n,i,r),r}}function Mo(t,e,s){if(0===e){const e=_t(t[0],t[1],s),i=_t(t[1],t[2],s);return _t(e,i,s)}if(1===e){return 2*((1-s)*(t[1]-t[0])+(t[2]-t[1])*s)}if(2===e){return 2*(t[2]-t[1]-(t[1]-t[0]))}m("")}function Go(t,e,s){if(s.toDouble()<=.5){const e=Mt(t[0],t[1],s),i=Mt(t[1],t[2],s);return Mt(e,i,s)}{const e=Gt(t[0],t[1],s),i=Gt(t[1],t[2],s);return Gt(e,i,s)}}function Vo(t,e,s,i,n){const r=[pi.constructPoint2D(t[0]),pi.constructPoint2D(t[1]),pi.constructPoint2D(t[2])];r[2].subThisE(r[0]),r[1].subThisE(r[0]),r[0].setCoords(0,0);Yo(r,[new ot(e[0]),new ot(e[1]),new ot(e[2])],s,i,n)}function Yo(e,s,i,n,r){t(i>0);const o=[e[0].clone(),e[1].clone(),e[2].clone()];if(!o[0].isZero()){for(let t=1;t<3;++t)o[t].subThisE(o[0]);o[0]=pi.constructCoords(0,0)}const a=Fo(o,s,0,n),h=Go(s,0,n),m=a.divE(h);r[0].setE(m);const l=[s[1].mulE(s[0]),s[2].mulE(s[0]).mul(.5),s[1].mulE(s[2])],u=Fo([e[1].subE(e[0]),e[2].subE(e[0]),e[2].subE(e[1])],l,0,n).mul(2),c=h.sqr(),g=u.divE(c);r[1].setE(g)}function Xo(t,e,s){const i=D(w,3);t.queryControlPoints(i);const n=new Array(3);t.queryWeights(n),ko(i,n,e,s)}function ko(t,e,s,i){s.value()<0&&s.set(0,s.eps()),s.value()>1&&s.set(1,s.eps());const n=D(pi,4);Vo(t,e,1,s,n),i.setE(n[1])}function Ro(t,e,s){const i=T(s,0,1),n=D(w,4);if(No(t,e,3,i,n),n[1].isZero()){if(n[2].isZero())return n[3];{const t=n[2].clone();return 1===i&&t.negateThis(),t}}return n[1]}class Bo{constructor(t,e){this.len=0,this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-Do(this.b,e,!1):0}getError(e){return t(0),0}}function Lo(t,e,s){const i=Do(t,1,!1);if(e<=0)return e;if(e>=i)return e-i+1;const n=[0];return 1!==xn(new Bo(t,e),A.unit(),1,n)&&m(""),n[0]}function Ho(t){const e=D(w,3),s=[0,0,0];return t.queryControlPoints(e),t.queryWeights(s),zo(e,s)}function zo(e,s){const i=Ta(s);if(1===i){return Nr(e)}if(0===i)return 0;const n=[new w(0,0),e[1].sub(e[0]),e[2].sub(e[0])],r=n[1].crossProduct(n[2]);if(i<1){t(i>0);const e=1-i;let s;if(e<.01)s=-1/3+e*(2/15+e*(3/35+e*(16/315+e*(20/693+e*(16/1001+e*(56/6435))))));else{const t=e*(1+i),n=Math.atan2(Math.sqrt(e),Math.sqrt(1+i));s=i*(.5*i-se(t)*n)/t}return r*s}{const t=(i-1)*(i+1);return.25*i/Math.pow(t,1.5)*(-2*i*Math.sqrt(t)*r-4*n[1].y*n[2].x*Math.atanh(Math.sqrt((i-1)/(i+1)))-n[1].x*n[2].y*Math.log(2*i*(i-Math.sqrt(t))-1))}}function Uo(e,s){const i=Ta(s);if(1===i){const t=D(w,3);$r(e,t);const s=t[2].clone(),i=t[1].clone(),n=new w,r=s.y*i.x-s.x*i.y;return n.x=-(4*s.x+5*i.x)*r/60,n.y=-(4*s.y+5*i.y)*r/60,n}if(0===i)return new w(0,0);t(i>0);const n=e[1].sub(e[0]),r=e[2].sub(e[0]);if(i<1){const t=Math.sqrt(1-i),e=Math.sqrt(1+i),s=(n.y*r.x-n.x*r.y)*i/Math.pow(t*e,5)/12,o=Math.atan2(t,e),a=i*t*e,h=i*i,m=n.mul(2*(2+h)),l=r.mul(2*h-5),u=m.add(l).mul(a),c=r.sub(n.mul(2*h)).mul(6*o);return u.add(c).mul(s)}{const t=Math.sqrt(i-1),e=Math.sqrt(i+1),s=(n.y*r.x-n.x*r.y)*i/Math.pow(t*e,5)/12,o=Math.atanh(t/e),a=i*t*e,h=i*i,m=n.mul(4).sub(r.mul(5)),l=n.add(r).mul(2*h),u=m.add(l).mul(a),c=r.sub(n.mul(2*h)).mul(6*o);return u.add(c).mul(s)}}function Oo(t){const e=D(w,3),s=[0,0,0];return t.queryControlPoints(e),t.queryWeights(s),Uo(e,s)}function Wo(t){return jo(t.calculateUpperLength2D())}function jo(t){return 256*st()*t}function Zo(t){if(0===t.m_weights[1])return!0;const e=w.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}function Qo(t){return t.m_cachedValues}function Ko(t,e){t.m_cachedValues=e}function Jo(t,e,s,i,n){const r=D(w,3);t.queryControlPoints(r);const o=[0,0,0];t.queryWeights(o);const a=[0];return 1===$o(r,o,e,A.unit(),i,n,1,a)?a[0]:Number.NaN}function $o(e,s,i,n,r,o,a,h){f(A.unit().contains(n)&&a>0,""),(o<0||Number.isNaN(o))&&(o=Number.MAX_VALUE);const m=new Array(3);for(let t=0;t<3;++t)m[t]=e[t].sub(i);const l=Ta(s),u=pr.constructPoint2D(m[0]),c=pr.constructPoint2D(m[1]),g=pr.constructPoint2D(m[2]),_=At.constructDouble(l),d=_.clone();d.ldexpThis(1);const p=u.dotProduct(c.sub(u)).mul(_),x=_.mul(_.addDouble(2)),y=g.sub(c.mul(x.ldexp(1))),P=c.sqrLength().mul(_.mul(_).ldexp(1)).add(u.sqrLength().mul(_.ldexp(2).subDouble(1))).add(u.dotProduct(y)),E=g.sub(c.mul(d)).add(u.mul(d.subDouble(1))),C=c.mul(_).sub(u).dotProduct(E).mulDouble(3),S=c.dotProduct(g).mul(_.subDouble(3).mul(_)).ldexp(1),v=c.sqrLength().mul(_.mul(_).ldexp(2)),b=u.sqrLength().mul(_.ldexp(2).subDouble(3)),I=u.dotProduct(g.sub(c.mul(_.mulDouble(3).subDouble(1)).mul(_))).ldexp(1),T=g.sqrLength().addThis(S).addThis(v).addThis(b).addThis(I),N=u.add(g).sub(c.mul(d)),q=_.subDouble(1),F=g.sub(u).dotProduct(N).mul(q),M=new w(0,0),G=[];let V=new w;wa(m,s,n.vmin,V);let Y=w.distance(V,M);if(Y<=o&&G.push(new w(n.vmin,Y)),n.vmin!==n.vmax&&(wa(m,s,n.vmax,V),Y=w.distance(V,M),Y<=o&&G.push(new w(n.vmax,Y))),n.width()>0){const t=m[2].isZero(),e=D(At,4),i=tr(F,T,C,P,p,58,n,t,e);for(let r=0;r<i;r++){if(!n.containsExclusiveCoordinate(e[r].toDouble()))continue;let t=e[r].toDouble();t=Na(s,t);const i=new w;wa(m,s,t,i),Y=w.distance(i,M),Y<=o&&G.push(new w(t,Y))}}if(r){t(n.equals(A.unit()));{wa(m,s,-1,V,!0);const t=new w;wa(m,s,0,t);const e=new CE({start:V,end:t}),i=e.getClosestCoordinate(M,!0);i<1&&(V=e.getCoord2D(i),Y=w.distance(V,M),Y<=o&&G.push(new w(i-1,Y)))}{wa(m,s,2,V,!0);const t=new w;wa(m,s,n.vmax,t);const e=new CE({start:t,end:V}),i=e.getClosestCoordinate(M,!0);i>0&&(V=e.getCoord2D(i),Y=w.distance(V,M),Y<=o&&G.push(new w(1+i,Y)))}}if(!G.length)return 0;G.sort(((t,e)=>t.compare(e)));let X=0;const k=G[0].x;if(h[X++]=k,X<a){const t=Es(m,4,!1).total(),e=G[0].y;for(let s=1,i=G.length;s<i;s++)if(G[s].y>e+t){G.length=s;break}G.sort(((t,e)=>Ft(t.x,e.x))),X=0,h[X++]=G[0].x;for(let s=1,i=G.length;s<i;s++)G[s].x!==h[X-1]&&X<a&&(h[X++]=G[s].x)}return X}function ta(t,e,s,i,n){return{tmin:t,tmax:e,t:s,d:i,pt:n.clone()}}function ea(e,s,i,n,r){const o=new ni;if(sa(e,A.unit(),o),o.inflate(n),!o.isIntersectingPoint2D(s))return 0;const a=Io(e);let h=0;const m=[];let l=a.specialPoints[0];for(let u=1,c=a.specialPoints.length;u<c;++u){const i=a.specialPoints[u],n=So(e,s,l,i);if(0===m.length)m.push(n);else if(n.t===n.tmin)t(m.at(-1).d<=n.d),m.at(-1).tmax=n.tmax;else if(m.at(-1).t===m.at(-1).tmax){t(m.at(-1).d>=n.d);const e=m.at(-1).tmin;m[m.length-1]=n,m.at(-1).tmin=e}else m.push(n);l=i}for(const t of m)if(t.d<=n){const e=t.t;i?(i[h]=e,h++):h++}return h}function sa(t,e,s){const i=D(w,3);t.queryControlPoints(i);const n=[0,0,0];t.queryWeights(n),ia(i,n,e,s)}function ia(t,e,s,i){if(s.equalsRange(0,1))return void i.setFromPoints(t,3);const n=D(w,3),r=[0,0,0];ma(t,e,s.vmin,s.vmax,n,r),i.setFromPoints(n,3)}function na(t){const e=mt(t[0].y,t[1].y),s=mt(t[1].y,t[2].y);if(e>=0&&s>=0||e<=0&&s<=0){const e=mt(t[0].x,t[1].x),s=mt(t[1].x,t[2].x);if(e>=0&&s>=0||e<=0&&s<=0)return!0}return!1}function ra(t){const e=D(w,3);t.queryControlPoints(e);const s=oa(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function oa(t){let e=!1;for(let s=0;s<2;s++){const i=mt(t[0][s],t[2][s]);i>0?(mt(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),mt(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):i<0?(mt(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),mt(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function aa(t,s,i){void 0===i&&(i=s,s=0);const n=new w;if(s<0||i>1)return n.setNAN(),n;if(s>i&&e("calculate_sub_weighted_centroid"),s===i||t.isDegenerate(0))return n.setCoords(0,0),n;const r=Io(t),o=Wo(t),a=o/t.calculateUpperLength2D();let h=s,m=0;for(let e=1,l=r.specialPointsCount();e<l;e++)if(s<r.specialPoints[e]){m=e-1;break}n.setCoords(0,0);for(let e=m+1,l=r.specialPointsCount();e<l;e++){const s=Math.min(r.specialPoints[e],i),m=vo(t,h,s,a,o);if(n.addThis(m),h=s,i<=r.specialPoints[e])break}return n.add(t.getStartXY().mul(t.calculateLength2D()))}function ha(e,s,i,n,r,o,a){t(i>=0&&i<=1&&n!==o&&r!==a),t(s[0]>0&&s[2]>0&&s[1]>=0);const h=[1,Ta(s),1],m=Aa(s,i),l=jt(e,3),u=D(Fe,3);Ca(l,h,u);const c=D(Fe,3),g=D(Fe,3);Fa(u,m,n?c:null,o?g:null),Ma(s,i,r,a);const _=na(l);if(n){for(let t=0;t<3;++t)Ia(c[t],n[t]);Va(l,n),_&&oa(n)}if(o){for(let t=0;t<3;++t)Ia(g[t],o[t]);Va(l,o),_&&oa(o)}}function ma(e,s,i,n,r,o){if(t(i>=0&&n<=1&&i<=n),i===n){const t=new w,n=Sa(e,s,i,t);return Ga(e,t),r[0].assign(t),r[1].assign(t),r[2].assign(t),o[0]=n,o[1]=n,void(o[2]=n)}if(0===i&&1===n)return r[0].assign(e[0]),r[1].assign(e[1]),r[2].assign(e[2]),o[0]=s[0],o[1]=s[1],void(o[2]=s[2]);const a=D(Fe,3);{const t=[1,Ta(s),1],r=Aa(s,i),o=Aa(s,n);Ca(e,t,a),Fa(a,o,a,null);Fa(a,r>=o?1:r/o,null,a)}const h=[0,0,0];Ma(s,n,h,null),Ma(h,i/n,null,h);const m=na(e),l=D(w,3);Ia(a[1],l[1]),wa(e,s,i,l[0]),wa(e,s,n,l[2]),Va(e,l);for(let t=0;t<3;++t)r[t].assign(l[t]),o[t]=h[t];m&&oa(r)}function la(t,e,s,i){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const n=!!i&&t.isMonotoneQuickAndDirty(),r=new Y,o=D(w,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new w;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=D(w,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformInPlace(t.m_cp):lt(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),n&&ra(t)}function ua(t,e,s,i,n){if(n){if(0!==gE(e,s))return t?4:2}else if(yi(e,s))return 1;return 0!==pa(t,e,s,null,null,null,i,void 0!==n&&n,!0,!1)?4:0}function ca(e,s,i,n,r){return t(0),0}function ga(t,e){const s=t.getEndXY().sub(t.getStartXY()),i=s.length(),n=t.getControlPoint1();n.subThis(t.getStartXY());return!(Math.abs(n.crossProduct(s))/i>e)}function _a(t,e,s,i,n){if(n){const i=gE(e,s);if(0!==i){if(t){if(1===i){if(e.m_weights[0]===s.m_weights[0]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[2])return 2}else if(e.m_weights[0]===s.m_weights[2]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[0])return 2;return 4}return 2}}else if(yi(e,s))return 1;return 0!==xa(t,e,s,null,null,null,i,void 0!==n&&n,!0,!1)?4:0}function da(e,s,i,n,r){return t(0),0}function pa(e,s,i,n,r,o,a,h,m,l){if(null!==r&&(r.length=0),null!==o&&(o.length=0),null!==n&&(n.length=0),i.isDegenerate(0)){const t=[0,0],e=s.intersectPoint(i.getStartXY(),t,a);if(e>0){if(null!==r)for(let s=0;s<e;s++)r.push(t[s]);if(null!=o)for(let t=0;t<e;t++)o.push(0);if(null!=n)for(let i=0;i<e;i++){const e=new w;s.queryCoord2D(t[i],e),n.push(e)}}return e}const u=Xi(s,i);if(a=Math.max(a,u),s.isDegenerateToLineHelper(u)){const t=new CE({start:s.getStartXY(),end:s.getEndXY()}),e=tn(t,i,n,r,o,a,h,l);if(r)for(let i=0;i<e;++i){const e=t.getCoord2D(r[i]);r[i]=s.getClosestCoordinate(e,!1)}return e}if(ki(s,i,a))return 0;const c=D(w,3);s.queryControlPoints(c);const g=[0,0,0];s.queryWeights(g);const _=[1,Ta(g),1],d=i.getEndXY().sub(i.getStartXY()),p=d.clone();p.leftPerpendicularThis();const f=c[0].clone(),x=c[1].clone(),y=c[2].clone(),P=x.sub(f),E=y.sub(f),C=y.sub(x),S=_[0],v=_[1],b=_[2],I=S*v,T=S*b,N=v*b,q=P.dotProduct(p)*I,F=E.dotProduct(p)*T;let M=q,G=F-2*q,V=C.dotProduct(p)*N+F-F;const Y=new Array(13),X=new Array(13);let k=Pn(V,G,M,A.unit(),!1,Y);k<0&&(Y[0]=0,Y[1]=1,k=2);let R=0;for(let t=0,D=R;t<k;++t){const e=new w;wa(c,_,Y[t+D],e),X[R]=i.getClosestCoordinate(e,!1);w.distance(e,i.getCoord2D(X[R]))<=a&&(Y[R]=Y[t+D],R++)}const B=D(w,3),L=D(w,3);if(s.queryControlPoints(L),L[0].subThis(i.getStartXY()),L[1].subThis(i.getStartXY()),L[2].subThis(i.getStartXY()),Pa(L,_,B,!1),Math.abs(d.x)>=Math.abs(d.y)){const t=d.y/d.x;V=B[2].y-B[2].x*t,G=B[1].y-B[1].x*t,M=B[0].y-B[0].x*t}else{const t=d.x/d.y;V=B[2].x-B[2].y*t,G=B[1].x-B[1].y*t,M=B[0].x-B[0].y*t}const H=s.getEndXY().equals(i.getStartXY())||s.getEndXY().equals(i.getEndXY()),z=[0,0];k=Pn(V,G,M,A.unit(),H,z);for(let t=0,D=R;t<k;++t){Y[t+D]=z[t];const e=new w;wa(c,_,Y[t+D],e),X[R]=i.getClosestCoordinate(e,!1);w.distance(e,i.getCoord2D(X[R]))<=a&&(Y[R]=Y[t+D],R++)}t(R<Y.length+4);for(let t=0;t<R;t++)Y[t]=Na(g,Y[t]);k=s.intersectPoint(i.getStartXY(),z,a);for(let t=0;t<k;t++)Y[R]=z[t],X[R++]=0;k=s.intersectPoint(i.getEndXY(),z,a);for(let t=0;t<k;t++)Y[R]=z[t],X[R++]=1;k=i.intersectPoint(s.getStartXY(),z,a);for(let t=0;t<k;t++)X[R]=z[t],Y[R++]=0;k=i.intersectPoint(s.getEndXY(),z,a);for(let t=0;t<k;t++)X[R]=z[t],Y[R++]=1;return 0===R?0:xE(e,s,i,Y,X,R,n,r,o,a,h,m,l)}function fa(e,s,i,n,r,o,a,h,m,l){return t(0),0}function xa(e,s,i,n,r,o,a,h,m,l){const u=D(w,3);s.queryControlPoints(u);const c=D(w,3);if(i.queryControlPoints(c),Ri(u,c,3)<0)return xa(e,i,s,n,o,r,a,h,m,!l);const g=Xi(s,i);if(s.isDegenerateToLineHelper(g)){const t=new CE({start:s.getStartXY(),end:s.getEndXY()}),u=pa(e,i,t,n,o,r,a,h,m,!l);if(r)for(let e=0;e<u;++e){const i=t.getCoord2D(r[e]);r[e]=s.getClosestCoordinate(i,!1)}return u}if(i.isDegenerateToLineHelper(g)){const t=new CE({start:i.getStartXY(),end:i.getEndXY()}),u=pa(e,s,t,n,r,o,a,h,m,l);if(o)for(let e=0;e<u;++e){const s=t.getCoord2D(o[e]);o[e]=i.getClosestCoordinate(s,!1)}return u}if(ki(s,i,a=Math.max(a,g)))return 0;const _=new Array(3);s.queryWeights(_);const d=new Array(3);i.queryWeights(d);const p=[1,Ta(_),1],f=[1,Ta(d),1],x=new A(0,1),y=new A(0,1);{const t=ni.constructEmpty();ia(u,p,new A(0,1),t);const e=ni.constructEmpty();ia(c,f,new A(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Da(u,p,t,x),Da(c,f,t,y),x.isEmpty()||y.isEmpty())return 0;ma(u,p,x.vmin,x.vmax,u,p),ma(c,f,y.vmin,y.vmax,c,f)}}const P=PE(u,2,c,2,a);if(0===P)return 0;const E=[],C=[];if(-1===P){const t=D(At,3),e=D(At,3),s=D(At,3);Ea(u,p,t,e,s);const i=D(At,3),n=D(At,3),r=D(At,3);Ea(c,f,i,n,r);const o=[],h=[],m=Wn(t,2,e,2,s,2,i,2,n,2,r,2,!0,A.unit(),A.unit(),o,h);if(m>0)for(let l=0;l<m;l++){const t=new w;wa(c,f,h[l],t);const e=new w;wa(u,p,o[l],e);w.distance(e,t)<=a&&(E.push(o[l]),C.push(h[l]))}}for(let S=0;S<2;S++){let e,s,i;0===S?(e=u,s=c,i=f):(e=c,s=u,i=p);for(let n=0;n<2;n++){const r=0===n?0:e.length-1,o=new w,h=[0],m=$o(s,i,e[r],A.unit(),!1,-1,1,h);t(1===m),wa(s,i,h[0],o),w.distance(e[r],o)<=a&&(0===S?(E.push(0===r?0:1),C.push(h[0])):(C.push(0===r?0:1),E.push(h[0])))}}if(0===E.length)return 0;if(!x.equalsRange(0,1))for(let t=0;t<E.length;++t)E[t]=Xa.recalculateParentT(x.vmin,x.vmax,E[t]);if(!y.equalsRange(0,1))for(let t=0;t<C.length;++t)C[t]=Xa.recalculateParentT(y.vmin,y.vmax,C[t]);for(let t=0;t<E.length;++t)E[t]=Na(_,E[t]);for(let t=0;t<C.length;++t)C[t]=Na(d,C[t]);return xE(e,s,i,E,C,E.length,n,r,o,a,h,m,l)}function ya(t,e,s,i,n,r,o,a,h,m){if(e.isLine()){return Qr(t,s,new CE({start:e.getStartXY(),end:e.getEndXY()}),i,r,n,o,a,h,!m)}if(s.isLine()){return pa(t,e,new CE({start:s.getStartXY(),end:s.getEndXY()}),i,n,r,o,a,h,m)}const l=Xi(e,s);if(ki(e,s,o=Math.max(o,l)))return 0;const u=D(w,3);e.queryControlPoints(u);const c=D(w,3);s.queryControlPoints(c);const g=PE(u,2,c,2,o);if(0===g)return 0;const _=[],d=[];if(-1===g){const t=D(At,3),i=D(At,3),n=D(At,3),r=[0,0,0];e.queryWeights(r),Ea(u,r,t,i,n);const a=D(pr,3);io(c,a);const h=Wn(t,2,i,2,n,2,[a[0].x,a[1].x,a[2].x],2,[a[0].y,a[1].y,a[2].y],2,null,0,!0,A.unit(),A.unit(),_,d);if(h>0){let t=0;for(let i=0;i<h;i++){const n=new w;s.queryCoord2D(d[i],n);const r=new w;e.queryCoord2D(_[i],r),w.distance(r,n)<=o&&(_[t]=_[i],d[t]=d[i],t++)}_.length=t,d.length=t}}for(let p=0;p<2;p++){let t;t=0===p?u:c;for(let i=0;i<2;i++){const n=0===i?0:t.length-1;let r;const a=new w;0===p?(r=Mr(s,t[n],A.unit(),!1),s.queryCoord2D(r,a)):(r=Jo(e,t[n],A.unit(),!1,-1),e.queryCoord2D(r,a)),w.distance(t[n],a)<=o&&(0===p?(_.push(0===n?0:1),d.push(r)):(d.push(0===n?0:1),_.push(r)))}}return xE(t,e,s,_,d,_.length,i,n,r,o,a,h,m)}function Pa(t,e,s,i=!1){const n=D(w,3);i?(n[0].setCoordsPoint2D(t[0]),n[1].setCoordsPoint2D(t[1]),n[1].subThis(n[0]),n[2].setCoordsPoint2D(t[2]),n[2].subThis(n[0]),n[0].setCoords(0,0)):(n[0].setCoordsPoint2D(t[0]),n[1].setCoordsPoint2D(t[1]),n[2].setCoordsPoint2D(t[2])),n[0].mulThis(e[0]),n[1].mulThis(e[1]),n[2].mulThis(e[2]),s[1].setCoords(n[1].x-n[0].x,n[1].y-n[0].y),s[2].setCoordsPoint2D(n[2].sub(n[1])),s[2].subThis(s[1]),s[1].x*=2,s[1].y*=2,s[0].setCoordsPoint2D(n[0])}function Ea(t,e,s,i,n){const r=At.constructDouble(e[0]),o=At.constructDouble(e[1]),a=At.constructDouble(e[2]);s[0].setDouble(t[0].x),s[0].mulThis(r),s[1].setDouble(t[1].x),s[1].mulThis(o),s[2].setDouble(t[2].x),s[2].mulThis(a),s[2].subThis(s[1]),s[1].subThis(s[0]),s[2].subThis(s[1]),s[1].ldexpThis(1),i[0].setDouble(t[0].y),i[0].mulThis(r),i[1].setDouble(t[1].y),i[1].mulThis(o),i[2].setDouble(t[2].y),i[2].mulThis(a),i[2].subThis(i[1]),i[1].subThis(i[0]),i[2].subThis(i[1]),i[1].ldexpThis(1),n[0].setDouble(e[0]),n[1].setDouble(e[1]),n[2].setThis(n[1]),n[2].ldexpThis(1),n[2].negateThis(),n[2].addThis(n[0]),n[2].addDoubleThis(e[2]),n[1].subThis(n[0]),n[1].ldexpThis(1)}function Ca(t,e,s){for(let i=0;i<3;++i)s[i].setCoordsPoint2DZ(t[i].mul(e[i]),e[i])}function Sa(t,e,s,i){if(0===s)return i.assign(t[0]),e[0];if(1===s)return i.assign(t[2]),e[2];const n=[t[0].x*e[0],t[1].x*e[1],t[2].x*e[2]],r=[t[0].y*e[0],t[1].y*e[1],t[2].y*e[2]],o=[e[0],e[1],e[2]],a=s;let h,m,l;if(s<=.5){const t=nt(n[0],n[1],a),e=nt(n[1],n[2],a);h=_t(t,e,a);const s=nt(r[0],r[1],a),i=nt(r[1],r[2],a);m=_t(s,i,a);const u=nt(o[0],o[1],a),c=nt(o[1],o[2],a);l=nt(u,c,a)}else{const t=rt(n[0],n[1],a),e=rt(n[1],n[2],a);h=rt(t,e,a);const s=rt(r[0],r[1],a),i=rt(r[1],r[2],a);m=rt(s,i,a);const u=rt(o[0],o[1],a),c=rt(o[1],o[2],a);l=rt(u,c,a)}return h/=l,m/=l,i.setCoords(h,m),Ga(t,i),l}function va(t,e,s){const i=D(w,3);t.queryControlPoints(i);const n=[0,0,0];t.queryWeights(n);ba([pi.constructPoint2D(i[0]),pi.constructPoint2D(i[1]),pi.constructPoint2D(i[2])],[new ot(n[0]),new ot(n[1]),new ot(n[2])],e,s)}function ba(t,e,s,i){if(0===s.value())return void i.setE(t[0]);if(1===s.value())return void i.setE(t[2]);const n=[t[0].x.mulE(e[0]),t[1].x.mulE(e[1]),t[2].x.mulE(e[2])],r=[t[0].y.mulE(e[0]),t[1].y.mulE(e[1]),t[2].y.mulE(e[2])],o=[e[0].clone(),e[1].clone(),e[2].clone()],a=new ot,h=new ot,m=new ot;if(s.value()<=.5){const t=Mt(n[0],n[1],s),e=Mt(n[1],n[2],s);a.setE(Mt(t,e,s));const i=Mt(r[0],r[1],s),l=Mt(r[1],r[2],s);h.setE(Mt(i,l,s));const u=Mt(o[0],o[1],s),c=Mt(o[1],o[2],s);m.setE(Mt(u,c,s))}else{const t=Gt(n[0],n[1],s),e=Gt(n[1],n[2],s);a.setE(Gt(t,e,s));const i=Gt(r[0],r[1],s),l=Gt(r[1],r[2],s);h.setE(Gt(i,l,s));const u=Gt(o[0],o[1],s),c=Gt(o[1],o[2],s);m.setE(Gt(u,c,s))}a.divThisE(m),h.divThisE(m);const l=new w(a.value(),h.value());Ga([t[0].value(),t[1].value(),t[2].value()],l),i.x.set(l.x,a.eps()),i.y.set(l.y,h.eps())}function Ia(t,e){return e.setCoords(t.x/t.z,t.y/t.z),t.z}function wa(t,e,s,i,n){if(n){if(s<0){return void Ui(new CE({start:t[0],end:t[0].add(Ro(t,e,0).getUnitVector())}),s,i)}if(s>1){return void Ui(new CE({start:t[2],end:t[2].add(Ro(t,e,1).getUnitVector())}),s-1,i)}}Sa(t,e,s,i)}function Da(t,e,s,i){i.setEmpty();const n=[];n.push(new A(0,1));const r=.5*Math.max(s.width(),s.height());for(;n.length;){const o=n.at(-1);n.pop();const a=new ni;if(ia(t,e,o,a),a.isIntersectingW(s)){const t=Math.max(a.width(),a.height());if(s.containsW(a)||t<=r||o.width()<1e-12)i.merge(o);else{const t=o.getCenter();n.push(A.construct(o.vmin,t)),n.push(A.construct(t,o.vmax))}}}}function Ta(t){return t[1]/Math.sqrt(t[0]*t[2])}function Na(t,e){const s=Math.sqrt(t[2]/t[0]);return e/_t(s,1,e)}function Aa(t,e){const s=Math.sqrt(t[0]/t[2]);return e/_t(s,1,e)}function qa(t,e){const s=D(w,3);t.queryControlPoints(s);const i=[0,0,0];t.queryWeights(i),e.setControlPointsAndWeights(s,i)}function Fa(e,s,i,n){t(s>=0&&s<=1);(new Fe).setCoordsPoint3D(e[0]);(new Fe).setCoordsPoint3D(e[1]);(new Fe).setCoordsPoint3D(e[2]);const r=new Fe,o=new Fe,a=new Fe;gt(3,e[0],e[1],s,r),gt(3,e[1],e[2],s,o),gt(3,r,o,s,a);const h=e[2].clone();i&&(i[0].assign(e[0]),i[1].assign(r),i[2].assign(a)),n&&(n[0].assign(a),n[1].assign(o),n[2].assign(h))}function Ma(e,s,i,n){const r=[e[0],e[1],e[2]];t(s>=0&&s<=1&&i!==n);const o=_t(r[0],r[1],s),a=_t(r[1],r[2],s),h=_t(o,a,s);i&&(i[0]=r[0],i[1]=o,i[2]=h),n&&(n[0]=h,n[1]=a,n[2]=r[2])}function Ga(t,e){const s=A.constructEmpty();s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e.x=T(e.x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e.y=T(e.y,s.vmin,s.vmax)}function Va(t,e){const s=new A;s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e[0].x=T(e[0].x,s.vmin,s.vmax),e[1].x=T(e[1].x,s.vmin,s.vmax),e[2].x=T(e[2].x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e[0].y=T(e[0].y,s.vmin,s.vmax),e[1].y=T(e[1].y,s.vmin,s.vmax),e[2].y=T(e[2].y,s.vmin,s.vmax)}var Ya=Ce;class Xa extends Hi{constructor(s){return void 0===s||it(s,"vd")?(super({vd:s?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new w(0,0),void(this.m_weights=[1,0,1])):(s.fromPoint&&s.weight?s={fromPoint:s.fromPoint,controlPoint1:s.controlPoint1,toPoint:s.toPoint,weight0:1,weight1:s.weight,weight2:1}:s.points&&s.weight?s={fromPoint:s.points[0],controlPoint1:s.points[1],toPoint:s.points[2],weight0:1,weight1:s.weight,weight2:1}:s.points&&s.weights&&(s={fromPoint:s.points[0],controlPoint1:s.points[1],toPoint:s.points[2],weight0:s.weights[0],weight1:s.weights[1],weight2:s.weights[2]}),s.fromPoint&&s.weight0?(super({start:s.fromPoint,end:s.toPoint}),(s.weight0<=0||s.weight1<0||s.weight2<=0)&&e("weights"),this.m_cp=s.controlPoint1.clone(),void(this.m_weights=[s.weight0,s.weight1,s.weight2])):s.copy?(super(s),this.m_cp=s.copy.m_cp.clone(),void(this.m_weights=s.copy.m_weights.slice())):s.move?(super(s),this.m_cp=s.move.m_cp.clone(),void(this.m_weights=s.move.m_weights.slice())):void t(0))}getBoundary(){return lm(this)}assignMove(t){return this}assignCopy(t){return t.copyTo(this),this}construct(t,e,s,i){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,1,i,1),bo(this)}constructWeights(t,e,s,i,n,r){}constructArray(t,e){this.construct(t[0],t[1],t[2],e)}constructArrayWeights(t,e){this.dropAllAttributes(),this.setCpsAndWeightsArray(t,e),bo(this)}convertToStandardForm(){}getStandardFormWeight(){return this.m_weights[1]/Math.sqrt(this.m_weights[0]*this.m_weights[2])}getGeometryType(){return s.enumRationalBezier2}queryEnvelope(t){if(t instanceof ge){if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=Qo(this);if(null!==e){const s=new w;for(const i of e.specialPoints)this.queryCoord2D(i,s),t.mergeNe(s)}else{const e=[],s=D(w,3);this.queryControlPoints(s),wo(s,this.m_weights,e);const i=new w;for(const n of e)this.queryCoord2D(n,i),t.mergeNe(i)}}}applyTransformation(t){if(t instanceof Y){const e=D(w,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}}createInstance(){return new Xa({vd:this.m_description})}calculateLength2D(){return Do(this,1,!1)}calculateLowerLength2D(){return w.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){if(this.m_weights[1]>0){return w.distance(this.getStartXY(),this.m_cp)+w.distance(this.getEndXY(),this.m_cp)}return w.distance(this.getStartXY(),this.getEndXY())}queryCoord2D(t,e){return this.queryCoord2DExtension(t,e,!0)}queryCoord2DE(t,e){va(this,t,e)}queryCoord2DExtension(t,e,s){if(s){if(t<0){return void Ui(new CE({start:this.getStartXY(),end:this.getStartXY().add(this.getTangent(0).getUnitVector())}),t,e)}if(t>1){return void Ui(new CE({start:this.getEndXY(),end:this.getEndXY().add(this.getTangent(1).getUnitVector())}),t-1,e)}}const i=D(w,3);this.queryControlPoints(i),wa(i,this.m_weights,t,e)}getCoordX(t){const e=new w;return this.queryCoord2DExtension(t,e,!0),e.x}getCoordY(t){const e=new w;return this.queryCoord2DExtension(t,e,!0),e.y}cut(t,e,s){const i=new SE;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createQuadraticRationalBezier();if(this.cutBezierIgnoreAttributes(t,e,n),i)return;n.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),i=Ya.getComponentCount(s);for(let e=0;e<i;e++){const i=this.getAttributeAsDbl(t,s,e);n.setStartAttribute(s,e,i)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),i=Ya.getComponentCount(s);for(let t=0;t<i;t++){const i=this.getAttributeAsDbl(e,s,t);n.setEndAttribute(s,t,i)}}}}queryDerivative(t,e){Xo(this,t,e)}cutBezierIgnoreAttributes(t,s,i){(t<0||s>1||t>s)&&e("Quadratic_rational_bezier.cut_bezier_ignore_attributes");const n=D(w,3);this.queryControlPoints(n);const r=[0,0,0];ma(n,this.m_weights,t,s,n,r),i.setControlPointsAndWeights(n,r)}splitBezierIgnoreAttributes(t,e,s){}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const i=this.calculateLength2D(),n=i>0?this.tToLength(t)/i:0,r=Ya.getInterpolation(e),o=this.getStartAttributeAsDbl(e,s),a=this.getEndAttributeAsDbl(e,s);return dt(r,o,a,n,Ya.getDefaultValue(e))}getClosestCoordinate(t,e){return Jo(this,t,A.unit(),e,-1)}getClosestCoordinateOnInterval(t,e,s=-1){return Jo(this,t,e,!1,s)}getYMonotonicParts(t,e){return 0}getMonotonicParts(s,i){s.length<2&&e("");const n=Io(this);let r=0;if(2===n.specialPointsCount())return 0;t(s.length>=n.specialPointsCount()-1);for(let t=1,e=n.specialPointsCount();t<e;++t)this.queryCut(n.specialPoints[t-1],n.specialPoints[t],s[r],i),r++;for(let t=0;t<r;++t){ra(s[t].get())}return r}intersectionWithAxis2D(t,e,s,i){s&&(s.length=9),i&&(i.length=9);const n=new Array(3),r=D(ot,2),o=new A(0,1);let a=0;const h=D(w,3);if(this.queryControlPoints(h),t){if(n[0]=new ot(h[0].y).sub(e).mul(this.m_weights[0]),n[1]=new ot(h[1].y).sub(e).mul(this.m_weights[1]),n[2]=n[0].subE(n[1].mul(2)).addE(new ot(h[2].y).sub(e).mul(this.m_weights[2])),n[1]=n[1].subE(n[0]).mulThisByPower2(2),a=Nn(n[2],n[1],n[0],o,!1,r),s)for(let m=0;m<a;m++)s[m]=this.getCoordX(r[m].value())}else if(n[0]=new ot(h[0].x).sub(e).mul(this.m_weights[0]),n[1]=new ot(h[1].x).sub(e).mul(this.m_weights[1]),n[2]=n[0].subE(n[1].mul(2)).addE(new ot(h[2].x).sub(e).mul(this.m_weights[2])),n[1]=n[1].subE(n[0]).mulThisByPower2(2),a=Nn(n[2],n[1],n[0],o,!1,r),s)for(let m=0;m<a;m++)s[m]=this.getCoordY(r[m].value());if(i)for(let m=0;m<a;m++)i[m]=r[m].value();else s&&z(s,0,a,Ft);return a}intersectionOfYMonotonicWithAxisX(e,s){if(this.m_YStart===this.m_YEnd)return e===this.m_YStart?s:Number.NaN;if(e===this.m_YStart)return this.m_XStart;if(e===this.m_YEnd)return this.m_XEnd;const i=[Number.NaN,Number.NaN],n=this.intersectionWithAxis2D(!0,e,i,null);return t(2!==n),-1===n?s:i[0]}isCurve(){return!0}isDegenerate(t){return Pi(this,t)}isDegenerate3D(t,e){return!1}queryLooseEnvelope(t){if(t instanceof ge)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY())}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=ge.constructEmpty();this.queryEnvelope(t);const s=A.constructEmpty();return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=D(w,3);this.queryControlPoints(s);const i=[0,0,0];ma(s,this.m_weights,t.vmin,t.vmax,s,i),e.setFromPoints(s,3)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),i=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):i&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return Do(this,t,!0)}lengthToT(t){return Lo(this,t)}calculateWeightedAreaCentroid2D(t){const e=Oo(this),s=Ho(this);return e.x+=(this.getStartX()-t.x)*s,e.y+=(this.getStartY()-t.y)*s,e}calculateWeightedCentroid2D(){const t=new w;return this.isDegenerate(0)?(t.setCoords(0,0),t):Zo(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(aa(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryWeights(t){for(let e=0;e<3;++e)t[e]=this.m_weights[e]}setWeights(t){}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}setControlPointsAndWeights(t,e){this.setCpsAndWeightsArray(t,e),this.afterCompletedModification()}getTangent(t){const e=D(w,3);return this.queryControlPoints(e),Ro(e,this.m_weights,t)}getDerivative(t){return w.getNAN()}getCurvature(t){return 0}isIntersecting(t,e,s){return!1}isIntersectingPoint(t,e,s){return!1}isIntersectingPoint3D(t,e,s,i,n=1){return!1}queryAttributeAsDbl(t,e,s,i){}isMonotoneQuickAndDirty(){const t=D(w,3);return this.queryControlPoints(t),na(t)}getMonotonicPartParams(t,s){const i=Io(this),n=i.specialPointsCount();if(!s)return i.specialPointsCount();t<n&&e("");for(let e=0;e<n;e++)s[e]=i.specialPoints[e];return n}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=q(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=q(this.m_YStart,this.m_YStart=this.m_YEnd),this.m_weights[2]=q(this.m_weights[0],this.m_weights[0]=this.m_weights[2]);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=q(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isLine(){return!1}isDegenerateToLineHelper(t){const e=[t];return!!Ei(this,e)&&ga(this,e[0])}copyIgnoreAttributes(t){qa(this,t)}calculateArea2DHelper(){return Ho(this)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)+this.m_cp.norm(1)}absNormXYZ(e){return t(0),0}queryEnvelopeW(t,e){sa(this,t,e)}setSegmentFromCoords(t,e){}writeInBufferStream(t,e){const s=new Float64Array(5);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,s[2]=this.m_weights[0],s[3]=this.m_weights[1],s[4]=this.m_weights[2],t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(5);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_weights[0]=s[2],this.m_weights[1]=s[3],this.m_weights[2]=s[4],this.m_cachedValues=null}snapControlPoints(t){const e=D(w,3);this.queryControlPoints(e);const s=w.sqrDistance(e[1],e[0]),i=w.sqrDistance(e[1],e[2]);let n=e[0].clone(),r=s;s>i&&(n=e[2].clone(),r=i);let o=!1;return r<=t&&0!==r&&(o=!0,this.setControlPoint1(n)),o}needsSnapControlPoints(t){if(!t)return!1;const e=D(w,3);this.queryControlPoints(e);const s=w.sqrDistance(e[1],e[0]),i=w.sqrDistance(e[1],e[2]);e[0].clone();let n=s;return s>i&&(e[2].clone(),n=i),n<=t&&0!==n}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return ra(this)}setCoordsForIntersector(t,e,s){la(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),e.m_weights[0]=this.m_weights[0],e.m_weights[1]=this.m_weights[1],e.m_weights[2]=this.m_weights[2],Ko(e,Qo(this))}reverseImpl(){this.m_weights[2]=q(this.m_weights[0],this.m_weights[0]=this.m_weights[2])}equalsImpl(t){const e=t;if(!this.m_cp.equals(e.m_cp))return!1;for(let s=0;s<3;s++)if(this.m_weights[s]!==e.m_weights[s])return!1;return!0}equalsImplTol(t,e){const s=t;if(!this.m_cp.isEqualPoint2D(s.m_cp,e))return!1;const i=D(w,3);this.queryControlPoints(i);const n=D(w,3);s.queryControlPoints(n);const r=[s.m_weights[0],s.m_weights[1],s.m_weights[2]];for(let o=0;o<3;o++){const t=new Fe;t.setCoordsPoint2DZ(i[o].mul(this.m_weights[o]),this.m_weights[o]);const s=new Fe;if(s.setCoordsPoint2DZ(n[o].mul(r[o]),r[o]),!t.isEqual(s,e))return!1}return!0}getHashCodeImpl(){return 0}swapImpl(t){}afterCompletedModification(){bo(this)}intersect(t,e,s,i,n){return dE(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){return ea(this,t,e,s)}intersect_(t,e,s,i){return 0}endPointModified(){bo(this)}clearEndPointModified(){}setCpsAndWeights(t,s,i,n,r,o){(n<=0||o<=0||r<0)&&e("weights"),(t.isNAN()||s.isNAN()||i.isNAN())&&e("NAN control points in bezier are not supported"),this.setStartXY(t),this.m_cp.assign(s),this.m_weights[0]=n,this.m_weights[1]=r,this.m_weights[2]=o,this.setEndXY(i)}setCpsAndWeightsArray(t,e){this.setCpsAndWeights(t[0],t[1],t[2],e[0],e[1],e[2])}}Xa.type=s.enumRationalBezier2;class ka{constructor(){this.length=Number.NaN,this.specialPoints=[]}specialPointsCount(){return this.specialPoints.length}}function Ra(t){return Ba(t.calculateUpperLength2D())}function Ba(t){return 256*st()*t}function La(t){const e=w.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}function Ha(t,e,s=!1){e[1].setCoords(t.m_cp[0].x-t.getStartX(),t.m_cp[0].y-t.getStartY()),e[1].mulThis(3),e[2].setCoords(t.m_cp[1].x-t.m_cp[0].x,t.m_cp[1].y-t.m_cp[0].y),e[2].mulThis(3),e[3]=t.getEndXY().sub(t.getStartXY()),e[3].subThis(e[2]),e[2].subThis(e[1]),s?e[0].setCoords(0,0):e[0]=t.getStartXY()}function za(t,e,s){const i=D(w,4);t.queryControlPoints(i),Oa(i,e,s)}function Ua(t,e,s){const i=D(w,4);t.queryControlPoints(i),Wa(i,e,s)}function Oa(t,e,s){let i=t[1].x;i-=t[0].x,i*=3;let n=t[2].x;n-=t[1].x,n*=3;let r=t[3].x;r-=t[0].x,r-=n,n-=i,e[3].setWithEps(r),e[2].setWithEps(n),e[1].setWithEps(i),s?e[0].set(0):e[0].set(t[0].x)}function Wa(t,e,s){let i=t[1].y;i-=t[0].y,i*=3;let n=t[2].y;n-=t[1].y,n*=3;let r=t[3].y;r-=t[0].y,r-=n,n-=i,e[3].setWithEps(r),e[2].setWithEps(n),e[1].setWithEps(i),s?e[0].set(0):e[0].set(t[0].y)}function ja(t,e,s=!1){const i=D(pr,4);i[0].assignPoint2D(t[0]),i[1].assignPoint2D(t[1]),i[2].assignPoint2D(t[2]),i[3].assignPoint2D(t[3]),e[1].setCoords(i[1].x.sub(i[0].x),i[1].y.sub(i[0].y)),e[1].mulThis(At.constructInt32(3)),e[2].setCoords(i[2].x.sub(i[1].x),i[2].y.sub(i[1].y)),e[2].mulThis(At.constructInt32(3)),e[3]=i[3].sub(i[0]),e[3]=e[3].sub(e[2]),e[2]=e[2].sub(e[1]),s?e[0].setCoords(qt,qt):e[0]=i[0].clone()}function Za(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+Za(t,1,!1)}if(t.isDegenerate(0))return 0;const i=1===e,n=Ja(t);if(i&&!Number.isNaN(n.length)&&!Number.isNaN(n.length))return n.length;const r=Ra(t),o=r/t.calculateUpperLength2D();let a=0,h=0;for(let m=1,l=n.specialPointsCount();m<l;m++){const s=n.specialPoints[m];if(a+=Kh(t,h,Math.min(e,s),o,r),e<=s)break;h=s}return i&&(n.length=a),a}function Qa(t,e,s){const i=Za(t,1,!1);if(e<=0)return e;if(e>=i)return e-i+1;const n=[0];return 1!==xn(new Zh(t,e),A.unit(),1,n)&&m(""),n[0]}function Ka(t,s,i){void 0===i&&(i=s,s=0);const n=new w;if(s<0||i>1)return n.setNAN(),n;if(s>i&&e("calculate_sub_weightedCentroid"),s===i||t.isDegenerate(0))return n.setCoords(0,0),n;const r=Ja(t),o=Ra(t),a=o/t.calculateUpperLength2D();let h=s,m=0;for(let e=1,l=r.specialPointsCount();e<l;e++)if(s<r.specialPoints[e]){m=e-1;break}n.setCoords(0,0);for(let e=m+1,l=r.specialPointsCount();e<l;e++){const s=Math.min(r.specialPoints[e],i),m=Jh(t,h,s,a,o);if(n.addThis(m),h=s,i<=r.specialPoints[e])break}return n.add(t.getStartXY().mul(t.calculateLength2D()))}function Ja(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new ka,s=D(ot,8),i=D(w,4);t.queryControlPoints(i);const n=Uh(i,s);e.specialPoints=[];for(let r=0;r<n;r++)e.specialPoints.push(s[r].value());return th(t,e),e}function $a(t){let e=null;return e=t.m_cachedValues,e}function th(t,e){t.m_cachedValues=e}function eh(t){t.m_cachedValues=null}function sh(t,e,s,i){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const n=!!i&&t.isMonotoneQuickAndDirty(),r=new Y,o=D(w,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new w;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=D(w,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformPoints2D(t.m_cp,2,t.m_cp):(lt(e,s,1/3,t.m_cp[0]),lt(e,s,2/3,t.m_cp[1])),t.changeEndPoints2D(e,s),n&&ch(t)}function ih(t,e,s,i,n){return{tmin:t,tmax:e,t:s,d:i,pt:n.clone()}}function nh(t,e,s,i){const n=new Array(18),r=D(w,4);t.queryControlPoints(r);const o=xn(new Yh(r,e),A.construct(s,i),18,n),a=new w;t.queryCoord2D(s,a);let h=s,m=w.distance(a,e);const l=new w;t.queryCoord2D(i,l);const u=w.distance(l,e);u<m&&(m=u,h=i,a.assign(l));for(let c=0;c<o;c++){t.queryCoord2D(n[c],l);const s=w.distance(l,e);s<m&&(m=s,h=n[c],a.assign(l))}return ih(s,i,h,m,a)}function rh(e,s){const i=D(ot,4);za(e,i,!0);const n=D(ot,4);Ua(e,n,!0);const r=i[3].clone(),o=i[2].clone(),a=i[1].clone(),h=n[3].clone(),m=n[2].clone(),l=n[1].clone(),u=o.mulE(a).addE(m.mulE(l)).mul(4),c=o.mulE(o).mul(8).addE(r.mulE(a).mul(12)).addE(m.mulE(m).mul(8).addE(h.mulE(l).mul(12))),g=r.mulE(o).addE(h.mulE(m)).mul(36),_=r.mulE(r).addE(h.mulE(h)).mul(36),d=D(ot,3),p=An(_,g,c,u,new A(0,1),!1,d);if(t(p<=3),p>0){const t=lh(e,1,0).sqrLength(),i=lh(e,1,1).sqrLength();let n=t;s.set(0),n<i&&(n=i,s.set(1));for(let r=0;r<p;r++){const t=lh(e,1,d[r].value()).sqrLength();t<n&&(n=t,s=d[r])}}}function oh(t,e,s,i){if(1===e){const e=1-s,n=e*e,r=s*s,o=t[1].sub(t[0]),a=t[2].sub(t[1]),h=t[3].sub(t[2]),m=o.mul(n).add(a.mul(2*e*s)).add(h.mul(r));i.assign(m.mul(3))}else if(2===e){const e=1-s,n=t[2].sub(t[1]).sub(t[1].sub(t[0])),r=t[3].sub(t[2]).sub(t[2].sub(t[1])),o=n.mul(e).add(r.mul(s));i.assign(o.mul(6))}else if(3===e){const e=t[2].sub(t[1]),s=t[3].sub(e.mul(3)).sub(t[0]);i.assign(s.mul(6))}else i.setCoords(0,0)}function ah(t,e,s,i){{const e=It.subE(s),n=e.sqr(),r=s.sqr(),o=t[1].subE(t[0]).mulE(n).addE(t[2].subE(t[1]).mulE(new ot(2).mulE(e).mulE(s))).addE(t[3].subE(t[2]).mulE(r));i.setE(o.mulE(new ot(3)))}}function hh(t,e,s){const i=new w;return oh(t,e,s,i),i}function mh(t,e,s){const i=[pi.constructPoint2D(t[0]),pi.constructPoint2D(t[1]),pi.constructPoint2D(t[2]),pi.constructPoint2D(t[3])],n=new pi;return ah(i,e,s,n),n}function lh(t,e,s){const i=D(w,4);return t.queryControlPoints(i),hh(i,e,s)}function uh(t){const e=t.m_cp[0].sub(t.getStartXY()),s=t.m_cp[1].sub(t.m_cp[0]),i=t.getEndXY().sub(t.getStartXY());e.mulThis(3),s.mulThis(3),i.subThis(s),s.subThis(e);return(3*i.x*(2*s.y+5*e.y)-3*i.y*(2*s.x+5*e.x)+10*(s.x*e.y-s.y*e.x))/60}function ch(t){const e=D(w,4);t.queryControlPoints(e);const s=gh(e);return s&&(t.m_cp[0].setCoordsPoint2D(e[1]),t.m_cp[1].setCoordsPoint2D(e[2]),t.afterCompletedModification()),s}function gh(t){let e=!1;for(let s=0;s<2;s++){const i=mt(t[0][s],t[3][s]);i>0?(mt(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),mt(t[1][s],t[3][s])<0&&(t[1][s]=t[3][s],e=!0),mt(t[0][s],t[2][s])<0&&(t[2][s]=t[0][s],e=!0),mt(t[2][s],t[3][s])<0&&(t[2][s]=t[3][s],e=!0),mt(t[1][s],t[2][s])<0&&(t[2][s]=t[1][s],e=!0)):i<0?(mt(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),mt(t[1][s],t[3][s])>0&&(t[1][s]=t[3][s],e=!0),mt(t[0][s],t[2][s])>0&&(t[2][s]=t[0][s],e=!0),mt(t[2][s],t[3][s])>0&&(t[2][s]=t[3][s],e=!0),mt(t[1][s],t[2][s])>0&&(t[2][s]=t[1][s],e=!0)):t[1][s]===t[0][s]&&t[2][s]===t[0][s]||(t[1][s]=t[0][s],t[2][s]=t[0][s],e=!0)}return e}function _h(t){const e=mt(t[0].y,t[1].y),s=mt(t[1].y,t[2].y),i=mt(t[2].y,t[3].y);if(e>=0&&s>=0&&i>=0||e<=0&&s<=0&&i<=0){const e=mt(t[0].x,t[1].x),s=mt(t[1].x,t[2].x),i=mt(t[2].x,t[3].x);if(e>=0&&s>=0&&i>=0||e<=0&&s<=0&&i<=0)return!0}return!1}function dh(t,e,s){const i=new w,n=new w,r=new w,o=new w,a=new w;e<=.5?(ut(2,t[0],t[1],e,i),ut(2,t[1],t[2],e,n),ut(2,t[2],t[3],e,r),ut(2,i,n,e,o),ut(2,n,r,e,a),ut(2,o,a,e,s)):(ct(2,t[0],t[1],e,i),ct(2,t[1],t[2],e,n),ct(2,t[2],t[3],e,r),ct(2,i,n,e,o),ct(2,n,r,e,a),ct(2,o,a,e,s))}function ph(e,s,i,n){t(s>=0&&s<=1);const r=new w,o=new w,a=new w,h=new w,m=new w,l=new w;s<=.5?(ut(2,e[0],e[1],s,r),ut(2,e[1],e[2],s,o),ut(2,e[2],e[3],s,a),ut(2,r,o,s,h),ut(2,o,a,s,m),ut(2,h,m,s,l)):(ct(2,e[0],e[1],s,r),ct(2,e[1],e[2],s,o),ct(2,e[2],e[3],s,a),ct(2,r,o,s,h),ct(2,o,a,s,m),ct(2,h,m,s,l));const u=e[3].clone();i&&(i[0].assign(e[0]),i[1].assign(r),i[2].assign(h),i[3].assign(l)),n&&(n[0].assign(l),n[1].assign(m),n[2].assign(a),n[3].assign(u))}function fh(e,s,i,n){if(t(s>=0&&i<=1&&s<=i),s===i){const t=new w;return xh(e,s,t),n[0].assign(t),n[1].assign(t),n[2].assign(t),void n[3].assign(t)}if(0===s&&1===i){for(let t=0;t<4;++t)n[t].assign(e[t]);return}const r=D(w,4);ph(e,i,r,null),ph(r,i>0?s/i:0,null,r),xh(e,s,r[0]),xh(e,i,r[3]),n[0].setCoordsPoint2D(r[0]),n[1].setCoordsPoint2D(r[1]),n[2].setCoordsPoint2D(r[2]),n[3].setCoordsPoint2D(r[3])}function xh(t,e,s,i){if(i){if(e<0){return void Ui(new CE({start:t[0],end:t[0].add(Eh(t,0).getUnitVector())}),e,s)}if(e>1){return void Ui(new CE({start:t[3],end:t[3].add(Eh(t,1).getUnitVector())}),e-1,s)}}if(e<=.5){const i=new w;ut(2,t[0],t[1],e,i);const n=new w;ut(2,t[1],t[2],e,n);const r=new w;ut(2,t[2],t[3],e,r);const o=new w;ut(2,i,n,e,o);const a=new w;ut(2,n,r,e,a),ut(2,o,a,e,s)}else{const i=new w;ct(2,t[0],t[1],e,i);const n=new w;ct(2,t[1],t[2],e,n);const r=new w;ct(2,t[2],t[3],e,r);const o=new w;ct(2,i,n,e,o);const a=new w;ct(2,n,r,e,a),ct(2,o,a,e,s)}}function yh(t,e,s){if(e.value()<=.5){const i=new pi;Dt(2,pi.constructPoint2D(t[0]),pi.constructPoint2D(t[1]),e,i);const n=new pi;Dt(2,pi.constructPoint2D(t[1]),pi.constructPoint2D(t[2]),e,n);const r=new pi;Dt(2,pi.constructPoint2D(t[2]),pi.constructPoint2D(t[3]),e,r);const o=new pi;Dt(2,i,n,e,o);const a=new pi;Dt(2,n,r,e,a),Dt(2,o,a,e,s)}else{const i=new pi;Tt(2,pi.constructPoint2D(t[0]),pi.constructPoint2D(t[1]),e,i);const n=new pi;Tt(2,pi.constructPoint2D(t[1]),pi.constructPoint2D(t[2]),e,n);const r=new pi;Tt(2,pi.constructPoint2D(t[2]),pi.constructPoint2D(t[3]),e,r);const o=new pi;Tt(2,i,n,e,o);const a=new pi;Tt(2,n,r,e,a),Tt(2,o,a,e,s)}}function Ph(t,e,s){const i=D(w,4);t.queryControlPoints(i),yh(i,e,s)}function Eh(t,e){const s=T(e,0,1);let i=hh(t,1,s);return i.isZero()&&(i=hh(t,2,s),i.isZero()?i=hh(t,3,s):1===s&&i.negateThis()),i}function Ch(t,e,s){const i=D(w,4);t.queryControlPoints(i),Sh(i,e,s)}function Sh(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(mh(t,1,e))}function vh(t,e,s,i,n){if(n){if(0!==gE(e,s))return t?4:2}else if(yi(e,s))return 1;return 0!==Th(t,e,s,null,null,null,i,void 0!==n&&n,!0,!1)?4:0}function bh(t,e,s,i,n){if(n){if(0!==gE(e,s))return t?4:2}else if(yi(e,s))return 1;return 0!==Nh(t,e,s,null,null,null,i,void 0!==n&&n,!0,!1)?4:0}function Ih(t,e,s,i,n){if(n){if(0!==gE(e,s))return 2}else if(yi(e,s))return 1;return 0!==Ah(t,e,s,null,null,null,i,void 0!==n&&n,!0,!1)?4:0}function wh(t,e,s,i,n){if(n){if(0!==gE(e,s))return t?4:2}else if(yi(e,s))return 1;return 0!==qh(t,e,s,null,null,null,i,void 0!==n&&n,!0,!1)?4:0}function Dh(e,s,i,n,r){return t(0),0}function Th(t,e,s,i,n,r,o,a,h,m){if(null!==n&&(n.length=0),null!=r&&(r.length=0),null!==i&&(i.length=0),s.isDegenerate(0)){const t=[0,0,0],a=e.intersectPoint(s.getStartXY(),t,o);if(a>0){if(null!==n)for(let e=0;e<a;e++)n.push(t[e]);if(null!==r)for(let t=0;t<a;t++)r.push(0);if(null!=i)for(let s=0;s<a;s++){const n=new w;e.queryCoord2D(t[s],n),i.push(n)}}return a}const l=Xi(e,s);if(ki(e,s,o=Math.max(o,l)))return 0;const u=D(w,4);Ha(e,u);const c=s.getEndXY();c.subThis(s.getStartXY());const g=c.clone();g.leftPerpendicularThis();let _=3*u[3].dotProduct(g),d=2*u[2].dotProduct(g),p=u[1].dotProduct(g);const f=new Array(15),x=new Array(15);let y=Pn(_,d,p,A.unit(),!1,f);y<0&&(f[0]=0,f[1]=1,y=2);let P,E=0;for(let v=0,b=E;v<y;++v){const t=e.getCoord2D(f[v+b]);x[E]=s.getClosestCoordinate(t,!1),w.distance(t,s.getCoord2D(x[E]))<=o&&(f[E]=f[v+b],E++)}if(u[0].subThis(s.getStartXY()),Math.abs(c.x)>=Math.abs(c.y)){const t=c.y/c.x;_=u[3].y-u[3].x*t,d=u[2].y-u[2].x*t,p=u[1].y-u[1].x*t,P=u[0].y-u[0].x*t}else{const t=c.x/c.y;_=u[3].x-u[3].y*t,d=u[2].x-u[2].y*t,p=u[1].x-u[1].y*t,P=u[0].x-u[0].y*t}const C=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),S=[0,0,0];y=En(_,d,p,P,A.unit(),C,S);for(let v=0,b=E;v<y;++v){f[v+b]=S[v];const t=e.getCoord2D(f[v+b]);x[E]=s.getClosestCoordinate(t,!1);w.distance(t,s.getCoord2D(x[E]))<=o&&(f[E]=f[v+b],E++)}y=e.intersectPoint(s.getStartXY(),S,o);for(let v=0;v<y;v++)f[E]=S[v],x[E++]=0;y=e.intersectPoint(s.getEndXY(),S,o);for(let v=0;v<y;v++)f[E]=S[v],x[E++]=1;return 0!==s.intersectPoint(e.getStartXY(),S,o)&&(x[E]=S[0],f[E++]=0),0!==s.intersectPoint(e.getEndXY(),S,o)&&(x[E]=S[0],f[E++]=1),0===E?0:xE(t,e,s,f,x,E,i,n,r,o,a,h,m)}function Nh(t,e,s,i,n,r,o,a,h,m){if(fP(s)){return Th(t,e,new CE({start:s.getStartXY(),end:s.getEndXY()}),i,n,r,o,a,h,m)}const l=Xi(e,s);if(ki(e,s,o=Math.max(o,l)))return 0;const u=[],c=[],g=[],_=D(w,4);{e.queryControlPoints(_);const t=D(w,4),i=new Y;s.canonicToWorldTransformation(i);const n=new Y;n.setInvert(i),n.transformPoints2D(_,4,t);const r=D(pr,4);ja(t,r);const a=[r[0].x,r[1].x,r[2].x,r[3].x],h=[r[0].y,r[1].y,r[2].y,r[3].y],m=D(At,3);m[0].setDouble(s.getSemiMinorAxis()),m[0].sqrThis(),m[1].setDouble(s.getSemiMajorAxis()),m[1].sqrThis(),m[2].setThis(m[0]),m[2].mulThis(m[1]),m[2].negateThis();const l=Qn(a,3,h,3,null,0,m,!0,A.unit(),A.unit(),c);if(l>0){let t=0;for(let i=0;i<l;i++){const n=new w;e.queryCoord2D(c[i],n);const r=s.getClosestCoordinate(n,!1),a=new w;s.queryCoord2D(r,a);w.distance(n,a)<=o&&(u.push(n.clone()),c[t]=c[i],g.push(r),t++)}c.length=t,u.length=t}}const d=[0,1];for(let p=0;p<2;p++){const t=0===p?s.getStartXY():s.getEndXY(),e=[0];Xh(_,t,A.unit(),!1,-1,1,e);const i=new w;xh(_,e[0],i);w.distance(t,i)<=o&&(c.push(e[0]),g.push(d[p]),u.push(i.clone()))}for(let p=0;p<2;p++){const t=[0,3];{const e=s.getClosestCoordinate(_[t[p]],!1),i=new w;s.queryCoord2D(e,i);w.distance(_[t[p]],i)<=o&&(c.push(d[p]),g.push(e),u.push(i.clone()))}}return xE(t,e,s,c,g,c.length,i,n,r,o,a,h,m)}function Ah(e,s,i,n,r,o,a,h,m,l){const u=D(w,4);s.queryControlPoints(u);const c=D(w,4);if(i.queryControlPoints(c),Ri(u,c,4)<0)return Ah(e,i,s,n,o,r,a,h,m,!l);const g=Xi(s,i);if(ki(s,i,a=Math.max(a,g)))return 0;if($h(s,i,n,r,o,a,h,m,l))return 2;const _=new A(0,1),d=new A(0,1);{const t=new ni;Vh(u,new A(0,1),t);const e=new ni;Vh(c,new A(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Wh(u,t,_),Wh(c,t,d),_.isEmpty()||d.isEmpty())return 0;fh(u,_.vmin,_.vmax,u),fh(c,d.vmin,d.vmax,c)}}const p=PE(u,3,c,3,a);if(0===p)return 0;const f=[],x=[],y=[];let P=!1;if(-1===p){const t=D(pr,4);ja(u,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],i=D(pr,4);ja(c,i);const n=[],r=[],o=Wn(e,3,s,3,null,0,[i[0].x,i[1].x,i[2].x,i[3].x],3,[i[0].y,i[1].y,i[2].y,i[3].y],3,null,0,!0,A.unit(),A.unit(),n,r);if(o>0)for(let h=0;h<o;h++){const t=new w;xh(c,r[h],t);const e=new w;xh(u,n[h],e);w.distance(e,t)<=a&&(f.push(e.clone()),y.push(r[h]),x.push(n[h]))}else-1===o&&(P=!0)}for(let t=0;t<2;t++){const e=0===t?u:c,s=0===t?c:u;for(let i=0;i<2;i++){const n=0===i?0:3,r=[0];Xh(s,e[n],A.unit(),!1,-1,1,r);const o=new w;xh(s,r[0],o);w.distance(e[n],o)<=a&&(0===t?(x.push(0===n?0:1),y.push(r[0])):(y.push(0===n?0:1),x.push(r[0])),f.push(o.clone()))}}if(0===x.length&&P){const e=s.calculateUpperLength2D()>i.calculateUpperLength2D();{const n=[0,0];if(2===Hh(e?s:i,n,!0)&&(t(A.unit().containsCoordinate(n[0])),!A.unit().containsCoordinate(n[1]))){const t=new w;xh(e?u:c,n[0],t);const s=[0,0];1===Xh(e?c:u,t,A.unit(),!1,-1,2,s)&&(f.push(t.clone()),x.push(e?n[0]:s[0]),y.push(e?s[0]:n[0]))}}}if(0===x.length)return 0;if(!_.equalsRange(0,1))for(let t=0;t<x.length;++t)x[t]=lo.recalculateParentT(_.vmin,_.vmax,x[t]);if(!d.equalsRange(0,1))for(let t=0;t<y.length;++t)y[t]=lo.recalculateParentT(d.vmin,d.vmax,y[t]);return xE(e,s,i,x,y,x.length,n,r,o,a,h,m,l)}function qh(e,s,i,n,r,o,a,h,m,l){const u=Xi(s,i);if(i.isDegenerateToLineHelper(u)){const t=new CE({start:i.getStartXY(),end:i.getEndXY()}),u=Th(e,s,t,n,r,o,a,h,m,l);if(o)for(let e=0;e<u;++e){const s=t.getCoord2D(o[e]);o[e]=i.getClosestCoordinate(s,!1)}return u}if(ki(s,i,a=Math.max(a,u)))return 0;const c=D(w,4);s.queryControlPoints(c);const g=D(w,3);i.queryControlPoints(g);const _=new A(0,1),d=new A(0,1),p=[0,0,0];i.queryWeights(p);const f=[1,Ta(p),1];{const t=new ni;Vh(c,new A(0,1),t);const e=new ni;ia(g,f,new A(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Wh(c,t,_),Da(g,f,t,d),_.isEmpty()||d.isEmpty())return 0;fh(c,_.vmin,_.vmax,c),ma(g,f,d.vmin,d.vmax,g,f)}}const x=PE(c,3,g,2,a);if(0===x)return 0;const y=[],P=[],E=[];if(-1===x){const t=D(pr,4);ja(c,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],i=D(At,3),n=D(At,3),r=D(At,3);Ea(g,f,i,n,r);const o=[],h=[],m=Wn(i,2,n,2,r,2,e,3,s,3,null,0,!0,A.unit(),A.unit(),h,o);if(m>0)for(let l=0;l<m;l++){const t=new w;xh(c,o[l],t);const e=new w;wa(g,f,h[l],e);w.distance(t,e)<=a&&(y.push(t.clone()),P.push(o[l]),E.push(h[l]))}}for(let C=0;C<2;C++){let e,s;0===C?(e=c,s=g):(s=c,e=g);for(let i=0;i<2;i++){const n=0===i?0:e.length-1,r=[0],o=new w;if(0===C){const i=$o(s,f,e[n],A.unit(),!1,-1,1,r);t(1===i),wa(s,f,r[0],o)}else{const i=Xh(s,e[n],A.unit(),!1,-1,1,r);t(1===i),xh(s,r[0],o)}w.distance(e[n],o)<=a&&(0===C?(P.push(0===n?0:1),E.push(r[0])):(E.push(0===n?0:1),P.push(r[0])),y.push(o.clone()))}}if(0===P.length)return 0;if(!_.equalsRange(0,1))for(let t=0;t<P.length;++t)P[t]=lo.recalculateParentT(_.vmin,_.vmax,P[t]);if(!d.equalsRange(0,1))for(let t=0;t<E.length;++t)E[t]=Xa.recalculateParentT(d.vmin,d.vmax,E[t]);for(let t=0;t<E.length;++t)E[t]=Na(p,E[t]);return xE(e,s,i,P,E,P.length,n,r,o,a,h,m,l)}function Fh(e,s,i,n,r,o,a,h,m,l){const u=Xi(s,i);if(ki(s,i,a=Math.max(a,u)))return 0;const c=D(w,4);s.queryControlPoints(c);const g=D(w,3);i.queryControlPoints(g);const _=PE(c,3,g,2,a);if(0===_)return 0;const d=[],p=[],f=[];if(-1===_){const t=D(pr,4);ja(c,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],n=[t[0].y,t[1].y,t[2].y,t[3].y],r=D(pr,3);io(g,r);const o=Wn([r[0].x,r[1].x,r[2].x],2,[r[0].y,r[1].y,r[2].y],2,null,0,e,3,n,3,null,0,!0,A.unit(),A.unit(),f,p);if(o>0){let t=0;for(let e=0;e<o;e++){const n=new w;s.queryCoord2D(p[e],n);const r=new w;i.queryCoord2D(f[e],r);w.distance(n,r)<=a&&(d.push(n.clone()),p[t]=p[e],f[t]=f[e],t++)}p.length=t,d.length=t}}for(let x=0;x<2;x++){let e,s;0===x?(e=c,s=g):(s=c,e=g);for(let i=0;i<2;i++){const n=0===i?0:e.length-1,r=[0],o=new w;if(0===x)Gr(s,e[n],r),no(s,r[0],o);else{const i=Xh(s,e[n],A.unit(),!1,-1,1,r);t(1===i),xh(s,r[0],o)}w.distance(e[n],o)<=a&&(0===x?(p.push(0===n?0:1),f.push(r[0])):(f.push(0===n?0:1),p.push(r[0])),d.push(o.clone()))}}return xE(e,s,i,p,f,p.length,n,r,o,a,h,m,l)}function Mh(e,s,n,r,o){const a=new ni;if(Gh(e,A.unit(),a),a.inflate(r),!a.isIntersectingPoint2D(s))return 0;const h=Ja(e);let m=0,l=h.specialPoints[0];const u=[];for(let i=1,c=h.specialPoints.length;i<c;++i){const n=h.specialPoints[i],r=nh(e,s,l,n);if(0===u.length)u.push(r);else if(r.t===r.tmin)t(u.at(-1).d<=r.d),u.at(-1).tmax=r.tmax;else if(u.at(-1).t===u.at(-1).tmax){t(u.at(-1).d>=r.d);const e=u.at(-1).tmin;u[u.length-1]=r,u.at(-1).tmin=e}else u.push(r);l=n}for(const t of u)if(t.d<=r){const e=t.t;n?(m>=n.length&&i(""),n[m]=e,m++):m++}return m}function Gh(t,e,s){const i=D(w,4);t.queryControlPoints(i),Vh(i,e,s)}function Vh(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,4);const i=D(w,4);fh(t,e.vmin,e.vmax,i),s.setFromPoints(i,4)}class Yh{constructor(t,e){this.controlPoints=t,this.point=e.clone()}getMaxDerivative(){return 6}getValue(t,e){switch(t){case 0:{const t=new w;xh(this.controlPoints,e,t);const s=hh(this.controlPoints,1,e);return 2*t.sub(this.point).dotProduct(s)}case 1:{const t=new w;xh(this.controlPoints,e,t);const s=hh(this.controlPoints,1,e),i=hh(this.controlPoints,2,e);return 2*(t.sub(this.point).dotProduct(i)+s.dotProduct(s))}case 2:{const t=new w;xh(this.controlPoints,e,t);const s=hh(this.controlPoints,1,e),i=hh(this.controlPoints,2,e),n=hh(this.controlPoints,3,e);return 2*(t.sub(this.point).dotProduct(n)+3*s.dotProduct(i))}case 3:{const t=hh(this.controlPoints,1,e),s=hh(this.controlPoints,2,e),i=hh(this.controlPoints,3,e);return 2*(4*t.dotProduct(i)+3*s.sqrLength())}case 4:{const t=hh(this.controlPoints,2,e),s=hh(this.controlPoints,3,e);return 2*(10*t.dotProduct(s))}case 5:{const t=hh(this.controlPoints,3,e);return 2*(10*t.dotProduct(t))}default:return 0}}getError(e){return t(0),0}}function Xh(e,s,i,n,r,o,a){f(A.unit().contains(i)&&o>0,"getClosestCoordinate"),(r<0||Number.isNaN(r))&&(r=Number.MAX_VALUE);const h=[],m=new w;xh(e,i.vmin,m);let l=w.distance(m,s);if(l<=r&&h.push(new w(i.vmin,l)),i.vmin!==i.vmax&&(xh(e,i.vmax,m),l=w.distance(m,s),l<=r&&h.push(new w(i.vmax,l))),i.width()>0){const t=new Array(18),n=xn(new Yh(e,s),i,18,t);for(let i=0;i<n;i++)xh(e,t[i],m),l=w.distance(m,s),l>r||h.push(new w(t[i],l))}if(n){t(i.equals(A.unit()));{xh(e,-1,m,!0);const t=new w;xh(e,0,t);const i=new CE({start:m,end:t}),n=i.getClosestCoordinate(s,!0);n<1&&(m.assign(i.getCoord2D(n)),l=w.distance(m,s),l<=r&&h.push(new w(n-1,l)))}{xh(e,2,m,!0);const t=new w;xh(e,i.vmax,t);const n=new CE({start:t,end:m}),o=n.getClosestCoordinate(s,!0);o>0&&(m.assign(n.getCoord2D(o)),l=w.distance(m,s),l<=r&&h.push(new w(1+o,l)))}}if(!h.length)return 0;h.sort(((t,e)=>t.compare(e)));let u=0;const c=h[0].x;if(a[u++]=c,u<o){const t=Es(e,4,!1).total(),s=h[0].y;for(let e=1,i=h.length;e<i;e++)if(h[e].y>s+t){h.length=e;break}h.sort(((t,e)=>Ft(t.x,e.x))),u=0,a[u++]=h[0].x;for(let e=1,i=h.length;e<i;e++)h[e].x!==a[u-1]&&u<o&&(a[u++]=h[e].x)}return u}function kh(t,e,s,i,n,r,o){const a=D(w,4);return t.queryControlPoints(a),Xh(a,e,s,i,n,r,o)}function Rh(t){return t.getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp[0].norm(1)+t.m_cp[1].norm(1)}function Bh(t){return t[0].norm(1)+t[1].norm(1)+t[2].norm(1)+t[3].norm(1)}function Lh(e,s,i){if(t(i>=2),2===i){const t=new w;lt(s[0],s[i-1],1/3,t);const n=new w;return lt(s[0],s[i-1],2/3,n),void e.construct(s[0],t,n,s[i-1])}const n=s[0],r=s[i-1],o=[0,0],a=kh(e,n,A.unit(),!1,Number.NaN,2,o),h=[0,0],m=kh(e,r,A.unit(),!1,Number.NaN,2,h),l=[];for(let t=0;t<a;t++)for(let a=0;a<m;a++){const m=o[t],u=h[a],c=(t,o)=>{const a=[];a.length=i-2;const h=()=>{let t=0;for(let e=1,n=i-1;e<n;e++){t+=w.distance(s[e-1],s[e]);const i=t;a[e-1]=i}t+=w.distance(s[i-2],s[i-1]);for(let e=1,s=i-1;e<s;e++)a[e-1]/=t};let l=!1,c=!1;{const s=new SE;m<=u?(e.queryCut(m,u,s,!0),t.assign(s.get().getControlPoint1()),o.assign(s.get().getControlPoint2())):(e.queryCut(u,m,s,!0),t.assign(s.get().getControlPoint2()),o.assign(s.get().getControlPoint1())),n.equals(t)&&(l=!0),r.equals(o)&&(c=!0)}h();let g=Number.MAX_VALUE;const _=t.clone(),d=o.clone();for(let e=0;e<5;e++){g=tm(!0,!1,n,_,d,r,l,c,a,i-2,s,i)}for(let e=0;e<30;e++){const t=_.clone();d.clone();const e=tm(!0,!0,n,_,d,r,l,c,a,i-2,s,i);if(g<=e&&t.equals(_)&&t.equals(d))break;g=e}h();let p=!1,f=Number.EPSILON;const x=t.clone(),y=o.clone();for(let e=0;e<30;e++){const t=x.clone();y.clone();const e=tm(p,!0,n,x,y,r,l,c,a,i-2,s,i);if(f<=e&&t.equals(x)&&t.equals(y))break;p=!0,f=e}return f<g?(t.assign(x),o.assign(y)):(t.assign(_),o.assign(d),f=g),f},g=new w,_=new w,d=[c(g,_),w.distance(n,g)+w.distance(g,_)+w.distance(_,r),g.x,g.y,_.x,_.y];l.splice(l.length,0,...d)}let u=l[0],c=l[1],g=0;for(let t=6;t<l.length;t+=6)l[t]<u&&(u=l[t],c=l[t+1],g=t);let _=g;for(let t=0;t<l.length;t+=6)t!==g&&l[t+1]<c&&Math.abs(u-l[t])<10*u&&(c=l[t+1],_=t);e.construct(n,new w(l[_+2],l[_+3]),new w(l[_+4],l[_+5]),r)}function Hh(t,e,s=!1){const i=D(w,4);t.queryControlPoints(i);const n=D(pr,4);let r,o,a;ja(i,n,!0);const h=n[3].x.isZero(),m=n[3].y.isZero();if(h||m)if(h&&!m){if(n[2].x.isZero())return 0;r=n[1].x.div(n[2].x).negate(),o=n[2].y.div(n[3].y),a=n[1].y.div(n[3].y)}else{if(h||!m)return 0;if(n[2].y.isZero())return 0;r=n[1].y.div(n[2].y).negate(),o=n[2].x.div(n[3].x),a=n[1].x.div(n[3].x)}else{n[2].x.divThis(n[3].x),n[1].x.divThis(n[3].x),n[2].y.divThis(n[3].y),n[1].y.divThis(n[3].y);const t=n[2].x.sub(n[2].y);if(t.isZero())return 0;r=n[1].x.sub(n[1].y).div(t).negate(),o=n[2].x.clone(),a=n[1].x.clone()}if(!s&&r.abs().value()>2)return 0;const l=[0,0],u=t.getStartXY().equals(t.getEndXY()),c=Pn(1,-r.toDouble(),r.add(o).mul(r).add(a).toDouble(),A.unit(),u,l);if(0===c)return 0;if(l[0]>=0&&l[0]<=1){const t=r.toDouble()-l[0];if(s||t>=0&&t<=1)return e[0]=l[0],e[1]=t,e[0]>e[1]&&(e[1]=q(e[0],e[0]=e[1])),2}if(2===c&&l[1]>=0&&l[1]<=1){const t=r.toDouble()-l[1];if(s||t>=0&&t<=1)return e[0]=l[1],e[1]=t,e[0]>e[1]&&(e[1]=q(e[0],e[0]=e[1])),2}return 0}function zh(t,e,s){const i=t[1].mulE(e[2]).subThisE(t[2].mulE(e[1])),n=t[1].mulE(e[3]).subThisE(t[3].mulE(e[1])).mulThis(3),r=t[2].mulE(e[3]).subThisE(t[3].mulE(e[2])).mulThis(3),o=D(ot,2);let a=Nn(r,n,i,new A(0,1),!1,o);a<0&&(a=0);let h=0;for(let m=0;m<a;m++)ht(o[m].value(),0,1)||(s[h].setE(o[m]),h++);return h}function Uh(e,s){s[0].set(0);let i=1;const n=D(ot,4);Oa(e,n,!0);const r=D(ot,4);Wa(e,r,!0);{const t=n[3].mul(3),e=n[2].mul(2),r=n[1].clone(),o=D(ot,2);let a=Nn(t,e,r,new A(0,1),!1,o);a<0&&(a=0);for(let n=0;n<a;n++)ht(o[n].value(),0,1)||(s[i]=o[n],i++)}{const t=r[3].mul(3),e=r[2].mul(2),n=r[1].clone(),o=D(ot,2);let a=Nn(t,e,n,new A(0,1),!1,o);a<0&&(a=0);for(let r=0;r<a;r++)ht(o[r].value(),0,1)||(s[i]=o[r],i++)}if(i+=zh(n,r,s.slice(i)),s[i].set(1),i++,i>2){z(s,0,i,((t,e)=>{const s=t.value(),i=e.value();return s<i?-1:s>i?1:0}));let t=0;const n=s[0].clone();let r=0;const o=Bh(e)*st(),a=new w;dh(e,s[0].value(),a);for(let h=1;h<i;h++){const i=new w;if(dh(e,s[h].value(),i),s[h].eq(n)||i.isEqualPoint2D(a,o)){if(0!==t){if(0===s[h].eps())n.setE(s[h]),r=0;else if(0!==r){const t=M(1/s[h].eps()),e=1/r,i=t+e;n.set((s[h].value()*t+n.value()*e)/i),r=1/i,n.setError(Math.sqrt(r))}s[t].setE(n),dh(e,n.value(),a)}}else t++,s[t].setE(s[h]),n.setE(s[h]),dh(e,n.value(),a),r=M(s[h].eps())}t++,i=t}return 1===i&&(i=2,s[1].set(1)),t(0===s[0].value()),t(1===s[i-1].value()),i}function Oh(t,e,s,i,n){const r=D(ot,4),o=D(ot,3),a=new A(0,1);let h=0;if(e){if(Wa(t,r,!1),h=An(r[3],r[2],r[1],r[0].sub(s),a,!1,o),i)for(let m=0;m<h;m++){const e=new w;xh(t,o[m].value(),e),i[m]=e.x}}else if(Oa(t,r,!1),h=An(r[3],r[2],r[1],r[0].sub(s),a,!1,o),i)for(let m=0;m<h;m++){const e=new w;xh(t,o[m].value(),e),i[m]=e.y}if(n)for(let m=0;m<h;m++)n[m]=o[m].value();else i&&z(i,0,h,Ft);return h}function Wh(t,e,s){s.setEmpty();const i=[];i.push(new A(0,1));const n=.5*Math.max(e.width(),e.height());for(;i.length;){const r=i.at(-1);i.pop();const o=new ni;if(Vh(t,r,o),o.isIntersectingW(e)){const t=Math.max(o.width(),o.height());if(e.containsW(o)||t<=n||r.width()<1e-12)s.merge(r);else{const t=r.getCenter();i.push(A.construct(r.vmin,t)),i.push(A.construct(t,r.vmax))}}}}function jh(t,e,s){s.length=0;{const e=new ot;rh(t,e);const i=new pi;if(Ch(t,e,i),i.isZero())return e.isZero()||e.eq(new ot(1))?0:(s.push(e.value()),1)}const i=D(ot,4);za(t,i,!0);const n=D(ot,4);Ua(t,n,!0);const r=D(ot,6),o=i[3].negate().mulE(n[1]).addE(i[2].mulE(n[2]).mul(2)).addE(i[1].mulE(n[3])),a=i[3].negate().mulE(n[1]).subE(i[2].mulE(n[2]).mul(2)).addE(i[1].mulE(n[3])),h=i[2].mulE(i[2]).subE(n[2].mulE(n[2]));r[0]=n[1].mulE(n[1]).mulE(o).addE(i[1].mulE(i[1]).mulE(a)).addE(i[1].mulE(n[1]).mulE(h).mul(2)).mul(6),r[1]=i[2].mulE(n[1]).subE(i[1].mulE(n[2])).mulE(i[2].mulE(i[2]).addE(i[1].mulE(i[3]).mul(2)).addE(n[2].mulE(n[2])).addE(n[1].mulE(n[3]).mul(2))).mul(24);const m=i[1].mulE(n[2]).mulE(n[2]).mulE(n[3]),l=i[2].mulE(i[2]).mulE(i[3]).mulE(n[1]).subE(m).mul(156),u=i[3].mulE(n[1]).subE(i[1].mulE(n[3])),c=i[3].mulE(n[1]).subE(i[1].mulE(n[3])),g=i[1].mulE(i[3]).mulE(c).addE(n[1].mulE(n[3]).mulE(u)).mul(72),_=n[1].mulE(n[3]).subE(i[1].mulE(i[3])),d=i[2].mulE(n[2]).mulE(_).mul(120),p=i[1].mulE(i[2]).mulE(i[2]).mulE(n[3]),f=i[3].mulE(n[1]).mulE(n[2]).mulE(n[2]).subE(p).mul(36);r[2]=l.addE(g).addE(d).addE(f);const x=i[2].mulE(i[3]).mulE(i[3]).mulE(n[1]).subE(i[1].mulE(n[2]).mulE(n[3]).mulE(n[3])).mul(360),y=i[2].mulE(n[2]).mulE(i[2].mulE(i[3]).subE(n[2].mulE(n[3]))).addE(i[3].mulE(n[2]).mulE(n[2]).mulE(n[2])).subE(i[2].mulE(i[2]).mulE(i[2]).mulE(n[3])).mul(24),P=i[2].mulE(n[1]).mulE(n[3]).mulE(n[3]).subE(i[1].mulE(i[3]).mulE(i[3]).mulE(n[2])).mul(72),E=i[3].mulE(n[3]).mulE(n[1].mulE(n[2]).subE(i[1].mulE(i[2]))).mul(288);r[3]=x.addE(y).addE(P).addE(E),r[4]=n[3].mulE(n[3]).addE(i[3].mulE(i[3])).mulE(i[3].mulE(n[1]).subE(i[1].mulE(n[3]))).mul(270).addE(i[3].mulE(n[2]).subE(i[2].mulE(n[3]))).mulE(i[2].mulE(i[3]).addE(n[2].mulE(n[3]))).mul(180),r[5]=i[3].mulE(n[2]).subE(i[2].mulE(n[3])).mulE(i[3].mulE(i[3]).addE(n[3].mulE(n[3]))).mul(216);const C=D(ot,5),S=qn(r,5,new A(0,1),!1,C,5);if(S>0){let i=Math.abs(t.getCurvature(0)),n=0;const r=Math.abs(t.getCurvature(1));(r>i||!Number.isFinite(r))&&(n=1);for(let e=0;e<S;e++){const s=Math.abs(t.getCurvature(C[e].value()));t.getCoord2D(C[e].value()),(s>i||!Number.isFinite(s))&&(i=s,n=C[e].value())}if((!Number.isFinite(i)||1/i<e)&&!ht(n,0,1)){const e=t.getCoord2D(n);if(!e.equals(t.getStartXY())&&!e.equals(t.getEndXY()))return s.push(n),1}}return 0}class Zh{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-Za(this.b,e,!1):0}getError(e){return t(0),0}}function Qh(e,s,i,n,r,o,a){for(;;){const h=w.distance(s[0],s[3]),m=w.distance(s[0],s[1])+w.distance(s[1],s[2])+w.distance(s[2],s[3]);if(m-h<=n+i*m)return e+_t(h,m,.5);const l=t=>hh(s,1,t).length();if(0===o){t(a<8);let h=l(0),u=l(1);r[0]+=2,h>u&&(u=q(h,h=u),s[3]=q(s[0],s[0]=s[3]),s[2]=q(s[1],s[1]=s[2]));let c=h/(h+u),g=1,_=m;for(;c<1/32&&_>=32*(n+i*_);){g/=4;const t=l(g);r[0]++,c=h/(t+h);const e=new w;if(xh(s,.5*g,e),_=w.distance(e,s[0]),_<=n){const t=new w;xh(s,g,t),_+=w.distance(t,e)}}if(1!==g){const t=D(w,4);ph(s,g,s,t),e=Qh(e,t,i,n,r,0,a+1),o++,a++;continue}}const u=8;r[0]+=u;const c=xo(u,l,0,1),g=16;r[0]+=g;const _=xo(g,l,0,1);let d=Math.abs(c-_)>n+i*m;if(!d)return e+_;if(o<3){const t=D(w,4);ph(s,.5,s,t),e=Qh(e,t,i,n,r,o+1,a+1),o++,a++;continue}const p=32;r[0]+=p;const f=xo(p,l,0,1);if(d=Math.abs(_-f)>n+i*m,!d)return e+f;const x=64;r[0]+=x;const y=xo(x,l,0,1);if(d=Math.abs(f-y)>n+i*m,!d)return e+y;const P=128;r[0]+=P;const E=xo(P,l,0,1);return d=Math.abs(y-E)>n+i*m,e+E}}function Kh(t,e,s,i,n){if(s===e)return 0;const r=D(w,4);t.queryControlPoints(r);const o=D(w,4);fh(r,e,s,o);return Qh(0,o,i,n,[0],0,0)}function Jh(t,e,s,i,n){let r=!0;const o=cr(5,e,s,i,n,(e=>{const s=lh(t,1,e);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()}));r=!1;const a=cr(5,e,s,i,n,(e=>{const s=lh(t,1,e);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()}));return new w(o,a)}function $h(t,e,s,i,n,r,o,a,h){const m=D(w,4);t.queryControlPoints(m);const l=D(w,4);if(e.queryControlPoints(l),m[0].equals(l[0])){if(m[1].equals(l[1])&&m[2].equals(l[2])&&m[3].equals(l[3]))return s&&(s.length=0,s.push(m[0]),s.push(m[3])),i&&(i.length=0,i.push(0),i.push(1)),n&&(n.length=0,n.push(0),n.push(1)),!0;if(!m[0].equals(l[3]))return!1}return!!(m[0].equals(l[3])&&m[1].equals(l[2])&&m[2].equals(l[1])&&m[3].equals(l[0]))&&(i&&(i.length=0,i.push(0),i.push(1),h&&(i[1]=q(i[0],i[0]=i[1]))),n&&(n.length=0,n.push(1),n.push(0),h&&(n[1]=q(n[0],n[0]=n[1]))),s&&(s.length=0,s.push(m[0]),s.push(m[3]),h&&(s[1]=q(s[0],s[0]=s[1]))),!0)}function tm(t,e,s,i,n,r,o,a,h,m,l,u){let c=0,g=0,_=0,d=0,p=0,f=0,x=0;for(let P=1,E=u-1;P<E;P++){let e,o,a,m,u,y,E=-1,C=h[P-1];t&&(P>2?(C=T(2*h[P-2]-h[P-3],0,1),h[P-1]=C):2===P&&C<=h[0]&&(C=h[0]));for(let c=0;c<11&&(e=h[P-1],o=e*e,a=o*e,m=1-e,u=m*m,y=u*m,t)&&!(Math.abs(e-E)<1e-12)&&10!==c;c++){const t=s.x-2*i.x+n.x,a=s.x-3*i.x+3*n.x-r.x,m=s.y-2*i.y+n.y,c=s.y-3*i.y+3*n.y-r.y,g=s.x-i.x-2*t*e+a*o,_=-l[P].x+s.x*y+e*(3*i.x*u+e*(3*n.x-3*n.x*e+r.x*e)),d=s.y-i.y-2*m*e+c*o,p=-l[P].y+s.y*y+e*(3*i.y*u+e*(3*n.y-3*n.y*e+r.y*e));E=e;const f=e- -6*(g*_+d*p)/(6*(3*M(g)-(-2*t+2*a*e)*_)+6*(3*M(d)-(-2*m+2*c*e)*p));h[P-1]=T(f,P>1?h[P-2]:0,1)}c+=3*o*u*u,g+=3*a*y,_+=3*o*o*u;const S=-(y*s.x+a*r.x-l[P].x);d+=S*e*u,p+=S*o*m;const v=-(y*s.y+a*r.y-l[P].y);f+=v*e*u,x+=v*o*m}if(e){const t=c*_-g*g;Math.abs(t)>=1e-12*(Math.abs(c*_)+Math.abs(g*g))+1e-10?(o||(i.x=(d*_-p*g)/t,i.y=(f*_-x*g)/t),a||(n.x=(c*p-g*d)/t,n.y=(c*x-g*f)/t)):(lt(s,r,.3,i),lt(s,r,.6,n))}let y=0;for(let P=1,E=u-1;P<E;P++){const t=h[P-1],e=1-t,o=s.mul(Vt(e)),a=i.mul(3*t*e*e),m=n.mul(3*t*t*e),u=r.mul(Vt(t));y+=o.add(a).add(m).add(u).sub(l[P]).sqrLength()}return y}function em(t,e,s,i){const n=t.getPathStart(e),r=t.getPathEnd(e);if(r-n<3)return;const o=2*n,a=w.getNAN();s.queryPoint2D(o,a);const h=a.x,m=a.y,l=w.getNAN();s.queryPoint2D(o+2,l);const u=w.getNAN();for(let c=o+4,g=2*r;c<g;c+=2)s.queryPoint2D(c,u),i.pe((u.x-a.x)*(l.y-m)),a.setCoordsPoint2D(l),l.setCoordsPoint2D(u);i.pe((h-a.x)*(l.y-m))}function sm(t,e,s){for(;e.hasNextSegment();){const t=e.nextCurve();if(null===t)break;s.pe(2*t.calculateArea2DHelper())}}var im=Ce;class nm{static toSegType(t){let e=0;switch(t){case s.enumLine:e=1;break;case s.enumBezier:e=2;break;case s.enumEllipticArc:e=4;break;case s.enumRationalBezier2:e=8;break;case s.enumBezier2:e=16;break;default:m("")}return e}constructor(){this.m_segmentFlags=null,this.m_segmentParamIndex=null,this.m_segmentParams=null,this.m_curveCount=0,this.m_bezierCount=0,this.m_arcCount=0,this.m_rbezier2Count=0,this.m_bezier2Count=0,this.m_curveParamWritePoint=0}assignCopy(t){return this.m_segmentFlags=t.m_segmentFlags,this.m_segmentParamIndex=t.m_segmentParamIndex,this.m_segmentParams=t.m_segmentParams,this.m_curveCount=t.m_curveCount,this.m_bezierCount=t.m_bezierCount,this.m_arcCount=t.m_arcCount,this.m_rbezier2Count=t.m_rbezier2Count,this.m_bezier2Count=t.m_bezier2Count,this.m_curveParamWritePoint=t.m_curveParamWritePoint,this}}class rm extends si{constructor(t){super(t),this.m_cachedRingAreas2D=null,this.m_paths=null,this.m_pathFlags=null,this.m_curveData=null,t.move?(this.m_bPolygon=t.move.m_bPolygon,this.m_cachedLength2D=t.move.m_cachedLength2D,this.m_cachedArea2D=t.move.m_cachedArea2D,this.m_currentPathIndex=t.move.m_currentPathIndex,this.m_cachedRingAreas2D=t.move.m_cachedRingAreas2D,this.m_paths=t.move.m_paths,this.m_pathFlags=t.move.m_pathFlags,this.m_curveData=t.move.m_curveData,t.move.m_curveData=null,t.move.setEmpty()):(this.m_bPolygon=t.bPolygon,this.m_cachedLength2D=0,this.m_cachedArea2D=0,this.m_currentPathIndex=0)}getGeometryType(){return this.m_bPolygon?s.enumPolygon:s.enumPolyline}getDimension(){return this.m_bPolygon?2:1}changeRingStartPoint(s){t(this.m_bPolygon);const i=this.getPathIndexFromPointIndex(s),n=this.getPathStart(i);if(n===s)return;const r=this.getPathEnd(i);(s>=r||s<n)&&e("change_ring_start_point");for(let t=0,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),i=im.getComponentCount(e);this.m_vertexAttributes.get(t).rotate(n*i,s*i,r*i)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.rotate(n,s,r),this.m_curveData.m_segmentParamIndex.rotate(n,s,r))}setFillRule(t){this.m_bFillRule=1===t}getFillRule(){return this.m_bFillRule?1:0}isExteriorRingOGC(t){return!!this.m_bPolygon&&(this.updateOGCFlagsProtected(),!!(8&this.m_pathFlags.read(t)))}isExteriorRing(t){return this.calculateRingArea2D(t)>0}calculateRingArea2D(t){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedRingAreas2D.read(t)):0}updateRingAreas2DProtected(){if(!this.hasDirtyFlag(1024))return;const t=this.getPathCount();if(0===t)return this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=0),void this.setDirtyFlagProtected(1024,!1);const e=new Je(t),s=new Yt(0),i=new Yt(0);if(0!==this.m_pointCount){const n=this.getAttributeStreamRef(0);if(this.hasNonLinearSegments()){const t=new un({parent:this});for(t.stripAttributes();t.nextPath();){i.reset();const r=t.getPathIndex();em(this,r,n,i),sm(this,t,i);const o=.5*i.getResult();s.add(o),e.write(r,o)}}else for(let r=0;r<t;r++){i.reset(),em(this,r,n,i);const t=.5*i.getResult();s.add(t),e.write(r,t)}}this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=s.getResult(),this.m_cachedRingAreas2D=e,this.setDirtyFlagProtected(1024,!1))}getOGCPolygonCount(){if(!this.m_bPolygon)return 0;this.updateOGCFlagsProtected();let t=0;const e=this.getPathCount();for(let s=0;s<e;s++)8&this.m_pathFlags.read(s)&&t++;return t}getHashCodeImpl(){return t(0),0}equalsImpl(t){const e=t,s=this.getPathCount();if(s!==e.getPathCount())return!1;const i=this.hasNonLinearSegments();if(i!==e.hasNonLinearSegments())return!1;if(i){if(this.m_curveData.m_curveCount!==e.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==e.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(e.m_paths,0,s+1))return!1;if(this.m_bFillRule!==e.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(e.m_pathFlags,0,s))return!1;if(this.hasNonLinearSegments()){if(!this.m_curveData.m_segmentFlags.equals(e.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;for(let t=0,s=this.getPointCount();t<s;t++){const s=this.m_curveData.m_segmentFlags.read(t);if(!rm.isNonLinearSegmentFlag(s))continue;const i=this.m_curveData.m_segmentParamIndex.read(t),n=e.m_curveData.m_segmentParamIndex.read(t),r=fn(s);for(let t=0;t<r;t++){const s=this.m_curveData.m_segmentParams.read(i+t),r=e.m_curveData.m_segmentParams.read(n+t);if(!F(s,r))return!1}}}return!0}equalsImplTol(t,e){const s=t,i=this.getPathCount();if(i!==s.getPathCount())return!1;const n=this.hasNonLinearSegments();if(n!==s.hasNonLinearSegments())return!1;if(n){if(this.m_curveData.m_curveCount!==s.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==s.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(s.m_paths,0,i+1))return!1;if(this.m_bFillRule!==s.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(s.m_pathFlags,0,i))return!1;if(!n)return!0;if(!this.m_curveData.m_segmentFlags.equals(s.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;const r=this.querySegmentIterator(),o=s.querySegmentIterator();for(;r.nextPath();){if(!o.nextPath())return!1;for(;r.hasNextSegment();){const t=r.nextCurve(),s=o.nextCurve();if(!(t&&s&&t.equals(s,e))){if(!t&&!s)break;return!1}}}return!0}reserveImplImpl(t,e){this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(t,1),this.m_curveData.m_segmentParamIndex.resize(t,-1),this.checkCompactSegmentParams())}verifyStreamsAfterSizeChangeExtraImpl(){this.m_paths||(this.m_paths=Ue(1,0),this.m_pathFlags=Oe(1,0)),this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount,1),this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount,-1),this.checkCompactSegmentParams())}copyToImpl(t,e){const s=t;s.m_bPathStarted=!1,s.m_bFillRule=this.m_bFillRule,this.m_paths?s.m_paths=e?this.m_paths:this.m_paths.clone():s.m_paths=null,this.m_pathFlags?s.m_pathFlags=e?this.m_pathFlags:this.m_pathFlags.clone():s.m_pathFlags=null,this.m_curveData&&(s.m_curveData||(s.m_curveData=new nm),s.m_curveData.assignCopy(this.m_curveData),s.m_curveData.m_curveCount=0,s.updateCurveCounter(this.m_curveData.m_curveCount),e||(this.m_curveData.m_segmentParamIndex?s.m_curveData.m_segmentParamIndex=this.m_curveData.m_segmentParamIndex.clone():s.m_curveData.m_segmentParamIndex=null,this.m_curveData.m_segmentFlags?s.m_curveData.m_segmentFlags=this.m_curveData.m_segmentFlags.clone():s.m_curveData.m_segmentFlags=null,this.m_curveData.m_segmentParams?s.m_curveData.m_segmentParams=this.m_curveData.m_segmentParams.clone():s.m_curveData.m_segmentParams=null)),s.hasDirtyFlag(512)||(s.m_cachedLength2D=this.m_cachedLength2D),s.m_cachedRingAreas2D=null,s.hasDirtyFlag(1024)||(s.m_cachedArea2D=this.m_cachedArea2D,null!==this.m_cachedRingAreas2D&&(s.m_cachedRingAreas2D=e?this.m_cachedRingAreas2D:this.m_cachedRingAreas2D.clone()))}calculateArea2D(){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedArea2D):0}calculateLength2D(){if(!this.hasDirtyFlag(512))return this.m_cachedLength2D;const t=this.querySegmentIterator(),e=new Yt(0);for(;t.nextPath();)for(;t.hasNextSegment();)e.add(t.nextSegment().calculateLength2D());return this.hasDirtyFlag(512)&&(this.m_cachedLength2D=e.getResult()),this.setDirtyFlagProtected(512,!1),e.getResult()}calculatePathLength2D(t){const e=this.querySegmentIteratorAtVertex(this.getPathStart(t)),s=new Yt(0);for(;e.hasNextSegment();)s.add(e.nextSegment().calculateLength2D());return s.getResult()}calculateLength3D(e){return t(0),0}calculatePathLength3D(e,s){return t(0),0}copyTo(t){p(t.getGeometryType())||e(""),this!==t&&super.copyTo(t)}swap(e){t(0)}hasNonLinearSegments(){return 0!==this.getCurveCount()}getSegmentCount(){let t=this.getPointCount();if(!this.m_bPolygon){t-=this.getPathCount();for(let e=0,s=this.getPathCount();e<s;e++)this.isClosedPath(e)&&t++}return t}getSegmentCountPath(t){let e=this.getPathSize(t);return!this.isClosedPath(t)&&e>0&&e--,e}add(t,s){this===t&&e("Multi_path_impl::add");for(let e=0,i=t.getPathCount();e<i;e++)this.addPath(t,e,!s)}addPath(t,e,s){this.insertPath(-1,t,e,s)}addPathPoint2D(t,e,s){this.insertPath2D(-1,t,0,e,s)}addSegmentsFromPath(t,s,n,r,o){if(this===t&&e("Multi_path_impl.add_segments_from_path"),o||0!==this.getPathCount()||(o=!0),s<0&&(s=t.getPathCount()-1),(s>=t.getPathCount()||n<0||r<0||n+r>t.getSegmentCountPath(s))&&i("add_segments_from_path"),0===r)return;const a=t.getPathStart(s),h=t.isClosedPath(s)&&n+r===t.getSegmentCountPath(s);this.m_bPathStarted=!1,this.mergeVertexDescription(t.getDescription());let m=r;const l=a+n;let u=l+1;o&&(m++,u--),!o&&t.hasNonLinearSegments()&&1!==t.m_curveData.m_segmentFlags.read(l)&&(t.getXY(l).equals(this.getXY(this.m_pointCount-1))||e("add_segments_from_path: start point mismatch"));const c=this.m_pointCount;if(this.resizeImpl(this.m_pointCount+m),this.verifyAllStreamsAfterSizeChange(),o){if(0===m)return;this.m_paths.add(this.m_pointCount);let e=t.m_pathFlags.read(s);this.m_bPolygon&&(e|=1),this.m_pathFlags.write(this.m_pathFlags.size()-1,e),this.m_pathFlags.add(0)}else this.m_paths.write(this.m_pathFlags.size()-1,this.m_pointCount);const g=h?m-1:m;for(let e=0,i=this.m_description.getAttributeCount();e<i;e++){const s=this.m_description.getSemantics(e),i=im.getComponentCount(s),n=t.m_description.getAttributeIndex(s);if(g>0){if(n<0||!t.m_vertexAttributes.get(n)){const t=im.getDefaultValue(s);this.m_vertexAttributes.get(e).insertRange(i*c,t,g*i,i*c),h&&this.m_vertexAttributes.get(e).insertRange(i*c+g*i,t,i,i*c);continue}this.m_vertexAttributes.get(e).insertRangeFromStream(i*c,t.m_vertexAttributes.get(n),i*u,g*i,!0,i,i*c)}h&&this.m_vertexAttributes.get(e).insertRangeFromStream(i*(c+g),t.m_vertexAttributes.get(n),i*a,i,!0,i,i*(c+g))}if(this.hasNonLinearSegments()&&this.initSegmentData(0),t.hasNonLinearSegments()){let e=0;for(let s=0,i=l;s<r;s++){e+=fn(t.m_curveData.m_segmentFlags.read(i)),i++}if(e>0){this.initSegmentData(e);let s=l,i=c-(o?0:1),n=0;for(let e=0;e<r;e++){const e=t.m_curveData.m_segmentFlags.read(s);if(this.m_curveData.m_segmentFlags.write(i,e),rm.isNonLinearSegmentFlag(e)){n++;let r=t.m_curveData.m_segmentParamIndex.read(s);const o=fn(e);this.m_curveData.m_segmentParamIndex.write(i,this.m_curveData.m_curveParamWritePoint);for(let e=0;e<o;e++){const e=t.m_curveData.m_segmentParams.read(r);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,e),this.m_curveData.m_curveParamWritePoint++,r++}this.incCurveType(e,1)}else this.m_curveData.m_segmentParamIndex.write(i,-1);i++,s++}this.modifyCurveCounter(n)}}if(h){const t=this.getPathCount()-1,e=this.getPathStart(t),s=this.getPathEnd(t)-1,i=this.getXY(e),n=this.getXY(s);i.isEqualPoint2D(n)&&(--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount))}this.notifyModifiedFlags(2001)}reverseAllPaths(){for(let t=0,e=this.getPathCount();t<e;t++)this.reversePath(t)}reversePath(t){t>=this.getPathCount()&&e("");const s=this.getPathSize(t);if(0===s)return;const i=this.getPathStart(t),n=this.isClosedPath(t);if(this.hasNonLinearSegments()){let t=i;const e=new this.m_segmentBufferCTor;let r=!1;for(let i=0;i<s;i++,t++){const s=this.m_curveData.m_segmentFlags.read(t);if(!rm.isNonLinearSegmentFlag(s))continue;r=!0,this.querySegment(t,e,!0),e.get().reverse();const i=this.m_curveData.m_segmentParamIndex.read(t);e.get().writeInBufferStream(this.m_curveData.m_segmentParams,i)}if(r){const t=n?0:1;this.m_curveData.m_segmentFlags.reverseRange(i,s-t,1),this.m_curveData.m_segmentParamIndex.reverseRange(i,s-t,1)}}const r=n?1:0;for(let e=0,a=this.m_description.getAttributeCount();e<a;e++)if(this.m_vertexAttributes.get(e)){const t=this.m_description.getSemantics(e),n=im.getComponentCount(t);this.m_vertexAttributes.get(e).reverseRange(n*(i+r),n*(s-r),n)}const o=6&this.m_pathFlags.read(t);if(o){let e=0;4&o&&(e|=2),2&o&&(e|=4),this.m_pathFlags.clearBits(t,6),this.m_pathFlags.setBits(t,e)}this.notifyModifiedFlags(1233)}removePath(t){const s=this.getPathCount();t<0&&(t=s-1),t>=s&&e("");const i=this.getPathStart(t),n=this.getPathSize(t);for(let e=0,r=this.m_description.getAttributeCount();e<r;e++)if(this.m_vertexAttributes.get(e)){const t=this.m_description.getSemantics(e),s=im.getComponentCount(t);this.m_vertexAttributes.get(e).eraseRange(s*i,s*n,s*this.m_pointCount)}if(this.hasNonLinearSegments()){let t=0;for(let e=i,s=i+n;e<s;e++){const s=this.m_curveData.m_segmentFlags.read(e);rm.isNonLinearSegmentFlag(s)&&(this.incCurveType(s,-1),t++)}this.modifyCurveCounter(-t),this.m_curveData.m_segmentFlags.eraseRange(i,n,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(i,n,this.m_pointCount)}for(let e=t+1;e<=s;e++){const t=this.m_paths.read(e);this.m_paths.write(e-1,t-n)}if(this.m_pathFlags)for(let e=t+1;e<=s;e++){const t=this.m_pathFlags.read(e);this.m_pathFlags.write(e-1,t)}this.m_paths.resize(s),this.m_pathFlags.resize(s),this.m_pointCount-=n,this.m_reservedPointCount-=n,t===s-1&&(this.m_bPathStarted=!1),this.notifyModifiedFlags(2001),this.checkCompactSegmentParams(),this.dbgVerifyCurves()}dbgVerifyCurves(){}insertPath(t,s,i,n){this===s&&e("Multi_path_impl::insert_path");const r=this.getPathCount();if(!n&&s.hasNonLinearSegmentsPath(i))return t=this.insertPath(t,s,i,!0),this.reversePath(t),t;i>=s.getPathCount()&&e(""),t>r&&e(""),t<0&&(t=r),i<0&&(i=s.getPathCount()-1),this.m_bPathStarted=!1,this.mergeVertexDescription(s.getDescription());const o=s.getPathStart(i),a=s.getPathSize(i);if(0===a)return this.insertPath2D(t,null,0,0,!0);const h=this.m_pointCount,m=s.isClosedPath(i)&&!n?1:0;this.resizeImpl(this.m_pointCount+a),this.verifyAllStreamsAfterSizeChange();const l=t<r?this.getPathStart(t):h;for(let e=0,g=this.m_description.getAttributeCount();e<g;e++){const t=this.m_description.getSemantics(e),i=s.getDescription().getAttributeIndex(t),r=im.getComponentCount(t);if(i>=0&&s.m_vertexAttributes.get(i))0!==m&&this.m_vertexAttributes.get(e).insertRangeFromStream(l*r,s.m_vertexAttributes.get(i),r*o,r,!0,r,r*h),this.m_vertexAttributes.get(e).insertRangeFromStream((l+m)*r,s.m_vertexAttributes.get(i),r*(o+m),r*(a-m),n,r,r*(h+m));else{const s=im.getDefaultValue(t);this.m_vertexAttributes.get(e).insertRange(l*r,s,r*a,r*h)}}const u=h+a;this.m_paths.add(u);for(let e=r;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+a)}this.m_pathFlags.add(0);for(let e=r-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}let c=s.getPathFlagsStreamRef().read(i);if(c&=-9,this.m_bPolygon&&(c|=1),this.m_pathFlags.write(t,c),s.hasNonLinearSegments()){this.initSegmentData(0);let t=o,e=0;for(let i=0;i<a;i++){e+=fn(s.m_curveData.m_segmentFlags.read(t)),t++}if(e>0){null===this.m_curveData.m_segmentFlags?(this.m_curveData.m_segmentFlags=Oe(this.m_pointCount,1),this.m_curveData.m_segmentParamIndex=Ue(this.m_pointCount,-1)):(this.m_curveData.m_segmentFlags.insertRange(l,1,a,h),this.m_curveData.m_segmentParamIndex.insertRange(l,-1,a,h)),this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint+e):this.m_curveData.m_segmentParams=We(e),t=o;let i=l,n=0;for(let e=0;e<a;e++){const e=s.m_curveData.m_segmentFlags.read(t);if(rm.isNonLinearSegmentFlag(e)){this.m_curveData.m_segmentFlags.write(i,e),this.m_curveData.m_segmentParamIndex.write(i,this.m_curveData.m_curveParamWritePoint);const r=fn(e);let o=s.m_curveData.m_segmentParamIndex.read(t);for(let t=0;t<r;t++){const t=s.m_curveData.m_segmentParams.read(o);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,t),this.m_curveData.m_curveParamWritePoint++,o++}n++,this.incCurveType(e,1)}t++,i++}this.modifyCurveCounter(n)}}return this.notifyModifiedFlags(2001),t}insertPath2D(t,s,i,n,r){const o=this.getPathCount();(t>o||i<0)&&e(""),t<0&&(t=o),this.m_bPathStarted=!1;const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+n),0===n&&this.notifyModifiedFlags(32),this.verifyAllStreamsAfterSizeChange();const h=t<o?this.getPathStart(t):a;if(s)this.m_vertexAttributes.get(0).insertRangeFromPoints(2*h,s,i,n,r,2*a);else{const t=im.getDefaultValue(0);this.m_vertexAttributes.get(0).insertRange(2*h,t,2*n,2*a)}for(let e=1,m=this.m_description.getAttributeCount();e<m;e++){const t=this.m_description.getSemantics(e),s=im.getComponentCount(t),i=im.getDefaultValue(t);this.m_vertexAttributes.get(e).insertRange(h*s,i,s*n,s*a)}this.m_paths.add(this.m_pointCount);for(let e=o;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+n)}this.m_pathFlags.add(0);for(let e=o-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}return this.m_bPolygon&&this.m_pathFlags.write(t,1),this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h,1,n,a),this.m_curveData.m_segmentParamIndex.insertRange(h,-1,n,a)),this.notifyModifiedFlags(2001),t}insertPathFromMultipoint(t,s,i,n,r){const o=s.getImpl(),a=this.getPathCount();(t>a||i<0)&&e("");const h=n<0?o.getPointCount()-i:n;if(h>o.getPointCount()&&e(""),i>=o.getPointCount()&&e("pointsOffset"),t<0&&(t=a),this.m_bPathStarted=!1,this.mergeVertexDescription(o.getDescription()),0===h)return void this.insertPath2D(t,null,0,0,!0);const m=this.m_pointCount,l=i;this.resizeImpl(this.m_pointCount+h),this.verifyAllStreamsAfterSizeChange();const u=t<a?this.getPathStart(t):m;for(let e=0,_=this.m_description.getAttributeCount();e<_;e++){const t=this.m_description.getSemantics(e),s=o.getDescription().getAttributeIndex(t),i=im.getComponentCount(t);if(s>=0){const s=o.getAttributeStreamRef(t);this.m_vertexAttributes.get(e).insertRangeFromStream(u*i,s,i*l,i*h,r,i,i*m)}else{const s=im.getDefaultValue(t);this.m_vertexAttributes.get(e).insertRange(u*i,s,i*h,i*m)}}const c=m+h;this.m_paths.add(c);for(let e=a;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+h)}this.m_pathFlags.add(0);for(let e=a-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}let g=0;this.m_bPolygon&&(g|=1),this.m_pathFlags.write(t,g),this.notifyModifiedFlags(2001)}insertPoints(t,s,n,r,o,a,h){if(this===n&&e("Multi_path_impl.insert_points"),t<0&&(t=this.getPathCount()),r<0&&(r=n.getPathCount()-1),(t>this.getPathCount()||s>=0&&s>this.getPathSize(t)||r>=n.getPathCount()||a>n.getPathSize(r))&&i(""),!a)return;if(this.mergeVertexDescription(n.m_description),t===this.getPathCount()){this.m_paths.add(this.m_pointCount);let t=n.m_pathFlags.read(r);t&=-9,this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}s<0&&(s=this.getPathSize(t));const m=this.m_pointCount;this.resizeImpl(this.m_pointCount+a),this.verifyAllStreamsAfterSizeChange();const l=this.getPathStart(t),u=l+s;a<0&&(a=n.getPathSize(r));const c=n.getPathStart(r),g=c+a;for(let e=0,i=this.m_description.getAttributeCount();e<i;e++){const t=this.m_description.getSemantics(e),i=im.getComponentCount(t),r=n.m_description.getAttributeIndex(t);if(r<0||!n.m_vertexAttributes.get(r)){const s=im.getDefaultValue(t);this.m_vertexAttributes.get(e).insertRange(i*u,s,g*i,i*m)}else this.m_vertexAttributes.get(e)?.insertRangeFromStream(i*(l+s),n.m_vertexAttributes.get(r),i*(c+o),a*i,h,i,i*m)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(l+s,1,a,m),this.m_curveData.m_segmentParamIndex.insertRange(l+s,-1,a,m),s>0&&this.isNonLinearSegment(l+s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(l+s-1),-1),this.m_curveData.m_segmentFlags.write(l+s-1,1),this.m_curveData.m_segmentParamIndex.write(l+s-1,-1),this.modifyCurveCounter(-1)));for(let e=t+1,i=this.getPathCount();e<=i;e++){const t=this.m_paths.read(e);this.m_paths.write(e,t+a)}this.notifyModifiedFlags(2001)}insertPointsFromPoints(t,e,s,n,r,o){if(t<0&&(t=this.getPathCount()),(t>this.getPathCount()||e>this.getPathSize(t)||n<0)&&i(""),!r)return;t===this.getPathCount()&&(this.m_paths.add(this.m_pointCount),this.m_bPolygon?this.m_pathFlags.add(1):this.m_pathFlags.add(0)),e<0&&(e=this.getPathSize(t));const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const h=this.getPathStart(t);this.m_vertexAttributes.get(0).insertRangeFromPoints(2*(h+e),s,n,r,o,2*a);for(let i=1,m=this.m_description.getAttributeCount();i<m;i++){const t=this.m_description.getSemantics(i),s=im.getComponentCount(t),n=im.getDefaultValue(t);this.m_vertexAttributes.get(i).insertRange((h+e)*s,n,s*r,s*a)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h+e,1,r,a),this.m_curveData.m_segmentParamIndex.insertRange(h+e,-1,r,a),e>0&&this.isNonLinearSegment(h+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(h+e-1),-1),this.m_curveData.m_segmentFlags.write(h+e-1,1),this.m_curveData.m_segmentParamIndex.write(h+e-1,-1),this.modifyCurveCounter(-1)));for(let i=t+1,m=this.getPathCount();i<=m;i++)this.m_paths.write(i,this.m_paths.read(i)+r);this.notifyModifiedFlags(2001)}insertPointsFromMultipoint(t,e,s,n,r,o){const a=s.getImpl();if(t<0&&(t=this.getPathCount()),r<0&&(r=s.getPointCount()),(t>this.getPathCount()||e>=0&&e>this.getPathSize(t)||r>s.getPointCount())&&i(""),!r)return;if(this.mergeVertexDescription(a.getDescription()),t===this.getPathCount()){this.m_paths.add(this.m_pointCount);const t=0;this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}e<0&&(e=this.getPathSize(t));const h=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const m=this.getPathStart(t),l=m+e,u=0,c=u+r;for(let i=0,g=this.m_description.getAttributeCount();i<g;i++){const t=this.m_description.getSemantics(i),s=im.getComponentCount(t);if(a.getDescription().getAttributeIndex(t)<0){const e=im.getDefaultValue(t);this.m_vertexAttributes.get(i).insertRange(s*l,e,c*s,s*h);continue}const g=a.getAttributeStreamRef(t);this.m_vertexAttributes.get(i).insertRangeFromStream(s*(m+e),g,s*(u+n),r*s,o,s,s*h)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(m+e,1,r,h),this.m_curveData.m_segmentParamIndex.insertRange(m+e,-1,r,h),e>0&&this.isNonLinearSegment(m+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(m+e-1),-1),this.m_curveData.m_segmentFlags.write(m+e-1,1),this.m_curveData.m_segmentParamIndex.write(m+e-1,-1),this.modifyCurveCounter(-1)));for(let i=t+1,g=this.getPathCount();i<=g;i++){const t=this.m_paths.read(i);this.m_paths.write(i,t+r)}this.notifyModifiedFlags(2001)}insertPoint2D(t,e,s){const n=this.getPathCount();t<0&&(t=n),(t>n||t<n&&e>this.getPathSize(t))&&i(""),t===n&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o,h=this.m_vertexAttributes.get(0);if(a===r)this.m_paths.write(t+1,r+1),h.writePoint2D(2*a,s);else{h.insert(2*a,s,2*r);for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=im.getComponentCount(e),i=im.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(s*a,i,s,s*r)}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let e=t+1,s=n;e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}insertPoint(t,e,s){const n=this.getPathCount();t<0&&(t=n),(t>n||t<n&&e>this.getPathSize(t))&&i(""),t===n&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o;if(a===r)this.m_paths.write(t+1,r+1),this.setPointByVal(a,s);else{const e=s.getDescription();this.m_description!==e&&this.mergeVertexDescription(e);for(let t=0,i=this.m_description.getAttributeCount();t<i;t++){const i=this.m_description.getSemantics(t),n=im.getComponentCount(i);if(e.hasAttribute(i))this.m_vertexAttributes.get(t).insertAttributes(n*a,s,i,n*r);else{const e=im.getDefaultValue(i);this.m_vertexAttributes.get(t).insertRange(n*a,e,n,n*r)}}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let s=t+1,i=n;s<=i;s++)this.m_paths.write(s,this.m_paths.read(s)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}removePointFromPath(t,e){const s=this.getPathCount();t<0&&(t=s-1),(t>=s||e>=this.getPathSize(t))&&i("Multi_path.remove_point");const n=this.getPathStart(t),r=this.isClosedPath(t);e<0&&(e=this.getPathSize(t)-1),e<0&&i("Multi_path.remove_point");const o=n+e;for(let i=0,a=this.m_description.getAttributeCount();i<a;i++)if(this.m_vertexAttributes.get(i)){const t=this.m_description.getSemantics(i),e=im.getComponentCount(t);this.m_vertexAttributes.get(i).eraseRange(e*o,e,e*this.m_pointCount)}if(this.m_curveData&&this.m_curveData.m_segmentFlags){this.checkCompactSegmentParams();let e=0;if(o>n&&this.isNonLinearSegment(o-1))e+=1,this.incCurveType(this.m_curveData.m_segmentFlags.read(o-1),-1),this.m_curveData.m_segmentFlags.write(o-1,1),this.m_curveData.m_segmentParamIndex.write(o-1,-1);else{const s=this.getPathEnd(t);r&&n+1<s&&this.isNonLinearSegment(s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(s-1),-1),this.m_curveData.m_segmentFlags.write(s-1,1),this.m_curveData.m_segmentParamIndex.write(s-1,-1),e+=1)}this.isNonLinearSegment(o)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(o),-1),e+=1),e>0&&this.modifyCurveCounter(-e),this.m_curveData.m_segmentFlags.eraseRange(o,1,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(o,1,this.m_pointCount)}for(let i=s;i>=t+1;i--){const t=this.m_paths.read(i);this.m_paths.write(i,t-1)}this.m_pointCount--,this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}removePoint(t){let e;e=t<0?this.getPathCount()-1:this.getPathIndexFromPointIndex(t),this.removePointFromPath(e,t-this.getPathStart(e))}getNumberOfCurves(t){if(!this.hasNonLinearSegments())return 0;let e=0;for(let s=this.getPathStart(t),i=this.getPathEnd(t);s<i;s++)rm.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s))&&++e;return e}getPathCount(){return this.m_paths?this.m_paths.size()-1:0}getPathSize(t){return this.m_paths.read(t+1)-this.m_paths.read(t)}getPathStart(t){return this.m_paths.read(t)}getPathEnd(t){return this.m_paths.read(t+1)}getPathIndexFromPointIndex(t,e=-1){-1===e&&(e=this.m_currentPathIndex);const s=this.getPathCount(),i=rm.getPathIndexFromPointIndexImpl(this.m_paths,s,t,e);return this.m_currentPathIndex=i,i}startPathCoords(t,e){this.startPathPoint(new Ge({x:t,y:e}))}startPath(t){this.startPathPoint(new Ge({pt:t}))}startPath3D(t){this.startPathPoint(new Ge({x:t.x,y:t.y,z:t.z}))}startPath3DCoords(t,e,s){this.startPathPoint(new Ge({x:t,y:e,z:s}))}startPathPoint(t){t.isEmpty()&&e("");const s=t.getDescription();let i;if(this.m_description!==s){this.mergeVertexDescription(s);const e=new Ge({vd:this.m_description});t.copyCommonAttributesTo(e),i=e}else i=t;this.m_bPathStarted?this.setPointByVal(this.m_pointCount-1,i):(this.insertPoint(-1,-1,i),this.m_bPathStarted=!0)}beforeNewSegmentHelper2(){this.m_paths=Ue(2),this.m_paths.write(0,0),this.m_pathFlags=Oe(2,0),this.m_bPolygon&&this.m_pathFlags.write(0,1)}beforeNewSegmentHelper1(){null!==this.m_paths?(this.m_paths.add(0),this.m_pathFlags.add(0),this.m_bPolygon&&this.m_pathFlags.write(this.m_pathFlags.size()-2,1)):this.beforeNewSegmentHelper2()}beforeNewSegment(t){0!==this.m_pointCount||this.m_bPathStarted||this.startPathCoords(0,0);const e=this.m_pointCount,s=this.m_paths.size()-1,i=e+t;this.m_paths.write(s,i),this.resizeImpl(i),this.m_bPathStarted&&(this.m_bPathStarted=!1)}finishLineTo(){if(this.hasNonLinearSegments()){const t=this.m_curveData.m_segmentFlags.read(this.m_pointCount-1);1!==t&&(this.m_curveData.m_segmentFlags.write(this.m_pointCount-1,1),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-1,-1),this.modifyCurveCounter(-1),this.incCurveType(t,-1))}}lineToCoords(t,e){if(this.beforeNewSegment(1),1===this.m_description.getAttributeCount())this.setXYCoords(this.m_pointCount-1,t,e);else{const s=Ee(),i=new Ge({vd:this.m_description,attribBuffer:s,initDefaultValues:!0});i.setXYCoords(t,e),this.setPointByVal(this.m_pointCount-1,i)}this.finishLineTo()}lineTo(t){this.lineToCoords(t.x,t.y)}lineTo3D(t){this.beforeNewSegment(1);const e=we(this.m_description,Ae()),s=Ee(),i=new Ge({vd:e,attribBuffer:s,initDefaultValues:!0});i.setXYZ(t),this.setPointByVal(this.m_pointCount-1,i),this.finishLineTo()}lineTo3DCoords(t,e,s){this.lineTo3D(new Fe(t,e,s))}lineToPoint(t){if(this.beforeNewSegment(1),this.m_description===t.getDescription())this.setPointByVal(this.m_pointCount-1,t);else{this.mergeVertexDescription(t.getDescription());const e=Ee(),s=new Ge({vd:this.m_description,attribBuffer:e,initDefaultValues:!1});t.copyCommonAttributesTo(s),this.setPointByVal(this.m_pointCount-1,s)}this.finishLineTo()}openPathAndDuplicateStartVertex(t){this.m_bPolygon&&m("");const s=this.getPathCount();if(t>s&&e(""),!this.isClosedPath(t))return;this.m_pathFlags||m("");const i=this.m_pointCount,n=this.getPathStart(t),r=this.getPathEnd(t);if(r-n!=0){this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),s=im.getComponentCount(e);this.m_vertexAttributes.get(t).insertRangeFromStream(s*r,this.m_vertexAttributes.get(t),s*n,s,!0,1,s*i)}for(let e=s;e>t;e--){const t=this.m_paths.read(e);this.m_paths.write(e,t+1)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(r,1,1,i),this.m_curveData.m_segmentParamIndex.insertRange(r,-1,1,i)),this.m_pathFlags.clearBits(t,1)}}openPath(e){t(0)}isStrongPathStart(t){return!!(2&this.m_pathFlags.read(t))}setStrongPathStart(t,e){e?this.m_pathFlags.setBits(t,2):this.m_pathFlags.clearBits(t,2)}isStrongPathEnd(t){return!!(4&this.m_pathFlags.read(t))}setStrongPathEnd(t,e){e?this.m_pathFlags.setBits(t,4):this.m_pathFlags.clearBits(t,4)}clearStrongPathEnds(){for(let t=0,e=this.getPathCount();t<e;++t)this.m_pathFlags.clearBits(t,6)}openAllPathsAndDuplicateStartVertex(){if(this.m_bPolygon&&m(""),this.isEmpty())return;this.m_pathFlags||m("");let t=0;const e=this.getPathCount();for(let m=0;m<e;m++)this.isClosedPath(m)&&(this.getPathSize(m)>0?t++:this.m_pathFlags.clearBits(m,1));if(0===t)return;const s=this.hasNonLinearSegments();let i=0;const n=this.getPathCount(),r=this.m_description.getAttributeCount(),o=new Array(r);let a=null,h=null;for(let m=0;m<n;++m){const e=this.getPathStart(m),n=this.getPathSize(m),l=this.isClosedPath(m);if(n>0){const m=e+i;for(let s=0;s<r;s++)if(this.m_vertexAttributes.get(s)){const i=this.m_description.getSemantics(s),r=im.getComponentCount(i);if(!o[s]){const e=ze(i,r*(this.m_pointCount+t));o[s]=e}o[s].writeRange(m*r,n*r,this.m_vertexAttributes.get(s),e*r,!0,1),l&&o[s].writeRange((m+n)*r,r,this.m_vertexAttributes.get(s),e*r,!0,1)}if(s){if(null===a){const e=this.m_pointCount+t;a=Oe(e),h=Ue(e)}a.writeRange(m,n,this.m_curveData.m_segmentFlags,e,!0,1),h.writeRange(m,n,this.m_curveData.m_segmentParamIndex,e,!0,1),l&&(a.write(m+n,1),h.write(m+n,-1))}}this.m_paths.write(m,e+i),l&&(this.m_pathFlags.clearBits(m,1),++i)}this.m_paths.write(n,this.m_pointCount+t),this.m_pathFlags.clearBits(n,1);for(let m=0;m<r;m++)this.m_vertexAttributes.get(m)&&this.m_vertexAttributes.set(m,o[m]);s&&(this.m_curveData.m_segmentFlags=a,this.m_curveData.m_segmentParamIndex=h),this.m_pointCount+=t,this.m_reservedPointCount>0&&(this.m_reservedPointCount=this.m_pointCount)}closePathWithLine(t){void 0===t&&(t=this.getPathCount()-1),this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&e("close_path_with_line"),t===this.getPathCount()-1&&(this.m_bPathStarted=!1);const s=this.m_pathFlags.read(t);if(this.m_pathFlags.write(t,1|s),this.m_curveData&&this.m_curveData.m_segmentFlags){const e=this.getPathEnd(t)-1,s=this.m_curveData.m_segmentFlags.read(e);this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),1!==s&&(this.incCurveType(s,-1),this.modifyCurveCounter(-1))}this.notifyModifiedFlags(2001)}closeLastPathWithSegment(t){this.closePathWithSegment(this.getPathCount()-1,t)}closePathWithSegment(t,i){if(this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&e("close_path_with_line"),i.getEndXY().equals(this.getXY(this.getPathStart(t)))||e("close_path_with_segment: end point mismatch"),t===this.getPathCount()-1)this.m_bPathStarted=!1,this.addSegment(i,!1),--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount);else{this.mergeVertexDescription(i.getDescription());const n=i.getStartXY(),r=this.getPathEnd(t)-1;n.equals(this.getXY(r))||e("close_path_with_segment: start point mismatch");const o=i.getGeometryType();if(o===s.enumLine)return void this.closePathWithLine(t);{const t=pn(i);this.initSegmentData(t);const e=nm.toSegType(o),s=this.m_curveData.m_segmentFlags.read(r);if(s!==e)this.m_curveData.m_segmentParamIndex.write(r,this.m_curveData.m_curveParamWritePoint),i.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=t,this.incCurveType(e,1),1!==s?this.incCurveType(s,-1):this.modifyCurveCounter(1);else{const t=this.m_curveData.m_segmentParamIndex.read(r);i.writeInBufferStream(this.m_curveData.m_segmentParams,t)}this.m_curveData.m_segmentFlags.write(r,e)}}const n=this.m_pathFlags.read(t);this.m_pathFlags.write(t,1|n),this.notifyModifiedFlags(2001)}closeAllPaths(){if(this.m_bPolygon||this.isEmptyImpl())return;this.m_bPathStarted=!1;let t=!1;for(let e=0,s=this.m_paths.size()-1;e<s;e++){if(this.isClosedPath(e))continue;const s=this.m_pathFlags.read(e);this.m_pathFlags.write(e,1|s),t=!0}t&&this.notifyModifiedFlags(512)}isClosedPath(t){return!!(1&this.m_pathFlags.read(t))}isClosedPathInXYPlane(t){if(this.isClosedPath(t))return!0;const e=this.getPathStart(t),s=this.getPathEnd(t)-1;if(e>s)return!1;const i=this.getXY(e),n=this.getXY(s);return i.isEqualPoint2D(n)}isClosedPathIn3D(e){return t(0),!1}hasNonLinearSegmentsPath(t){if(!this.hasNonLinearSegments())return!1;for(let e=this.getPathStart(t),s=this.getPathEnd(t);e<s;e++)if(rm.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e)))return!0;return!1}isNonLinearSegment(t){return!(1&this.getSegmentFlags(t))}addEnvelope(t,e){if(t.isEmpty())return;const s=0===this.m_pointCount;if(t instanceof ge)this.startPathCoords(t.xmin,t.ymin),e?(this.lineToCoords(t.xmax,t.ymin),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmin,t.ymax)):(this.lineToCoords(t.xmin,t.ymax),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmax,t.ymin));else{const s=t.getDescription(),i=Ee(),n=new Ge({vd:s,attribBuffer:i,initDefaultValues:!1});for(let r=0,o=4;r<o;r++){const s=e?o-r-1:r;t.queryCornerByVal(s,n),0===r?this.startPathPoint(n):this.lineToPoint(n)}}this.closePathWithLine(),this.m_bPathStarted=!1,s&&!e&&(this.setDirtyFlagProtected(256,!1),this.m_bPolygon&&Math.min(t.width(),t.height())>0&&this.setIsSimple(3,0))}addPathFromClosedSegment(t,s){if(t.isClosed()||e("add_path_from_closedSegment: segment must be closed"),s){const e=t.getReversed(),s=new Ge;e.queryStart(s),this.startPathPoint(s),this.closeLastPathWithSegment(e)}else{const e=new Ge;t.queryStart(e),this.startPathPoint(e),this.closeLastPathWithSegment(t)}}addSegment_(t,i){const n=t.getDescription();this.mergeVertexDescription(n);const r=Ee(),o=new Ge({vd:n,attribBuffer:r,initDefaultValues:!1}),a=t.getGeometryType();if(a===s.enumLine)(i||this.isEmptyImpl())&&(t.queryStart(o),this.startPathPoint(o)),t.queryEnd(o),this.lineToPoint(o);else{let s=!1;if((i||this.isEmptyImpl())&&(s=!0),!s){t.getStartXY().equals(this.getXY(this.m_pointCount-1))||e("add_segment: start point mismatch")}if(s&&(t.queryStart(o),this.startPathPoint(o)),this.beforeNewSegment(1),t.queryEnd(o),o.getDescription()===this.m_description)this.setPointByVal(this.m_pointCount-1,o);else{const t=Ee(),e=new Ge({vd:this.m_description,attribBuffer:t,initDefaultValues:!1});o.copyCommonAttributesTo(e),this.setPointByVal(this.m_pointCount-1,e)}const n=pn(t);this.initSegmentData(n),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-2,this.m_curveData.m_curveParamWritePoint),t.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=n;const r=nm.toSegType(a);this.incCurveType(r,1),this.modifyCurveCounter(1),this.m_curveData.m_segmentFlags.write(this.m_pointCount-2,r)}}addSegment(t,e,s){s?e?this.addPathFromClosedSegment(t,!1):this.closeLastPathWithSegment(t):this.addSegment_(t,e)}interpolateAttributesRange(t,s,i,n){for(let a=t;a<i-1;a++)this.isClosedPath(a)&&e("cannot interpolate across closed paths");const r=this.m_description.getAttributeCount();if(1===r)return;const o=this.calculateSubLength2D(t,s,i,n);if(0!==o)for(let e=1;e<r;e++){const r=this.m_description.getSemantics(e);this.interpolateAttributesSemanticsImpl(r,t,s,i,n,o)}}interpolateAttributesSemantics(t,s,i,n,r){if(0===t)return;this.hasAttribute(t)||e("does not have the given attribute");2===im.getInterpolation(t)&&e("angular interpolation");for(let a=s;a<n-1;a++)this.isClosedPath(a)&&e("cannot interpolate across closed paths");const o=this.calculateSubLength2D(s,i,n,r);0!==o&&this.interpolateAttributesSemanticsImpl(t,s,i,n,r,o)}interpolateAttributesPath(t,e,s){const i=this.m_description.getAttributeCount();if(1===i)return;if(e===s)return;const n=this.calculatePathSubLength2D(t,e,s);for(let r=1;r<i;r++){const i=this.m_description.getSemantics(r);this.interpolateAttributesSemanticsPathImpl(i,t,e,s,n)}}interpolateAttributesSemanticsPath(t,s,i,n){if(0===t)return;this.hasAttribute(t)||e("does not have the given attribute");2===im.getInterpolation(t)&&e("angular interpolation");const r=this.calculatePathSubLength2D(s,i,n);0!==r&&this.interpolateAttributesSemanticsPathImpl(t,s,i,n,r)}interpolateAttributesSemanticsImpl(t,e,s,i,n,r){const o=this.querySegmentIterator(),a=this.getPathStart(e)+s,h=this.getPathStart(i)+n,m=im.getComponentCount(t),l=new Array(im.maxComponentCount());this.queryAttributeAsDbl(t,a,l,m);const u=new Array(im.maxComponentCount());this.queryAttributeAsDbl(t,h,u,m);const c=new Array(im.maxComponentCount());X(c,l,0,0,m);let g=0;const _=im.getDefaultValue(t),d=im.getInterpolation(t);o.resetToVertex(a,e);do{if(o.hasNextSegment()){if(o.nextSegment(),o.getStartPointIndex()===h)return;this.setAttributeFromArray(t,o.getStartPointIndex(),c,m),o.previousSegment();do{const e=o.nextSegment();if(o.getEndPointIndex()===h)return;g+=e.calculateLength2D();B(d,l,u,c,0,m,g/r,_),o.isClosingSegment()||this.setAttributeFromArray(t,o.getEndPointIndex(),c,m)}while(o.hasNextSegment())}}while(o.nextPath())}interpolateAttributesSemanticsPathImpl(t,e,s,i,n){const r=this.querySegmentIterator(),o=im.getInterpolation(t),a=this.getPathStart(e)+s,h=this.getPathStart(e)+i;if(h===a)return;const m=im.getComponentCount(t),l=new Array(im.maxComponentCount());this.queryAttributeAsDbl(t,a,l,m);const u=new Array(im.maxComponentCount());this.queryAttributeAsDbl(t,h,u,m);const c=new Yt(0);r.resetToVertex(a,e),r.setCirculator(this.isClosedPath(e));const g=im.getDefaultValue(t),_=new Array(im.maxComponentCount());X(_,l,0,0,m);const d=0===n;let p=.5;do{const e=r.nextSegment();if(this.setAttributeFromArray(t,r.getStartPointIndex(),_,m),!d){const t=e.calculateLength2D();c.pe(t),p=c.getResult()/n}B(o,l,u,_,0,m,p,g)}while(r.getEndPointIndex()!==h)}querySegment(t,s,i){const n=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(n);r>=this.getSegmentCountPath(n)&&e("get_segment"),this.getSegmentFromPath(n,r,s,i)}getSegment(t,e){const s=new this.m_segmentBufferCTor;return this.getSegmentBuffer(t,s,e),s.releaseSegment()}getSegmentType(t){const s=this.getPathIndexFromPointIndex(t),i=t-this.getPathStart(s);return i>=this.getSegmentCountPath(s)&&e("get_segment"),this.getSegmentTypeFromPath(s,i)}getSegmentFromPath(t,e,s,i){const n=this.getPathStart(t)+e,r=this.getSegmentFlagsStreamRef();let o=1;switch(r&&(o=31&r.read(n)),o){case 1:s.createLine();break;case 2:s.createCubicBezier();break;case 4:s.createEllipticArc();break;case 8:s.createQuadraticRationalBezier();break;case 16:s.createQuadraticBezier();break;default:m("")}const a=s.get();let h,l=null;i?(l=Ne(),a.assignVertexDescription(l)):a.assignVertexDescription(this.m_description),h=n===this.getPathEnd(t)-1&&this.isClosedPath(t)?this.getPathStart(t):n+1;bi(a,this.getXY(n));if(wi(a,this.getXY(h)),!i)for(let m=1,u=this.m_description.getAttributeCount();m<u;m++){const t=this.m_description.getSemantics(m),e=im.getComponentCount(t);for(let s=0;s<e;s++){const e=this.getAttributeAsDbl(t,n,s);a.setStartAttribute(t,s,e);const i=this.getAttributeAsDbl(t,h,s);a.setEndAttribute(t,s,i)}}if(rm.isNonLinearSegmentFlag(o)){const t=this.m_curveData.m_segmentParamIndex.read(n);a.readFromBufferStream(this.m_curveData.m_segmentParams,t)}}replaceLinearEllipticalArcsWithTrueLines(){if(!this.hasNonLinearSegments())return!1;if(0===this.m_curveData.m_arcCount)return!1;let t=!1;for(let e=0,s=this.getPointCount();e<s;e++){if(4===this.m_curveData.m_segmentFlags.read(e)){const s=this.m_curveData.m_segmentParamIndex.read(e);dn(this.m_curveData.m_segmentParams,s).isNAN()&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),this.incCurveType(4,-1),this.modifyCurveCounter(-1),t=!0)}}return t&&this.checkCompactSegmentParams(),t}queryPointAlongPath(t,s,i,n=!1){const r={iSegment:-1},o=n?r:{iSegment:-1,tSegment:0};if(i.setEmpty(),this.isEmpty())return r;if((t<0||t>=this.getPathCount())&&e("query_point_along_path"),s<0)return r;const a=this.getPathSize(t);if(0===a)return r;if(1===a)return this.getPointByVal(this.getPathStart(t),i),o.tSegment=0,r.iSegment=this.getPathStart(t),r;const h=this.querySegmentIteratorAtVertex(this.getPathStart(t)),m=new Yt(0);for(;h.hasNextSegment();){const t=h.nextSegment(),e=t.calculateLength2D(),n=m.getResult();if(m.add(e),m.getResult()>=s){let a=s-n;a>e&&(a=e);const m=t.lengthToT(a);return t.queryCoord(m,i),o.tSegment=m,r.iSegment=h.getStartPointIndex(),r}}if(this.isClosedPath(t)){const e=this.getPathStart(t);return this.getPointByVal(e,i),o.tSegment=1,r.iSegment=this.getPathEnd(t)-1,r}{const e=this.getPathEnd(t)-1;return this.getPointByVal(e,i),this.getPathSize(t)>1?(o.tSegment=1,r.iSegment=this.getPathEnd(t)-2,r):(o.tSegment=0,r.iSegment=this.getPathStart(t),r)}}queryPointsAlongPath(t,s,i,n,r,o){{let t=0;for(let a=0;a<s;++a)n&&n[a].setEmpty(),r&&(r[a]=-1),o&&(o[a]=0),t>i[a]&&e("query_points_along"),t=i[a]}const a=this.getPathSize(t);if(0===s||0===a)return 0;if(1===a){const e=this.getPathStart(t);return n&&this.getPointByVal(e,n[0]),o&&(o[0]=0),r&&(r[0]=e),1}const h=this.getPathStart(t),m=new Yt(0),l=this.querySegmentIteratorAtVertex(h);let u=0,c=0,g=i[u];for(;l.hasNextSegment();){const t=l.nextSegment(),e=t.calculateLength2D(),a=m.getResult();for(m.add(e);m.getResult()>=g;){let h=g-a;h>e&&(h=e);const m=t.lengthToT(h);if(n&&t.queryCoord(m,n[c]),o&&(o[c]=m),r&&(r[c]=l.getStartPointIndex()),c++,u++,g=i[u],u===s)return c}}if(this.isClosedPath(t)){const e=this.getPathStart(t),s=0;n&&this.getPointByVal(e,n[c]),o&&(o[c]=s),r&&(r[c]=e),c++}else if(this.getPathSize(t)>1){const e=this.getPathEnd(t)-2,s=1;n&&this.getPointByVal(e+1,n[c]),o&&(o[c]=s),r&&(r[c]=e),c++}return c}queryPointsAlong(t,s,i,n,r){{let o=0;for(let a=0;a<t;++a)i&&i[a].setEmpty(),n&&(n[a]=-1),r&&(r[a]=0),o>s[a]&&e("query_points_along"),o=s[a]}if(0===t)return 0;const o=new Yt(0),a=this.querySegmentIterator();let h=-1,m=0,l=0,u=s[m];for(;a.nextPath();)for(;a.hasNextSegment();){h=a.getPathIndex();const e=a.nextSegment(),c=e.calculateLength2D(),g=o.getResult();for(o.add(c);o.getResult()>=u;){let o=u-g;o>c&&(o=c);const h=e.lengthToT(o);if(i&&e.queryCoord(h,i[l]),r&&(r[l]=h),n&&(n[l]=a.getStartPointIndex()),l++,m++,u=s[m],m===t)return l}}if(h<0)return 0;if(this.isClosedPath(h)){const t=this.getPathStart(h),e=0;i&&this.getPointByVal(t,i[l]),r&&(r[l]=e),n&&(n[l]=t),l++}else if(this.getPathSize(h)>1){const t=this.getPathEnd(h)-2,e=1;i&&this.getPointByVal(t+1,i[l]),r&&(r[l]=e),n&&(n[l]=t),l++}return l}querySegmentIterator(){return new un({parent:this})}querySegmentIteratorAtVertex(t){return new un({parent:this,pointIndex:t})}queryPathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!0)}queryLoosePathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!1)}queryPathEnvelopeImpl(s,i,n){if(i instanceof ke&&t(0,"not implemented for Envelope"),i instanceof _e&&t(0,"not implemented for Envelope3D"),(s>=this.getPathCount()||s<0)&&e(""),this.isEmpty())return void i.setEmpty();const r=this.getAttributeStreamRef(0),o=ge.constructEmpty();o.setEmpty();for(let e=2*this.getPathStart(s),a=2*this.getPathEnd(s);e<a;){const s=a-e;t(!(1&s)),o.mergePointsInterleaved(r,e/2,s/2),e+=s}if(i.setCoords({env2D:o}),this.hasNonLinearSegmentsPath(s)){const e=this.querySegmentIterator();if(e.resetToPath(s),e.nextPath())for(;e.hasNextSegment();){const t=e.nextCurve();if(!t)break;{const e=ge.constructEmpty();n?t.queryEnvelope(e):t.queryLooseEnvelope(e),i.mergeEnvelope2D(e)}}else t(0)}}checkCompactSegmentParams(){if(!this.m_curveData||null===this.m_curveData.m_segmentParams)return!1;if(this.m_curveData.m_segmentParams.size()<=this.m_vertexAttributes.get(0).size())return!1;const t=10,e=fn(4)*this.m_curveData.m_arcCount+fn(2)*this.m_curveData.m_bezierCount+fn(8)*this.m_curveData.m_rbezier2Count+fn(16)*this.m_curveData.m_bezier2Count;return this.m_curveData.m_segmentParams.size()>Math.max(3*e>>1,t)?(this.forceCompactSegmentParams(),!0):(0===this.m_pointCount&&(this.m_curveData.m_curveParamWritePoint=0),!1)}forceCompactSegmentParams(){let t=0;for(let i=0,n=this.getPointCount();i<n;i++){const e=this.m_curveData.m_segmentFlags.read(i);if(rm.isNonLinearSegmentFlag(e)){t+=fn(e)}}const e=We(t);let s=0;for(let i=0,n=this.getPointCount();i<n;i++){const t=this.m_curveData.m_segmentFlags.read(i);if(rm.isNonLinearSegmentFlag(t)){let n=this.m_curveData.m_segmentParamIndex.read(i);this.m_curveData.m_segmentParamIndex.write(i,s);const r=fn(t);for(let t=0;t<r;t++)e.write(s,this.m_curveData.m_segmentParams.read(n)),s++,n++}}this.m_curveData.m_segmentParams=e,this.m_curveData.m_curveParamWritePoint=s}setPathsFromJsonArrays(e,i,n){t(!1===i),t(!1===e),this.setEmpty();const r=n.length;if(0===r)return;let o=0;for(const t of n)o+=t.length;const a=this.getGeometryType()===s.enumPolygon,h=new Je(2*o),m=new Qe(r+1);let l=0,u=0;for(let t=0;t<r;++t){m.write(t,l);const e=n[t],s=e.length;for(let t=0;t<s;++t)h.write(u++,e[t][0]),h.write(u++,e[t][1]);a&&s>2&&h.read(2*l)===h.read(u-2)&&h.read(2*l+1)===h.read(u-1)&&(u-=2,o--,l--),l+=n[t].length}m.write(r,o);const c=new Ze(m.size());c.setRange(this.getGeometryType()===s.enumPolygon?1:0,0,r),c.write(r,0),this.setAttributeStreamRef(0,h),this.setPathFlagsStreamRef(c),this.setPathStreamRef(m),this.notifyModifiedFlags(65535)}setEmpty(){this.m_curveData&&(this.removeAllCurvesFromGlobalCounter(),this.m_curveData=null),this.m_bPathStarted=!1,this.m_paths=null,this.m_pathFlags=null,this.setEmptyImpl()}applyTransformation(t){this.applyTransformationToPath(t,-1)}applyTransformation3D(e){t(0)}getImpl(){return this}reserve(t){this.reserveImpl(t),t>0&&!this.m_paths&&(this.m_paths=Ue(0),this.m_pathFlags=Oe(0),this.m_paths.reserve(2),this.m_pathFlags.reserve(2),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,0))}reserveParts(t,e){this.reserveImpl(t),e>0&&(this.m_paths?(this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1)):(this.m_paths=Ue(0),this.m_pathFlags=Oe(0),this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,0)))}clone(){const t=this.createInstance();return this.copyTo(t),t}createShallowClone(){return t(0),this}queryLimitedSegmentIterator(t){return new om(this,t)}getPathStreamRef(){return this.throwIfEmpty(),this.m_paths}setPathStreamRef(t){this.m_paths=t}getSegmentFlagsStreamRef(){return this.throwIfEmpty(),null!=this.m_curveData?this.m_curveData.m_segmentFlags:null}getPathFlagsStreamRef(){return this.throwIfEmpty(),this.m_pathFlags}setPathFlagsStreamRef(t){this.m_pathFlags=t}getSegmentIndexStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParamIndex:null}getSegmentDataStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParams:null}setSegmentData(t,e,s,i){this.m_curveData||(this.m_curveData=new nm),this.m_curveData.m_segmentFlags=s,this.m_curveData.m_segmentParams=e,this.m_curveData.m_segmentParamIndex=t,this.m_curveData.m_curveParamWritePoint=i}static getPathIndexFromPointIndexImpl(t,e,s,i){if(i>=0&&i<e){if(s>=t.read(i)){if(s<t.read(i+1))return i;i++}else i--;if(i>=0&&i<e&&s>=t.read(i)&&s<t.read(i+1))return i}if(e<5){for(let i=0;i<e;i++)if(s<t.read(i+1))return i;x("")}let n=0,r=e-1;for(;r>n;){const e=n+(r-n>>1);if(s<t.read(e))r=e-1;else{if(!(s>=t.read(e+1)))return e;n=e+1}}return n}getHighestPointIndex(e){t(e>=0&&e<this.getPathCount());const s=this.getAttributeStreamRef(0),i=this.getPathEnd(e),n=this.getPathStart(e);let r=-1;const o=new w;o.y=Number.NEGATIVE_INFINITY,o.x=Number.NEGATIVE_INFINITY;for(let t=n+0;t<i;t++){const e=s.readPoint2D(2*t);-1===o.compare(e)&&(r=t,o.setCoordsPoint2D(e))}return r}applyTransformationToPath(t,s){if(s>=this.getPathCount()&&e("apply_transformation"),this.isEmpty())return;if(t.isIdentity())return;const i=this.m_vertexAttributes.get(0);if(!(s<0?this.hasNonLinearSegments():this.hasNonLinearSegmentsPath(s))){let e,n;return s<0?(e=0,n=this.m_pointCount):(e=this.getPathStart(s),n=this.getPathEnd(s)),i.applyTransformation(t,2*e,n-e),void this.notifyModifiedFlags(2001)}const n=new this.m_segmentBufferCTor,r=this.getPathCount();let o=s<0?0:s;do{const e=this.getPathStart(o),r=this.getPathEnd(o),a=this.isClosedPath(o),h=i.readPoint2D(2*e);if(!this.hasNonLinearSegmentsPath(o)){i.applyTransformation(t,2*e,r-e);continue}const m=w.getNAN();for(let s=e;s<r;++s){if(1!==(31&this.m_curveData.m_segmentFlags.read(s))){const o=a&&s+1===r;o&&i.writePoint2D(2*e,h),this.getSegmentBuffer(s,n,!0),n.get().applyTransformation(t);const m=this.m_curveData.m_segmentParamIndex.read(s);n.get().writeInBufferStream(this.m_curveData.m_segmentParams,m),i.writePoint2D(2*s,n.get().getStartXY()),o&&i.writePoint2D(2*e,n.get().getEndXY());continue}const o=2*s;i.queryPoint2D(o,m),t.transformInPlace(m),i.writePoint2D(o,m)}if(o===s)break}while(++o<r);this.notifyModifiedFlags(2001)}calculateSubLength2D(t,e,s,i){const n=this.getPathStart(t)+e,r=this.getPathStart(s)+i;(r<n||n<0||r>this.getPointCount()-1)&&h("");const o=this.querySegmentIterator();let a=0;o.resetToVertex(n,t);do{for(;o.hasNextSegment();){const t=o.nextSegment();if(o.getStartPointIndex()===r)break;a+=t.calculateLength2D()}if(o.getStartPointIndex()===r)break}while(o.nextPath());return a}calculatePathSubLength2D(t,s,i){const n=this.getPathStart(t)+s,r=this.getPathStart(t)+i;(n<0||r>this.getPointCount()-1)&&h("");const o=this.querySegmentIterator();if(n>r&&(this.isClosedPath(t)||e("cannot iterate across an open path"),o.setCirculator(!0)),n===r)return 0;let a=0,m=0;o.resetToVertex(n,t);do{m+=a;a=o.nextSegment().calculateLength2D()}while(o.getStartPointIndex()!==r);return m}calculateEnvelope2D(e){return t(0),new ge(0,0,0,0)}updateXYImpl(t){const e=super.updateXYImpl(t);if(this.hasNonLinearSegments()){const s=ge.constructEmpty(),i=this.querySegmentIterator();for(;i.nextPath();)for(;i.hasNextSegment();){const n=i.nextCurve();if(!n)break;t?n.queryEnvelope(s):n.queryLooseEnvelope(s),e.mergeEnvelope2D(s)}}return e}notifyModifiedAllImpl(){null!==this.m_paths&&this.m_paths.size()?this.m_pointCount=this.m_paths.read(this.m_paths.size()-1):this.m_pointCount=0}setDirtyOGCFlags(t){this.setDirtyFlagProtected(16,t)}hasDirtyOGCStartFlags(){return this.hasDirtyFlag(16)}setDirtyRingAreas2D(t){this.setDirtyFlagProtected(1024,t)}hasDirtyRingAreas2D(){return this.hasDirtyFlag(1024)}static isNonLinearSegmentFlag(t){return!(1&t)}addAndExplicitlyOpenAllPaths(t,s){this===t&&e("Multi_path_impl::add");let i=this.getPathCount();for(let e=0,n=t.getPathCount();e<n;e++)this.addPath(t,e,!s),this.openPathAndDuplicateStartVertex(i),i++}getSegmentFlags(t){return null!==this.m_curveData&&null!==this.m_curveData.m_segmentFlags?this.m_curveData.m_segmentFlags.read(t):1}getSegmentBuffer(t,s,i){const n=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(n);r>=this.getSegmentCountPath(n)&&e("getSegmentBuffer"),this.getSegmentFromPath(n,r,s,i)}getSegmentTypeFromPath(t,e){const i=this.getPathStart(t)+e,n=this.getSegmentFlagsStreamRef();let r=1;switch(n&&(r=31&n.read(i)),r){case 1:return s.enumLine;case 2:return s.enumBezier;case 4:return s.enumEllipticArc;case 8:return s.enumRationalBezier2;case 16:return s.enumBezier2;default:m("")}}ensureXYMonotoneSegments(){if(!this.m_curveData)return!1;let t=!1;for(let e=0,s=this.getPathCount();e<s;e++){const s=this.getPathStart(e),i=this.getPathEnd(e),r=i-s;for(let e=s;e<i;e++){const i=31&this.m_curveData.m_segmentFlags.read(e);if(1===i)continue;2!==i&&n("ensure_xy_monotone_segments");const o=(e-s+1)%r+s,a=this.m_curveData.m_segmentParamIndex.read(e),h=D(w,4);h[0]=this.getXY(e),h[3]=this.getXY(o),h[1].x=this.m_curveData.m_segmentParams.read(a),h[1].y=this.m_curveData.m_segmentParams.read(a+1),h[2].x=this.m_curveData.m_segmentParams.read(a+2),h[2].y=this.m_curveData.m_segmentParams.read(a+3),gh(h)&&(t=!0,this.m_curveData.m_segmentParams.write(a,h[1].x),this.m_curveData.m_segmentParams.write(a+1,h[1].y),this.m_curveData.m_segmentParams.write(a+2,h[2].x),this.m_curveData.m_segmentParams.write(a+3,h[2].y))}}return t&&this.notifyModifiedFlags(2001),t}buildRasterizedGeometryAccelerator(t,e){return!1}buildQuadTreeAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new cn),null!==this.m_accelerators.getQuadTree())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTree(null);const e=Hs(this);return this.m_accelerators.setQuadTree(e),!0}buildQuadTreeForPathsAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new cn),null!==this.m_accelerators.getQuadTreeForPaths())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTreeForPaths(null);const e=Bs(this);return this.m_accelerators.setQuadTreeForPaths(e),!0}updateCurveCounter(t){this.modifyCurveCounter(t-this.getCurveCount())}removeAllCurvesFromGlobalCounter(){this.m_curveData&&(rm.st_totalCurveCount-=this.m_curveData.m_curveCount,this.m_curveData.m_curveCount=0,this.m_curveData.m_bezierCount=0,this.m_curveData.m_arcCount=0,this.m_curveData.m_bezier2Count=0,this.m_curveData.m_rbezier2Count=0,this.m_curveData.m_curveParamWritePoint=0)}modifyCurveCounter(t){t&&(this.m_curveData||(this.m_curveData=new nm),rm.st_totalCurveCount+=t,this.m_curveData.m_curveCount+=t)}getCurveCount(){return this.m_curveData?this.m_curveData.m_curveCount:0}incCurveType(t,e){this.m_curveData||(this.m_curveData=new nm),2&t?this.m_curveData.m_bezierCount+=e:4&t?this.m_curveData.m_arcCount+=e:8&t?this.m_curveData.m_rbezier2Count+=e:16&t&&(this.m_curveData.m_bezier2Count+=e)}getCurveWritePoint(){return t(0),0}initSegmentData(t){null===this.m_curveData&&(this.m_curveData=new nm);const e=this.m_reservedPointCount>0?this.m_reservedPointCount:this.m_pointCount;null===this.m_curveData.m_segmentParamIndex&&(this.m_curveData.m_segmentFlags=Oe(e,1),this.m_curveData.m_segmentParamIndex=Ue(e,-1));const s=this.m_curveData.m_curveParamWritePoint+t;null===this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams=We(s):s!==this.m_curveData.m_segmentParams.size()&&this.m_curveData.m_segmentParams.resize(s,0),this.m_curveData.m_segmentFlags.size()<e&&(this.m_curveData.m_segmentFlags.resize(e,1),this.m_curveData.m_segmentParamIndex.resize(e,-1))}updateCurveWritePoint(t){null===this.m_curveData&&(this.m_curveData=new nm),this.m_curveData.m_curveParamWritePoint=t}updateOGCFlagsHelper(){const t=this.getPathCount();if(0===t)return;const e=this.m_pathFlags;let s=0;for(let i=0;i<t;i++){const t=this.m_cachedRingAreas2D.read(i);0===s&&(s=Q(t)),t*s>0||0===s?e.setBits(i,8):e.clearBits(i,8)}}updateOGCFlagsProtected(){this.hasDirtyFlag(16)&&(this.updateRingAreas2DProtected(),this.updateOGCFlagsHelper(),this.setDirtyFlagProtected(16,!1))}replaceSegment(s,i,n){(s<0||s>=this.getPointCount())&&e("Multi_path_impl.replace_segment"),t(i.isCurve());const r=this.getPathIndexFromPointIndex(s),o=this.getPathStart(r),a=(s-o+1)%this.getPathSize(r)+o;{const e=this.getXY(s),n=this.getXY(a),r=!e.isEqualPoint2D(i.getStartXY())||!n.isEqualPoint2D(i.getEndXY());t(!r)}const h=i.getDescription();this.mergeVertexDescription(h);const m=new Array(32),l=new Ge({vd:h,attribBuffer:m,initDefaultValues:!1}),u=null===this.m_curveData?1:31&this.m_curveData.m_segmentFlags.read(s),c=fn(u),g=pn(i);let _,d=!1;c>=g?(t(null!==this.m_curveData),d=!0,_=this.m_curveData.m_segmentParamIndex.read(s)):(this.initSegmentData(g),d=!1,_=this.m_curveData.m_curveParamWritePoint);const p=i.getGeometryType(),f=nm.toSegType(p);n||(i.queryStart(l),this.setPointByVal(s,l),i.queryEnd(l),this.setPointByVal(a,l)),this.m_curveData.m_segmentParamIndex.write(s,1!==f?_:-1),this.m_curveData.m_segmentFlags.write(s,f),1!==f&&i.writeInBufferStream(this.m_curveData.m_segmentParams,_),d||(this.m_curveData.m_curveParamWritePoint+=g),u!==f&&(this.incCurveType(u,-1),this.incCurveType(f,1),this.modifyCurveCounter(1===u?1:-1))}verifyPathIndex(e){t(0)}setAttributeImpl(t,s,i){if(this.addAttribute(t),!this.isEmpty())if(this.hasNonLinearSegments()&&0===t){(s<0||s>1)&&e("");const t=new Y,n=0===s?i:0,r=0===s?0:1;t.setShiftCoords(n,r),0===s?t.xx=0:t.yy=0,this.applyTransformation(t)}else super.setAttributeImpl(t,s,i)}}rm.st_totalCurveCount=0;class om{constructor(t,e){this.m_segIter=null,this.m_quadTree=null,this.m_qtIter=null,this.m_extentOfInterest=new ge(e),this.m_bfirst=!0,this.m_prevIndex=-100,this.m_parent=t}nextSegment(){return this.m_bfirst&&this.prepare_(),this.m_quadTree?this.nextSegmentQt():this.nextSegmentNoQt()}getPathIndex(){return this.m_segIter.getPathIndex()}getStartPointIndex(){return this.m_segIter.getStartPointIndex()}getEndPointIndex(){return this.m_segIter.getEndPointIndex()}isClosingSegment(){return this.m_segIter.isClosingSegment()}isPathClosed(){return this.m_segIter.isPathClosed()}prepare_(){const t=this.m_parent.getAccelerators();t&&(this.m_quadTree=t.getQuadTree(),this.m_quadTree&&(this.m_qtIter=this.m_quadTree.getSortedIterator(this.m_extentOfInterest,0))),this.m_segIter=this.m_parent.querySegmentIterator()}nextSegmentQt(){this.m_bfirst=!1;const t=this.m_qtIter.next();if(-1===t)return null;const e=this.m_quadTree.getElement(t);(e!==this.m_prevIndex+1||this.m_segIter.isLastSegmentInPath())&&(this.m_segIter.resetToVertex(e,this.m_segIter.getPathIndex()),this.m_prevIndex=e);return this.m_segIter.nextSegment()}nextSegmentNoQt(){for(;;){if(!this.m_bfirst&&this.m_segIter.hasNextSegment()){const t=this.m_segIter.nextSegment(),e=ge.constructEmpty();if(t.queryLooseEnvelope(e),!e.isIntersecting(this.m_extentOfInterest))continue;return t}if(this.m_bfirst=!1,!this.m_segIter.nextPath())return null}}}class am extends rm{constructor(e){e?e.vd?(super({vd:e.vd,bPolygon:!1}),this.m_segmentBufferCTor=SE):e.copy?(super({vd:e.copy.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=SE,e.copy.copyTo(this)):e.move?(super({move:e.move}),this.m_segmentBufferCTor=SE):e.start?(super({vd:e.start.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=SE,this.startPathPoint(e.start),this.lineToPoint(e.end)):e.path?(super({bPolygon:!1}),this.m_segmentBufferCTor=SE,this.addPathPoint2D(e.path,e.pointCount,e.bForward)):t(0):(super({bPolygon:!1}),this.m_segmentBufferCTor=SE)}getBoundary(){return lm(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}assignMove(t){return t.copyTo(this),this}getGeometryType(){return am.type}getDimension(){return 1}createInstance(){return new am({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}am.type=s.enumPolyline;var hm=s;function mm(t,e){if(t.isEmpty())return!1;const s=t.getGeometryType();if(s===hm.enumPolygon)return 0!==t.calculateArea2D();if(s===hm.enumPolyline)return um(t.getImpl(),e,!0).bNotEmpty;if(s===hm.enumEnvelope)return!0;if(l(s))return!!t.isClosed();if(u(s))return!1;if(s===hm.enumGeometryCollection){const s=t;for(let t=0,i=s.getGeometryCount();t<i;t++)if(mm(s.getGeometry(t),e))return!0;return!1}n("")}function lm(t,e){const s=t.getGeometryType();if(s===hm.enumPolygon){const e=new am({vd:t.getDescription()});return t.isEmpty()||t.copyToUnchecked(e),e}if(s===hm.enumPolyline)return um(t.getImpl(),e,!1).boundary;if(s===hm.enumEnvelope){const e=new am({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(l(s)){const e=new ii({vd:t.getDescription()});if(!t.isEmpty()&&!t.isClosed()){const s=new Ge;e.reserve(2),t.queryStart(s),e.add(s),t.queryEnd(s),e.add(s)}return e}if(s===hm.enumGeometryCollection){const s=t;let i=null;for(let n=0,r=s.getGeometryCount();n<r;n++){const r=lm(s.getGeometry(n),e);if(null!==r){null===i&&(i=t.createInstance());const e=r;i.addGeometry(e)}}return i}if(u(s))return new Ge({vd:t.getDescription()});n("")}function um(t,e,s){const i=!1,n=t;let r=null;if(s||(r=new ii({vd:n.getDescription()})),!n.isEmpty()){const t=new Qe(0);for(let e=0,s=n.getPathCount();e<s;e++){if(n.getPathSize(e)>0&&!n.isClosedPathInXYPlane(e)){const s=n.getPathStart(e);t.add(s);const i=n.getPathEnd(e)-1;t.add(i)}}if(t.size()>0){const e=new ss,i=n.getAttributeStreamRef(0),o={userSort(t,e,s){const n=w.getNAN(),r=w.getNAN();s.sort(t,e,((t,e)=>(i.queryPoint2D(2*t,n),i.queryPoint2D(2*e,r),n.compare(r))))},getValue:t=>i.read(2*t+1)};e.sort(t,0,t.size(),o);let a=i.readPoint2D(2*t.read(0)),h=0,m=1;const l=new Ge;for(let n=1,r=t.size();n<r;n++){const e=i.readPoint2D(2*t.read(n));if(e.isEqualPoint2D(a))t.read(h)>t.read(n)?(t.write(h,L()),h=n):t.write(n,L()),m++;else{if(1&m){if(s)return{bNotEmpty:!0,boundary:new ii({})}}else t.write(h,L());a=e,h=n,m=1}}if(1&m){if(s)return{bNotEmpty:!0,boundary:new ii({})}}else t.write(h,L());if(!s){t.sort(0,t.size());for(let e=0,s=t.size();e<s&&t.read(e)!==L();e++)n.getPointByVal(t.read(e),l),r.add(l)}}}return s?{bNotEmpty:i,boundary:new ii({})}:{bNotEmpty:i,boundary:r}}const cm=pt/180,gm=180/pt;function _m(t){let e=t;return e>=-360&&e<720?(e<0?e+=360:e>=360&&(e-=360),e):(e=$(e,360),e<0&&(e+=360),e)}function dm(t){let e=t;return e=_m(e),e>180&&(e-=360),e}function pm(t){return t*cm}function fm(t){return t*gm}function xm(t){const e=St();let s=t;return s>=-e&&s<2*e?(s<0&&(s+=e),s>=e&&(s-=e),s):(s=$(s,e),s<0&&(s+=e),s)}function ym(t){const e=ft();let s=t;return s>-e&&s<=e||(s=xm(s),s>e&&(s-=St())),s}function Pm(t,e){return dm(e-t)}var Em=Ce;class Cm extends Hi{constructor(t){if(void 0===t||it(t,"vd"))return super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_semiMajorAxis=0,this.m_minorMajorRatio=1,this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,this.m_center=new w(0,0),this.m_sweepAngle=0,this.m_startAngle=0,this.m_interior=new w(0,0),void(this.m_bits=0);if(t.copy)return super(t),void(this!==t.copy&&(this.m_center=new w(0,0),this.m_interior=new w(0,0),t.copy.copyToImpl(this)));if(t.move)super(t),this.m_semiMajorAxis=t.move.m_semiMajorAxis,this.m_minorMajorRatio=t.move.m_minorMajorRatio,this.m_rotation=t.move.m_rotation,this.m_cosr=t.move.m_cosr,this.m_sinr=t.move.m_sinr,this.m_center=t.move.m_center.clone(),this.m_sweepAngle=t.move.m_sweepAngle,this.m_startAngle=t.move.m_startAngle,this.m_interior=t.move.m_interior.clone(),this.m_bits=t.move.m_bits,this.m_cachedValues=t.move.m_cachedValues,t.move.m_cachedValues=null;else{if(t.fromPoint)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new w(0,0),this.m_interior=new w(0,0),void this.constructCircularArcThreePoint(t.fromPoint,t.toPoint,t.interiorPoint);if(t.center)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new w(0,0),this.m_interior=new w(0,0),void this.constructCircleRadius(t.radius,t.center,t.bIsCounterClockwise);if(t.semiMajorAxis)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),void this.constructEllipticArcEndPoints(t.fromPoint,t.toPoint,t.semiMajorAxis,t.minorMajorRatio,t.axisXRotationRad,t.bBigArc,t.bIsCounterClockwise)}}getBoundary(){return lm(this)}assignMove(e){return t(0),this}assignCopy(t){return this!==t&&t.copyTo(this),this}constructCircleRadius(t,e,s=!1){return this.constructEllipse(t,1,e,0,s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircleCenterAndPoint(t,e,s=!1){const i=w.distance(t,e);return this.constructEllipticArcEndPointsCenter(e,e,i,1,0,!0,s,t),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructTwoPointCircle(t,e,s=!1){const i=w.lerp(t,e,.5);return this.constructCircleCenterAndPoint(i,t,s),this}constructLineEllipticArc(t,e){return pP(this,t,e,1),this}constructLineCircularArc(t,e){return pP(this,t,e,0),this}constructEllipse(t,e,s,i,n=!1){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const r=new w(0,this.m_minorMajorRatio*this.m_semiMajorAxis),o=Math.cos(i),a=Math.sin(i);return r.rotateDirect(o,a),r.addThis(s),this.constructEllipticArcEndPointsCenter(r,r,this.m_semiMajorAxis,this.m_minorMajorRatio,i,!0,n,s),this}inflate(t){if(this.isDegenerateToLine())return;let e=this.getSemiMinorAxis()+t;if(e=e<=0?0:(this.getSemiMajorAxis()+t)/this.getSemiMajorAxis(),this.isCircular()){const t=new Y;t.setShiftCoords(-this.m_center.x,-this.m_center.y),t.scale(e,e),t.shiftCoords(this.m_center.x,this.m_center.y),this.applyTransformation(t)}else{const t=new Y;this.canonicToWorldTransformation(t);const s=t.clone();s.invertPreciseThis(),s.scale(e,e),s.multiply(t),this.applyTransformation(s)}}constructEnclosingCircle(t,e,s=!1){return VP(this,t,e,s),this}constructThreePointCircle(t,e,s,i=!1){if(t.equals(e)||e.equals(s)||t.equals(s)){const n=t.clone(),r=e.clone(),o=s.clone();return n.equals(r)&&r.assign(o),this.constructTwoPointCircle(n,r,i)}{const n=w.calculateCircleCenterFromThreePoints(t,e,s);if(!n.isFinite()||!Number.isFinite(w.distance(t,n))){const i=w.distance(t,e),n=w.distance(t,s);this.constructLineCircularArc(t,i>=n?e:s)}return this.constructCircleCenterAndPoint(n,t,i)}}constructCircularArcThreePoint(t,e,s){const i=new ot(t.x),n=new ot(e.x),r=new ot(s.x),o=new ot(t.y),a=new ot(e.y),h=new ot(s.y),m=new ot(.5),l=n.subE(i),u=a.subE(o),c=r.subE(i),g=h.subE(o),_=l.mulE(g).subThisE(u.mulE(c));if(_.scaleError(10),_.isZero()){if(!l.isZero()||!u.isZero())return pP(this,t,e,0),this;{const i=t.clone().addThis(e).mulThis(.5).addThis(s).mulThis(.5),n=s.sub(i).length();this.constructEllipticArcEndPointsCenter(t,e,n,1,0,!0,!1,i),this.m_interior.assign(s)}return this.setProjectionBehavior(0),this}const d=l.sqr().addThisE(u.sqr()).mulThisE(m),p=c.sqr().addThisE(g.sqr()).mulThisE(m),f=d.mulE(g).subThisE(p.mulE(u)),x=l.mulE(p).subThisE(c.mulE(d));f.divThisE(_),x.divThisE(_);const y=f.sqr().addThisE(x.sqr());y.sqrtThis();const P=f.addE(i),E=x.addE(o);let C=t.x-P.value(),S=t.y-E.value();const v=Math.atan2(S,C);C=e.x-P.value(),S=e.y-E.value();const b=Math.atan2(S,C);C=s.x-P.value(),S=s.y-E.value();const I=Math.atan2(S,C);let D=I-2*ft();for(;D<v;)D+=2*ft();let T=b-2*ft();for(;T<D;)T+=2*ft();let N=I+2*ft();for(;N>v;)N-=2*ft();let A,q=b+2*ft();for(;q>N;)q-=2*ft();A=T-v<v-q?T-v:q-v;const F=new w(P.value(),E.value());return this.constructEllipticArcEndPointsCenter(t,e,y.value(),1,0,Math.abs(A)>ft(),A>0,F),this.m_interior.assign(s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircularArc(t,e,s,i){return this.constructEllipticArcGeneral(t,1,e,s,i,0),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructEllipticArcEndPoints(t,e,s,i,n,r,o){return dP(this,t,e,s,i,n,r,o)}constructEllipticArcEndPointsCenter(t,e,s,i,n,r,o,a){return dP(this,t,e,s,i,n,r,o,a)}constructEllipticArcGeneral(t,e,s,i,n,r){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const o=ym(r),a=Math.cos(o),h=Math.sin(o),m=new w(this.m_semiMajorAxis,this.m_minorMajorRatio*this.m_semiMajorAxis),l=w.getNAN(),u=ym(i);l.x=m.x*Math.cos(u),l.y=m.y*Math.sin(u),l.rotateDirect(a,h),l.addThis(s);const c=Xt(n,St());let g=c;Math.abs(g)===St()&&(g=0);const _=w.getNAN();return _.x=m.x*Math.cos(u+g),_.y=m.y*Math.sin(u+g),_.rotateDirect(a,h),_.addThis(s),this.constructEllipticArcEndPointsCenter(l,_,this.m_semiMajorAxis,this.m_minorMajorRatio,o,Math.abs(c)>ft(),c>0,s)}constructEllipticArcAsNURB(t,s,i,n){(n>=1||n<0)&&e("construct_elliptic_arc_as_NURB: weight"),s.isFinite()||e("construct_elliptic_arc_as_NURB: control_point");return FP([t,s,i],n*n,null,!1,this),this}constructCanonic(e){return t(0),this}isCircular(){return 1===this.m_minorMajorRatio&&0===this.m_rotation&&!this.isDegenerateToLine()}isDegenerateToLineHelper(t){return!!Ei(this,[t])&&fP(this)}isDegenerateToLine(){return fP(this)}getCenter(){return this.m_center.clone()}setCenter(e){t(0)}getAxisXRotation(){return this.m_rotation}getSemiAxes(){return w.construct(this.m_semiMajorAxis,this.m_semiMajorAxis*this.m_minorMajorRatio)}getSemiMajorAxis(){return this.m_semiMajorAxis}getSemiMinorAxis(){return this.m_semiMajorAxis*this.m_minorMajorRatio}getMinorMajorRatio(){return this.m_minorMajorRatio}isClockwise(){return!bP(this)}isMajor(){return wP(this)}getSweepAngle(){return this.m_sweepAngle}getStartAngle(){return this.m_startAngle}getEndAngle(){return this.m_startAngle+this.m_sweepAngle}getGeometryType(){return s.enumEllipticArc}queryEnvelope(e){if(e instanceof ke){e.setEmpty(),e.assignVertexDescription(this.m_description);const t=ge.constructEmpty();this.queryEnvelope(t),e.setEnvelope(t);for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const t=this.m_description.getSemantics(s);for(let i=0,n=Em.getComponentCount(t);s<n;s++){const s=this.queryInterval(t,i);e.setIntervalEnvelope(t,i,s)}}}else e instanceof ge?HP(this,A.unit(),e):t(0)}applyTransformation(t){EP(this,t,!1)}createInstance(){return new Cm}calculateLength2D(){return mP(this,0,1)}queryCoord2D(t,e){if(fP(this))Oi(t,this.getStartXY(),this.getEndXY(),e);else if(0===t)e.assign(w.construct(this.m_XStart,this.m_YStart));else if(1===t)e.assign(w.construct(this.m_XEnd,this.m_YEnd));else{const s=rP(this,t),i=new w(this.m_semiMajorAxis*Math.cos(s),this.getSemiMinorAxis()*Math.sin(s));i.rotateDirect(this.m_cosr,this.m_sinr),i.addThis(this.m_center),e.assign(i)}}queryCoord2DE(t,e){Ky(this,t,e)}getCoordX(t){const e=new w;return this.queryCoord2D(t,e),e.x}getCoordY(t){const e=new w;return this.queryCoord2D(t,e),e.y}cut(t,e,s){const i=new SE;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createEllipticArc();let r=0===t&&1===e;if(r&&!i)return void this.copyTo(n);const o=w.getNAN();this.queryCoord2D(t,o);const a=w.getNAN();if(this.queryCoord2D(e,a),!r)if(o.equals(a))e-t>.5&&this.isMajor()&&this.isClosed()?(r=!0,t=0,e=1):1===e?t=e:e=t;else if(t>0&&o.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&a.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),r=0===t&&1===e,r&&!i)return void this.copyTo(n);if(n.m_center.assign(this.m_center),n.m_semiMajorAxis=this.m_semiMajorAxis,n.m_minorMajorRatio=this.m_minorMajorRatio,n.m_interior.assign(this.m_interior),n.m_rotation=this.m_rotation,n.m_cosr=this.m_cosr,n.m_sinr=this.m_sinr,n.m_sweepAngle=this.m_sweepAngle,n.m_startAngle=this.m_startAngle,n.m_bits=this.m_bits,Ii(n,o.x,o.y),Di(n,a.x,a.y),r)return void CP(n,lP(this));n.m_startAngle=rP(this,t),n.m_sweepAngle=rP(this,e)-n.m_startAngle,n.m_startAngle=tP(n.m_startAngle),IP(n,Math.abs(n.m_sweepAngle)>ft()),n.assignVertexDescription(this.m_description),XP(n),iP(n);const h=this.m_description.getAttributeCount();if(h>1){for(let e=1;e<h;e++){const s=this.m_description.getSemantics(e),i=Em.getComponentCount(s);for(let e=0;e<i;e++){const i=this.getAttributeAsDbl(t,s,e);n.setStartAttribute(s,e,i)}}for(let t=1;t<h;t++){const s=this.m_description.getSemantics(t),i=Em.getComponentCount(s);for(let t=0;t<i;t++){const i=this.getAttributeAsDbl(e,s,t);n.setEndAttribute(s,t,i)}}}n.afterCompletedModification()}queryDerivative(t,e){WP()}cutArcIgnoreAttributes(t,e,s){let i=0===t&&1===e;const n=new w;this.queryCoord2D(t,n);const r=new w;this.queryCoord2D(e,r),i||(n.equals(r)?e-t>.5&&this.isMajor()&&this.isClosed()?(i=!0,t=0,e=1):1===e?t=e:e=t:(t>0&&n.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&r.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),i=0===t&&1===e)),s.m_center.assign(this.m_center),s.m_semiMajorAxis=this.m_semiMajorAxis,s.m_minorMajorRatio=this.m_minorMajorRatio,s.m_interior.assign(this.m_interior),s.m_rotation=this.m_rotation,s.m_cosr=this.m_cosr,s.m_sinr=this.m_sinr,s.m_sweepAngle=this.m_sweepAngle,s.m_startAngle=this.m_startAngle,s.m_bits=this.m_bits,Ii(s,n.x,n.y),Di(s,r.x,r.y),i?CP(s,lP(this)):(s.m_startAngle=rP(this,t),s.m_sweepAngle=rP(this,e)-s.m_startAngle,s.m_startAngle=tP(s.m_startAngle),IP(s,Math.abs(s.m_sweepAngle)>Math.PI),XP(s),s.afterCompletedModification())}changeEndPoints2D(t,e){cP(this,t,e,!1)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const i=this.calculateLength2D(),n=i>0?this.tToLength(t)/i:0,r=Em.getInterpolation(e),o=this.getStartAttributeAsDbl(e,s),a=this.getEndAttributeAsDbl(e,s);return dt(r,o,a,n,Em.getDefaultValue(e))}getClosestCoordinate(t,e){return zP(this,t,A.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return zP(this,t,e,!1)}getYMonotonicParts(s,i=!1){s.length<2&&e("");const n=this.getSemiAxes(),r=Math.atan2(n.y*this.m_cosr,n.x*this.m_sinr),o=r+ft(),a=new Array(3);let h=0;if(a[0]=nP(this,r),a[0]>0&&a[0]<1&&h++,a[1]=nP(this,o),a[1]>0&&a[1]<1&&(a[h]=a[1],h++),0===h)return 0;a[h]=1,h++,t(s.length>=h);let m=0;for(let t=0;t<h;t++){const e=a[t];this.queryCut(m,e,s[t],i),m=e}return h}getMonotonicParts(s,i){if(s.length<4&&e(""),this.isDegenerateToLine())return s[0].createEllipticArc().assignCopy(this),i&&s[0].get().dropAllAttributes(),1;const n=this.getSemiAxes(),r=new Array(4);r[0]=Math.atan2(n.y*this.m_cosr,n.x*this.m_sinr),r[1]=r[0]+ft(),r[2]=Math.atan2(-n.y*this.m_sinr,n.x*this.m_cosr),r[3]=r[2]+ft();const o=new Array(5);let a=0;for(let t=0;t<4;t++)o[a]=nP(this,r[t]),o[a]>0&&o[a]<1&&a++;if(0===a)return 0;at(o,a),o[a-1]<1&&(o[a]=1,a++),t(s.length>=a);let h=0;for(let t=0;t<a;t++){const e=o[t];this.queryCut(h,e,s[t],i),h=e}return a}intersectionWithAxis2D(t,e,s,i){if(fP(this)){return new CE({start:this.getStartXY(),end:this.getEndXY()}).intersectionWithAxis2D(t,e,s,i)}let n,r;const o=new ot(e),a=this.getSemiAxes();if(t){if(e>this.m_center.y+a.x||e<this.m_center.y-a.x)return 0;n=new ot(a.x).mulThis(this.m_sinr),r=new ot(a.y).mulThis(this.m_cosr),o.subThis(this.m_center.y)}else{if(e>this.m_center.x+a.x||e<this.m_center.x-a.x)return 0;n=new ot(a.x).mulThis(this.m_cosr),r=new ot(a.y).mulThis(-this.m_sinr),o.subThis(this.m_center.x)}const h=n.sqr(),m=r.sqr(),l=h.addE(m),u=r.mulE(o).mulThis(-2),c=o.sqr().subThisE(h),g=u.sqr().subThisE(l.mulE(c).mulThis(4)),_=n.mulE(o).mulThis(-2),d=o.sqr().subThisE(m),p=_.sqr().subThisE(l.mulE(d).mulThis(4));let f=g.eps()*Math.abs(p.value())<=p.eps()*Math.abs(g.value());f?n.isZero()&&(f=!1):r.isZero()&&(f=!0),f||(u.setE(_),c.setE(d));const x=D(ot,2);let y=Nn(l,u,c,A.construct(-1,1),!1,x);if(0===y)return 0;const P=[0,0];let E=0;for(let C=0;C<y;C++){const t=new ot,e=new ot;f?(t.setE(x[C]),e.setE(o.subE(r.mulE(x[C])).divThisE(n))):(e.setE(x[C]),t.setE(o.subE(n.mulE(x[C])).divThisE(r)));const s=nP(this,Math.atan2(t.value(),e.value()));s>=0&&s<=1&&(P[E]=s,E++)}return y=E,0===y?0:(2===y&&P[0]>P[1]&&(P[1]=q(P[0],P[0]=P[1])),i&&X(i,P,0,0,y),s&&(s[0]=t?this.getCoordX(P[0]):this.getCoordY(P[0]),y>1&&(s[1]=t?this.getCoordX(P[1]):this.getCoordY(P[1]),!i&&s[0]>s[1]&&(s[1]=q(s[0],s[0]=s[1])))),y)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0];return-1===this.intersectionWithAxis2D(!0,t,s,null)?e:s[0]}isCurve(){return!0}isDegenerate(t){return Pi(this,t)}isDegenerate3D(e,s){return t(0),!1}queryLooseEnvelope(e){e instanceof _e?t(0):this.queryLooseEnvelopeOnInterval(new A(0,1),e)}clone(t){const e=new Cm;return this.copyTo(e),e}queryInterval(t,e){if(0===t){if(fP(this))return 0===e?A.construct(this.getStartX(),this.getEndX()):A.construct(this.getStartY(),this.getEndY());let t;const s=this.getSemiAxes();t=0===e?Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr):Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr);const i=t+Math.PI,n=[0,0];n[0]=nP(this,t),n[1]=nP(this,i);const r=0===e?A.construct(this.getStartX(),this.getEndX()):A.construct(this.getStartY(),this.getEndY()),o=new w;for(let a=0;a<2;a++){const t=n[a];t>0&&t<1&&(this.queryCoord2D(t,o),r.mergeNeCoordinate(0===e?o.x:o.y))}return r}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=new A(0,1);if(s.intersect(t),s.isEmpty())return void e.setEmpty();if(fP(this))return e.setCoords(this.getCoord2D(s.vmin)),void e.mergeNe(this.getCoord2D(s.vmax));const i=this.getCoord2D(s.vmin),n=this.getCoord2D(s.vmax);if(1===this.m_minorMajorRatio&&Math.abs(this.m_sweepAngle)*s.width()<=xt){let t=w.lerp(i,n,.5);const s=t.sub(this.m_center);return s.normalize(),t=t.add(s.mul(.5*w.distance(i,n))),e.setCoords(i),e.mergeNe(n),void e.mergeNe(t)}HP(this,s,e)}tToLength(t){return fP(this)?t*w.distance(this.getStartXY(),this.getEndXY()):1===this.m_minorMajorRatio?Math.abs(this.getSweepAngle()*t)*this.m_semiMajorAxis:xP(this,t)}parametricAngleToT(t){return nP(this,t)}tToParametricAngle(t){return rP(this,t)}lengthToT(t){if(fP(this)){const e=w.distance(this.getStartXY(),this.getEndXY());return 0===e?0:t/e}if(1===this.m_minorMajorRatio){const e=Math.abs(this.getSweepAngle())*this.m_semiMajorAxis;return 0===e?0:t/e}return yP(this,t)}calculateWeightedAreaCentroid2D(t){if(fP(this)){const t=new w;return t.setCoords(0,0),t}const e=YP(this),s=this.getStartXY().sub(this.m_center),i=this.getEndXY().sub(this.m_center),n=this.m_semiMajorAxis,r=this.getSemiMinorAxis(),o=this.m_startAngle+this.m_sweepAngle,a=new w;a.x=n*r*(n*this.m_cosr*(-Math.sin(o)+Math.sin(this.m_startAngle))+r*(-Math.cos(o)+Math.cos(this.m_startAngle))*this.m_sinr)/3,a.y=n*r*(r*(Math.cos(o)-Math.cos(this.m_startAngle))*this.m_cosr+n*(-Math.sin(o)+Math.sin(this.m_startAngle))*this.m_sinr)/3;const h=i.add(s).mul(i.crossProduct(s)/6);return a.x-=h.x,a.y-=h.y,a.add(this.m_center.sub(t).mul(e))}calculateWeightedCentroid2D(){const t=new w;if(this.isDegenerate(0))return t.setCoords(0,0),t;if(fP(this))return t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t;let e=this.m_startAngle,s=this.m_startAngle+this.m_sweepAngle;if(s<e){const t=e;e=s,s=t}const i=Math.sin(e),n=Math.sin(s),r=Math.cos(e),o=Math.cos(s);if(1===this.m_minorMajorRatio){const e=this.getSemiMajorAxis(),s=e*e,a=s*(n-i),h=s*(r-o);t.setCoords(a,h)}else{const e=this.getSemiMajorAxis(),s=this.getSemiMinorAxis(),a=e*e,h=s*s,m=e*s,l=a-h,u=l/h,c=l/a,g=Math.sqrt(u),_=Math.sqrt(c),d=.5*m*(Math.asinh(g*n)/g+n*Math.sqrt(1+u*n*n))-.5*m*(Math.asinh(g*i)/g+i*Math.sqrt(1+u*i*i)),p=-.5*m*(Math.asin(_*o)/_+o*Math.sqrt(1-c*o*o))- -.5*m*(Math.asin(_*r)/_+r*Math.sqrt(1-c*r*r));t.setCoords(d,p)}return t.rotateDirect(this.m_cosr,this.m_sinr),t.assign(t.add(this.m_center.mul(this.calculateLength2D()))),t}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;if(!fP(this)){const s=w.distance(t,this.m_center),i=this.getSemiAxes();if(s<i.x-e||s>i.y+e)return!1}const i=this.getClosestCoordinate(t,!1),n=new w;this.queryCoord2D(i,n);return w.distance(n,t)<=e}isIntersectingPoint3D(e,s,i,n,r=1){return t(0),!1}getTangent(t){if(fP(this))return this.getEndXY().sub(this.getStartXY());{const e=rP(this,t),s=new w;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}getDerivative(e){return t(0),w.getNAN()}normalizeAfterEndpointChange(){return!!TP(this)&&(fP(this)?(NP(this),!1):AP(this,!1))}projectionBehavior(){return(4&this.m_bits)>>2}setProjectionBehavior(t){this.m_bits=-5&this.m_bits|t<<2}convertToCanonic(t){const e=new w(t.x,t.y);return e.subThis(this.m_center),e.rotateReverse(this.m_cosr,this.m_sinr),e}convertFromCanonic(t){const e=new w(t.x,t.y);return e.rotateDirect(this.m_cosr,this.m_sinr),e.addThis(this.m_center),e}canonicToWorldTransformation(t){t.setRotate(this.m_cosr,this.m_sinr),t.shiftCoords(this.m_center.x,this.m_center.y)}queryAttributeAsDbl(e,s,i,n){t(0)}getCurvature(e){return t(0),0}getMonotonicPartParams(t,s){const i=new Array(6);i[0]=0;let n=1;if(this.isDegenerateToLine())i[1]=1,n=2;else{const t=this.getSemiAxes(),e=new Array(4);this.m_rotation?(e[0]=Math.atan2(t.y*this.m_cosr,t.x*this.m_sinr),e[1]=e[0]+Math.PI,e[2]=Math.atan2(-t.y*this.m_sinr,t.x*this.m_cosr),e[3]=e[2]+Math.PI):(e[0]=0,e[1]=Math.PI,e[2]=.5*Math.PI,e[3]=yt());for(let s=0;s<4;s++){const t=nP(this,e[s]);t>0&&t<1&&(i[n]=t,n++)}n>2&&at(i,n),i[n]=1,n++}if(s){t<n&&e("");for(let t=0;t<n;t++)s[t]=i[t]}return n}calculateLowerLength2D(){const t=w.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMinorAxis();return Math.max(e,t)}calculateUpperLength2D(){const t=w.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMajorAxis();return Math.max(e,t)}orientBottomUp(){t(0)}isLine(){return fP(this)}copyIgnoreAttributes(t){t.m_XStart=this.m_XStart,t.m_YStart=this.m_YStart,t.m_XEnd=this.m_XEnd,t.m_YEnd=this.m_YEnd,t.m_center.assign(this.m_center),t.m_semiMajorAxis=this.m_semiMajorAxis,t.m_minorMajorRatio=this.m_minorMajorRatio,t.m_interior.assign(this.m_interior),t.m_rotation=this.m_rotation,t.m_cosr=this.m_cosr,t.m_sinr=this.m_sinr,t.m_sweepAngle=this.m_sweepAngle,t.m_startAngle=this.m_startAngle,t.m_bits=this.m_bits,SP(t)}calculateArea2DHelper(){return YP(this)}absNorm(){let t=this.getStartXY().norm(1)+this.getEndXY().norm(1);return this.isDegenerateToLine()||(t+=this.m_center.norm(1),t+=this.m_semiMajorAxis),t}queryEnvelopeW(t,e){if(e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax)),fP(this))return;const s=this.getSemiAxes(),i=new Array(8);{const t=Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr),e=t+Math.PI,n=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),r=n+Math.PI;i[0]=nP(this,t),i[1]=nP(this,e),i[2]=nP(this,n),i[3]=nP(this,r)}{const t=this.m_cosr+this.m_sinr,e=this.m_cosr-this.m_sinr,n=Math.atan2(-s.y*t,s.x*e),r=n+Math.PI,o=Math.atan2(s.y*e,s.x*t),a=o+Math.PI;i[4]=nP(this,n),i[5]=nP(this,r),i[6]=nP(this,o),i[7]=nP(this,a)}const n=w.getNAN();for(let r=0;r<8;r++){const s=i[r];t.containsExclusiveCoordinate(s)&&(this.queryCoord2D(s,n),e.mergeNe(n))}}setSegmentFromCoords(t,e){gP(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(10);return s[0]=this.m_bits,s[1]=this.m_semiMajorAxis,s[2]=this.m_minorMajorRatio,s[3]=this.m_rotation,s[4]=this.m_center.x,s[5]=this.m_center.y,s[6]=this.m_sweepAngle,s[7]=this.m_startAngle,s[8]=this.m_interior.x,s[9]=this.m_interior.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(10);t.queryRange(e,s.length,s,!0,1),this.m_bits=s[0],this.m_semiMajorAxis=s[1],this.m_minorMajorRatio=s[2],this.m_rotation=s[3],this.m_center.x=s[4],this.m_center.y=s[5],this.m_sweepAngle=s[6],this.m_startAngle=s[7],this.m_interior.x=s[8],this.m_interior.y=s[9],this.m_cosr=Math.cos(this.m_rotation),this.m_sinr=Math.sin(this.m_rotation),this.m_cachedValues=null}snapControlPoints(t){return!1}needsSnapControlPoints(e){return t(0),!1}calculateSpecialPointsForCracking(e,s){return t(0),0}ensureXYMonotone(){return t(0),!1}setCoordsForIntersector(t,e,s){cP(this,t,e,s)}getInteriorPoint(){return this.m_interior.clone()}copyToImpl(t){const e=t;e.m_center.assign(this.m_center),e.m_semiMajorAxis=this.m_semiMajorAxis,e.m_minorMajorRatio=this.m_minorMajorRatio,e.m_interior.assign(this.m_interior),e.m_rotation=this.m_rotation,e.m_cosr=this.m_cosr,e.m_sinr=this.m_sinr,e.m_sweepAngle=this.m_sweepAngle,e.m_startAngle=this.m_startAngle,e.m_bits=this.m_bits,CP(e,lP(this))}reverseImpl(){vP(this,!bP(this)),iP(this),(0!==this.projectionBehavior()||this.getStartXY().equals(this.getEndXY()))&&XP(this)}equalsImpl(t){const e=t;if(this.m_bits!==e.m_bits)return!1;if(this.m_semiMajorAxis!==e.m_semiMajorAxis)return!1;if(this.m_minorMajorRatio!==e.m_minorMajorRatio)return!1;if(!(this.m_center.isEqualPoint2D(e.m_center)||this.m_center.isNAN()&&e.m_center.isNAN()))return!1;if(this.m_rotation!==e.m_rotation)return!1;if(!this.m_interior.equals(e.m_interior))return!1;const s=e.m_sweepAngle;if(this.m_sweepAngle!==s)return!1;const i=e.m_startAngle;return this.m_startAngle===i}equalsImplTol(t,e){const s=t;if(this.m_bits!==s.m_bits)return!1;if(this.m_center.isNAN()&&s.m_center.isNAN())return!0;if(this.m_center.isNAN()!==s.m_center.isNAN())return!1;if(!this.getSemiAxes().isEqualPoint2D(s.getSemiAxes(),e))return!1;if(!this.m_center.isEqualPoint2D(s.m_center,e))return!1;const i=Math.abs(pm(dm(fm(this.m_rotation-s.m_rotation)))),n=Math.abs(ft()-i),r=Math.min(i,n);if(this.m_semiMajorAxis*Math.abs(r)>e)return!1;const o=this.getCoord2D(.5),a=s.getCoord2D(.5);return!!o.isEqualPoint2D(a,e)}getHashCodeImpl(){return t(0),0}swapImpl(e){t(0)}afterCompletedModification(){NP(this),SP(this)}intersect(t,e,s,i,n){return dE(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){if(e.length<2&&i(""),fP(this)){return new CE({start:this.getStartXY(),end:this.getEndXY()}).intersectPoint(t,e,s)}{const e=w.distance(t,this.m_center);if(e>this.m_semiMajorAxis+s||e<this.getSemiMinorAxis()-s)return 0}const n=this.getClosestCoordinate(t,!1),r=w.getNAN();return this.queryCoord2D(n,r),w.distance(r,t)<=s?ht(n,0,1)&&(this.queryCoord2D(0===n?1:0,r),w.distance(r,t)<=s)?(e&&(e[0]=0,e[1]=1),2):(e&&(e[0]=n),1):0}isIntersecting(t,e,s){return 0!==uE(!1,this,t,e,s)}intersect_(e,s,i,n){return t(0),0}endPointModified(){this.m_bits|=8,SP(this)}clearEndPointModified(){NP(this)}}Cm.type=s.enumEllipticArc;class Sm extends rm{constructor(e){e?e.vd?(super({vd:e.vd,bPolygon:!0}),this.m_segmentBufferCTor=SE):e.copy?(super({vd:e.copy.getDescription(),bPolygon:!0}),this.m_segmentBufferCTor=SE,e.copy.copyTo(this)):e.move?(super({move:e.move}),this.m_segmentBufferCTor=SE):(e.envelope,t(0)):(super({bPolygon:!0}),this.m_segmentBufferCTor=SE)}assignMove(t){return t.copyTo(this),this}assignCopy(t){return t.copyTo(this),this}getBoundary(){return lm(this)}getExteriorRingCount(){return this.getOGCPolygonCount()}getGeometryType(){return Sm.type}getDimension(){return 2}createInstance(){return new Sm({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}Sm.type=s.enumPolygon;class vm extends hi{constructor(t){if("number"==typeof t)return super(),this.m_factor=t,void(this.m_wkid=0);super(t)}getUnitType(){return 1}convertFromRadians(t){return t/this.getUnitToBaseFactor()}convertToRadians(t){return t*this.getUnitToBaseFactor()}}function bm(t){return new ky}function Im(t){return t.getType()===yC.PE_TYPE_LINUNIT?new ky(t):t.getType()===yC.PE_TYPE_ANGUNIT?new vm(t):void e("peUnit")}function wm(t){const s=DC(null);return t.getType()===yC.PE_TYPE_PROJCS||t.getType()===yC.PE_TYPE_GEOGCS?s.reset(t.getUnit()):e("PE_coord_sys"),s.get()||m("cannot create units from coord sys"),Im(s.get())}function Dm(i,n){let r=n,o=null;r||(o=y(i)?Ae():Ne(),r=o);let a=null;switch(i){case s.enumPoint:a=new Ge({vd:r});break;case s.enumLine:a=new CE({vd:r});break;case s.enumBezier:a=new lo({vd:r});break;case s.enumEllipticArc:a=new Cm({vd:r});break;case s.enumRationalBezier2:a=new Xa({vd:r});break;case s.enumBezier2:a=new Ln({vd:r});break;case s.enumEnvelope:a=new ke({vd:r});break;case s.enumMultiPoint:a=new ii({vd:r});break;case s.enumPolyline:a=new am({vd:r});break;case s.enumPolygon:a=new Sm({vd:r});break;case s.enumMultipatch:t(0);break;case s.enumGeometryCollection:a=new li({vd:r});break;default:e("Geometry.create")}return a}var Tm=Ce;const Nm=-1,Am=1;class qm{constructor(t){this.m_shape=t}userSort(t,e,s){this.m_shape.sortVerticesSimpleByYHelper(s,t,e)}getValue(t){return this.m_shape.getY(t)}}function Fm(t){return void 0!==t.parent}class Mm{constructor(t){Fm(t)?(this.m_parent=t.parent,this.m_geometry=t.geometry,this.m_path=t.path,this.m_vertex=t.vertex,this.m_firstVertex=t.firstVertex,this.m_index=t.selection?0:t.index,this.m_bSkipMultiPoints=t.bSkipMultiPoints,this.m_selection=t.selection,this.m_bOneGeom=t.bOneGeom,this.m_bFirst=!0):(this.m_parent=t.copy.m_parent,this.m_geometry=t.copy.m_geometry,this.m_path=t.copy.m_path,this.m_vertex=t.copy.m_vertex,this.m_index=t.copy.m_index,this.m_bSkipMultiPoints=t.copy.m_bSkipMultiPoints,this.m_firstVertex=t.copy.m_firstVertex,this.m_bFirst=!0,this.m_selection=t.copy.m_selection,this.m_bOneGeom=t.copy.m_bOneGeom)}moveToNextHelper(){for(this.m_path=this.m_parent.getNextPath(this.m_path),this.m_index=0;this.m_geometry!==Nm;){for(;this.m_path!==Nm;this.m_path=this.m_parent.getNextPath(this.m_path))if(this.m_vertex=this.m_parent.getFirstVertex(this.m_path),this.m_firstVertex=this.m_vertex,this.m_vertex!==Nm)return this.m_vertex;if(this.m_bOneGeom)return Nm;if(this.m_geometry=this.m_parent.getNextGeometry(this.m_geometry),this.m_geometry===Nm)break;this.m_bSkipMultiPoints&&!p(this.m_parent.getGeometryType(this.m_geometry))||(this.m_path=this.m_parent.getFirstPath(this.m_geometry))}return Nm}nextSelection(){for(;this.m_index<this.m_parent.m_selectedVertices.length;){const t=this.m_parent.m_selectedVertices[this.m_index++];if(t!==Nm&&(this.m_path=this.m_parent.getPathFromVertex(t),!this.m_bOneGeom||this.m_geometry===this.m_parent.getGeometryFromPath(this.m_path)))return this.m_geometry=this.m_parent.getGeometryFromPath(this.m_path),t}return Nm}next(){return this.m_selection?this.nextSelection():this.m_bFirst?(this.m_bFirst=!1,this.m_vertex):this.m_vertex!==Nm?(this.m_vertex=this.m_parent.getNextVertex(this.m_vertex),this.m_index++,this.m_vertex!==Nm&&this.m_vertex!==this.m_firstVertex?this.m_vertex:this.moveToNextHelper()):Nm}currentGeometry(){return this.m_geometry}currentPath(){return t(0),0}static create_(t,e,s,i,n,r,o,a,h){return new Mm({parent:t,geometry:e,path:s,vertex:i,firstVertex:n,index:r,bSkipMultiPoints:o,selection:a,bOneGeom:h})}}class Gm{constructor(t){this.parentage=t}equals(t){return this.parentage===t.parentage}}class Vm{setPrevPath(t,e){this.m_pathIndexList.setField(t,1,e)}setNextPath(t,e){this.m_pathIndexList.setField(t,2,e)}setPathFlags(t,e){this.m_pathIndexList.setField(t,6,e)}getPathFlags(t){return this.m_pathIndexList.getField(t,6)}setPathGeometry(t,e){this.m_pathIndexList.setField(t,7,e)}getPathIndex(t){return this.m_pathIndexList.getField(t,0)}setNextGeometry(t,e){this.m_geometryIndexList.setField(t,1,e)}setPrevGeometry(t,e){this.m_geometryIndexList.setField(t,0,e)}getGeometryIndex(t){return this.m_geometryIndexList.getField(t,7)}setFirstPath(t,e){this.m_geometryIndexList.setField(t,3,e)}setLastPath(t,e){this.m_geometryIndexList.setField(t,4,e)}newGeometry(t){const e=this.m_geometryIndexList.newElement();return this.m_geometryIndexList.setField(e,2,t),this.m_geometryIndexList.setField(e,5,0),this.m_geometryIndexList.setField(e,6,0),this.m_geometryIndexList.setField(e,7,this.m_geometryIndexList.elementToIndex(e)),e}freeGeometry(t){this.m_geometryIndexList.deleteElement(t)}newPath(t){const e=this.m_pathIndexList.newElement(),s=this.m_pathIndexList.elementToIndex(e);if(this.m_pathIndexList.setField(e,0,s),this.m_pathIndexList.setField(e,3,0),this.m_pathIndexList.setField(e,6,0),this.setPathGeometry(e,t),s>=this.m_pathAreas.length){const t=Math.trunc(s<16?16:3*s/2);this.m_pathAreas.length=t,this.m_pathLengths.length=t}return this.m_pathAreas[s]=0,this.m_pathLengths[s]=0,this.m_pathCount++,e}freePath(t){this.m_pathIndexList.deleteElement(t),this.m_pathCount--}newVertex(t){const e=this.m_vertexIndexList.newElement(),s=t>=0?t:this.m_vertexIndexList.elementToIndex(e);if(this.m_vertexIndexList.setField(e,0,s),t<0){if(s>=this.m_vertices.getPointCount()){const t=Math.trunc(s<16?16:3*s/2);this.m_vertices.reserveRounded(t),this.m_vertices.resizeNoInit(t),null!==this.m_segments&&(this.m_segments.length=t),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0)}this.m_segments&&(this.m_segments[s]=null)}return this.m_pointCount++,e}freeVertex(t){this.unselect(t);const e=this.getVertexIndex(t);this.m_vertexIndexList.deleteElement(t),this.m_pointCount--;for(let s=0,i=this.m_indices.length;s<i;s++){if(s===this.m_selectionIndex)continue;const t=this.m_indices[s];null!==t&&t.size()>e&&t.write(e,-1)}this.m_weights&&this.m_weights.size()>e&&this.m_weights.write(e,1),this.m_ranks&&this.m_ranks.size()>e&&this.m_ranks.write(e,Am),this.m_segmentWeights&&this.m_segmentWeights.size()>e&&this.m_segmentWeights.write(e,1),this.m_segmentRanks&&this.m_segmentRanks.size()>e&&this.m_segmentRanks.write(e,Am),this.m_segments&&this.setSegmentToIndex(e,null)}insertVertex_(t,e,s,i){this.m_bHasForceSetEnvelope=!1;const n=e!==Nm?this.getPrevVertex(e):this.getLastVertex(t),r=n!==Nm?this.getNextVertex(n):Nm,o=this.newVertex(null===s?this.m_pointCount:-1),a=this.getVertexIndex(o);null!==s&&this.m_vertices.setPointByVal(a,s),this.setPathToVertex(o,t),this.setNextVertex(o,r),this.setPrevVertex(o,n),r!==Nm&&this.setPrevVertex(r,o),n!==Nm&&this.setNextVertex(n,o);const h=this.isClosedPath(t),m=this.getFirstVertex(t);e===Nm&&this.setLastVertex(t,o),e===m&&(h&&i&&m!==Nm||this.setFirstVertex(t,o)),h&&r===Nm&&(this.setNextVertex(o,o),this.setPrevVertex(o,o)),this.setPathSize(t,this.getPathSize(t)+1);const l=this.getGeometryFromPath(t);return this.setGeometryVertexCount(l,this.getPointCount(l)+1),o}getHelperPoint(){return this.m_helperPoint||(this.m_helperPoint=new Ge({vd:this.m_vertices.getDescription()}),this.m_helperPoint.setXYCoords(0,0)),this.m_helperPoint}addMultiPath_(e){return t(0),0}addMultiPoint(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return this.appendMultiPoint(s,t,e),s}addPoint_(t,e){const i=this.createGeometry(s.enumMultiPoint,t.getDescription());return this.appendPoint(i,t,e),i}appendMultiPath_(t,e){if(e.isEmpty())return;const s=e.getImpl();this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+s.getPointCount()),this.m_verticesMp.addPoints(e,0,s.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const i=null!==this.m_segments||null!==s.getSegmentFlagsStreamRef();this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+s.getPointCount()),this.m_pathIndexList.setCapacity(this.m_pathIndexList.size()+s.getPathCount());for(let n=0,r=s.getPathCount();n<r;n++){if(0===s.getPathSize(n))continue;const e=this.insertPath(t,Nm);this.setClosedPath(e,s.isClosedPath(n));for(let t=s.getPathStart(n),r=s.getPathEnd(n);t<r;t++){const n=this.insertVertex_(e,Nm,null,!1);if(i){const e=this.getVertexIndex(n);if(1&s.getSegmentFlags(t))this.setSegmentToIndex(e,null);else{const i=new SE;s.querySegment(t,i,!0),this.setSegmentToIndex(e,i.releaseSegment())}}}s.isStrongPathStart(n)&&this.setStrongPathStart(e,!0),s.isStrongPathEnd(n)&&this.setStrongPathEnd(e,!0)}}addMultiPath(t,e){const i=this.createGeometry(t.getGeometryType(),t.getDescription());return t.getGeometryType()===s.enumPolygon&&this.setFillRule(i,t.getFillRule()),this.appendMultiPath(i,t,e),i}appendMultiPathPolyline(e,s,i){t(0)}appendMultiPathPolygon(e,s,i){const n=s.getImpl(),r=null!==this.m_segments||null!==n.getSegmentFlagsStreamRef(),o=ge.constructEmpty();s.queryEnvelope(o),t(i.isIntersecting(o)&&!i.containsEnvelope(o));let a=ge.construct(Number.NEGATIVE_INFINITY,i.ymin,Number.POSITIVE_INFINITY,i.ymax),h=ge.construct(i.xmin,Number.NEGATIVE_INFINITY,i.xmax,Number.POSITIVE_INFINITY);const m=n.getAccelerators();if(m&&m.getQuadTree()){const t=m.getQuadTree(),e=t.getIntersectionCount(a,0,0);e>t.getIntersectionCount(h,0,e+1)&&(h=q(a,a=h))}else a.height()>h.width()&&(h=q(a,a=h));const l=[],u=n.queryLimitedSegmentIterator(a);let c=-1,g=-100,_=-1,d=0,p=-1,f=-1,x=Nm,y=!0,P=u.nextSegment();if(null!==P)for(;;P=u.nextSegment()){let i=null===P;const o=null!==P?u.getPathIndex():c,a=null!==P?u.getStartPointIndex():g;if(i||(o===c?g+1===a?d++:i=!0:(i=c>=0,c<0&&(c=o,_=n.getSegmentCountPath(c),p=a,x=Nm,d=1))),i){if(!(0===l.length&&_===d)){0!==l.length&&l[0].first===p||(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(s,p,p+1),-1===f&&(f=p),x===Nm&&(x=this.insertPath(e,Nm),this.setClosedPath(x,!0)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.insertVertex_(x,Nm,null,!1));for(const{first:i,second:o}of l){-1===f&&(f=i);let a=-1,h=-1;const m=i+o-1;if(o===_){const e=m+1;h=e-i,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h),this.m_verticesMp.addPoints(s,i,e),a=m,t(1===l.length)}else if(m+1<n.getPathEnd(c)){const t=m+2;h=t-i,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h),this.m_verticesMp.addPoints(s,i,t),a=m}else{const t=n.getPathStart(c),e=t!==f?1:0,r=m+1;h=r-i+e,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+(r-i)+e),this.m_verticesMp.addPoints(s,i,r),a=m,e>0&&this.m_verticesMp?.addPoints(s,t,t+1)}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),x===Nm&&(x=this.insertPath(e,Nm),this.setClosedPath(x,!0));for(let t=0,e=i;t<h;t++,e++){const t=this.insertVertex_(x,Nm,null,!1);if(r){const s=this.getVertexIndex(t);if(1&n.getSegmentFlags(e)||e>a)this.setSegmentToIndex(s,null);else{const t=new SE;n.getSegmentBuffer(e,t,!0),this.setSegmentToIndex(s,t.releaseSegment())}}}}if(0===l.length||l.at(-1).first+l.at(-1).second!==p+d){let t=p+d;t===s.getPathEnd(c)&&(t=s.getPathStart(c)),f!==t&&(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(s,t,t+1),this.insertVertex_(x,Nm,null,!1))}}l.length=0,y=!0,o!==c&&(c=o,_=n.getSegmentCountPath(c),x=Nm,f=-1),p=a,d=1}if(!P)break;{const t=ge.constructEmpty();P.queryLooseEnvelope(t),h.isIntersecting(t)?(y?l.push(j(a,1)):l.at(-1).second++,y=!1):y=!0}g=a}}appendMultiPath(t,e,i){if(void 0===i)return void this.appendMultiPath_(t,e);if(e.isEmpty())return;const n=e.getGeometryType()===s.enumPolygon,r=ge.constructEmpty();e.queryEnvelope(r),i.isIntersecting(r)&&(!i.containsEnvelope(r)&&e.getPointCount()>10?n?this.appendMultiPathPolygon(t,e,i):this.appendMultiPathPolyline(t,e,i):this.appendMultiPath_(t,e))}appendPoint(t,e,s){if(e.isEmpty())return;if(void 0!==s&&!s.contains(e.getXY()))return;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.add(e),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+1);const i=this.insertPath(t,Nm);this.insertVertex_(i,Nm,null,!1)}appendMultiPoint_(t,e){this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+e.getPointCount()),this.m_verticesMp.addPoints(e,0,e.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+e.getPointCount());const s=this.insertPath(t,Nm);for(let i=0,n=e.getPointCount();i<n;i++)this.insertVertex_(s,Nm,null,!1)}appendMultiPoint(t,e,s){if(void 0===s)return void this.appendMultiPoint_(t,e);const i=e.getAttributeStreamRef(0);let n=0;for(let m=0,l=e.getPointCount();m<l;m++){const t=i.readPoint2D(2*m);s.contains(t)&&n++}this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+n);let r=-1,o=-1,a=0;for(let m=0,l=e.getPointCount();m<l;m++){const t=i.readPoint2D(2*m);s.contains(t)?(-1===r&&(r=m,o=m),o++):r>=0&&(this.m_verticesMp.addPoints(e,r,o-r),r=-1,a++)}if(r>0&&(this.m_verticesMp.addPoints(e,r,o-r),a++),!a)return;this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+n);const h=this.insertPath(t,Nm);for(let m=0,l=e.getPointCount();m<l;m++){const t=i.readPoint2D(2*m);s.contains(t)&&this.insertVertex_(h,Nm,null,!1)}}splitSegmentForward(t,i,n,r,o){const a=this.getNextVertex(t);a===Nm&&e("Edit_shape.split_segment_forward_");const h=this.getHelperPoint(),m=this.getPathFromVertex(t);let l=t;const u=this.hasSegmentParentage();for(let e=0,c=i.getResultSegmentCount(n);e<c;e++){const t=this.getVertexIndex(l),r=this.getNextVertex(l),g=i.getResultSegment(n,e);let _=null;if(g.getGeometryType()!==s.enumLine&&(_=g.clone(),_.dropAllAttributes()),0===e&&(g.queryStart(h),this.setSegmentToIndex(t,null),this.setPointEx(l,h,i.getResultSegmentStartPointRank(n,e),i.getResultSegmentStartPointWeight(n,e),o)),this.setSegmentRank(l,i.getResultSegmentInteriorRank(n,e)),this.setSegmentWeight(l,i.getResultSegmentInteriorWeight(n,e)),u){const t=i.getResultSegmentSegmentParentage(n,e),s=i.getResultSegmentStartPointIsBreak(n,e);this.setSegmentParentageAndBreak(l,t,s)}if(g.queryEnd(h),e<c-1){this.setSegmentToIndex(t,_);const s=this.insertVertex(m,r,h);this.setWeight(s,i.getResultSegmentEndPointWeight(n,e)),this.setRank(s,i.getResultSegmentEndPointRank(n,e)),this.select(s),l=s}else{this.setPointEx(a,h,i.getResultSegmentEndPointRank(n,e),i.getResultSegmentEndPointWeight(n,e),o);const s=i.getResultSegmentEndPointIsBreak(n,e);this.setSegmentParentageBreakVertex(a,s),this.setSegmentToIndex(t,_)}}}splitSegmentBackward(t,i,n,r,o){const a=this.getNextVertex(t);a===Nm&&e("Edit_shape.split_segment_backward_");const h=this.getHelperPoint(),m=this.getPathFromVertex(t);let l=t;const u=this.hasSegmentParentage();for(let e=0,c=i.getResultSegmentCount(n);e<c;e++){const t=c-e-1,r=this.getVertexIndex(l),g=this.getNextVertex(l),_=i.getResultSegment(n,t);let d=null;if(_.getGeometryType()!==s.enumLine&&(d=_.clone(),d.reverse(),d.dropAllAttributes()),0===e&&(_.queryEnd(h),this.setSegmentToIndex(r,null),this.setPointEx(l,h,i.getResultSegmentEndPointRank(n,t),i.getResultSegmentEndPointWeight(n,t),o),this.setSegmentParentageAndBreak(l,i.getResultSegmentSegmentParentage(n,t),i.getResultSegmentEndPointIsBreak(n,t))),_.getGeometryType()===s.enumLine?this.setSegmentToIndex(r,null):this.setSegmentToIndex(r,d),this.setSegmentRank(l,i.getResultSegmentInteriorRank(n,t)),this.setSegmentWeight(l,i.getResultSegmentInteriorWeight(n,t)),_.queryStart(h),e<c-1){const e=this.insertVertex(m,g,h);this.setWeight(e,i.getResultSegmentStartPointWeight(n,t)),this.setRank(e,i.getResultSegmentStartPointRank(n,t)),this.select(e),l=e,u&&this.setSegmentParentageAndBreak(e,i.getResultSegmentSegmentParentage(n,t),i.getResultSegmentEndPointIsBreak(n,t))}else this.setPointEx(a,h,i.getResultSegmentStartPointRank(n,t),i.getResultSegmentStartPointWeight(n,t),o)}}selected_(e){return t(0),!1}allocateIndex(t=!0){if(this.m_deletedIndices.length){const e=this.m_deletedIndices.pop();return t&&e.setRange(-1,0,e.size()),e}return t?Ue(0,-1):Ue(0)}recycleUserIndex(t){this.m_deletedIndices.push(t)}allocatePathIndex(){if(this.m_deletedPathIndices.length){const t=this.m_deletedPathIndices.at(-1);return this.m_deletedPathIndices.pop(),t}return Ue(0)}recyclePathUserIndex(t){this.m_deletedPathIndices.push(t)}peelALoop_(t,e,s){const i=this.getNextVertex(t),n=this.getNextVertex(e),r=this.getVertexIndex(t),o=this.getVertexIndex(e);if(this.setNextVertex(t,n),this.setPrevVertex(n,t),this.setNextVertex(e,i),this.setPrevVertex(i,e),this.m_segments){const t=this.getSegmentFromIndex(r),e=this.getSegmentFromIndex(o);this.setSegmentToIndex(o,null),this.setSegmentToIndex(r,e),this.setSegmentToIndex(o,t)}if(this.hasSegmentParentage()){let s=this.getSegmentParentage(e),i=this.getSegmentParentage(t);-1===s&&-1===i||(i=q(s,s=i),this.setSegmentParentageAndBreak(t,i),this.setSegmentParentageAndBreak(e,s))}if(s){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e),r=[!1],o=this.insertClosedPath(s,Nm,i,this.getFirstVertex(e),r);r[0]&&this.setFirstVertex(e,n);let a=this.getPathSize(e);return a-=this.getPathSize(o),this.setPathSize(e,a),o}return Nm}sortVerticesSimpleByYHelper(t,e,s){t.sort(e,s,((t,e)=>{let s=this.compareVerticesSimpleY(t,e);if(0===s){const i=this.getPathInternalIndexFromVertex(t),n=this.getPathInternalIndexFromVertex(e);s=i<n?-1:i>n?1:0}return s}))}sortVerticesSimpleByYHelper3D(e,s,i){t(0)}constructor(){this.m_verticesMp=null,this.m_vertices=null,this.m_xyStream=null,this.m_vertexDescription=null,this.m_segments=null,this.m_weights=null,this.m_ranks=null,this.m_segmentWeights=null,this.m_segmentRanks=null,this.m_indices=[],this.m_deletedIndices=[],this.m_pathAreas=[],this.m_pathLengths=[],this.m_pathindices=[],this.m_deletedPathIndices=[],this.m_geometryIndices=[],this.m_selectedVertices=[],this.m_helperPoint=null,this.m_forceSetEnvelope=_e.constructEmpty(),this.m_bHasForceSetEnvelope=!1,this.m_workPoint2D=w.getNAN(),this.m_workPoint2_2D=w.getNAN(),this.m_curveStitcher=null,this.m_pathCount=0,this.m_pointCount=0,this.m_firstGeometry=Nm,this.m_lastGeometry=Nm,this.m_vertexIndexList=new is(5),this.m_pathIndexList=new is(8),this.m_geometryIndexList=new is(8),this.m_bHasAttributes=!1,this.m_selectedCount=0,this.m_selectionIndex=-1,this.m_selection=!1,this.m_bucketSort=new ss,this.m_bHasForceSetEnvelope=!1,this.m_segmentParentageIndex=-1}getTotalPointCount(){return this.m_pointCount}getEnvelope2D(t){if(this.m_bHasForceSetEnvelope)return new ge(this.m_forceSetEnvelope.xmin,this.m_forceSetEnvelope.ymin,this.m_forceSetEnvelope.xmax,this.m_forceSetEnvelope.ymax);const e=this.hasCurves(),s=ge.constructEmpty(),i=this.queryVertexIterator();let n=!0;for(let r=i.next();r!==Nm;r=i.next()){if(n?s.merge(this.getXY(r)):s.mergeNe(this.getXY(r)),e){const t=this.getSegment(r);if(null!==t){const e=ge.constructEmpty();t.queryLooseEnvelope(e),s.mergeEnvelope2D(e)}}n=!1}return s}getEnvelope3D(e){return t(0),_e.constructEmpty()}forceSetEnvelope2D(t){this.m_bHasForceSetEnvelope=!0,this.m_forceSetEnvelope.setCoords(t.xmin,t.ymin,0,t.xmax,t.ymax,0)}forceSetEnvelope3D(e){t(0)}forgetForceSetEnvelope2D(){t(0)}getGeometryCount(){return this.m_geometryIndexList.size()}addGeometry(t,i){const n=t.getGeometryType();if(p(n))return this.addMultiPath(t,i);if(n===s.enumMultiPoint)return this.addMultiPoint(t,i);if(n===s.enumPoint)return this.addPoint_(t,i);if(n===s.enumEnvelope){const e=new Sm;return e.addEnvelope(t,!1),this.addMultiPath(e,i)}e("")}appendGeometry(t,i){this.mergeVertexDescription(i.getDescription());const n=i.getGeometryType();p(n)?this.appendMultiPath(t,i):n!==s.enumMultiPoint?e(""):this.appendMultiPoint(t,i)}assignRankToGeometryVertices(e,s){t(0)}collapseAllGeometriesToFirst(){this.collapseGeometriesToFirst(s.enumUnknown)}collapseGeometriesToFirst(t){this.dbgVerifyVertexCounts();let e=Nm,i=-1,n=-1;for(let r=this.getFirstGeometry();r!==Nm;)if(t!==s.enumUnknown&&this.getGeometryType(r)!==t)r=this.getNextGeometry(r);else{if(e===Nm){e=r,i=this.getPathCount(e),n=this.getPointCount(e),r=this.getNextGeometry(r);continue}for(let i=this.getFirstPath(r);i!==Nm;i=this.getNextPath(i))this.setPathGeometry(i,e);i+=this.getPathCount(r),n+=this.getPointCount(r);const t=this.getLastPath(e),s=this.getFirstPath(r);t!==Nm?this.setNextPath(t,s):this.setFirstPath(e,s),s!==Nm&&(this.setPrevPath(s,t),this.setLastPath(e,this.getLastPath(r))),this.setFirstPath(r,Nm),this.setLastPath(r,Nm);const o=r;r=this.getNextGeometry(r),this.setGeometryVertexCount(o,0),this.removeGeometry(o)}return e!==Nm&&(this.setGeometryVertexCount(e,n),this.setGeometryPathCount(e,i),this.dbgVerifyVertexCounts()),e}setFillRule(t,e){let s=this.m_geometryIndexList.getField(t,2);s&=-134217729,s|=1===e?134217728:0,this.m_geometryIndexList.setField(t,2,s)}getFillRule(t){return 134217728&this.m_geometryIndexList.getField(t,2)?1:0}setGeometryModified(t,e){let s=this.m_geometryIndexList.getField(t,2);!!(67108864&s)!==e&&(s&=-67108865,s|=e?67108864:0,this.m_geometryIndexList.setField(t,2,s))}getGeometryModified(t){return!!(67108864&this.m_geometryIndexList.getField(t,2))}setGeometryModifiedWithVertex(t,e){const s=this.getPathFromVertex(t),i=this.getGeometryFromPath(s);this.setGeometryModified(i,e)}getGeometryModifiedWithVertex(e){return t(0),!0}swapGeometry(e,s){t(0)}addPathFromMultiPath(t,e,i){const n=this.createGeometry(i?s.enumPolygon:s.enumPolyline,t.getDescription()),r=t.getImpl();if(t.getPathSize(e)<2)return n;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+t.getPathSize(e)),this.m_verticesMp.addPoints(t,t.getPathStart(e),r.getPathEnd(e)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const o=this.insertPath(n,Nm);this.setClosedPath(o,r.isClosedPath(e)||i);const a=null!==this.m_segments||null!==r.getSegmentFlagsStreamRef();for(let s=r.getPathStart(e),h=r.getPathEnd(e);s<h;s++){const t=this.insertVertex_(o,Nm,null,!1);if(a){const e=this.getVertexIndex(t);if(1&r.getSegmentFlags(s))this.setSegmentToIndex(e,null);else{const t=new SE;r.querySegment(s,t,!0),this.setSegmentToIndex(e,t.releaseSegment())}}}return r.isStrongPathStart(e)&&this.setStrongPathStart(o,!0),r.isStrongPathEnd(e)&&this.setStrongPathEnd(o,!0),n}getGeometry(e){const i=this.getGeometryType(e),n=Dm(i,this.m_verticesMp.getDescription()),r=this.getPointCount(e);if(0===r)return n;if(p(i)){const t=n.getImpl(),s=this.getPathCount(e),i=Ue(s+1),o=Oe(s+1,0),a=n.getDescription(),h=this.hasCurves();for(let n=0,m=a.getAttributeCount();n<m;n++){const h=a.getSemantics(n),m=Tm.getComponentCount(h),l=He(h,r),u=this.m_vertices.getAttributeStreamRef(h);let c=0,g=0,_=0;for(let t=this.getFirstPath(e);t!==Nm;t=this.getNextPath(t)){let e=0;this.isClosedPath(t)&&(e|=1),this.isExterior(t)&&(e|=8),this.isStrongPathStart(t)&&(e|=2),this.isStrongPathEnd(t)&&(e|=4),e&&o.setBits(g,e);const s=this.getPathSize(t);if(i.write(g++,_),_+=s,0===h){const e=u,s=l;let i;for(let n=this.getFirstVertex(t);c<_;n=this.getNextVertex(n),c++){const t=this.getVertexIndex(n);i=e.readPoint2D(2*t),s.writePoint2D(2*c,i)}}else for(let i=this.getFirstVertex(t);c<_;i=this.getNextVertex(i),c++){const t=this.getVertexIndex(i);for(let e=0;e<m;e++){const s=u.readAsDbl(t*m+e);l.writeAsDbl(c*m+e,s)}}}t.setAttributeStreamRef(h,l),i.write(s,r)}if(t.setPathFlagsStreamRef(o),t.setPathStreamRef(i),t.notifyModifiedFlags(65535),h){let s=0,i=0;for(let n=this.getFirstPath(e);n!==Nm;n=this.getNextPath(n)){s+=this.getPathSize(n);for(let e=this.getFirstVertex(n);i<s;e=this.getNextVertex(e)){const s=this.getSegment(e);null!==s&&s.isCurve()&&t.replaceSegment(i,s,!0),i++}}}}else if(i===s.enumMultiPoint){const t=n.getImpl(),s=n.getDescription();t.reserve(r),t.resizeNoInit(r);for(let i=0,n=s.getAttributeCount();i<n;i++){const n=s.getSemantics(i),r=Tm.getComponentCount(n),o=t.getAttributeStreamRef(n),a=this.m_vertices.getAttributeStreamRef(n);let h=0;const m=this.getFirstPath(e),l=this.getPathSize(m);for(let t=this.getFirstVertex(m);h<l;t=this.getNextVertex(t),h++){const e=this.getVertexIndex(t);for(let t=0;t<r;t++){const s=a.readAsDbl(e*r+t);o.writeAsDbl(h*r+t,s)}}t.setAttributeStreamRef(n,o)}t.notifyModifiedFlags(65535)}else t(0);return n}queryPointGeometryOnly(t,i){this.getGeometryType(t)!==s.enumMultiPoint&&e("get_point_geometry_only");const n=this.getPointCount(t);if(n>1&&e("get_point_geometry_only"),0===n)return i.assignVertexDescription(this.m_vertexDescription),void i.setEmpty();const r=this.getFirstPath(t),o=this.getFirstVertex(r);this.queryPoint(o,i)}removeGeometry(t){for(let i=this.getFirstPath(t);i!==Nm;i=this.removePath(i));const e=this.getPrevGeometry(t),s=this.getNextGeometry(t);return e!==Nm?this.setNextGeometry(e,s):this.m_firstGeometry=s,s!==Nm?this.setPrevGeometry(s,e):this.m_lastGeometry=e,this.freeGeometry(t),s}createGeometry(t,e){void 0===e&&(e=Ne());const s=this.newGeometry(t);return this.m_vertices||(this.m_verticesMp=new ii({vd:e}),this.m_vertices=this.m_verticesMp.getImpl()),this.mergeVertexDescription(e),this.m_firstGeometry===Nm?(this.m_firstGeometry=s,this.m_lastGeometry=s):(this.setPrevGeometry(s,this.m_lastGeometry),this.setNextGeometry(this.m_lastGeometry,s),this.m_lastGeometry=s),s}getFirstGeometry(){return this.m_firstGeometry}getLastGeometry(){return this.m_lastGeometry}getNextGeometry(t){return this.m_geometryIndexList.getField(t,1)}getPrevGeometry(t){return this.m_geometryIndexList.getField(t,0)}getGeometryType(t){return 16777215&this.m_geometryIndexList.getField(t,2)}setGeometryUserIndex(t,e,s){const i=this.m_geometryIndices[e],n=this.getGeometryIndex(t);n>=i.size()&&i.resize(Math.max(1.25*n,16),-1),i.write(n,s)}getGeometryUserIndex(t,e){const s=this.getGeometryIndex(t),i=this.m_geometryIndices[e];return s<i.size()?i.read(s):-1}createGeometryUserIndex(){for(let t=0;t<this.m_geometryIndices.length;t++)if(null===this.m_geometryIndices[t])return this.m_geometryIndices[t]=Ue(0),t;this.m_geometryIndices.push(Ue(0));const e=this.m_geometryIndices.length-1;return t(e>=0&&e<=Number.MAX_SAFE_INTEGER),e}removeGeometryUserIndex(t){for(this.m_geometryIndices[t]=null;this.m_geometryIndices.length>0&&null===this.m_geometryIndices.at(-1);)this.m_geometryIndices.pop()}getFirstPath(t){return this.m_geometryIndexList.getField(t,3)}getLastPath(t){return this.m_geometryIndexList.getField(t,4)}hasPointFeatures(){for(let t=this.getFirstGeometry();t!==Nm;t=this.getNextGeometry(t))if(!p(this.getGeometryType(t)))return!0;return!1}getPointCount(t){return this.m_geometryIndexList.getField(t,5)}getPathCount(t){return this.m_geometryIndexList.getField(t,6)}filterClosePoints(e,i,n,r,o){const a=e*e;let h=0;const m=this.hasCurves(),l=this.hasSegmentParentage();for(let u=o===Nm?this.getFirstGeometry():o;u!==Nm;u=o===Nm?this.getNextGeometry(u):Nm){const e=this.getGeometryType(u);if(!p(e))continue;if(n&&e!==s.enumPolygon)continue;const o=this.getGeometryType(u)===s.enumPolygon;let c=this.getGeometryModified(u);for(let s=this.getFirstPath(u);s!==Nm;){let e=0;for(let i=this.getFirstVertex(s);e<Math.trunc(this.getPathSize(s)/2);){const n=this.getNextVertex(i);if(n===Nm)break;const o=this.getXY(i),g=this.getXY(n);let _=w.sqrDistance(o,g),d=!0;do{if(_<=a){if(m){const t=this.getSegment(i);if(null!==t){const e=t.calculateLength2D();if(_=e*e,_>a)break}}if(0===_?0===h&&(h=-1):h=1,n!==this.getLastVertex(s)){const e=l&&(this.getSegmentParentageBreakVertex(i)||this.getSegmentParentageBreakVertex(n));if(this.transferAllDataToTheVertex(n,i),this.removeVertex(n,!1),r&&!c&&(this.setGeometryModified(u,!0),c=!0),l&&i!==n){this.setSegmentParentageBreakVertex(i,e);const s=this.getNextVertex(i);t(s!==Nm),this.isDiscontinuousSegmentParentage(s)&&this.setSegmentParentageBreakVertex(s,!0)}}d=!1}}while(0);d&&(i=this.getNextVertex(i)),e++}let n=this.getFirstVertex(s);for(let t=this.isClosedPath(s)?n:this.getLastVertex(s);this.getPathSize(s)>0;){const e=this.getPrevVertex(t);if(e===Nm)break;{const i=this.getXY(e),o=this.getXY(t);let g=w.sqrDistance(i,o),_=!0;do{if(g<=a){if(m){const t=this.getSegment(e);if(null!==t){const e=t.calculateLength2D();if(g=e*e,g>a)break}}0===g?0===h&&(h=-1):h=1;const i=l&&(this.getSegmentParentageBreakVertex(t)||this.getSegmentParentageBreakVertex(e));this.removeVertex(e,!0),r&&!c&&(this.setGeometryModified(u,!0),c=!0),l&&e!==t&&(i||this.isDiscontinuousSegmentParentage(t))&&this.setSegmentParentageBreakVertex(t,!0),n===e&&(n=this.getFirstVertex(s)),_=!1}}while(0);if(_&&(t=this.getPrevVertex(t),t===n))break}}const g=this.getPathSize(s);let _=i&&g<(o?3:2);_&&o&&2===g&&m&&(_=!this.pathHasCurves(s)),_?(s=this.removePath(s),0===h&&(h=-1),r&&!c&&(this.setGeometryModified(u,!0),c=!0)):s=this.getNextPath(s)}}return h}filterClosePoints3D(e,s,i,n,r,o){return t(0),0}hasDegenerateSegments(t){for(let e=this.getFirstGeometry();e!==Nm;e=this.getNextGeometry(e))if(p(this.getGeometryType(e)))for(let s=this.getFirstPath(e);s!==Nm;){const e=this.getPathSize(s);if(0===e)return!0;let i=this.getFirstVertex(s);for(let s=0;s<e;s++){const e=this.getNextVertex(i);if(e===Nm)break;const s=this.getVertexIndex(i),n=this.getSegmentFromIndex(s);let r=0;if(null!==n){if(r=n.calculateLowerLength2D(),r<=t){if(r=n.calculateUpperLength2D(),r<=t)return!0;if(r=n.calculateLength2D(),r<=t)return!0}}else{const i=this.getVertexIndex(e);if(r=this.m_vertices.getShortestDistance(s,i),r<=t)return!0}i=e}s=this.getNextPath(s)}return!1}hasDegenerateSegments3D(e,s){return t(0),!1}transferAllDataToTheVertex(t,e){const s=this.getVertexIndex(t),i=this.getVertexIndex(e);if(this.m_weights){const t=this.getWeightWithIndex(s);this.setWeightWithIndex(i,t)}if(this.m_ranks){const t=this.getRankWithIndex(s);this.setRankWithIndex(i,t)}if(this.m_segmentWeights){const t=this.getSegmentWeightWithIndex(s);this.setSegmentWeightWithIndex(i,t)}if(this.m_segmentRanks){const t=this.getSegmentRankWithIndex(s);this.setSegmentRankWithIndex(i,t)}for(let r=0,o=this.m_indices.length;r<o;r++)if(r!==this.m_selectionIndex&&null!==this.m_indices[r]){const s=this.getUserIndex(t,r);-1!==s&&this.setUserIndex(e,r,s)}const n=this.selected(t);n!==this.selected(e)&&(n?this.select(e):this.unselect(e))}splitSegmentAxisAware(t,s,i,n,r){let o=0;const a=this.getNextVertex(t);a===Nm&&e("");const h=this.getVertexIndex(t),m=this.getVertexIndex(a),l=this.getSegmentFromIndex(h);let u=this.m_vertices.getShortestDistance(h,m);const c=this.getPathFromVertex(t),g=this.m_bHasAttributes;g&&l&&(u=l.calculateLength2D());const _=this.getSegmentParentage(t),d=this.getHelperPoint();if(l){let t=0,e=0,r=Nm;for(let p=0;p<i;p++){const i=s[p];if(t<i&&i<1){const s=l.cut(t,i);if(null!==n&&(p>0&&s.setStartXY(n[p-1]),s.setEndXY(n[p]),s.normalizeAfterEndpointChange(),e=p),g){const t=u>0?l.calculateSubLengthFromStart(i)/u:0;this.m_vertices.interpolateTwoVertices(h,m,t,d)}d.setXY(s.getEndXY()),r=this.insertVertex(c,a,d),o++;const f=this.getPrevVertex(r),x=this.getVertexIndex(f);this.setSegmentToIndex(x,s),-1!==_&&this.setSegmentParentageAndBreak(r,_,!1),t=i}}if(r!==Nm){const s=l.cut(t,1);null!==n&&(s.setStartXY(n[e]),s.normalizeAfterEndpointChange());const i=this.getVertexIndex(r);this.setSegmentToIndex(i,s)}}else{let t=0;for(let e=0;e<i;e++){const i=s[e];if(t<i&&i<1){this.m_vertices.interpolateTwoVertices(h,m,i,d);const t=this.insertVertex(c,a,d);o++,-1!==_&&this.setSegmentParentageAndBreak(t,_,!1)}t=i}}return o}splitSegment(t,e,s,i=null){return this.splitSegmentAxisAware(t,e,s,i,-1)}snapControlPoints(e,s,i){return t(0),!1}snapControlPointsOnSelection(t){if(!this.hasCurves())return!1;let e=0;const s=this.queryVertexIteratorOnSelection();for(let i=s.next();i!==Nm;i=s.next()){const s=this.getVertexIndex(i),n=this.getSegmentFromIndex(s);n&&(e|=n.snapControlPoints(t)?1:0)}return 0!==e}calculateSubLength2D(e,s,i){return t(0),0}setPoint(t,e,s){if(this.setPointOnly(t,e),null!==this.m_segments){const i=this.getVertexIndex(t),n=this.getSegmentFromIndex(i);null!==n&&(n.setStartXY(e.getXY()),n.normalizeAfterEndpointChange(),s&&n.ensureXYMonotone());const r=this.getPrevVertex(t);if(r!==Nm){const t=this.getVertexIndex(r),i=this.getSegmentFromIndex(t);null!==i&&(i.setEndXY(e.getXY()),i.normalizeAfterEndpointChange(),s&&i.ensureXYMonotone())}}}setPointEx(t,e,s,i,n){this.setPoint(t,e,n);const r=this.getVertexIndex(t);this.setWeightWithIndex(r,i),this.setRankWithIndex(r,s)}setPointOnly(t,e){const s=this.getVertexIndex(t);this.m_vertices.setPointByVal(s,e)}setPointOnlyEx(e,s,i,n){t(0)}queryPoint(t,e){const s=this.getVertexIndex(t);this.m_vertices.getPointByVal(s,e)}setXY(t,e){this.setXYCoords(t,e.x,e.y)}setXYCoords(t,e,s){const i=this.getVertexIndex(t);if(this.m_vertices?.setXYCoords(i,e,s),null!==this.m_segments){const n=this.getSegmentFromIndex(i);null!==n&&(n.setStartXYCoords(e,s),n.normalizeAfterEndpointChange());const r=this.getPrevVertex(t);if(r!==Nm){const t=this.getVertexIndex(r),i=this.getSegmentFromIndex(t);null!=i&&(i.setEndXYCoords(e,s),i.normalizeAfterEndpointChange())}}}setXYMonotonic(t,e,s){const i=this.getVertexIndex(t);if(this.m_vertices.setXYCoords(i,e,s),null!==this.m_segments){const n=this.getSegmentFromIndex(i);if(null!==n){const t=n.getEndXY();n.setCoordsForIntersector(new w(e,s),t,!1),n.ensureXYMonotone()}const r=this.getPrevVertex(t);if(r!==Nm){const t=this.getVertexIndex(r),i=this.getSegmentFromIndex(t);if(null!==i){const t=i.getStartXY();i.setCoordsForIntersector(t,new w(e,s),!1),i.ensureXYMonotone()}}}}setXYMonotonicPoint2D(t,e){this.setXYMonotonic(t,e.x,e.y)}queryXY(t,e){const s=this.getVertexIndex(t);return this.m_vertices.queryXY(s,e)}getXY(t){const e=this.getVertexIndex(t);return this.m_vertices.getXY(e)}getXYWithIndex(t){return this.m_xyStream.readPoint2D(2*t)}static setSegDefault(e,s,i){t(0)}setXYZ(e,s,i){t(0)}setXYZCoords(e,s,i,n){t(0)}queryXYZ(e,s){t(0)}getXYZ(e){return t(0),Fe.getNAN()}getXYZWithIndex(e){return t(0),Fe.getNAN()}mergeVertexDescription(t){this.m_verticesMp.mergeVertexDescription(t),this.m_vertexDescription=this.m_verticesMp.getDescription(),this.m_bHasAttributes=this.m_vertexDescription.getAttributeCount()>1}addAttribute(e){t(0)}getAttributeAsDbl(t,e,s){return this.m_vertices.getAttributeAsDbl(t,this.getVertexIndex(e),s)}queryAttributeAsDbl(e,s,i,n){t(0)}setAttribute(e,s,i,n){t(0)}setAttributeInt(e,s,i,n){t(0)}getVertexDescription(){return this.m_vertexDescription}getMinPathVertexY(e){return t(0),0}getVertexIndex(t){return this.m_vertexIndexList.getField(t,0)}getY(t){const e=this.getVertexIndex(t);return this.m_vertices.queryXY(e,this.m_workPoint2D),this.m_workPoint2D.y}getX(t){return this.getXY(t).x}isEqualXY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D)}isEqualXYPoint2D(t,e){return this.queryXY(t,this.m_workPoint2D),this.m_workPoint2D.isEqualPoint2D(e)}isEqualXYZPoint3D(e,s){return t(0),!1}setWeight(t,e){e<1&&(e=1);const s=1===e;if(null==this.m_weights){if(s)return;this.m_weights=We(this.m_vertices.getPointCount(),1)}const i=this.getVertexIndex(t);if(i>=this.m_weights.size()){if(s)return;this.m_weights.resize(i+1,1)}this.m_weights.write(i,e)}setWeightWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_weights){if(s)return;this.m_weights=We(this.m_vertices.getPointCount(),1)}if(t>=this.m_weights.size()){if(s)return;this.m_weights.resize(t+1,1)}this.m_weights.write(t,e)}getWeight(t){if(null===this.m_weights)return 1;const e=this.getVertexIndex(t);return e>=this.m_weights.size()?1:this.m_weights.read(e)}getWeightWithIndex(t){return null===this.m_weights||t>=this.m_weights.size()?1:this.m_weights.read(t)}getRank(t){if(null===this.m_ranks)return Am;const e=this.getVertexIndex(t);return e>=this.m_ranks.size()?Am:this.m_ranks.read(e)}getRankWithIndex(t){return null===this.m_ranks||t>=this.m_ranks.size()?Am:this.m_ranks.read(t)}setRank(t,e){e<Am&&(e=Am);const s=e===Am;if(null===this.m_ranks){if(s)return;this.m_ranks=Ue(this.m_vertices.getPointCount(),Am)}const i=this.getVertexIndex(t);if(i>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(i+1,Am)}this.m_ranks.write(i,e)}setRankWithIndex(t,e){e<Am&&(e=Am);const s=e===Am;if(null===this.m_ranks){if(s)return;this.m_ranks=Ue(this.m_vertices.getPointCount(),Am)}if(t>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(t+1,Am)}this.m_ranks.write(t,e)}setSegmentWeight(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_segmentWeights){if(s)return;this.m_segmentWeights=We(this.m_vertices.getPointCount(),1)}const i=this.getVertexIndex(t);if(i>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(i+1,1)}this.m_segmentWeights.write(i,e)}setSegmentWeightWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null==this.m_segmentWeights){if(s)return;this.m_segmentWeights=We(this.m_vertices.getPointCount(),1)}if(t>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(t+1,1)}this.m_segmentWeights.write(t,e)}getSegmentWeight(t){if(null===this.m_segmentWeights)return 1;const e=this.getVertexIndex(t);return e>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(e)}getSegmentWeightWithIndex(t){return null==this.m_segmentWeights||t>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(t)}getSegmentRank(t){if(null===this.m_segmentRanks)return Vm.st_defaultRank;const e=this.getVertexIndex(t);return e>=this.m_segmentRanks.size()?Vm.st_defaultRank:this.m_segmentRanks.read(e)}getSegmentRankWithIndex(t){return null===this.m_segmentRanks||t>=this.m_segmentRanks.size()?Am:this.m_segmentRanks.read(t)}setSegmentRank(t,e){e<Am&&(e=Am);const s=e===Am;if(null===this.m_segmentRanks){if(s)return;this.m_segmentRanks=Ue(this.m_vertices.getPointCount(),Am)}const i=this.getVertexIndex(t);if(i>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(i+1,Am)}this.m_segmentRanks.write(i,e)}setSegmentRankWithIndex(e,s){t(0)}removeWeights(){t(0),this.m_weights=new Je(0),this.m_segmentWeights=new Je(0)}removeRanks(){t(0),this.m_ranks=new Qe(0),this.m_segmentRanks=new Qe(0)}setUserIndex(t,e,s){const i=this.m_indices[e],n=this.getVertexIndex(t);if(i.size()<=n){if(-1===s)return;i.resize(this.m_vertices.getPointCount(),-1)}i.write(n,s)}getUserIndex(t,e){const s=this.getVertexIndex(t),i=this.m_indices[e];if(s<i.size()){return i.read(s)}return-1}addToUserIndex(t,e,s){const i=this.m_indices[e],n=this.getVertexIndex(t);i.size()<=n&&i.resize(this.m_vertices.getPointCount(),-1);const r=i.read(n);i.write(n,r+s)}createUserIndex(){for(let t=0;t<this.m_indices.length;t++)if(null===this.m_indices[t])return this.m_indices[t]=this.allocateIndex(),t;this.m_indices.push(this.allocateIndex());const e=this.m_indices.length-1;return t(e>=0&&e<=k()),e}createUserIndexUninitialized(){for(let t=0;t<this.m_indices.length;t++)if(null===this.m_indices[t])return this.m_indices[t]=this.allocateIndex(!1),t;this.m_indices.push(this.allocateIndex(!1));const e=this.m_indices.length-1;return t(e>=0&&e<=Number.MAX_SAFE_INTEGER),e}fillUserIndexForGeometry(t,e,s){const i=this.m_indices[e],n=i.size();for(let r=this.getFirstPath(t);r!==Nm;r=this.getNextPath(r)){let t=this.getFirstVertex(r);for(let e=0,o=this.getPathSize(r);e<o;e++,t=this.getNextVertex(t)){const e=this.getVertexIndex(t);e<n&&i.write(e,s)}}}fillUserIndexForSelection(e,s){t(0)}removeUserIndex(t){for(this.recycleUserIndex(this.m_indices[t]),this.m_indices[t]=null;this.m_indices.length>0&&null===this.m_indices[this.m_indices.length-1];)this.m_indices.pop()}replaceCurveWithLine(t){if(null!==this.m_segments){const e=this.getVertexIndex(t);this.setSegmentToIndex(e,null)}}queryLineConnector(t,e,s=!1){const i=this.getNextVertex(t);if(i===Nm)return!1;if(!this.m_bHasAttributes||s){const s=this.getXY(t);e.setStartXY(s);const n=this.getXY(i);e.setEndXY(n)}else{const s=new Ge({vd:this.getVertexDescription()});this.queryPoint(t,s),e.setStart(s),this.queryPoint(i,s),e.setEnd(s)}return!0}queryLineConnector3D(e,s,i=!1){return t(0),!1}hasCurves(){return null!==this.m_segments}geometryHasCurves(e){return t(0),!1}pathHasCurves(t){if(!this.hasCurves())return!1;const e=this.getFirstVertex(t);if(e===Nm)return!1;const i=this.getPathSize(t);let n=e;for(let r=0;r<i;r++,n=this.getNextVertex(n)){const t=this.getSegment(n);if(null!==t&&t.getGeometryType()!==s.enumLine)return!0}return!1}insertPath(t,s){let i=Nm;s!==Nm?(t!==this.getGeometryFromPath(s)&&e(""),i=this.getPrevPath(s)):i=this.getLastPath(t);const n=this.newPath(t);return s!==Nm&&this.setPrevPath(s,n),this.setNextPath(n,s),this.setPrevPath(n,i),i!==Nm?this.setNextPath(i,n):this.setFirstPath(t,n),s===Nm&&this.setLastPath(t,n),this.setGeometryPathCount(t,this.getPathCount(t)+1),n}removePath(t){const e=this.getPrevPath(t),s=this.getNextPath(t),i=this.getGeometryFromPath(t);return e!==Nm?this.setNextPath(e,s):this.setFirstPath(i,s),s!==Nm?this.setPrevPath(s,e):this.setLastPath(i,e),this.clearPath(t),this.setGeometryPathCount(i,this.getPathCount(i)-1),this.freePath(t),s}clearPath(t){const e=this.getFirstVertex(t);if(e!==Nm){let s=e;for(let e=0,n=this.getPathSize(t);e<n;e++){const t=s;s=this.getNextVertex(s),this.freeVertex(t)}const i=this.getGeometryFromPath(t);this.setGeometryVertexCount(i,this.getPointCount(i)-this.getPathSize(t))}this.setPathSize(t,0)}getNextPath(t){return this.m_pathIndexList.getField(t,2)}getPrevPath(t){return this.m_pathIndexList.getField(t,1)}getPathSize(t){return this.m_pathIndexList.getField(t,3)}isClosedPath(t){return!!(1&this.getPathFlags(t))}setClosedPath(t,e){if(this.isClosedPath(t)===e)return;if(this.getPathSize(t)>0){const s=this.getFirstVertex(t),i=this.getLastVertex(t);if(e){this.setNextVertex(i,s),this.setPrevVertex(s,i);const t=this.getVertexIndex(i);this.setSegmentToIndex(t,null)}else{this.setNextVertex(i,Nm),this.setPrevVertex(s,Nm);const t=this.getVertexIndex(i);this.setSegmentToIndex(t,null)}}const s=(1|this.getPathFlags(t))-1;this.setPathFlags(t,s|(e?1:0))}closeAllPaths(e){t(0)}isStrongPathStart(t){return!!(8&this.getPathFlags(t))}isStrongPathEnd(t){return!!(16&this.getPathFlags(t))}setStrongPathStart(t,e){const s=(8|this.getPathFlags(t))-8;this.setPathFlags(t,s|(e?8:0))}setStrongPathEnd(t,e){const s=(16|this.getPathFlags(t))-16;this.setPathFlags(t,s|(e?16:0))}getGeometryFromPath(t){return this.m_pathIndexList.getField(t,7)}isExterior(t){return!!(2&this.getPathFlags(t))}setExterior(t,e){const s=(2|this.getPathFlags(t))-2;this.setPathFlags(t,s|(e?2:0))}getRingArea(t){if(this.isRingAreaValid(t))return this.m_pathAreas[this.getPathIndex(t)];const e=this.getFirstVertex(t);if(e===Nm)return 0;const i=this.getXY(e),n=new Yt(0),r=this.getPathSize(t);if(r>2){const t=i.clone(),s=t.x,o=t.y;let a=this.getNextVertex(e);const h=this.getXY(a);a=this.getNextVertex(a);const m=w.getNAN();for(let e=2;e<r;e++,a=this.getNextVertex(a))this.queryXY(a,m),n.pe((m.x-t.x)*(h.y-o)),t.setCoordsPoint2D(h),h.setCoordsPoint2D(m);n.pe((s-t.x)*(h.y-o))}if(this.hasCurves()){let t=e;for(let e=0;e<r;e++,t=this.getNextVertex(t)){const e=this.getSegment(t);if(null===e||e.getGeometryType()===s.enumLine)continue;const i=2*e.calculateArea2DHelper();n.pe(i)}}this.setRingAreaValid(t,!0);const o=.5*n.getResult();return this.m_pathAreas[this.getPathIndex(t)]=o,o}getPathIndexInternal(t){return this.getPathIndex(t)}getPathInternalIndexFromVertex(t){return this.getPathIndex(this.getPathFromVertex(t))}setPathUserIndex(t,e,s){const i=this.m_pathindices[e],n=this.getPathIndex(t);i.size()<this.m_pathAreas.length&&i.resize(this.m_pathAreas.length,-1),i.write(n,s)}getPathUserIndex(t,e){const s=this.getPathIndex(t),i=this.m_pathindices[e];return s<i.size()?i.read(s):-1}createPathUserIndex(){for(let t=0;t<this.m_pathindices.length;t++)if(null===this.m_pathindices[t])return this.m_pathindices[t]=this.allocatePathIndex(),t;this.m_pathindices.push(this.allocatePathIndex());const e=this.m_pathindices.length-1;return t(e>=0&&e<=Number.MAX_SAFE_INTEGER),e}fillPathUserIndexForGeometry(t,e,s){const i=this.m_pathindices[e],n=i.size();for(let r=this.getFirstPath(t);r!==Nm;r=this.getNextPath(r)){const t=this.getPathIndex(r);t<n&&i.write(t,s)}}removePathUserIndex(t){for(this.recyclePathUserIndex(this.m_pathindices[t]),this.m_pathindices[t]=null;this.m_pathindices.length>0&&null===this.m_pathindices.at(-1);)this.m_pathindices.pop()}movePath(t,s,i){if(i===Nm&&e(""),s===i)return;const n=this.getNextPath(i);let r=this.getPrevPath(i);const o=this.getGeometryFromPath(i);r===Nm?this.setFirstPath(o,n):this.setNextPath(r,n),n===Nm?this.setLastPath(o,r):this.setPrevPath(n,r),this.setGeometryVertexCount(o,this.getPointCount(o)-this.getPathSize(i)),this.setGeometryPathCount(o,this.getPathCount(o)-1),r=s===Nm?this.getLastPath(t):this.getPrevPath(s),this.setPrevPath(i,r),this.setNextPath(i,s),s===Nm?this.setLastPath(t,i):this.setPrevPath(s,i),r===Nm?this.setFirstPath(t,i):this.setNextPath(r,i),this.setGeometryVertexCount(t,this.getPointCount(t)+this.getPathSize(i)),this.setGeometryPathCount(t,this.getPathCount(t)+1),this.setPathGeometry(i,t)}addVertex(t,e){this.m_vertices.getPointByVal(this.getVertexIndex(e),this.getHelperPoint());return this.insertVertex_(t,Nm,this.getHelperPoint(),!1)}insertVertex(t,e,s){return this.insertVertex_(t,e,s,!0)}removeVertex(t,e){const s=this.getPathFromVertex(t),i=this.getPrevVertex(t),n=this.getNextVertex(t);i!==Nm&&this.setNextVertex(i,n);const r=this.getPathSize(s);t===this.getFirstVertex(s)&&this.setFirstVertex(s,r>1?n:Nm),n!==Nm&&this.setPrevVertex(n,i),t===this.getLastVertex(s)&&this.setLastVertex(s,r>1?i:Nm);if(this.hasCurves()&&i!==Nm&&n!==Nm){const s=this.getVertexIndex(t),r=this.getVertexIndex(i),o=this.getVertexIndex(n);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(s,null)}else{const t=this.getSegmentFromIndex(s);if(this.setSegmentToIndex(s,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}this.setPathSize(s,r-1);const o=this.getGeometryFromPath(s);return this.setGeometryVertexCount(o,this.getPointCount(o)-1),this.freeVertex(t),n}removeVertices(e,s){t(e!==s);const i=this.getPathFromVertex(e),n=this.getPrevVertex(e),r=this.getPrevVertex(s);n!==Nm&&this.setNextVertex(n,s);let o=this.getPathSize(i);const a=this.getVertexIndex(e);this.setSegmentToIndex(a,null),this.setPrevVertex(s,n),this.setPrevVertex(e,Nm),this.setNextVertex(r,Nm);let h=0,m=e;const l=this.getFirstVertex(i);let u=!1;for(;;){const t=this.getNextVertex(m);if(u||=l===m,this.freeVertex(m),h++,m===r)break;m=t}o-=h,u&&this.setFirstVertex(i,o>0?s:Nm),this.setPathSize(i,o);const c=this.getGeometryFromPath(i);this.setGeometryVertexCount(c,this.getPointCount(c)-h)}getFirstVertex(t){return this.m_pathIndexList.getField(t,4)}getLastVertex(t){return this.m_pathIndexList.getField(t,5)}getNextVertex(t){return this.m_vertexIndexList.getField(t,2)}getPrevVertex(t){return this.m_vertexIndexList.getField(t,1)}getNextVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,2):this.m_vertexIndexList.getField(t,1)}getPrevVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,1):this.m_vertexIndexList.getField(t,2)}getPathFromVertex(t){return this.m_vertexIndexList.getField(t,3)}addPoint(t,e){return this.insertVertex_(t,Nm,e,!1)}getGeometryFromVertex(t){return this.getGeometryFromPath(this.getPathFromVertex(t))}replaceNaNs(t,e){this.m_vertexDescription.hasAttribute(t)||m(""),this.m_vertices.replaceNaNs(t,e)}removeNaNVertices(){for(let t=this.getFirstGeometry();t!==Nm;t=this.getNextGeometry(t))for(let e=this.getFirstPath(t);e!==Nm;e=this.getNextPath(e)){let t=this.getFirstVertex(e);for(let s=0,i=this.getPathSize(e);s<i;s++)t=this.getXY(t).isFinite()?this.getNextVertex(t):this.removeVertex(t,!0)}}queryVertexIterator(t=Nm){return this.queryVertexIteratorEx(!1,t)}queryVertexIteratorEx(t,e=Nm){let s=Nm,i=Nm,n=Nm,r=Nm,o=0,a=!1;for(s=e!==Nm?e:this.getFirstGeometry();s!==Nm;s=this.getNextGeometry(s))if(!t||p(this.getGeometryType(s))){for(i=this.getFirstPath(s);i!==Nm;i=this.getNextPath(i))if(n=this.getFirstVertex(i),r=n,o=0,n!==Nm){a=!0;break}if(a||e!==Nm)break}return a||(s=Nm),Mm.create_(this,s,i,n,r,o,t,!1,e!==Nm)}queryVertexIteratorOnSelection(t=Nm){return this.m_selection?Mm.create_(this,t,Nm,Nm,Nm,-1,!1,!0,t!==Nm):this.queryVertexIteratorEx(!1,t)}hasSelection(){return this.m_selection}createEmptySelection(){t(0)}removeSelection(){this.m_selection&&(this.m_selectedVertices.length=0,this.removeUserIndex(this.m_selectionIndex),this.m_selectionIndex=-1,this.m_selection=!1,this.m_selectedCount=0)}select(t){return!!this.selected(t)||(this.setUserIndex(t,this.m_selectionIndex,this.m_selectedVertices.length),this.m_selectedVertices.push(t),this.m_selectedCount++,!1)}unselect(t){if(!this.m_selection)return;const e=this.getUserIndex(t,this.m_selectionIndex);e>=0&&(this.m_selectedVertices[e]=Nm,this.setUserIndex(t,this.m_selectionIndex,-1),this.m_selectedCount--)}selected(t){return!this.m_selection||this.selected_(t)}getSelectedCount(){return this.m_selection?this.m_selectedCount:this.getTotalPointCount()}createSelectionForCrackingAndClustering(e,s){return t(0),!1}peelALoop(t,e){this.peelALoop_(t,e,!1)}peelALoopIntoAPath(t,e){return this.peelALoop_(t,e,!0)}applyTransformation(t){if(this.m_verticesMp.applyTransformation(t),null!==this.m_segments)for(let e=0,s=this.m_segments.length;e<s;e++)this.m_segments[e]&&this.m_segments[e].applyTransformation(t)}setGeometryType(t,e){this.m_geometryIndexList.setField(t,2,e)}splitSegmentWithIntersector(t,e,s,i,n){i?this.splitSegmentForward(t,e,s,!0,n):this.splitSegmentBackward(t,e,s,!0,n)}setPrevVertex(t,e){this.m_vertexIndexList.setField(t,1,e)}setNextVertex(t,e){this.m_vertexIndexList.setField(t,2,e)}setPathToVertex(t,e){this.m_vertexIndexList.setField(t,3,e)}setPathSize(t,e){this.m_pathIndexList.setField(t,3,e)}setFirstVertex(t,e){this.m_pathIndexList.setField(t,4,e)}setLastVertex(t,e){this.m_pathIndexList.setField(t,5,e)}getSegment(t){if(null!=this.m_segments){const e=this.getVertexIndex(t);return this.getSegmentFromIndex(e)}return null}isCurve(e){return t(0),!1}querySegment(t,e,s=!0,i=!1){const n=this.getNextVertex(t);if(n===Nm)return!1;const r=this.getSegment(t);if(!r)return!s&&(this.queryLineConnector(t,e.createLine(),i),!0);if(e.copyFrom(r,!0),i)return!0;if(this.m_vertexDescription.getAttributeCount()>1){const s=this.getHelperPoint();this.queryPoint(t,s),e.get().setStart(s),this.queryPoint(n,s),e.get().setEnd(s)}return!0}getSegmentFromIndex(t){const e=null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null;return e||null}getAndClearSegmentFromIndex(t){const e=null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null;return e||null}setSegmentToIndex(t,e){if(this.m_bHasForceSetEnvelope=!1,null===this.m_segments){if(!e)return;this.m_segments=[],this.m_segments.length=this.m_vertices.getPointCount()}t>=this.m_segments.length&&(this.m_segments.length=t+1),this.m_segments[t]=e}setGeometryPathCount(t,e){this.m_geometryIndexList.setField(t,6,e)}setGeometryVertexCount(t,e){this.m_geometryIndexList.setField(t,5,e)}ringParentageCheckInternal(e,s){return t(0),!1}reverseRingInternal(t){const e=this.hasCurves(),s=this.hasSegmentParentage();let i=null,n=-1,r=t;if(e){const t=this.getVertexIndex(r);i=this.getAndClearSegmentFromIndex(t)}s&&(n=this.getSegmentParentage(r));do{const t=this.getPrevVertex(r),o=this.getNextVertex(r);if(this.setNextVertex(r,t),this.setPrevVertex(r,o),e){const t=this.getVertexIndex(o),e=this.getSegmentFromIndex(t);i&&i.reverse(),this.setSegmentToIndex(t,i),i=e}if(s){const t=this.getSegmentParentage(o);this.setSegmentParentagePreserveBreak(o,n),n=t}r=o}while(r!==t);this.dbgVerifyIntegrity(t)}setTotalPointCount(t){this.m_pointCount=t}removePathOnly(t){const e=this.getPrevPath(t),s=this.getNextPath(t),i=this.getGeometryFromPath(t);e!==Nm?this.setNextPath(e,s):this.setFirstPath(i,s),s!==Nm?this.setPrevPath(s,e):this.setLastPath(i,e),this.setFirstVertex(t,Nm),this.setLastVertex(t,Nm),this.freePath(t)}insertClosedPath(t,e,s,i,n){const r=this.insertPath(t,Nm);let o=0,a=s;for(n[0]=!1;;){a===i&&(n[0]=!0),this.setPathToVertex(a,r),o++;const t=this.getNextVertex(a);if(t===s)break;a=t}return this.setClosedPath(r,!0),this.setPathSize(r,o),n[0]&&(s=i),this.setFirstVertex(r,s),this.setLastVertex(r,this.getPrevVertex(s)),this.setRingAreaValid(r,!1),r}findVertex2D(e,s){return t(0),0}findVertex3D(e,s,i){return t(0),0}dbgVerifyMonotone(){}dbgCheckSelection(){}dbgVerifySegment(t){}dbgVerifyIntegrity(t,e=!0){}dbgVerifyVertexCounts(){}dbgVerifyCurves(){}dbgDumpGeometry(e,s){t(0)}removeVertexInternal(t,e){const s=this.getPrevVertex(t),i=this.getNextVertex(t);s!==Nm&&this.setNextVertex(s,i),i!==Nm&&this.setPrevVertex(i,s);if(this.hasCurves()&&s!==Nm&&i!==Nm){const n=this.getVertexIndex(t),r=this.getVertexIndex(s),o=this.getVertexIndex(i);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(n,null)}else{const t=this.getSegmentFromIndex(n);if(this.setSegmentToIndex(n,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}return this.freeVertex(t),i}isRingAreaValid(t){return!!(4&this.getPathFlags(t))}setRingAreaValid(t,e){const s=(4|this.getPathFlags(t))-4;this.setPathFlags(t,s|(e?4:0))}compareVerticesSimpleY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.compare(this.m_workPoint2_2D)}compareVerticesSimpleY3D(t,e){return this.getXYZ(t).compare(this.getXYZ(e))}compareVerticesSimpleX(t,e){return this.getXY(t).compareX(this.getXY(e))}sortVerticesSimpleByYHeapMerge(e,s){t(0)}sortVerticesSimpleByY(t,e,s){this.m_bucketSort.sort(t,e,s,new qm(this))}sortVerticesSimpleByX(e,s,i){t(0)}sortVerticesSimpleByY3D(e,s,i){t(0)}snapVertexForPoleClipping(t,e){const s=this.getPrevVertex(t);s!==Nm&&this.replaceCurveWithLine(s);this.getNextVertex(t)!==Nm&&this.replaceCurveWithLine(t);const i=new w;this.queryXY(t,i),i.y=e,this.setXY(t,i)}setSegmentParentageAndBreak(e,s,i=!0){if(-1===this.m_segmentParentageIndex){if(-1===s)return;this.m_segmentParentageIndex=this.createUserIndex()}s>=0&&(t(s<=L()>>1),s<<=1,s|=i?1:0),this.setUserIndex(e,this.m_segmentParentageIndex,s)}setSegmentParentagePreserveBreak(e,s){if(t(s>=-1),-1===this.m_segmentParentageIndex){if(-1===s)return;this.m_segmentParentageIndex=this.createUserIndex()}if(s>=0){t(s<=L()>>1),s<<=1;s|=this.getSegmentParentageBreakVertex(e)?1:0}this.setUserIndex(e,this.m_segmentParentageIndex,s)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0?e:e>>1}getOriginalSegmentInfo(t){if(-1!==this.m_segmentParentageIndex){const e=this.getSegmentParentage(t);return new Gm(e)}return new Gm(-1)}setSegmentParentageBreakVertex(t,e){if(-1===this.m_segmentParentageIndex)return;let s=this.getUserIndex(t,this.m_segmentParentageIndex);s<0||!!(1&s)!==e&&(e?s|=1:s&=L()>>1<<1,this.setUserIndex(t,this.m_segmentParentageIndex,s))}getSegmentParentageBreakVertex(t){if(-1===this.m_segmentParentageIndex)return!0;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0||!!(1&e)}isDiscontinuousSegmentParentage(t){const e=this.getPrevVertex(t);if(e===Nm)return!1;return this.getSegmentParentage(e)!==this.getSegmentParentage(t)}setCurveStitcherPointer(t){this.m_curveStitcher=t}hasSegmentParentage(){return-1!==this.m_segmentParentageIndex}deleteSegmentParentage(){-1!==this.m_segmentParentageIndex&&(this.removeUserIndex(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),this.m_curveStitcher=null}clearSegments(){this.m_segments=null}}Vm.st_defaultRank=1;class Ym{constructor(t,s,i){void 0===t?(this.x=new ot,this.y=new ot,this.z=new ot):t instanceof Fe?(this.x=new ot(t.x),this.y=new ot(t.y),this.z=new ot(t.z)):t instanceof ot?(this.x=t.clone(),this.y=s.clone(),this.z=i.clone()):e("EPoint3D constructor")}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y)).addE(this.z.mulE(t.z))}crossProduct(t){return new Ym(this.y.mulE(t.z).subE(this.z.mulE(t.y)),this.z.mulE(t.x).subE(this.x.mulE(t.z)),this.x.mulE(t.y).subE(this.y.mulE(t.x)))}crossProductVector(t){const e=this.y.mulE(t.z).subE(t.y.mulE(this.z)),s=t.x.mulE(this.z).subE(this.x.mulE(t.z)),i=this.x.mulE(t.y).subE(t.x.mulE(this.y));return new Ym(e,s,i)}sqrLength(){return this.x.mulE(this.x).addE(this.y.mulE(this.y)).addE(this.z.mulE(this.z))}length(){return this.sqrLength().sqrt()}static distance(t,e){return t.sub(e).length()}negate(){return new Ym(this.x.negate(),this.y.negate(),this.z.negate())}add(t){return new Ym(this.x.addE(t.x),this.y.addE(t.y),this.z.addE(t.z))}sub(t){return new Ym(this.x.subE(t.x),this.y.subE(t.y),this.z.subE(t.z))}subThis(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this.z.subThisE(t.z),this}addThis(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this.z.addThisE(t.z),this}mul(t){return new Ym(this.x.mulE(t),this.y.mulE(t),this.z.mulE(t))}div(t){return new Ym(this.x.divE(t),this.y.divE(t),this.z.divE(t))}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)&&this.z.eq(t.z)}isZero(){return this.x.isZero()&&this.y.isZero()&&this.z.isZero()}value(){return Fe.construct(this.x.value(),this.y.value(),this.z.value())}}class Xm{constructor(e){this.m_origin=new Fe,this.m_normal=new Fe,this.m_axisX=new Fe,this.m_axisY=new Fe,t(0)}assign(e){return t(0),this}set(e,s,i,n){t(0)}setFromPoints(e,s,i){return t(0),!1}getCoord(e,s){return t(0),{}}getCoord2D(e){return t(0),{}}getCoordX(e,s){return t(0),0}getCoordY(e,s){return t(0),0}getCoordZ(e,s){return t(0),0}setPreferredAxisX(e){t(0)}getOrigin(){return t(0),{}}getNormal(){return t(0),{}}getAxisX(){return this.m_axisX.clone()}getAxisY(){return this.m_axisY.clone()}setAxisX(e,s=!1){t(0)}setAxisY(e,s=!1){t(0)}recalculateAxisY(){t(0)}setOrigin(e){t(0)}setNormal(e,s){t(0)}intersect(e,s){return t(0),!1}intersectLine(e){return t(0),0}intersectLineEx(e,s){return t(0),0}closestCoordinate(e){return t(0),{}}projectVector(e){return t(0),{}}signedDistance(e){return t(0),0}distance(e){return t(0),0}}function km(t,e){return!1}function Rm(e,s,i,n,r=100,o=km){let a,h,m,l,u,c,g,_,d;t(n>0);let p,f,x,y=0,P=0;const E=kt();s>i&&(i=q(s,s=i));const C=e(s),S=e(i);C<S?(a=h=m=s,l=u=c=C):(a=h=m=i,l=u=c=S);let v=0;for(;v<r&&(x=.5*(i-s),d=s+x,p=n*(Math.abs(a)+.25),f=2*p,!(o(a,l)||Math.abs(a-d)<=f-x));++v){if(Math.abs(P)>p){const t=(a-h)*(l-c);let e=(a-m)*(l-u),n=(a-m)*e-(a-h)*t;e=2*(e-t),e>0&&(n=-n),e=Math.abs(e);const r=P;P=y,Math.abs(n)>=Math.abs(e*r*.5)||n<=e*(s-a)||n>=e*(i-a)?(P=a>=d?s-a:i-a,y=kt()*P):(y=n/e,_=a+y,(_-s<f||i-_<f)&&(y=d-a<0?-Math.abs(p):Math.abs(p)))}else P=a>=d?s-a:i-a,y=P*E;_=a+y,g=e(_),g<l?(_>=a?s=a:i=a,m=h,h=a,a=_,c=u,u=l,l=g):(_<a?s=_:i=_,g<=u||h===a?(m=h,h=_,c=u,u=g):(g<=c||m===a||m===h)&&(m=_,c=g))}return j(a,l)}function Bm(t,e,s){if(t>s){t-=Math.ceil((t-s)/ae)*ae}else if(t<e){t+=Math.ceil((e-t)/ae)*ae}return t}function Lm(t,e,s){return Hm(t,e,s,0)}function Hm(t,e,s,i){const n=s.x,r=s.y;return Um(t,e,Math.cos(n),Math.sin(n),Math.cos(r),Math.sin(r),i)}function zm(t,e,s,i,n,r){return Um(t,e,s,i,n,r,0)}function Um(t,e,s,i,n,r,o){const a=t/Math.sqrt(1-e*r*r),h=a+o,m=h*n*s,l=h*n*i,u=(a*(1-e)+o)*r;return Fe.construct(m,l,u)}function Om(t,e,s){const i=new ot,n=new ot,r=new ot,o=new ot;i.setCos(s.x),n.setSin(s.x),r.setCos(s.y),o.setSin(s.y);const a=o.negate().mulE(o.mul(e)).add(1).sqrt(),h=new ot(t).divE(a),m=h.mulE(r).mulE(i),l=h.mulE(r).mulE(n),u=h.mul(1-e).mulE(o);return new Ym(m,l,u)}function Wm(t,e,s){const i=s.x,n=s.y,r=s.z,o=Math.atan2(n,i),a=Math.sqrt(i*i+n*n),h=Math.atan2(r,(1-e)*a);return w.construct(o,h)}function jm(t,e,s){const i=1-e,n=t/Math.sqrt(M(s.x)+M(s.y)+M(s.z)/i);return s.mul(n)}function Zm(t,e,s,i,n){const r=Lm(t,e,s),o=Lm(t,e,i);return Wm(t,e,Fe.lerp(r,o,n))}function Qm(t,e,s){const i=new Fe;return i.setCrossProductVector(e,s),Math.abs(Math.atan2(i.length(),e.dotProduct(s)))*t}function Km(t,e,s,i,n){const r=s.getUnitVector(),o=i.getUnitVector(),a=e.getUnitVector(),h=new Fe;if(h.setCrossProductVector(r,o),!h.isZero()){h.normalizeThis();const e=a.sub(h.mul(h.dotProduct(a)));if(!e.isZero()){e.normalizeThis();const s=r.add(o).mul(.5);if(s.dotProduct(e)>s.dotProduct(r)){const s=Math.abs(h.dotProduct(a)),i=Math.asin(s);return n.assign(e.getUnitVector().mul(t)),i*t}}}const m=Qm(1,r,a),l=Qm(1,o,a);return m<=l?(n.assign(s),m*t):(n.assign(i),l*t)}function Jm(t,e,s,i){const n={stack:[],error:void 0,hasError:!1};try{const r=me(n,new fC,!1);return bC.geodeticDistance(t,e,s.x,s.y,i.x,i.y,r,null,null,yC.PE_LINETYPE_GEODESIC),r.val}catch(r){n.error=r,n.hasError=!0}finally{le(n)}}function $m(e,s,i,r,o){switch(t(i.isFinite()&&r.isFinite()),o){case 0:return Jm(e,s,i,r);case 1:return sl(e,s,i);case 2:case 3:{const t=Lm(e,s,i),n=Lm(e,s,r);return Fe.distance(t,n)}default:n("")}}function tl(t,e,s,i,n,r=0,o){if(2===r||3===r)return el(t,e,s,i,n,3===r,o);const a=Wm(t,e,s),h=s=>{const o=Wm(t,e,Fe.lerp(i,n,s));return $m(t,e,a,o,r)},m=Fe.distance(i,n);if(m>0){const s=_l(t,m),{first:r,second:a}=Rm(h,0,1,s);return o&&o.assign(jm(t,e,Fe.lerp(i,n,r))),j(r,a)}{const t=h(0);return o&&o.assign(i),j(.5,t)}}function el(t,e,s,i,n,r=!1,o){const a=jm(t,e,s);if(r){const r=new Xm({pt0:new Fe(0,0,0),pt1:i,pt2:n}),h=r.closestCoordinate(s),m=r.closestCoordinate(i),l=r.closestCoordinate(n),u=w.getClosestCoordinate(m,l,h),c=jm(t,e,Fe.lerp(i,n,u)),g=Fe.distance(c,a);return o&&o.assign(c),j(u,g)}const h=s=>{const r=jm(t,e,Fe.lerp(i,n,s));return Fe.distance(r,a)},m=Fe.distance(i,n);if(m>0){const s=_l(t,m),{first:r,second:a}=Rm(h,0,1,s);return o&&o.assign(jm(t,e,Fe.lerp(i,n,r))),j(r,a)}{const t=Fe.distance(s,i);return o&&o.assign(s),j(.5,t)}}function sl(t,e,s,i){const n={stack:[],error:void 0,hasError:!1};try{const i=me(n,new fC,!1);return bC.greatEllipticDistance(t,e,s.x,s.y,s.x,s.y,i,null,null),i.val}catch(r){n.error=r,n.hasError=!0}finally{le(n)}}function il(t,e,s,i,n){if(Math.abs(s.x-i.x)>Math.PI)return Number.NaN;if(Math.abs(s.y)>xt||Math.abs(i.y)>xt)return Number.NaN;if((Math.abs(s.y)===xt||Math.abs(i.y)===xt)&&s.x!==i.x)return Number.NaN;const{first:r,second:o}=Jt(s.x,i.x);let a=n;a=Bm(a,r,o);if(!A.construct(s.x,i.x).containsCoordinate(a))return Number.NaN;const h=pi.constructPoint2D(s),m=pi.constructPoint2D(i),l=Om(1,e,h),u=Om(1,e,m),c=l.crossProductVector(u);if(c.z.isZero()){return s.y}const g=c.x.divE(c.z.negate()),_=c.y.divE(c.z.negate()),d=g.mulE(g).addE(_.mulE(_)).sqrt();if(d.isZero()||g.isZero()&&_.isZero()){return s.y}const p=Math.atan2(_.value(),g.value());let f=Math.atan2(d.value()*Math.cos(p-a),1-e);const x=Lm(1,e,w.construct(a,f)),y=Fe.construct(x.x,x.y,-x.z),P=c.value().dotProduct(x),E=c.value().dotProduct(y);return Math.abs(E)<Math.abs(P)&&(f=-f),f}function nl(t,e,s,i,n,r){if(r[0]=Number.NaN,r[1]=Number.NaN,Math.abs(s.x-i.x)>Math.PI)return 0;if(Math.abs(s.y)>xt||Math.abs(i.y)>xt)return 0;if((Math.abs(s.y)===xt||Math.abs(i.y)===xt)&&s.x!==i.x)return 0;if(Math.abs(n)>=xt)return 0;if(s.y>0&&i.y>0&&s.y>n&&i.y>n||s.y<0&&i.y<0&&s.y<n&&i.y<n)return 0;const o=pi.constructPoint2D(s),a=pi.constructPoint2D(i),h=Om(1,e,o),m=Om(1,e,a),l=h.crossProductVector(m);if(l.z.isZero()){return A.construct(s.y,i.y).containsCoordinate(n)?(r[0]=s.x,1):0}const u=l.x.divE(l.z.negate()),c=l.y.divE(l.z.negate()),g=u.mulE(u).addE(c.mulE(c)).sqrt();if(g.isZero()||u.isZero()&&c.isZero())return 0===n?(r[0]=s.x,r[1]=i.x,2):0;const _=(1-e)*Math.tan(n)/g.value();if(Math.abs(_)>1)return 0;const d=Math.acos(_),p=Math.atan2(c.value(),u.value()),f=p-d;let x=p+d;const y=Math.min(s.x,i.x),P=Math.max(s.x,i.x);Bm(f,y,P),0!==n?Bm(x,y,P):x=f;let E=0;return y<=f&&f<=P&&(r[E]=f,E++),x!==f&&y<=x&&x<=P&&(r[E]=x,E++),E}function rl(e,s){s[0]>.5*Math.PI?(e[0]+=Math.PI,s[0]=Math.PI-s[0]):s[0]<.5*-Math.PI&&(e[0]-=Math.PI,s[0]=-Math.PI-s[0]),t(s[0]>=.5*-Math.PI&&s[0]<=.5*Math.PI)}function ol(t,e){return t*Math.sqrt(1-e)}function al(t){return 1-t}function hl(t,e,s,i,n){i=T(i,-xt,xt),n=T(n,-xt,xt);const r=xt-.03;let o;o=i>r&&n>r||i<-r&&n<-r?ml(t,i,n):ll(t,n)-ll(t,i);return.5*(s-e)*o*al(t)}function ml(t,e,s){let i=1;if(e<0&&(i=-1,e=-e,s=-s),0!==t){const n=t*t,r=n*t,o=[1,(1+11*t)/12,(1+118*t+241*n)/360,(1+1089*t+10419*n+8651*r)/20160,(1+9836*t+318246*n+1027436*r+458881*(r*t))/1814400],a=e=>{let s=0;const i=M(e)/(t-1);for(let t=o.length-1;t>=0;--t)s=o[t]+s*i;return s*=-M(e/(1-t)),s},h=a(xt-e);return(a(xt-s)-h)*i}{const t=xt-e,n=xt-s,r=-4*M(Math.sin(t/2));return(-4*M(Math.sin(n/2))-r)*i}}function ll(t,e){if(0===e)return 0;const s=Math.sin(e);let i=s,n=s;if(0!==t){i/=1-t*s*s;const e=Math.sqrt(t);n=s*Pt(e*s)}return i+n}function ul(t,e){return t/Math.sqrt(1-e)}function cl(t,e){return(1-e)*t}function gl(t,e,s){const i=s/(2*cl(t,e)),n=i*i;return s*(1-n*(.16666666666666666-.008333333333333333*n))}function _l(t,e){if(0!==e){const s=t*re()/e;return Math.min(s,1e-10)}return 0}function dl(t,e,s,i,n){return pl(t,e,null,s,i,n)}function pl(i,n,r,a,h,l){const u=i.getGeometryType();if(u===s.enumPoint){const t=i.getXY();return n.contains(t)?i:i.createInstance()}if(u===s.enumEnvelope){const t=ge.constructEmpty();if(i.queryEnvelope(t),t.intersect(n)){const e=i.clone();return e.setEnvelope(t),e}return i.createInstance()}if(i.isEmpty())return i;if(n.isEmpty())return i.createInstance();const c=n.clone();{const t=new ge;if(i.queryLooseEnvelope(t),c.containsEnvelope(t))return i;if(!c.isIntersecting(t))return i.createInstance();0===h&&(t.intersect(c),t.inflate(Math.max(.1*t.maxDimension(),1)),t.intersect(c),c.assign(t))}let g=a;if((null!==r||Number.isNaN(g))&&(g=Cs(r,c,!1).total()),u===s.enumGeometryCollection){const t=i,e=i.createInstance();for(let s=0,i=t.getGeometryCount();s<i;s++){const i=t.getGeometry(s);if(i.isEmpty())continue;const n=dl(i,c,g,h,l);n.isEmpty()||(n===i?e.addGeometry(n.clone()):e.addGeometry(n))}return e}o(u)||e("Clip: geometry not supported");const _=i.getImpl().getAccelerators();if(null!==_){const e=_.getRasterizedGeometry();t(null===e)}switch(u){case s.enumMultiPoint:{const e=i;let s;const n=e.getPointCount(),r=e.getImpl().getAttributeStreamRef(0);let o=0;for(let t=0;t<n;t++){const i=r.readPoint2D(2*t);c.contains(i)||(0===o&&(s=e.createInstance()),o<t&&s.addPoints(e,o,t),o=t+1)}return o>0&&s.addPoints(e,o,n),0===o?e:(t(null!==s),s)}case s.enumPolygon:case s.enumPolyline:return xl(i,c,g,h,l);default:m("")}}function fl(t,e,s,i,n,r){const o=new yl(e,r),a=new ge;return t.queryLooseEnvelope(a),e.containsEnvelope(a)?t:e.isIntersecting(a)?o.clipPolesOut(t,n):t.createInstance()}function xl(t,e,s,i,n){return new yl(e,n).clipMultiPath2(t,s,i)}class yl{constructor(t,e){this.m_shape=new Vm,this.m_geometry=Nm,this.m_verticesOnExtentIndex=-1,this.m_verticesOnExtent=[],this.m_progressCounter=0,this.m_extent=new ge(t),this.m_progressTracker=e}progress_(){}clipMultiPath2(t,e,i){return t.getGeometryType()===s.enumPolygon?this.clipPolygonOrProjectedPolyline2(t,i):this.clipPolyline(t,e)}clipPolygonOrProjectedPolyline2(e,i){const n=e.getGeometryType()===s.enumPolyline;if(0===this.m_extent.width()||0===this.m_extent.height())return e.createInstance();const r=ge.constructEmpty();e.queryLooseEnvelope(r),this.m_geometry=n?this.m_shape.addGeometry(e):this.m_shape.addGeometry(e,this.m_extent);const o=ge.constructEmpty(),a=ge.constructEmpty(),h=new w,m=new w,l=new Array(9),u=new Array(9),c=D(w,9);let g=null;const _=new CE,d=[];let p=!1;for(let s=0;!p&&s<4;s++){let e=!1;const i=!!(1&s);let f=0;switch(s){case 0:f=this.m_extent.xmin,e=r.xmin<=f&&r.xmax>=f;break;case 1:f=this.m_extent.ymin,e=r.ymin<=f&&r.ymax>=f;break;case 2:f=this.m_extent.xmax,e=r.xmin<=f&&r.xmax>=f;break;case 3:f=this.m_extent.ymax,e=r.ymin<=f&&r.ymax>=f}if(e){p=!0;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Nm;){let r=!0,x=-1,y=-1;const P=this.m_shape.getFirstVertex(e);let E=P;do{this.progress_(),g=this.m_shape.getSegment(E);let e=g;if(null===e){const s=this.m_shape.getNextVertex(E);if(s===Nm){t(n),0===x&&d.push(E);break}this.m_shape.queryXY(E,h),_.setStartXY(h),this.m_shape.queryXY(s,m),_.setEndXY(m),e=_}e.queryLooseEnvelope(o);let P=yl.checkSegmentIntersection(o,s,f);e.isCurve()&&0===P&&e.isCurve()&&(_.setStartXY(e.getStartXY()),_.setEndXY(e.getEndXY()),this.m_shape.replaceCurveWithLine(E),e=_,_.queryEnvelope(o),P=yl.checkSegmentIntersection(o,s,f));let C=0,S=Nm;if(-1===P){const n=e.intersectionWithAxis2D(i,f,l,u);if(n>0){let s=null;if(e.isCurve()){s=c,t(n<=9);for(let t=0;t<n;t++)i?c[t].setCoords(l[t],f):c[t].setCoords(f,l[t]);C=this.m_shape.splitSegmentAxisAware(E,u,n,s,i?1:0)}else C=this.m_shape.splitSegmentAxisAware(E,u,n,null,-1)}else C=0;C+=1;let o=E,P=this.m_shape.getNextVertex(o);e=null;for(let t=0;t<C;t++){this.m_shape.queryXY(o,h),this.m_shape.queryXY(P,m),g=this.m_shape.getSegment(o);let t=g;null===t&&(_.setStartXY(h),_.setEndXY(m),t=_),t.queryEnvelope(a);let e=yl.checkSegmentIntersection(a,s,f);if(t.isCurve()&&0===e&&(this.m_shape.replaceCurveWithLine(o),_.setStartXY(h),_.setEndXY(m),t=_,t.queryEnvelope(a),e=yl.checkSegmentIntersection(a,s,f)),-1===e){if(i){Math.abs(h.y-f)<Math.abs(m.y-f)?(h.y=f,this.m_shape.setXY(o,h)):(m.y=f,this.m_shape.setXY(P,m))}else{Math.abs(h.x-f)<Math.abs(m.x-f)?(h.x=f,this.m_shape.setXY(o,h)):(m.x=f,this.m_shape.setXY(P,m))}g=this.m_shape.getSegment(o),t=g,null===t&&(_.setStartXY(h),_.setEndXY(m),t=_),t.queryEnvelope(a),e=yl.checkSegmentIntersection(a,s,f),-1===e&&(e=yl.checkSegmentIntersectionLoose(a,s,f))}const n=x;x=e,-1===y&&(y=x),0===n&&1===x||1===n&&0===x||0===n&&0===x&&d.push(o),1===x&&(p=!1,r=!1),o=P,S=o,P=this.m_shape.getNextVertex(P)}}if(0===C){const t=x;x=P,-1===y&&(y=x),0===t&&x>=1||t>=1&&0===x||0===t&&0===x&&d.push(E),1===x&&(p=!1,r=!1),S=this.m_shape.getNextVertex(E)}if(E=S,d.length>=256){for(let t=1,e=d.length-1;t<e;t++){const e=d[t];n?this.m_shape.snapVertexForPoleClipping(e,f):this.m_shape.removeVertex(e,!1)}d[1]=d.at(-1),d.length=2}}while(E!==P);if(!r){0!==y||!n&&0!==x&&2!==x||d.push(P);for(let t=0,e=d.length;t<e;t++){const e=d[t];n?this.m_shape.snapVertexForPoleClipping(e,f):this.m_shape.removeVertex(e,!1)}}d.length=0,e=r||0===this.m_shape.getPathSize(e)?this.m_shape.removePath(e):this.m_shape.getNextPath(e)}}}if(p)return e.createInstance();g=null,n?this.removeSpikesAlongPoles():this.resolveBoundaryOverlaps(),i>0&&this.densifyAlongClipExtent(i);const f=this.m_shape.getGeometry(this.m_geometry);if(f.getGeometryType()===s.enumPolygon){f.setFillRule(e.getFillRule())}return f}clipPolyline(t,e){const s=ge.constructEmpty(),i=ge.constructEmpty(),n=new Array(9),r=new Array(9),o=new SE;let a=t;const h=ge.constructEmpty();t.queryLooseEnvelope(h);for(let m=0;m<4;m++){let e=!1;const l=!!(1&m);let u=0;switch(m){case 0:u=this.m_extent.xmin,e=h.xmin<=u&&h.xmax>=u;break;case 1:u=this.m_extent.ymin,e=h.ymin<=u&&h.ymax>=u;break;case 2:u=this.m_extent.xmax,e=h.xmin<=u&&h.xmax>=u;break;case 3:u=this.m_extent.ymax,e=h.ymin<=u&&h.ymax>=u}if(!e)continue;const c=a;a=t.createInstance();const g=c.getImpl().querySegmentIterator();g.resetToFirstPath();const _=new w,d=new w;for(;g.nextPath();){let t=-1,e=!0;for(;g.hasNextSegment();){this.progress_();const h=g.nextSegment(),c=h.isDegenerate(0);h.queryLooseEnvelope(s);const p=yl.checkSegmentIntersection(s,m,u);if(-1===p){const s=h.intersectionWithAxis2D(l,u,n,r);let g=0;_.assign(h.getStartXY());for(let p=0;p<=s;p++){const f=p<s?r[p]:1;if(g===f)continue;h.queryCut(g,f,o,!1);const x=o.get();let y=!1;if(x.getStartXY().equals(_)||(x.setStartXY(_),y=!0),p<s&&(l?(d.x=n[p],d.y=u):(d.x=u,d.y=n[p]),x.getEndXY().equals(d)||(x.setEndXY(d),y=!0)),y&&x.normalizeAfterEndpointChange(),!c&&x.isDegenerate(0))continue;x.queryEnvelope(i);let P=yl.checkSegmentIntersection(i,m,u);if(-1===P){const t=x.getStartXY(),e=x.getEndXY();if(y=!1,l){Math.abs(t.y-u)<Math.abs(e.y-u)?(t.y=u,x.setStartXY(t),t.equals(x.getStartXY())||(x.setStartXY(t),y=!0)):(e.y=u,e.equals(x.getEndXY())||(x.setEndXY(e),y=!0))}else{Math.abs(t.x-u)<Math.abs(e.x-u)?(t.x=u,t.equals(x.getStartXY())||(x.setStartXY(t),y=!0)):(e.x=u,e.equals(x.getEndXY())||(x.setEndXY(e),y=!0))}y&&x.normalizeAfterEndpointChange(),x.queryEnvelope(i),P=yl.checkSegmentIntersection(i,m,u),-1===P&&(P=yl.checkSegmentIntersectionLoose(i,m,u))}_.assign(x.getEndXY()),g=f,t=P,t>=1?(a.addSegment(x,e),e=!1):e=!0}}else t=p,t>=1?(a.addSegment(h,e),e=!1):e=!0}}}return a}static checkSegmentIntersection(e,s,i){switch(s){case 0:return e.xmin<i&&e.xmax<=i?0:e.xmin>=i?e.xmax===i?2:1:-1;case 1:return e.ymin<i&&e.ymax<=i?0:e.ymin>=i?e.ymax===i?2:1:-1;case 2:return e.xmin>=i&&e.xmax>i?0:e.xmax<=i?e.xmin===i?2:1:-1;case 3:return e.ymin>=i&&e.ymax>i?0:e.ymax<=i?e.ymin===i?2:1:-1}return t(0),0}static checkSegmentIntersectionLoose(e,s,i){return t(0),0}resolveBoundaryOverlaps(){this.m_verticesOnExtentIndex=-1,this.splitSegments(!1,this.m_extent.xmin),this.splitSegments(!1,this.m_extent.xmax),this.splitSegments(!0,this.m_extent.ymin),this.splitSegments(!0,this.m_extent.ymax),this.m_verticesOnExtent.length=0,this.m_verticesOnExtentIndex=this.m_shape.createUserIndex();const t=new w;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Nm;e=this.m_shape.getNextPath(e)){let s=this.m_shape.getFirstVertex(e);for(let i=0,n=this.m_shape.getPathSize(e);i<n;i++,s=this.m_shape.getNextVertex(s))this.progress_(),this.m_shape.queryXY(s,t),this.m_extent.xmin!==t.x&&this.m_extent.xmax!==t.x&&this.m_extent.ymin!==t.y&&this.m_extent.ymax!==t.y||(this.m_shape.setUserIndex(s,this.m_verticesOnExtentIndex,this.m_verticesOnExtent.length),this.m_verticesOnExtent.push(s))}this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmin),this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmax),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymin),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymax),this.fixPaths()}densifyAlongClipExtent(e){const s=new w(0,0),i=new w(0,0),n=new Array(2048);for(let r=this.m_shape.getFirstPath(this.m_geometry);r!==Nm;r=this.m_shape.getNextPath(r)){const o=this.m_shape.getFirstVertex(r);let a=o;do{const r=this.m_shape.getNextVertex(a);this.m_shape.queryXY(a,s);let o=-1;if(s.x===this.m_extent.xmin?(this.m_shape.queryXY(r,i),i.x===this.m_extent.xmin&&(o=1)):s.x===this.m_extent.xmax&&(this.m_shape.queryXY(r,i),i.x===this.m_extent.xmax&&(o=1)),s.y===this.m_extent.ymin?(this.m_shape.queryXY(r,i),i.y===this.m_extent.ymin&&(o=0)):s.y===this.m_extent.ymax&&(this.m_shape.queryXY(r,i),i.y===this.m_extent.ymax&&(o=0)),-1===o){a=r;continue}if(this.isCurve(a)){a=r;continue}const h=s.clone(),l=new w(0,0);if(o){const t=s.y-this.m_extent.ymin;l.y=Q(i.y-s.y),h.y=e*Z(Math.floor(Math.abs(t)/e),t)+this.m_extent.ymin,l.y<0&&(h.y+=e)}else{const t=s.x-this.m_extent.xmin;l.x=Q(i.x-s.x),h.x=e*Z(Math.floor(Math.abs(t)/e),t)+this.m_extent.xmin,l.x<0&&(h.x+=e)}const u=o?i.y-s.y:i.x-s.x,c=Math.abs(u);if(c/e>65536&&m(""),c>0){const i=Math.trunc(c/e)+2;n.length<i&&(n.length=i);let r=0;for(let a=0;;a++){const i=h.add(l.mul(a*e)),m=(o?i.y-s.y:i.x-s.x)/u;if(m>=1)break;m<=0||(t(r<=n.length),n[r]=m,r++)}0!==r&&this.m_shape.splitSegment(a,n,r)}a=r}while(a!==o)}}splitSegments(t,e){let s=-1;const i=new w,n=[];for(let g=this.m_shape.getFirstPath(this.m_geometry);g!==Nm;g=this.m_shape.getNextPath(g)){let r=this.m_shape.getFirstVertex(g),o=Nm;for(let a=0,h=this.m_shape.getPathSize(g);a<h;a++,r=o)if(this.progress_(),o=this.m_shape.getNextVertex(r),this.m_shape.queryXY(r,i),(t?i.y===e:i.x===e)&&(this.m_shape.queryXY(o,i),t?i.y===e:i.x===e)){if(this.isCurve(r))continue;-1===s&&(s=this.m_shape.createUserIndex()),1!==this.m_shape.getUserIndex(r,s)&&(n.push(r),this.m_shape.setUserIndex(r,s,1)),1!==this.m_shape.getUserIndex(o,s)&&(n.push(o),this.m_shape.setUserIndex(o,s,1))}}if(-1!==s&&this.m_shape.removeUserIndex(s),n.length<3)return;n.sort(((t,e)=>this.compareVertices(t,e)));const r=new w,o=new w,a=new w;o.setNAN();let h=-1;let m=[],l=[];const u=this.m_shape.createUserIndex(),c=this.m_shape.createUserIndex();for(let g=0,_=n.length;g<_;g++){const s=n[g];if(this.m_shape.queryXY(s,i),!i.isEqualPoint2D(o)){if(-1===h){h=g,o.setCoordsPoint2D(i);continue}for(let i=h;i<g;i++){const s=n[i],a=this.m_shape.getNextVertex(s),h=this.m_shape.getPrevVertex(s);let l=!1;this.m_shape.queryXY(a,r),o.compare(r)<0&&(t?r.y===e:r.x===e)&&(this.isCurve(s)||(m.push(s),l=!0,this.m_shape.setUserIndex(s,c,1))),this.m_shape.queryXY(h,r),o.compare(r)<0&&(t?r.y===e:r.x===e)&&(this.isCurve(h)||(l||m.push(s),this.m_shape.setUserIndex(s,u,1)))}for(let t=0,e=m.length;t<e;t++){const e=m[t],s=this.m_shape.getUserIndex(e,u),n=this.m_shape.getUserIndex(e,c);if(1===s){const t=this.m_shape.getPrevVertex(e);this.m_shape.queryXY(t,a);let s=0;if(!a.isEqualPoint2D(i)){const n=w.distance(o,a);s=w.distance(a,i)/n,0===s?s=Number.EPSILON:1===s&&(s=1-Number.EPSILON),this.m_shape.splitSegment(t,[s],1);const r=this.m_shape.getPrevVertex(e);this.m_shape.setXY(r,i),l.push(r),this.m_shape.setUserIndex(r,u,1),this.m_shape.setUserIndex(r,c,-1)}}if(1===n){const t=this.m_shape.getNextVertex(e);this.m_shape.queryXY(t,a);let s=0;if(!a.isEqualPoint2D(i)){const t=w.distance(o,a);s=w.distance(o,i)/t,0===s?s=Number.EPSILON:1===s&&(s=1-Number.EPSILON),this.m_shape.splitSegment(e,[s],1);const n=this.m_shape.getNextVertex(e);this.m_shape.setXY(n,i),l.push(n),this.m_shape.setUserIndex(n,u,-1),this.m_shape.setUserIndex(n,c,1)}}}const s=m;m=l,l=s,l.length=0,h=g,o.setCoordsPoint2D(i)}}this.m_shape.removeUserIndex(u),this.m_shape.removeUserIndex(c)}resolveOverlaps(e,s){const i=new w,n=[];let r=-1;for(let t=0,m=this.m_verticesOnExtent.length;t<m;t++){this.progress_();const o=this.m_verticesOnExtent[t];if(o===Nm)continue;const a=this.m_shape.getNextVertex(o);if(this.m_shape.queryXY(o,i),(e?i.y===s:i.x===s)&&(this.m_shape.queryXY(a,i),e?i.y===s:i.x===s)){if(this.isCurve(o))continue;-1===r&&(r=this.m_shape.createUserIndex()),-2!==this.m_shape.getUserIndex(o,r)&&(n.push(o),this.m_shape.setUserIndex(o,r,-2)),-2!==this.m_shape.getUserIndex(a,r)&&(n.push(a),this.m_shape.setUserIndex(a,r,-2))}}if(0===n.length)return void(-1!==r&&this.m_shape.removeUserIndex(r));t(-1!==r),n.sort(((t,e)=>this.compareVertices(t,e)));for(let t=0,m=n.length;t<m;t++){const e=n[t];this.m_shape.setUserIndex(e,r,t)}const o=new w,a=new w;a.setNAN();let h=-1;for(let t=0,m=n.length;t<m;t++){this.progress_();const m=n[t];if(m!==Nm&&(this.m_shape.queryXY(m,i),!i.isEqualPoint2D(a))){if(-1!==h)for(;;){let i=!1;const m=t;for(let l=h;l<m;l++){const h=n[l];if(h===Nm)continue;let m=Nm;const u=this.m_shape.getNextVertex(h);this.m_shape.queryXY(u,o),a.compare(o)<0&&(e?o.y===s:o.x===s)&&(this.isCurve(h)||(m=u));let c=Nm;const g=this.m_shape.getPrevVertex(h);if(this.m_shape.queryXY(g,o),a.compare(o)<0&&(e?o.y===s:o.x===s)&&(this.isCurve(g)||(c=g)),m===Nm||c===Nm){if(m!==Nm||c!==Nm){for(let u=l+1;u<t;u++){const t=n[u];if(t===Nm)continue;const l=this.m_shape.getNextVertex(t);let g=Nm;this.m_shape.queryXY(l,o),a.compare(o)<0&&(e?o.y===s:o.x===s)&&(this.isCurve(t)||(g=l));const _=this.m_shape.getPrevVertex(t);let d=Nm;if(this.m_shape.queryXY(_,o),a.compare(o)<0&&(e?o.y===s:o.x===s)&&(this.isCurve(_)||(d=_)),g!==Nm&&d!==Nm){this.beforeRemoveVertex(t,n,r),this.m_shape.removeVertex(t,!1),this.beforeRemoveVertex(g,n,r),this.m_shape.removeVertex(g,!1),i=!0;break}if(m!==Nm&&d!==Nm){this.removeOverlap(n,h,m,t,d,r),i=!0;break}if(c!==Nm&&g!==Nm){this.removeOverlap(n,t,g,h,c,r),i=!0;break}}if(i)break}}else this.beforeRemoveVertex(h,n,r),this.m_shape.removeVertex(h,!1),this.beforeRemoveVertex(m,n,r),this.m_shape.removeVertex(m,!1),i=!0}if(!i)break}h=t,a.setCoordsPoint2D(i)}}this.m_shape.removeUserIndex(r)}beforeRemoveVertex(e,s,i){let n=this.m_shape.getUserIndex(e,i);t(n>=0),s[n]=Nm,n=this.m_shape.getUserIndex(e,this.m_verticesOnExtentIndex),t(n>=0),this.m_verticesOnExtent[n]=Nm;const r=this.m_shape.getPathFromVertex(e);if(r!==Nm){this.m_shape.getFirstVertex(r)===e&&(this.m_shape.setFirstVertex(r,Nm),this.m_shape.setLastVertex(r,Nm))}}removeOverlap(t,e,s,i,n,r){this.m_shape.setNextVertex(e,i),this.m_shape.setPrevVertex(i,e),this.m_shape.setPrevVertex(s,n),this.m_shape.setNextVertex(n,s),this.beforeRemoveVertex(i,t,r),this.m_shape.removeVertexInternal(i,!1),this.beforeRemoveVertex(n,t,r),this.m_shape.removeVertexInternal(n,!0)}removeSpikesAlongPoles(){this.removeSpikesOnPole(this.m_extent.ymin),this.removeSpikesOnPole(this.m_extent.ymax)}removeSpikesOnPole(t){for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Nm;e=this.m_shape.getNextPath(e)){const s=this.m_shape.getPathSize(e);if(s<3)continue;let i=this.m_shape.getFirstVertex(e);const n=new w;this.m_shape.queryXY(i,n);let r=n.y===t&&!this.isCurve(i);i=this.m_shape.getNextVertex(i);const o=new w;this.m_shape.queryXY(i,o);let a=o.y===t&&!this.isCurve(i);i=this.m_shape.getNextVertex(i);const h=new w;for(let e=0,m=s-2;e<m;e++,i=this.m_shape.getNextVertex(i)){this.progress_(),this.m_shape.queryXY(i,h);const e=h.y===t;if(a&&r&&e){if((o.x-n.x)*(h.x-o.x)<=0){this.m_shape.removeVertex(this.m_shape.getPrevVertex(i),!1),o.setCoordsPoint2D(h),a=e&&!this.isCurve(i);continue}}n.setCoordsPoint2D(o),r=a,o.setCoordsPoint2D(h),a=e&&!this.isCurve(i)}}}fixPaths(){for(let t=0,r=this.m_verticesOnExtent.length;t<r;t++){const e=this.m_verticesOnExtent[t];e!==Nm&&this.m_shape.setPathToVertex(e,Nm)}const e=this.m_shape.hasCurves();let s=0,i=0;for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==Nm;){const e=this.m_shape.getFirstVertex(t);if(e===Nm||t!==this.m_shape.getPathFromVertex(e)){const e=t;t=this.m_shape.getNextPath(t),this.m_shape.setFirstVertex(e,Nm),this.m_shape.removePathOnly(e);continue}let n=e,r=0;do{this.m_shape.setPathToVertex(n,t),r++,n=this.m_shape.getNextVertex(n)}while(n!==e);this.m_shape.setRingAreaValid(t,!1),this.m_shape.setLastVertex(t,this.m_shape.getPrevVertex(e)),this.m_shape.setPathSize(t,r),i+=r,s++,t=this.m_shape.getNextPath(t)}for(let r=0,o=this.m_verticesOnExtent.length;r<o;r++){let n=this.m_verticesOnExtent[r];if(n===Nm)continue;let o=this.m_shape.getPathFromVertex(n);if(o!==Nm)continue;o=this.m_shape.insertPath(this.m_geometry,Nm);let a=!1,h=0;const m=n;do{this.m_shape.setPathToVertex(n,o),h++,e&&h<=2&&(a||=this.isCurve(n)),n=this.m_shape.getNextVertex(n)}while(n!==m);if(a?0===h:h<=2){let e=this.m_shape.getUserIndex(m,this.m_verticesOnExtentIndex);t(e>=0),this.m_verticesOnExtent[e]=Nm;const s=this.m_shape.removeVertex(m,!1);2===h&&(e=this.m_shape.getUserIndex(s,this.m_verticesOnExtentIndex),e>=0&&(this.m_verticesOnExtent[e]=Nm),this.m_shape.removeVertex(s,!1));const i=o;o=this.m_shape.getNextPath(o),this.m_shape.setFirstVertex(i,Nm),this.m_shape.removePathOnly(i)}else this.m_shape.setClosedPath(o,!0),this.m_shape.setPathSize(o,h),this.m_shape.setFirstVertex(o,m),this.m_shape.setLastVertex(o,this.m_shape.getPrevVertex(m)),this.m_shape.setRingAreaValid(o,!1),i+=h,s++}this.m_shape.setGeometryPathCount(this.m_geometry,s),this.m_shape.setGeometryVertexCount(this.m_geometry,i);let n=0;for(let t=this.m_shape.getFirstGeometry();t!==Nm;t=this.m_shape.getNextGeometry(t))n+=this.m_shape.getPointCount(t);this.m_shape.setTotalPointCount(n)}dbgCheckPathFirst(){}isCurve(t){return null!==this.m_shape.getSegment(t)}compareVertices(t,e){const s=new w;this.m_shape.queryXY(t,s);const i=new w;this.m_shape.queryXY(e,i);return s.compare(i)}clipPolesOut(t,e){return this.clipPolygonOrProjectedPolyline2(t,e)}}function Pl(t,e,s,i,n,r){return new bl(0,0,0,null,!1,k()).densifyEx(t,e,s,i,!1,r)}function El(t,i,n,r){return Number.isFinite(i)||e("replace_all_curves_with_beziers: max_deviation"),Tl(s.enumBezier,t,i,n)}function Cl(e,i,r,o,a,h,m,l){h&&(h.length=0),m&&(m.length=0);const u=e.getGeometryType();if(u===s.enumLine)return h&&(h.push(e.getStartXY()),h.push(w.getNAN()),h.push(w.getNAN()),h.push(e.getEndXY())),m&&(m.push(0),m.push(1)),1;if(u===s.enumBezier){if(!o)return h&&(h.push(e.getStartXY()),h.push(e.getControlPoint1()),h.push(e.getControlPoint2()),h.push(e.getEndXY())),m&&(m.push(0),m.push(1)),1;const t=[];t.length=9;let s=e.getMonotonicPartParams(t.length,t);if(t.length=s,s=Il(e,r,t),2===s&&a&&(t[1]=.5,t.push(1),s=3),m&&m.splice(0,0,...t.slice(0,s)),h){const i=new SE;for(let n=1;n<s;n++){const s=t[n-1],r=t[n];e.queryCut(s,r,i,!0);const o=i.get();ch(o),1===n&&h.push(o.getStartXY()),h.push(o.getControlPoint1()),h.push(o.getControlPoint2()),h.push(o.getEndXY())}}return s-1}if(u===s.enumEllipticArc){const s=e;if(s.isDegenerateToLine()||s.isDegenerate(0))return h&&(h.push(e.getStartXY()),h.push(w.getNAN()),h.push(w.getNAN()),h.push(e.getEndXY())),m&&(m.push(0),m.push(1)),1;if(o&&(a||!s.isMonotoneQuickAndDirty())){const n=[];n.length=6;let l=s.getMonotonicPartParams(n.length,n);n.length=l,l=Il(e,r,n),2===l&&a&&(n[1]=.5,n.push(1),l=3);let u=0;if(l>2){const e=new SE,a=m||[];let c=0;for(let g=1;g<l;g++){const _=n[c],d=n[g];if(s.queryCut(_,d,e,!0),e.get().isDegenerate(0))continue;const p=a.length,f=Nl(1===g,e.get(),i,r,o,h,m);t(f>0),u+=f;const x=g===l-1,y=n[c],P=e.get().getSweepAngle()/s.getSweepAngle();for(let t=p,e=a.length;t<e;t++)if(a[t]=!x||t+1<e?y+a[t]*P:1,h){const e=3*t,i=s.getCoord2D(a[t]);if(h[e].setCoordsPoint2D(i),e>0){gh(h.slice(e-3))}}c=g}return u}}return Nl(!0,s,i,r,o,h,m)}if(u===s.enumRationalBezier2){const t=e;if(o&&(a||!t.isMonotoneQuickAndDirty())){const s=[];s.length=6;let i=t.getMonotonicPartParams(s.length,s);s.length=i,i=Il(e,r,s),2===i&&a&&(s[1]=.5,s.push(1),i=3);let n=0;if(i>2){const e=new SE,r=m||[];for(let o=1;o<i;o++){const a=s[o-1],m=s[o];t.queryCut(a,m,e,!0);const l=r.length;n+=ql(1===o,e.get());const u=o===i-1,c=s[o-1];for(let e=l,s=r.length;e<s;e++)if(r[e]=!u||e+1<s?c+r[e]:1,h){const s=3*e,i=t.getCoord2D(r[e]);if(h[s].setCoordsPoint2D(i),s>0){Br(h.slice(s-3))}}}return n}}return ql()}if(u===s.enumBezier2){const t=e,s=D(w,3);t.queryControlPoints(s);const n=new lo;return n.constructFromQuadratic(s),Cl(n,i,r,o,a,h,m)}n("")}function Sl(t,e,i,r,o,a,h,m){a&&(a.length=0),h&&(h.length=0);const l=t.getGeometryType();if(l===s.enumLine)return a&&(a.push(t.getStartXY()),a.push(w.getNAN()),a.push(t.getEndXY())),h&&(h.push(0),h.push(1)),1;if(l===s.enumBezier2){const e=[];e.length=9;let s=t.getMonotonicPartParams(e.length,e);if(e.length=s,s=Il(t,i,e),2===s&&o&&(e[1]=.5,e.push(1),s=3),h&&h.splice(0,0,...e.slice(0,s)),a){const i=new SE;for(let n=1;n<s;n++){const s=e[n-1],r=e[n];t.queryCut(s,r,i,!0);const o=i.get();Rr(o),1===n&&a.push(o.getStartXY()),a.push(o.getControlPoint1()),a.push(o.getEndXY())}}return s-1}if(l===s.enumEllipticArc){const s=t;if(s.isDegenerateToLine()||s.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(w.getNAN()),a.push(t.getEndXY())),h&&(h.push(0),h.push(1)),1;if(!s.isMonotoneQuickAndDirty()){const n=[];n.length=6;let r=s.getMonotonicPartParams(n.length,n);n.length=r,r=Il(t,i,n),2===r&&o&&(n[1]=.5,n.push(1),r=3);let m=0;if(r>2){const t=new SE,o=h||[];for(let l=1;l<r;l++){const u=n[l-1],c=n[l];s.queryCut(u,c,t,!0);const g=o.length;m+=Fl(1===l,t.get(),e,i,!1,a,h);const _=l===r-1,d=n[l-1],p=t.get().getSweepAngle()/s.getSweepAngle();for(let t=g,e=o.length;t<e;t++)if(o[t]=!_||t+1<e?d+o[t]*p:1,a){const e=2*t,i=s.getCoord2D(o[t]);if(a[e].setCoordsPoint2D(i),e>0){Br(a.slice(e-2))}}}return m}}return Nl(!0,s,e,i,r,a,h)}if(l===s.enumBezier){const e=t;if(!e.isMonotoneQuickAndDirty()){const s=[];s.length=6;let n=e.getMonotonicPartParams(s.length,s);s.length=n,n=Il(t,i,s),2===n&&o&&(s[1]=.5,s.push(1),n=3);let r=0;if(n>2){const t=new SE,i=h||[];for(let o=1;o<n;o++){const h=s[o-1],m=s[o];e.queryCut(h,m,t,!0);const l=i.length;r+=Ml(1===o,t.get());const u=o===n-1,c=s[o-1];for(let t=l,s=i.length;t<s;t++)if(i[t]=!u||t+1<s?c+i[t]:1,a){const s=2*t,n=e.getCoord2D(i[t]);if(a[s].setCoordsPoint2D(n),s>0){Br(a.slice(s-2))}}}return r}}return Ml()}if(l===s.enumRationalBezier2){const e=t;if(!e.isMonotoneQuickAndDirty()){const s=[];s.length=6;let n=e.getMonotonicPartParams(s.length,s);s.length=n,n=Il(t,i,s),2===n&&o&&(s[1]=.5,s.push(1),n=3);let r=0;if(n>2){const t=new SE,i=h||[];for(let o=1;o<n;o++){const h=s[o-1],m=s[o];e.queryCut(h,m,t,!0);const l=i.length;r+=Al(1===o,t.get());const u=o===n-1,c=s[o-1];for(let t=l,s=i.length;t<s;t++)if(i[t]=!u||t+1<s?c+i[t]:1,a){const s=2*t,n=e.getCoord2D(i[t]);if(a[s].setCoordsPoint2D(n),s>0){Br(a.slice(s-2))}}}return r}}return Al()}n("")}function vl(e,i,n,r,o,a,h,m,l){const u=e.getGeometryType();if(a&&(a.length=0,h.length=0),m&&(m.length=0),u===s.enumEllipticArc){const t=e;if(t.isDegenerateToLine()||t.isDegenerate(0))return a&&(a.push(e.getStartXY()),a.push(w.getNAN()),a.push(e.getEndXY()),h.push(Number.NaN),h.push(Number.NaN),h.push(Number.NaN)),m&&(m.push(0),m.push(1)),1}const c=H(9,Number.NaN);let g;if(o)g=e.getMonotonicPartParams(c.length,c),c.length=g,g=Il(e,n,c);else{if(g=2,c[0]=0,c[1]=1,u===Cm.type){const t=e.getSweepAngle();if(t>.9*Math.PI){const e=2*Math.PI/3;Math.min(3,Math.trunc(t/e+.5))>2?(c[0]=0,c[1]=1/3,c[2]=2/3,c[3]=1,g=4):(c[0]=0,c[1]=.5,c[2]=1,g=3)}}else t(u===Xa.type);c.length=g}if(2===g&&r&&(c[1]=.5,c.push(1),g=3),a){const t=new SE;let i=1;for(;i<g;){const n=c[i-1],r=c[i];e.queryCut(n,r,t,!0);const m=D(w,3),l=[1,1,1];if(u===s.enumEllipticArc){const e=t.get();if(Math.abs(e.getSweepAngle())>.9*Math.PI){const t=(r-n)/3;c.splice(i,0,n+t),c.splice(i+1,0,n+2*t),g+=2;continue}l[1]=qP(e,m)}else{const e=t.get();e.queryControlPoints(m),e.queryWeights(l)}o&&oa(m),1===i&&(a.push(m[0].clone()),h.push(l[0])),a.push(m[1].clone()),a.push(m[2].clone()),h.push(l[1]),h.push(l[2]),i++}}return m&&(m.length=g,X(m,c,0,0,g)),g-1}let bl=class e{static constructDefault(t){return new e(0,0,0,t,!1,k())}constructor(t,e,s,i,n,r){this.m_segmentBuffer=null,this.m_dummyPoint=new Ge,this.m_progressCounter=0,this.m_progressTracker=i,this.m_bSetDensifyFlag=n,this.m_maxLength=t,this.m_maxDeviation=e,this.m_maxAngle=s>Et()?Et():s,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_maxSegmentsPerCurve=r,f(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve}densify(t){return this.densifyGeom(t)}densifySegment(e,s){t(0)}densifyEx(t,e,s,i,n,r){return this.m_maxLength=e,this.m_maxDeviation=s,this.m_maxAngle=i>Et()?Et():i,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_bSetDensifyFlag=n,this.m_maxSegmentsPerCurve=r,f(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve,this.densifyGeom(t)}densifyGeom(t){if(t.isEmpty()||t.getDimension()<1)return t;const e=t.getGeometryType();return y(e)?t:p(e)?this.densifyMultiPath(t):l(e)?this.densifySegmentImpl(t):e===s.enumEnvelope?this.densifyEnvelope(t):void m("")}densifySegmentEx(t,e,i,n,r){const o=t.getGeometryType();if(!(this.m_maxLength>0||this.m_bOnlyCurveDensify&&o!==s.enumLine)&&(!n||i))return void(e?o===s.enumLine?e.addSegment(t,i):(i&&(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)),t.queryEnd(this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint)):(i&&r.push(0),r.push(1)));if(o===s.enumBezier)return void this.densifyCubicBezier(t,e,i,n,r);if(o===s.enumRationalBezier2)return void this.densifyRationalBezier2(t,e,i,n,r);if(o===s.enumBezier2)return void this.densifyBezier2(t,e,i,n,r);if(o===s.enumEllipticArc&&!t.isLine()&&t.getMinorMajorRatio()<.25)return void this.densifyEllipticArc(t,e,i,n,r);let a=1;this.m_maxLength>0&&(a=this.calculateLengthSubdivisionStep(t,this.m_maxLength)),this.m_maxDeviation>0&&(a=Math.min(a,this.calculateDeviationSubdivisionStep(t,this.m_maxDeviation))),this.m_maxAngle>0&&(a=Math.min(a,this.calculateAngularSubdivisionStep(t,this.m_maxAngle))),this.densifySegmentByLength(t,a,e,i,n,r)}densifyMultiPath(t){if(!t.hasNonLinearSegments()){if(1===t.getDescription().getAttributeCount())return this.densifyMultiPathLinear(t);if(!(this.m_maxLength>0))return t}const e=t.createInstance();if(e.getGeometryType()===s.enumPolygon){e.setFillRule(t.getFillRule())}e.reserve(t.getPointCount());const i=t.getImpl().querySegmentIterator();for(;i.nextPath();){let t=!0;for(;i.hasNextSegment();){const s=i.nextSegment(),n=i.isClosingSegment();this.densifySegmentEx(s,e,t,n,null),n&&e.closePathWithLine(),t=!1}}return e}densifySegmentImpl(t){const e=new am({vd:t.getDescription()}),s=[0];return this.densifySegmentEx(t,e,!0,!1,s),e}densifyEnvelope(t){const e=new Sm({vd:t.getDescription()});e.addEnvelope(t,!1);const s=ge.constructEmpty();t.queryEnvelope(s);const i=s.width(),n=s.height();return!(this.m_maxLength>0)||i<=this.m_maxLength&&n<=this.m_maxLength?e:this.densifyMultiPath(e)}densifyMultiPathLinear(t){if(!(this.m_maxLength>0))return t;const e=t.createInstance();if(e.getGeometryType()===s.enumPolygon){e.setFillRule(t.getFillRule())}e.reserve(t.getPointCount());const i=e.getImpl(),n=t.getImpl(),r=n.getAttributeStreamRef(0),o=new CE;for(let s=0,a=n.getPathCount();s<a;s++){const t=n.isClosedPath(s);if(0===n.getPathSize(s))continue;const a=n.getPathStart(s),h=r.readPoint2D(2*a),m=h.clone();i.startPath(h);for(let l=a+1,u=n.getPathEnd(s);l<u;l++){const t=r.readPoint2D(2*l),s=w.distance(m,t);if(s>this.m_maxLength){let e=Math.ceil(s/this.m_maxLength);e>k()&&(e=k());const n=1/e;let r,a,h;m.compare(t)<0?(o.setStartXY(m),o.setEndXY(t),r=0,a=1):(o.setStartXY(t),o.setEndXY(m),r=e-2,a=-1);for(let t=0,s=e-1;t<s;t++,r+=a){this.progress_(),h=n*(r+1);const t=new w;o.queryCoord2D(h,t),i.lineTo(t),this.m_bSetDensifyFlag&&i.setAttribute(10,i.getPointCount()-1,0,1)}}else this.progress_();e.lineTo(t),m.assign(t)}if(t){const t=w.distance(m,h);if(t>this.m_maxLength){const e=h;let s=Math.ceil(t/this.m_maxLength);s>k()&&(s=k());const n=1/s;let r,a;m.compare(e)<0?(o.setStartXY(m),o.setEndXY(e),r=0,a=1):(o.setStartXY(e),o.setEndXY(m),r=s-2,a=-1);const l=new w(0,0);let u;for(let t=0,h=s-1;t<h;t++,r+=a)this.progress_(),u=n*(r+1),o.queryCoord2D(u,l),i.lineTo(l),this.m_bSetDensifyFlag&&i.setAttribute(10,i.getPointCount()-1,0,1)}i.closePathWithLine()}}return e}densifySegmentByLength(e,i,n,r,o,a){t(e.getGeometryType()!==s.enumBezier);let h=e.getStartXY().compare(e.getEndXY());if(0===h&&i<1){e.getGeometryType()===s.enumEllipticArc?h=e.getSweepAngle()<0?1:-1:t(0)}let m=0;if(r&&(n?(e.queryStart(this.m_dummyPoint),n.startPathPoint(this.m_dummyPoint)):a.push(0),++m),i*this.m_maxSegmentsPerCurve<1&&(i=1/this.m_maxSegmentsPerCurve),i<1){this.m_segmentBuffer||(this.m_segmentBuffer=new SE);let t=Math.ceil(1/i);t>k()&&(t=k()),i=1/t,this.m_segmentBuffer.create(e.getGeometryType());let s,r,o,l=e;h<0?(s=0,r=1):(e.copyTo(this.m_segmentBuffer.get()),this.m_segmentBuffer.get().reverse(),s=t-2,r=-1,l=this.m_segmentBuffer.get());const u=t-1;for(let e=0;e<u;e++,s+=r)o=i*(s+1),n?(l.queryCoord(o,this.m_dummyPoint),n.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==o&&0!==o&&n.setAttribute(10,n.getPointCount()-1,0,1)):a.push(h>0?1-o:o),this.progress_();o=1,m+=u}(!o||o&&r&&m<2)&&(n?(e.queryEnd(this.m_dummyPoint),n.lineToPoint(this.m_dummyPoint)):a.push(1))}densifyCubicBezier(t,e,s,i,n){const r=new lo;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());if(0===h&&a>0){const e=D(w,4);t.queryControlPoints(e),h=e[1].compare(e[2]),0===h&&(h=e[1].compare(e[0]))}h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):n.push(0),++m);const l=[],u=[],c=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));let g=!0,_=0;if(h>0)for(l.push([o.getStartXY(),o.getControlPoint1(),o.getControlPoint2(),o.getEndXY(),new w(0,1)]),u.push(0);l.length;){this.progress_();const t=l.at(-1),r=u.at(-1),a=t[4].x,h=t[4].y;if(r<c&&this.bezierNeedsSplit(t)){g&&(_=o.findMinDeriv(),g=!1);let e=.5*(a+h);Math.abs(_-e)<.4*(h-a)&&(e=_);const s=(e-a)/(h-a),i=t[0].mul(1-s).add(t[1].mul(s)),n=t[1].mul(1-s).add(t[2].mul(s)),m=t[2].mul(1-s).add(t[3].mul(s)),c=i.mul(1-s).add(n.mul(s)),d=n.mul(1-s).add(m.mul(s)),p=c.mul(1-s).add(d.mul(s)),f=t[3];t[1]=i,t[2]=c,t[3]=p,t[4].setCoords(a,e);const x=[p,d,m,f,new w(e,h)];l.push(x),u[u.length-1]=r+1,u.push(r+1)}else l.pop(),u.pop(),(l.length>0||!i||i&&s&&m<2)&&(e?(o.queryCoord(a,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==a&&0!==a&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(1-a),++m)}else for(l.push([o.getStartXY(),o.getControlPoint1(),o.getControlPoint2(),o.getEndXY(),new w(0,1)]),u.push(0);l.length;){this.progress_();const t=l.at(-1),r=u.at(-1),a=t[4].x,h=t[4].y;if(r<c&&this.bezierNeedsSplit(t)){g&&(_=o.findMinDeriv(),g=!1);let e=.5*(a+h);Math.abs(_-e)<.4*(h-a)&&(e=_);const s=(e-a)/(h-a),i=t[0].mul(1-s).add(t[1].mul(s)),n=t[1].mul(1-s).add(t[2].mul(s)),m=t[2].mul(1-s).add(t[3].mul(s)),c=i.mul(1-s).add(n.mul(s)),d=n.mul(1-s).add(m.mul(s)),p=c.mul(1-s).add(d.mul(s)),f=t[0];t[0]=p,t[1]=d,t[2]=m,t[4].setCoords(e,h);const x=[f,i,c,p,new w(a,e)];l.push(x),u[u.length-1]=r+1,u.push(r+1)}else l.pop(),u.pop(),(l.length>0||!i||i&&s&&m<2)&&(e?(o.queryCoord(h,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==h&&0!==h&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(h),++m)}}densifyRationalBezier2(t,e,s,i,n){const r=new Xa;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&a>0&&(h=0),h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):n.push(0),++m);const l=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),u=new Xa,c=[],g=[];for(c.push(new A(0,1)),g.push(0);c.length;){this.progress_();const t=c.at(-1).clone(),r=g.at(-1);if(r<l&&this.rationalBezier2NeedsSplit(o,u,t.vmin,t.vmax)){const e=t.getCenter();h>0?(c.at(-1).vmax=e,c.push(new A(e,t.vmax))):(c.at(-1).vmin=e,c.push(new A(t.vmin,e))),g[g.length-1]=r+1,g.push(r+1)}else if(c.pop(),g.pop(),c.length>0||!i||i&&s&&m<2){const s=h>0?t.vmin:t.vmax;e?(o.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(h>0?1-s:s),++m}}}densifyBezier2(t,e,s,i,n){const r=new Ln;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&a>0&&(h=0),h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):n.push(0),++m);const l=Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)),u=new Ln,c=[],g=[];for(c.push(new A(0,1)),g.push(0);c.length;){this.progress_();const t=c.at(-1).clone(),r=g.at(-1);if(r<l&&this.bezier2NeedsSplit(o,u,t.vmin,t.vmax)){const e=t.getCenter();h>0?(c.at(-1).vmax=e,c.push(new A(e,t.vmax))):(c.at(-1).vmin=e,c.push(new A(t.vmin,e))),g[g.length-1]=r+1,g.push(r+1)}else if(c.pop(),g.pop(),c.length>0||!i||i&&s&&m<2){const s=h>0?t.vmin:t.vmax;e?(o.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(h>0?1-s:s),++m}}}densifyEllipticArc(t,e,s,i,n){const r=new Cm;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&a>0&&(h=t.isClockwise()?0:1),h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):n.push(0),++m);const l=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),u=new Cm,c=[],g=[];for(c.push(new A(0,1)),g.push(0);c.length;){this.progress_();const t=c.at(-1).clone(),r=g.at(-1);if(r<l&&this.ellipticArcNeedsSplit(o,u,t.vmin,t.vmax)){const e=t.getCenter();h>0?(c.at(-1).vmax=e,c.push(new A(e,t.vmax))):(c.at(-1).vmin=e,c.push(new A(t.vmin,e))),g[g.length-1]=r+1,g.push(r+1)}else if(c.pop(),g.pop(),c.length>0||!i||i&&s&&m<2){const s=h>0?t.vmin:t.vmax;e?(o.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):n.push(h>0?1-s:s),++m}}}calculateLengthSubdivisionStep(t,e){const i=t.calculateUpperLength2D();if(!t.isCurve())return i?e/i:1;if(t.getGeometryType()===s.enumEllipticArc){const s=t;if(s.isCircular()||s.isDegenerate(0)||s.isDegenerateToLine()){let t=e/i;return t<this.m_minStep&&(t=this.m_minStep),t}return e/i*s.getSemiAxes().y/s.getSemiAxes().x}t.getGeometryType()===s.enumBezier&&n(""),n("")}calculateDeviationSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===s.enumEllipticArc){const s=t;if(s.isDegenerate(0)||s.isDegenerateToLine())return 1;{const i=s.getSemiMajorAxis(),n=1-e/i;let r=Math.PI/2;if(n>0){const t=4*Math.sqrt(e/i*.5);r=Math.min(Math.PI/2,Math.abs(t))}r=Math.max(r,2*Math.PI/this.m_maxSegmentsPerCurve);const o=r*i;return this.calculateLengthSubdivisionStep(t,o)}}n("")}calculateAngularSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===s.enumEllipticArc){const s=t;return s.isDegenerate(0)||s.isDegenerateToLine()?1:this.calculateLengthSubdivisionStep(t,e*s.getSemiMinorAxis())}n("")}rationalBezier2NeedsSplit(t,s,i,n){t.cutBezierIgnoreAttributes(i,n,s);let r=!1;if(this.m_maxLength>0){if(s.calculateUpperLength2D()>this.m_maxLength)return r=!0,!0}const o=D(w,3);s.queryControlPoints(o);const a=[0,0,0];return s.queryWeights(a),!r&&this.m_maxDeviation>0&&(r=!e.checkRationalBezier2MaxDeviation(o,a,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!e.checkRationalBezier2MaxAngle(o,a,this.m_cosMaxAngle)),r}bezier2NeedsSplit(t,s,i,n){t.cutBezierIgnoreAttributes(i,n,s);let r=!1;if(this.m_maxLength>0){if(s.calculateUpperLength2D()>this.m_maxLength)return r=!0,!0}const o=D(w,3);return s.queryControlPoints(o),!r&&this.m_maxDeviation>0&&(r=!e.checkBezier2MaxDeviation(o,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!e.checkBezier2MaxAngle(o,this.m_cosMaxAngle)),r}ellipticArcNeedsSplit(t,s,i,n){t.cutArcIgnoreAttributes(i,n,s);let r=!1;if(this.m_maxLength>0){if(s.calculateUpperLength2D()>this.m_maxLength)return r=!0,!0}return!r&&this.m_maxDeviation>0&&(r=!e.checkEllipticArcMaxDeviation(s,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!e.checkEllipticArcMaxAngle(s,this.m_cosMaxAngle)),r}bezierNeedsSplit(t){let s=!1;if(this.m_maxLength>0){if(w.distance(t[0],t[1])+w.distance(t[1],t[2])+w.distance(t[2],t[3])>this.m_maxLength)return s=!0,!0}return!s&&this.m_maxDeviation>0&&(s=!e.checkBezierMaxDeviation(t,this.m_maxDeviation)),!s&&this.m_maxAngle>0&&(s=!e.checkBezierMaxAngle(t,this.m_cosMaxAngle)),s}progress_(){}static checkBezierMaxDeviation(t,e){const s=t[3].sub(t[0]);if(s.sqrLength()>0){const i=s.clone();i.leftPerpendicularThis(),i.normalize();const n=i.dotProduct(t[0].sub(t[1])),r=i.dotProduct(t[0].sub(t[2]));if(Math.max(Math.abs(n),Math.abs(r))<=e){const e=new w;xh(t,.5,e,!1);const i=e.sub(t[0]).dotProduct(s);return i>=0&&i<=s.sqrLength()}return!1}return Math.max(t[0].sub(t[1]).sqrLength(),t[0].sub(t[2]).sqrLength())<=e*e}static checkBezierMaxAngle(t,e){if(t[0].equals(t[3]))return!(!t[0].equals(t[1])||!t[1].equals(t[2]));const s=t[3].sub(t[0]);s.normalize();{const i=t[1].sub(t[0]),n=i.dotProduct(s);if(n<0)return!1;if(i.length()*e>n)return!1}{const i=t[2].sub(t[0]),n=i.dotProduct(s);if(n<0)return!1;if(i.length()*e>n)return!1}{const i=t[2].sub(t[1]),n=i.dotProduct(s);if(n<0)return!1;if(i.length()*e>n)return!1}return!0}static checkRationalBezier2MaxDeviation(t,e,s){if(0===e[1])return!1;const i=t[2].sub(t[0]);if(i.sqrLength()>0){const e=i.clone();e.leftPerpendicularThis(),e.normalize();const n=e.dotProduct(t[0].sub(t[1]));if(Math.abs(n)<=s){const e=t[1].sub(t[0]).dotProduct(i);return e>=0&&e<=i.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=s*s}static checkRationalBezier2MaxAngle(e,s,i){return t(0),!1}static checkBezier2MaxDeviation(t,e){const s=t[2].sub(t[0]);if(s.sqrLength()>0){const i=s.clone();i.leftPerpendicularThis(),i.normalize();const n=i.dotProduct(t[0].sub(t[1]));if(Math.abs(n)<=e){const e=t[1].sub(t[0]).dotProduct(s);return e>=0&&e<=s.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=e*e}static checkBezier2MaxAngle(e,s){return t(0),!1}static checkEllipticArcMaxDeviation(t,e){if(Math.abs(t.getSweepAngle())<Math.PI){const s=t.getEndXY().sub(t.getStartXY()),i=[0,0];if(1===OP(t,s,i)){const s=t.getCoord2D(i[0]),n=w.getClosestCoordinate(t.getStartXY(),t.getEndXY(),s),r=new w;lt(t.getStartXY(),t.getEndXY(),n,r);return w.distance(s,r)<=e}}const s=t.getCoord2D(.5),i=new w;lt(t.getEndXY(),t.getStartXY(),.5,i);return w.distance(s,i)<=e}static checkEllipticArcMaxAngle(e,s){return t(0),!1}static checkTypeForReplace(e,s){return t(0),!1}};function Il(t,e,s){const i=s.length;if(e<=0||i<=2)return i;let n=0;const r=[];r.length=i-1;for(let o=1,a=i;o<a;o++){const e=t.tToLength(s[o]);r[o-1]=e-n,n=e}for(;r.length>1;){const t=r.findIndex((t=>t<=2*e));if(-1===t)break;let i=t+1,n=t+1;if(t>0){const e=t-1;(n===r.length||r[e]>r[n])&&(n=e,i--)}r[n]+=r[t],r.splice(t,1),s.splice(i,1)}return s.length}function wl(t,e,s,i,n){const r=[],o=[],a=Cl(e,s,0,i,!1,r,o),h=new lo;let m=n;const l=e.getDescription();h.assignVertexDescription(l);const u=l.getAttributeCount()>1,c=new Ge,g=new CE;for(let _=0,d=0;_<a;_++){if(r[d+1].isNAN()){if(u){let t=o[_];e.queryCoord(t,c),g.setStart(c),t=o[_+1],e.queryCoord(t,c),g.setEnd(c)}g.setStartXY(r[d]),g.setEndXY(r[d+3]),t.addSegment(g,m)}else{if(u){let t=o[_];e.queryCoord(t,c),h.setStart(c),t=o[_+1],e.queryCoord(t,c),h.setEnd(c)}h.setStartXY(r[d]),h.setControlPoint1(r[d+1]),h.setControlPoint2(r[d+2]),h.setEndXY(r[d+3]),t.addSegment(h,m)}d+=3,m=!1}}function Dl(t,e,s,i,n){const r=[],o=[],a=Sl(e,s,0,i,!1,r,o),h=new Ln;let m=n;const l=e.getDescription();h.assignVertexDescription(l);const u=l.getAttributeCount()>1,c=new Ge,g=new CE;for(let _=0,d=0;_<a;_++){if(r[d+1].isNAN()){if(u){let t=o[_];e.queryCoord(t,c),g.setStart(c),t=o[_+1],e.queryCoord(t,c),g.setEnd(c)}g.setStartXY(r[d]),g.setEndXY(r[d+2]),t.addSegment(g,m)}else{if(u){let t=o[_];e.queryCoord(t,c),h.setStart(c),t=o[_+1],e.queryCoord(t,c),h.setEnd(c)}h.setStartXY(r[d]),h.setControlPoint1(r[d+1]),h.setEndXY(r[d+2]),t.addSegment(h,m)}d+=2,m=!1}}function Tl(e,i,n,r,o){t(e===s.enumBezier||e===s.enumEllipticArc||e===s.enumBezier2);const a=i.createInstance();a.getGeometryType()===s.enumPolygon&&a.setFillRule(i.getFillRule());const h=i.querySegmentIterator();for(let l=0,u=i.getPathCount();l<u;++l){if(!i.hasNonLinearSegmentsPath(l)){a.addPath(i,l,!0);continue}const o=i.getPathStart(l);let u=!0,c=0;for(h.resetToPath(l),t(h.nextPath());h.hasNextSegment();){const t=h.nextCurve();if(!t)break;{const g=h.getStartPointIndex()-o,_=g-c;_>0&&(a.addSegmentsFromPath(i,l,c,_,u),u=!1),c=g+1,e===s.enumBezier?wl(a,t,n,r,u):e===s.enumBezier2?Dl(a,t,n,r,u):m(""),u=!1}}const g=i.getSegmentCountPath(l);g-c!=0&&a.addSegmentsFromPath(i,l,c,g-c,u)}return a}function Nl(t,e,s,i,n,r,o,a){const h=e.clone();h.dropAllAttributes();const m=(t,e,s,i)=>(e&&(t&&e.push(i.getStartXY()),e.push(w.getNAN()),e.push(w.getNAN()),e.push(i.getEndXY())),s&&(t&&s.push(0),s.push(1)),1);if(h.isDegenerateToLine()||h.isDegenerate(0))return m(t,r,o,e);const l=h.getStartXY(),u=h.getEndXY(),c=h.getSemiAxes(),g=new Y;if(h.isCircular())g.setIdentity();else{const t=h.getAxisXRotation();g.setScaleCoords(1,h.getMinorMajorRatio()),g.rotateAngle(t)}const _=h.getCenter();g.shift(_);const d=g.clone();d.invertThis(),h.applyTransformation(d);const p=h.getSweepAngle();if(0===p)return m(t,r,o,e);const f=ge.constructEmpty();f.setCoords({center:_,width:2*c.x,height:2*c.x});const x=.05*f.calculateToleranceFromEnvelope(),y=Math.max(s/c.x,x/c.x);let P=4*Math.pow(y/.0741,1/6);P=Math.min(P,Math.PI/2);const E=xm(h.getStartAngle());let C=p>0?Math.floor(E/P):Math.ceil(E/P);C*=P;const S=p>0?P:-P;C+S===E&&(C+=S);let v=4/3*Math.tan(Math.abs(P)/4);p>0&&(v=-v),o&&t&&o.push(0);const b=P/Math.abs(p);let I=(C-E)/p;const T=l.clone(),N=new w;h.queryCoord2D(0,N);const A=N.clone(),q=1-.01*b;let F=0,M=0;for(;I<1;){let s;if(I+=b,M>0&&I<q)s=v;else{I>=q&&(I=1);const t=(I-M)*p;s=4/3*Math.tan(Math.abs(t)/4),p>0&&(s=-s)}h.queryCoord2D(I,N);const a=new w;g.queryTransform(N,a);const m=e.getClosestCoordinate(a,!1);if(e.queryCoord2D(m,a),1!==I&&(w.distance(T,a)<=2*i||w.distance(a,u)<=2*i))continue;T.setCoordsPoint2D(a);const c=D(w,4);c[0].assign(A),c[3].assign(N),c[1].rightPerpendicularOther(A),c[1].scaleAddThis(s,A),c[2].leftPerpendicularOther(N),c[2].scaleAddThis(s,N),g.transformPoints2D(c,3,c),c[3].assign(a),0===M&&c[0].setCoordsPoint2D(l),1===I&&c[3].setCoordsPoint2D(u),n&&gh(c);let _=!0;for(let t=1;t<4;t++)if(!c[t].isEqualPoint2D(c[0])){_=!1;break}_||(o&&o.push(m),r&&(0===M&&t&&r.push(c[0].clone()),r.push(c[1].clone()),r.push(c[2].clone()),r.push(c[3].clone())),F++),M=I,A.setCoordsPoint2D(N)}return F}function Al(e,s,i,n,r,o,a,h){return t(0),0}function ql(e,s,i,n,r,o,a,h){return t(0),0}function Fl(t,e,s,i,n,r,o,a){const h=e.clone();if(h.dropAllAttributes(),h.isDegenerateToLine()||0===h.getSweepAngle())return r&&(t&&r.push(e.getStartXY()),r.push(w.getNAN()),r.push(e.getEndXY())),o&&(t&&o.push(0),o.push(1)),1;const m=h.getStartXY(),l=h.getEndXY(),u=h.getSemiAxes(),c=new Y;if(h.isCircular())c.setIdentity();else{const t=h.getAxisXRotation();c.setScaleCoords(1,h.getMinorMajorRatio()),c.rotateAngle(t)}const g=h.getCenter();c.shift(g);const _=c.clone();_.invertThis(),h.applyTransformation(_);const d=ge.constructEmpty();d.setCoords({center:g,width:2*u.x,height:2*u.x});const p=.05*d.calculateToleranceFromEnvelope(),f=Math.max(s/u.x,p/u.x),x=Math.sqrt(2*f+f*f);let y=2*Math.sqrt(2*x*(1+f-x));y=Math.min(y,Math.PI/2);const P=h.getSweepAngle(),E=Math.ceil(Math.abs(P)/y),C=Math.max(E,1);y=P/C;const S=1/C;let v=Math.tan(Math.abs(y)/2);P>0&&(v=-v),o&&t&&o.push(0);const b=new w;h.queryCoord2D(0,b);for(let I=0;I<C;I++){const e=b.clone(),s=(I+1)*S;if(o&&o.push(s),!r)continue;h.queryCoord2D(s,b);const i=D(w,3);i[0].assign(e),i[2].assign(b),i[1].rightPerpendicularOther(i[0]),i[1].mulThis(v),i[1].addThis(i[0]),c.transformPoints2D(i,3,i),0===I&&i[0].setCoordsPoint2D(m),I===C-1&&i[2].setCoordsPoint2D(l),0===I&&t&&r.push(i[0]),r.push(i[1]),r.push(i[2])}return C}function Ml(e,s,i,n,r,o,a,h){return t(0),0}var Gl,Vl,Yl=bl;class Xl extends ue{constructor(t,e,s,i,n,r){super(),this.m_densificator=new Yl(e,s,i,r,!1,n),this.m_index=-1,this.m_inputGeoms=t}tock(){return!0}getRank(){return 1}next(){let t=null;for(;t=this.m_inputGeoms.next();)return g(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.densify(t);return null}getGeometryID(){return this.m_index}densify(t){return this.m_densificator.densify(t)}}class kl{getOperatorType(){return 10202}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s,i,n,r=12e3){return new Xl(t,e,s,i,r,n)}execute(t,e,s,i,n,r=12e3){return Pl(t,e,s,i,n,r)}}class Rl{constructor(t){this.m_currentShift=63n,this.m_currentElt=0n,this.m_iCurrentElt=-1,this.m_parent=t,this.m_aiSetElts=t.m_bits.flatMap(((t,e)=>e))}next(){if(this.m_currentShift++,64n===this.m_currentShift){if(this.m_iCurrentElt++,this.m_iCurrentElt===this.m_aiSetElts.length)return Rl.npos();this.m_currentShift=0n,this.m_currentElt=this.m_parent.m_bits[this.m_aiSetElts[this.m_iCurrentElt]]}for(;this.m_currentShift<63n&&!(this.m_currentElt&1n<<this.m_currentShift);)this.m_currentShift++;return this.m_currentElt&1n<<this.m_currentShift?64*this.m_aiSetElts[this.m_iCurrentElt]+Number(this.m_currentShift):this.next()}static npos(){return Number.MAX_SAFE_INTEGER}}function Bl(t){return 1n<<(0x3fn&BigInt(t))}function Ll(t){return t>>6}class Hl{constructor(t){this.m_bits=[],void 0!==t&&t.copy&&(this.m_bits=t.copy.m_bits.slice())}assignMove(){return this}assignCopy(){return this}hasBit(t){const e=Bl(t),s=Ll(t);return void 0!==this.m_bits[s]&&!!(this.m_bits[s]&e)}setBit(t){const e=Bl(t),s=Ll(t);void 0===this.m_bits[s]&&(this.m_bits[s]=0n),this.m_bits[s]|=e}clearBit(t){}flipBit(t){const e=Bl(t),s=Ll(t);return void 0===this.m_bits[s]&&(this.m_bits[s]=0n),this.m_bits[s]^=e,0n!==(this.m_bits[s]&e)}clear(){this.m_bits.length=0}isZero(){let t=0;return this.m_bits.forEach((e=>{t|=e?2:1})),!(2&t)}equals(t){if(this===t)return!0;if(this.m_bits.length!==t.m_bits.length)return!1;let e=0;return this.m_bits.forEach(((s,i)=>{e|=s===t.m_bits[i]?2:1})),!(1&e)&&(t.m_bits.forEach(((t,s)=>{e|=t===this.m_bits[s]?2:1})),!(1&e))}notEquals(t){return!this.equals(t)}assignOr(t){return t.m_bits.forEach(((t,e)=>{void 0===this.m_bits[e]?this.m_bits[e]=t:this.m_bits[e]|=t})),this}assignSubtract(t){return t.m_bits.forEach(((t,e)=>{void 0!==this.m_bits[e]&&(this.m_bits[e]&=~t)})),this}assignAnd(t){return t.m_bits.forEach(((t,e)=>{void 0!==this.m_bits[e]&&(this.m_bits[e]&=t)})),this}assignXor(t){return t.m_bits.forEach(((t,e)=>{void 0===this.m_bits[e]?this.m_bits[e]=t:this.m_bits[e]^=t})),this}getHashCode(){return this.m_bits.reduce(((t,e)=>$t(t,e)),W(0))}getUnorderedBitIterator(){return new Rl(this)}}class zl{constructor(t,e){this.m_map=new Map,this.m_hf=t,this.m_ef=e}add(t){const e=this.m_hf(t);if(!this.m_map.has(e))return this.m_map.set(e,t),this;const s=this.m_map.get(e);return s instanceof Array?s.find((e=>this.m_ef(e,t)))||s.push(t):this.m_ef(s,t)||this.m_map.set(e,[s,t]),this}clear(){this.m_map.clear()}delete(t){return!1}has(t){const e=this.m_hf(t);if(!this.m_map.has(e))return!1;const s=this.m_map.get(e);return s instanceof Array?void 0!==s.find((e=>this.m_ef(e,t))):this.m_ef(s,t)}get(t){const e=this.m_hf(t),s=this.m_map.get(e);if(void 0!==s)return s instanceof Array?s.find((e=>this.m_ef(e,t))):s}get size(){let t=0;for(const e of this.m_map.values())t+=e instanceof Array?e.length:1;return t}forEach(t,e){}[Symbol.iterator](){return(new Set)[Symbol.iterator]()}entries(){return(new Set).entries()}keys(){return(new Set).keys()}values(){return(new Set).values()}get[Symbol.toStringTag](){return"ValueSet"}}class Ul extends hs{constructor(t){super(),this.m_bufferLeft=new SE,this.m_bufferRight=new SE,this.m_intervalLeft=A.constructEmpty(),this.m_intervalRight=A.constructEmpty(),this.m_yScanline=Number.NaN,this.m_helper=t}compare(t,e,s){const i=e,n=t.getElement(s);this.m_helper.querySegmentXY(i,this.m_bufferLeft),this.m_helper.querySegmentXY(n,this.m_bufferRight);const r=this.m_bufferLeft.get(),o=this.m_bufferRight.get();if(this.m_intervalLeft.setCoords(r.getStartX(),r.getEndX()),this.m_intervalRight.setCoords(o.getStartX(),o.getEndX()),this.m_intervalLeft.vmax<this.m_intervalRight.vmin)return-1;if(this.m_intervalLeft.vmin>this.m_intervalRight.vmax)return 1;const a=r.getStartY()===r.getEndY(),h=o.getStartY()===o.getEndY();if(a||h){if(a&&h)return 0;if(r.getStartY()===o.getStartY()&&r.getStartX()===o.getStartX())return a?1:-1;if(r.getEndY()===o.getEndY()&&r.getEndX()===o.getEndX())return a?-1:1}let m=r.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalLeft.vmin),l=o.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalRight.vmin);if(m===l){const t=r.getEndY(),e=o.getEndY(),s=Math.min(t,e);let i=.5*(s+this.m_yScanline);i===this.m_yScanline&&(i=s),m=r.intersectionOfYMonotonicWithAxisX(i,this.m_intervalLeft.vmin),l=o.intersectionOfYMonotonicWithAxisX(i,this.m_intervalRight.vmin)}return m<l?-1:m>l?1:0}setY(t){this.m_yScanline=t}}class Ol{constructor(t){this.m_segmentBuffer=new SE,this.m_point=w.getNAN(),this.m_parent=t}setPointXY(t){this.m_point.assign(t)}compare(t,e){const s=t.getElement(e);this.m_parent.querySegmentXY(s,this.m_segmentBuffer);const i=this.m_segmentBuffer.get(),n=new A;if(n.setCoords(i.getStartX(),i.getEndX()),this.m_point.x<n.vmin)return-1;if(this.m_point.x>n.vmax)return 1;const r=i.intersectionOfYMonotonicWithAxisX(this.m_point.y,this.m_point.x);return this.m_point.x<r?-1:this.m_point.x>r?1:0}}function Wl(t,e){return{parentage:t,rank:e}}function jl(t,e){const s=t.length;if(s!==e.length)return!1;const i=t[0].parentage;if(i!==e[0].parentage)return!1;if(-1===i)return!0;for(let n=1;n<s;++n)if(t[n].parentage!==e[n].parentage)return!1;return!0}function Zl(t,e,s){s.length=0;let i=!1;{let n=t.getHalfEdgeVertexIterator(e);for(;n!==Nm;){const e=t.getVertexFromVertexIterator(n),r=t.getShape().getSegmentRank(e),o=t.getShape().getSegmentParentage(e);i||=o>=0,s.push(Wl(o,r)),n=t.incrementVertexIterator(n)}}{let n=t.getHalfEdgeVertexIterator(t.getHalfEdgeTwin(e));for(;n!==Nm;){const e=t.getVertexFromVertexIterator(n),r=t.getShape().getSegmentRank(e),o=t.getShape().getSegmentParentage(e);i||=o>=0,s.push(Wl(o,r)),n=t.incrementVertexIterator(n)}}i&&s.sort(((t,e)=>t.rank>e.rank?-1:t.rank<e.rank?1:t.parentage<e.parentage?-1:t.parentage>e.parentage?1:0)),-1===s[0].parentage&&(s.length=1)}function Ql(){return new zl((t=>t.getHashCode()),((t,e)=>t.equals(e)))}!function(t){t[t.enumInputModeBuildGraph=0]="enumInputModeBuildGraph",t[t.enumInputModeSimplifyAlternate=1]="enumInputModeSimplifyAlternate",t[t.enumInputModeSimplifyWinding=2]="enumInputModeSimplifyWinding"}(Gl||(Gl={})),function(t){t[t.enumSegmentParentageBreakNode=1]="enumSegmentParentageBreakNode",t[t.enumPathBreakNode=2]="enumPathBreakNode"}(Vl||(Vl={}));class Kl{constructor(){this.m_shape=null,this.m_clusterData=new is(8),this.m_clusterVertices=new is(2),this.m_firstCluster=Nm,this.m_lastCluster=Nm,this.m_halfEdgeData=new is(8),this.m_chainData=new is(8),this.m_chainAreas=null,this.m_chainPerimeters=null,this.m_universeChain=-1,this.m_simplifiedGeometry=-1,this.m_edgeIndices=[],this.m_clusterIndices=[],this.m_chainIndices=[],this.m_bBuildGeometryParentageSets=!1,this.m_chainBitSetIndex=-1,this.m_edgeBitSetIndex=-1,this.m_edgeBitSetIndexLeft=-1,this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_uniqueBitSets=null,this.m_chainBitSets=[],this.m_edgeBitSets=[],this.m_checkDirtyPlanesweepTolerance=Number.NaN,this.m_geometryIDIndex=-1,this.m_clusterIndex=-1,this.m_halfEdgeIndex=-1,this.m_tmpHalfEdgeParentageIndex=-1,this.m_tmpHalfEdgeParentageIndexLeft=-1,this.m_tmpHalfEdgeWindingNumberIndex=-1,this.m_tmpHalfEdgeOddEvenNumberIndex=-1,this.m_segmentParentageIndex=-1,this.m_segmentIndexHe=-1,this.m_clusterBreakNodeIndex=-1,this.m_universeGeomID=-1,this.m_pointCount=0,this.m_progressCounter=0,this.m_bBuildChains=!0,this.m_bDirtyCheckFailed=!1}setCheckDirtyPlanesweepTolerance(t){this.m_checkDirtyPlanesweepTolerance=t}dirtyCheckFailed(){return this.m_bDirtyCheckFailed}getShape(){return this.m_shape}setEditShape(t,e,s=!0,i=!1){i?this.setEditShapeImpl3D_(t,Gl.enumInputModeBuildGraph,null,e,!1):this.setEditShapeImpl_(t,Gl.enumInputModeBuildGraph,null,e,s)}setAndSimplifyEditShapeAlternate(t,e,i=null,n=!1){const r=[];r.push(e),this.m_simplifiedGeometry=e,n?this.setEditShapeImpl3D_(t,Gl.enumInputModeSimplifyAlternate,r,i,!1):this.setEditShapeImpl_(t,Gl.enumInputModeSimplifyAlternate,r,i,t.getGeometryType(e)===s.enumPolygon)}setAndSimplifyEditShapeWinding(t,e,s=null){const i=[];i.push(e),this.m_simplifiedGeometry=e,this.setEditShapeImpl_(t,Gl.enumInputModeSimplifyWinding,i,s,!0)}removeShape(){null!==this.m_shape&&(-1!==this.m_geometryIDIndex&&(this.m_shape.removeGeometryUserIndex(this.m_geometryIDIndex),this.m_geometryIDIndex=-1),-1!==this.m_clusterIndex&&(this.m_shape.removeUserIndex(this.m_clusterIndex),this.m_clusterIndex=-1),-1!==this.m_halfEdgeIndex&&(this.m_shape.removeUserIndex(this.m_halfEdgeIndex),this.m_halfEdgeIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),-1!==this.m_tmpHalfEdgeWindingNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),-1!==this.m_tmpHalfEdgeOddEvenNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1),-1!==this.m_segmentParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),-1!==this.m_segmentIndexHe&&(this.deleteUserIndexForHalfEdges(this.m_segmentIndexHe),this.m_segmentIndexHe=-1),-1!==this.m_clusterBreakNodeIndex&&(this.deleteUserIndexForClusters(this.m_clusterBreakNodeIndex),this.m_clusterBreakNodeIndex=-1),this.deleteEdgeBitSets_(),this.deleteChainBitSets_(),this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_shape=null,this.m_clusterData.deleteAll(!0),this.m_clusterVertices.deleteAll(!0),this.m_firstCluster=Nm,this.m_lastCluster=Nm,this.m_halfEdgeData.deleteAll(!0),this.m_edgeIndices.length=0,this.m_clusterIndices.length=0,this.m_chainIndices.length=0,this.m_chainData.deleteAll(!0),this.m_universeChain=Nm,this.m_chainAreas=null)}getClusterHalfEdge(t){return this.m_clusterData.getField(t,2)}queryXY(t,e){const s=this.getClusterVertexIndex_(t);e.assign(this.m_shape.getXYWithIndex(s))}queryXYZ(e,s){t(0)}getClusterParentage(t){return this.m_clusterData.getField(t,1)}getFirstCluster(){return this.m_firstCluster}getPrevCluster(t){return this.m_clusterData.getField(t,3)}getNextCluster(t){return this.m_clusterData.getField(t,4)}getClusterChain(t){return this.m_clusterData.getField(t,6)}getClusterVertexIterator(t){return this.m_clusterData.getField(t,7)}incrementVertexIterator(t){return this.m_clusterVertices.getField(t,1)}getVertexFromVertexIterator(t){return this.m_clusterVertices.getField(t,0)}getClusterUserIndex(t,e){const s=this.getClusterIndex_(t),i=this.m_clusterIndices[e];return i.size()<=s?-1:i.read(s)}setClusterUserIndex(t,e,s){const i=this.getClusterIndex_(t),n=this.m_clusterIndices[e];n.size()<=i&&n.resize(this.m_clusterData.size(),-1),n.write(i,s)}hasClusterUserIndexFlags(t,e,s){if(-1===e)return!1;const i=this.getClusterUserIndex(t,e);return-1!==i&&!!(s&i)}setClusterUserIndexFlags(t,e,s){const i=this.getClusterIndex_(t),n=this.m_clusterIndices[e];n.size()<=i&&n.resize(this.m_clusterData.size(),-1);let r=n.read(i);-1===r&&(r=0),n.write(i,s|r)}clearClusterUserIndexFlags(e,s,i){t(0)}createUserIndexForClusters(t=-1){const e=new Qe(this.m_clusterData.capacity(),t);for(let s=0,i=this.m_clusterIndices.length;s<i;s++)if(null===this.m_clusterIndices[s])return this.m_clusterIndices[s]=e,s;this.m_clusterIndices.push(e);return this.m_clusterIndices.length-1}deleteUserIndexForClusters(t){this.m_clusterIndices[t]=null}getHalfEdgeOrigin(t){return this.m_halfEdgeData.getField(t,1)}getHalfEdgeTo(t){return this.getHalfEdgeOrigin(this.getHalfEdgeTwin(t))}getHalfEdgeTwin(t){return this.m_halfEdgeData.getField(t,4)}getHalfEdgePrev(t){return this.m_halfEdgeData.getField(t,5)}getHalfEdgeNext(t){return this.m_halfEdgeData.getField(t,6)}getHalfEdgeChain(t){return this.m_halfEdgeData.getField(t,2)}getHalfEdgeFaceParentage(t){return this.getChainParentage(this.getHalfEdgeChain(t))}getHalfEdgeVertexIterator(t){return this.m_halfEdgeData.getField(t,7)}getHalfEdgeFromXY(t,e){this.queryXY(this.getHalfEdgeOrigin(t),e)}getHalfEdgeToXY(t,e){this.queryXY(this.getHalfEdgeTo(t),e)}isHalfEdgeCurve(t){if(-1!==this.m_segmentIndexHe){return-1!==this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)}return!1}getHalfEdgeFromXYZ(e,s){t(0)}getHalfEdgeToXYZ(e,s){t(0)}getHalfEdgeParentage(t){return this.m_halfEdgeData.getField(t,3)&Kl.c_EdgeParentageMask}getHalfEdgeUserIndex(t,e){const s=this.getHalfEdgeIndex_(t),i=this.m_edgeIndices[e];return i.size()<=s?-1:i.read(s)}setHalfEdgeUserIndex(t,e,s){const i=this.getHalfEdgeIndex_(t),n=this.m_edgeIndices[e];n.size()<=i&&n.resize(this.m_halfEdgeData.size(),-1),n.write(i,s)}createUserIndexForHalfEdges(e){void 0===e&&(e=-1);const s=new Qe(this.m_halfEdgeData.capacity(),e);for(let t=0,n=this.m_edgeIndices.length;t<n;t++)if(null===this.m_edgeIndices[t])return this.m_edgeIndices[t]=s,t;this.m_edgeIndices.push(s);const i=this.m_edgeIndices.length-1;return t(i>=0&&i<=Number.MAX_SAFE_INTEGER),i}deleteUserIndexForHalfEdges(t){this.m_edgeIndices[t]=null}deleteEdgesBreakFaces_(t){for(let e=0,s=t.length;e<s;e++){const s=t[e],i=this.getHalfEdgeChain(s),n=this.getHalfEdgeTwin(s),r=this.getHalfEdgeChain(n);this.setChainHalfEdge_(i,Nm),this.setChainHalfEdge_(r,Nm),this.updateVertexToHalfEdgeConnection_(s,!0),this.deleteEdgeImpl_(s)}}doesHalfEdgeBelongToAPolygonInterior(e,s){return t(0),!1}doesHalfEdgeBelongToAPolygonExterior(e,s){return t(0),!1}doesHalfEdgeBelongToAPolygonBoundary(e,s){return t(0),!1}doesHalfEdgeBelongToAPolylineInterior(e,s){return t(0),!1}doesHalfEdgeBelongToAPolylineExterior(e,s){return t(0),!1}doesClusterBelongToAPolygonInterior(e,s){return t(0),!1}doesClusterBelongToAPolygonExterior(e,s){return t(0),!1}doesClusterBelongToAPolygonBoundary(e,s){return t(0),!1}getFirstChain(){return this.m_universeChain}getChainHalfEdge(t){return this.m_chainData.getField(t,1)}getChainParentage(t){return this.m_chainData.getField(t,2)}getChainParent(t){return this.m_chainData.getField(t,3)}getChainFirstIsland(t){return this.m_chainData.getField(t,4)}getChainNextInParent(t){return this.m_chainData.getField(t,5)}getChainNext(t){return this.m_chainData.getField(t,7)}getChainArea(t){const e=this.getChainIndex_(t);let s=this.m_chainAreas.read(e);return Number.isNaN(s)&&(this.updateChainAreaAndPerimeter_(t),s=this.m_chainAreas.read(e)),s}getChainPerimeter(e){return t(0),0}getChainUserIndex(t,e){const s=this.getChainIndex_(t),i=this.m_chainIndices[e];return i.size()<=s?-1:i.read(s)}setChainUserIndex(t,e,s){const i=this.getChainIndex_(t),n=this.m_chainIndices[e];n.size()<=i&&n.resize(this.m_chainData.size(),-1),n.write(i,s)}createUserIndexForChains(){const t=new Qe(this.m_chainData.capacity(),-1);for(let e=0,s=this.m_chainIndices.length;e<s;e++)if(null===this.m_chainIndices[e])return this.m_chainIndices[e]=t,e;this.m_chainIndices.push(t);return this.m_chainIndices.length-1}deleteUserIndexForChains(e){t(0)}extractPolygonFromChainAndIslands(t,e,i,n){const r=e===Nm?t.createGeometry(s.enumPolygon):e,o=new SE;this.extractPolygonPathFromChain_(t,r,i,n,o);for(let s=this.getChainFirstIsland(i);s!==Nm;s=this.getChainNextInParent(s))this.extractPolygonPathFromChain_(t,r,s,n,o);return r}getGeometryID(e){const s=this.m_shape.getGeometryUserIndex(e,this.m_geometryIDIndex);return t(s>=0),1<<Math.min(s,31)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_clusterIndex)}getHalfEdgeFromVertex(t){return this.m_shape.getUserIndex(t,this.m_halfEdgeIndex)}buildGeometryParentageSets(){this.m_bBuildGeometryParentageSets=!0}getChainBitSet(e){if(t(this.m_bBuildGeometryParentageSets),-1===this.m_chainBitSetIndex)return this.getEmptySet();const s=this.getChainUserIndex(e,this.m_chainBitSetIndex);t(s>=0);let i=this.m_chainBitSets.at(s);return i||(i=this.getEmptySet()),i}getChainBoundaryBitSet(e){t(this.m_bBuildGeometryParentageSets);const s=new Hl,i=t=>{const e=this.getChainHalfEdge(t);let i=e;do{const t=this.getEdgeBitSet_(i);null!==t&&s.assignOr(t);const e=this.getEdgeBitSet_(this.getHalfEdgeTwin(i));null!==e&&s.assignOr(e),i=this.getHalfEdgeNext(i)}while(i!==e)};i(e);for(let t=this.getChainFirstIsland(e);t!==Nm;t=this.getChainNextInParent(t))i(e);return s}getChainPolygons(e){return t(0),[]}getGeometriesFromBits(e){if(!this.m_bBuildGeometryParentageSets||null===e)return[];if(null===this.m_geometryMapID){this.m_geometryMapID=new Map;for(let t=this.m_shape.getFirstGeometry();t!==Nm;t=this.m_shape.getNextGeometry(t))this.m_geometryMapID.set(this.m_shape.getGeometryUserIndex(t,this.m_geometryIDIndex),t)}const s=[],i=e.getUnorderedBitIterator();for(let n=i.next();n!==Rl.npos();n=i.next())t(this.m_geometryMapID.has(n)),s.push(this.m_geometryMapID.get(n));return s}getVertexDominant(t,e){if(e===Nm)return t;const s=this.getClusterFromVertex(t);return this.getVertexDominantFromCluster(s,e)}getVertexDominantFromCluster(t,e){if(e!==Nm){let s=Nm;for(let i=this.getClusterVertexIterator(t);i!==Nm;i=this.incrementVertexIterator(i)){const t=this.getVertexFromVertexIterator(i);s===Nm&&(s=t);const n=this.m_shape.getPathFromVertex(t);if(this.m_shape.getGeometryFromPath(n)===e){s=t;break}}return s}{const e=this.getClusterVertexIterator(t);if(e!==Nm){return this.getVertexFromVertexIterator(e)}return Nm}}isBreakNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Vl.enumSegmentParentageBreakNode)}setBreakNode(e,s){t(-1!==this.m_clusterBreakNodeIndex),s?this.setClusterUserIndexFlags(e,this.m_clusterBreakNodeIndex,Vl.enumSegmentParentageBreakNode):this.clearClusterUserIndexFlags(e,this.m_clusterBreakNodeIndex,Vl.enumSegmentParentageBreakNode)}isStrongPathNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Vl.enumPathBreakNode)}setStrongPathNode(t,e){if(-1===this.m_clusterBreakNodeIndex){if(!e)return;this.m_clusterBreakNodeIndex=this.createUserIndexForClusters()}e?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Vl.enumPathBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,Vl.enumPathBreakNode)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const e=this.getHalfEdgeUserIndex(t,this.m_segmentParentageIndex);return e>=0?e:-1}isCrossroadAhead(t){const e=this.getHalfEdgeNext(t);if(this.isStrongPathNode(this.getHalfEdgeOrigin(e)))return!0;const s=this.getHalfEdgeTwin(e),i=this.getHalfEdgeNext(s);return t!==this.getHalfEdgeTwin(i)}isCrossroadBehind(e){return t(0),!1}getHalfEdgeConnector(t,e){const s=this.getClusterHalfEdge(t);if(s===Nm)return Nm;let i=s,n=Nm,r=Nm;do{if(this.getHalfEdgeTo(i)===e)return i;if(n===Nm){if(n=this.getClusterHalfEdge(e),n===Nm)return Nm;r=n}if(this.getHalfEdgeTo(r)===t)return i=this.getHalfEdgeTwin(r),i;i=this.getHalfEdgeNext(this.getHalfEdgeTwin(i)),r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(i!==s&&r!==n);return Nm}querySegmentXY(t,e){if(-1!==this.m_segmentIndexHe){let s=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(-1!==s){if(-2!==s){const t=this.m_shape.getSegmentFromIndex(s);e.copyFrom(t,!0)}else{s=this.getHalfEdgeUserIndex(this.getHalfEdgeTwin(t),this.m_segmentIndexHe);const i=this.m_shape.getSegmentFromIndex(s);e.copyFrom(i,!0),e.get().reverse()}return}}e.createLine();const s=e.get(),i=w.getNAN();this.getHalfEdgeFromXY(t,i),s.setStartXY(i),this.getHalfEdgeToXY(t,i),s.setEndXY(i)}isCurveEdge(t){if(-1!==this.m_segmentIndexHe){return-1!==this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)}return!1}compareEdgeAnglesCurveHelper_(e,s,i){const n=new SE,r=new SE;this.querySegmentXY(e,n),this.querySegmentXY(s,r);const o=n.get(),a=r.get();if(o.equals(a))return 0;const h=new w;this.getHalfEdgeFromXY(e,h);const m=new w;this.getHalfEdgeToXY(e,m);const l=new w;this.getHalfEdgeToXY(s,l),t(!m.isEqualPoint2D(l));const u=o.getTangent(0),c=a.getTangent(0);return w.compareVectors(u,c)}compareEdgeAnglesHelper_(t,e,s){if(t===e)return 0;if(this.isHalfEdgeCurve(t)||this.isHalfEdgeCurve(e))return this.compareEdgeAnglesCurveHelper_(t,e,s);const i=w.getNAN();this.getHalfEdgeToXY(t,i);const n=w.getNAN();if(this.getHalfEdgeToXY(e,n),i.isEqualPoint2D(n))return 0;const r=w.getNAN();this.getHalfEdgeFromXY(t,r);const o=w.getNAN();o.setSub(i,r);const a=w.getNAN();if(a.setSub(n,r),!s||a.y>=0&&o.y>0){return w.compareVectors(o,a)}return 0}compareEdgeAngles_(t,e){return this.compareEdgeAnglesHelper_(t,e,!1)}compareEdgeAnglesForPair_(t,e){return this.compareEdgeAnglesHelper_(t,e,!0)}compareEdgeAngles3D_(e,s){return t(0),0}compareEdgeAnglesForPair3D_(e,s){return t(0),0}dbgDumpChains_(){}dbgDumpChainToPolygon_(e,s){t(0)}deleteEdgeInternal_(e){const s=this.getHalfEdgeChain(e),i=this.getHalfEdgeTwin(e),n=this.getHalfEdgeChain(i);t(n===s),t(e===this.getHalfEdgeNext(i)||i===this.getHalfEdgeNext(e));let r=this.getHalfEdgeNext(e);r===i&&(r=this.getHalfEdgeNext(r),r===e&&(r=Nm));const o=this.getChainIndex_(s),a=this.m_chainAreas.read(o);Number.isNaN(a)||(this.setChainArea_(s,Number.NaN),this.setChainPerimeter_(s,Number.NaN));const h=this.getChainHalfEdge(s);h!==e&&h!==i||this.setChainHalfEdge_(s,r),this.updateVertexToHalfEdgeConnection_(e,!0),this.deleteEdgeImpl_(e)}getFirstUnvisitedHalfEdgeOnCluster_(t,e,s){let i=e!==Nm?e:this.getClusterHalfEdge(t);if(i===Nm)return Nm;const n=i;for(;;){if(1!==this.getHalfEdgeUserIndex(i,s))return i;const t=this.getHalfEdgeNext(this.getHalfEdgeTwin(i));if(t===n)return Nm;i=t}}removeSpikes_(){let t=!1;const e=this.createUserIndexForHalfEdges();for(let s=this.getFirstCluster();s!==Nm;s=this.getNextCluster(s)){let i=Nm;for(;;){let n=this.getFirstUnvisitedHalfEdgeOnCluster_(s,i,e);if(n===Nm)break;i=this.getHalfEdgeNext(this.getHalfEdgeTwin(n));let r=n;for(;;){const s=this.getHalfEdgeNext(r),o=this.getHalfEdgePrev(r),a=this.getHalfEdgeTwin(r);if(o===a){if(this.deleteEdgeInternal_(r),t=!0,i!==r&&i!==a||(i=Nm),r===n||o===n){if(n=s,r===n||o===n)break;r=s;continue}}else this.setHalfEdgeUserIndex(r,e,1);if(r=s,r===n)break}}}return this.deleteUserIndexForHalfEdges(e),t}progress_(t,e=!1){}newCluster_(){const t=this.m_clusterData.newElement();return this.m_clusterData.setField(t,1,0),t}newHalfEdgePair_(){const t=this.m_halfEdgeData.newElement();this.m_halfEdgeData.setField(t,2,0),this.m_halfEdgeData.setField(t,3,0);const e=this.m_halfEdgeData.newElement();return this.m_halfEdgeData.setField(e,2,0),this.m_halfEdgeData.setField(e,3,0),this.setHalfEdgeTwin_(t,e),this.setHalfEdgeTwin_(e,t),t}newChain_(){const t=this.m_chainData.newElement();return this.m_chainData.setField(t,2,0),t}deleteChain_(e){return t(0),0}getClusterIndex_(t){return this.m_clusterData.elementToIndex(t)}setClusterVertexIterator_(t,e){this.m_clusterData.setField(t,7,e)}setClusterHalfEdge_(t,e){this.m_clusterData.setField(t,2,e)}setClusterParentage_(t,e){this.m_clusterData.setField(t,1,e)}setPrevCluster_(t,e){this.m_clusterData.setField(t,3,e)}setNextCluster_(t,e){this.m_clusterData.setField(t,4,e)}setClusterVertexIndex_(t,e){this.m_clusterData.setField(t,5,e)}getClusterVertexIndex_(t){return this.m_clusterData.getField(t,5)}setClusterChain_(t,e){this.m_clusterData.setField(t,6,e)}addClusterToExteriorChain_(t,e){this.setClusterChain_(e,t)}getHalfEdgeIndex_(t){return this.m_halfEdgeData.elementToIndex(t)}setHalfEdgeOrigin_(t,e){this.m_halfEdgeData.setField(t,1,e)}setHalfEdgeTwin_(t,e){this.m_halfEdgeData.setField(t,4,e)}setHalfEdgePrev_(t,e){this.m_halfEdgeData.setField(t,5,e)}setHalfEdgeNext_(t,e){this.m_halfEdgeData.setField(t,6,e)}setHalfEdgeChain_(t,e){this.m_halfEdgeData.setField(t,2,e)}setHalfEdgeParentage_(t,e){this.m_halfEdgeData.setField(t,3,e)}getHalfEdgeParentageMask_(t){return this.m_halfEdgeData.getField(t,3)}setHalfEdgeVertexIterator_(t,e){this.m_halfEdgeData.setField(t,7,e)}updateVertexToHalfEdgeConnectionHelper_(t,e){const s=e?Nm:t;for(let i=this.getHalfEdgeVertexIterator(t);i!==Nm;i=this.incrementVertexIterator(i)){const t=this.getVertexFromVertexIterator(i);this.m_shape.setUserIndex(t,this.m_halfEdgeIndex,s)}}updateVertexToHalfEdgeConnection_(t,e){t!==Nm&&(this.updateVertexToHalfEdgeConnectionHelper_(t,e),this.updateVertexToHalfEdgeConnectionHelper_(this.getHalfEdgeTwin(t),e))}getChainIndex_(t){return this.m_chainData.elementToIndex(t)}setChainHalfEdge_(t,e){this.m_chainData.setField(t,1,e)}setChainParentage_(t,e){this.m_chainData.setField(t,2,e)}setChainParent_(t,e){this.m_chainData.setField(t,3,e);const s=this.getChainFirstIsland(e);this.setChainNextInParent_(t,s),this.setChainFirstIsland_(e,t)}setChainFirstIsland_(t,e){this.m_chainData.setField(t,4,e)}setChainNextInParent_(t,e){this.m_chainData.setField(t,5,e)}setChainPrev_(t,e){this.m_chainData.setField(t,6,e)}setChainNext_(t,e){this.m_chainData.setField(t,7,e)}setChainArea_(t,e){const s=this.getChainIndex_(t);this.m_chainAreas.write(s,e)}setChainPerimeter_(t,e){const s=this.getChainIndex_(t);this.m_chainPerimeters.write(s,e)}updateChainAreaAndPerimeter_(t){const e=this.m_shape.hasCurves(),s=new Yt(0),i=new Yt(0),n=this.getChainHalfEdge(t),r=w.getNAN(),o=w.getNAN(),a=w.getNAN();this.getHalfEdgeFromXY(n,r),o.setCoordsPoint2D(r);let h=n;do{this.getHalfEdgeToXY(h,a),e&&this.isCurveEdge(h)||i.pe(w.distance(o,a));this.getHalfEdgeChain(this.getHalfEdgeTwin(h))!==t&&s.pe((a.x-r.x-(o.x-r.x))*(a.y-r.y+(o.y-r.y))*.5),o.setCoordsPoint2D(a),h=this.getHalfEdgeNext(h)}while(h!==n);if(e){const e=new SE;h=n;do{this.getHalfEdgeToXY(h,a);const n=this.isCurveEdge(h);n&&(this.querySegmentXY(h,e),i.pe(e.get().calculateLength2D()));if(this.getHalfEdgeChain(this.getHalfEdgeTwin(h))!==t&&n){const t=e.get().calculateArea2DHelper();s.pe(t)}h=this.getHalfEdgeNext(h)}while(h!==n)}const m=this.getChainIndex_(t);this.m_chainAreas.write(m,s.getResult()),this.m_chainPerimeters.write(m,i.getResult())}getChainTopmostEdge_(e){return t(0),0}planeSweepParentage_(t,e){const s=new Ul(this),i=new ms;i.setCapacity(Math.trunc(this.m_pointCount/2)),i.setComparator(s);const n=[],r=this.createUserIndexForHalfEdges();let o=null;const a=w.getNAN();for(let h=this.getFirstCluster();h!==Nm;h=this.getNextCluster(h)){this.progress_(e);const m=this.getClusterHalfEdge(h);if(m!==Nm){if(n.length=0,!this.tryOptimizedInsertion_(i,r,n,h,m)){this.queryXY(h,a),s.setY(a.y);let t=m;do{const e=this.getHalfEdgeUserIndex(t,r);-1!==e&&(i.deleteNode(e),this.setHalfEdgeUserIndex(t,r,is.impossibleIndex2())),t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(m!==t);t=m;do{if(-1===this.getHalfEdgeUserIndex(t,r)){const e=i.addElement(t);n.push(e)}t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(m!==t)}for(let e=n.length-1;e>=0;e--){const s=n[e],o=i.getElement(s),a=this.getHalfEdgeTwin(o);this.setHalfEdgeUserIndex(a,r,s),this.planeSweepParentagePropagateParentage_(i,s,t)}}else if(this.getClusterChain(h)===Nm){null===o&&(o=new Ol(this)),this.queryXY(h,a),o.setPointXY(a);const t=i.searchLowerBound(o);let e=this.m_universeChain;if(-1!==t){let s=i.getElement(t);this.getHalfEdgeChain(s)===this.getHalfEdgeChain(this.getHalfEdgeTwin(s))&&(s=this.getLeftSkipPolylines_(i,t)),s!==Nm&&(e=this.getHalfEdgeChain(s))}this.addClusterToExteriorChain_(e,h)}}this.deleteUserIndexForHalfEdges(r)}planeSweepParentagePropagateParentage_(e,s,i){const n=e.getElement(s),r=this.getHalfEdgeChain(n);if(this.getChainParent(r)!==Nm)return;const o=this.getLeftSkipPolylines_(e,s),a=this.getHalfEdgeTwin(n),h=this.getHalfEdgeChain(a);let m=this.getChainParent(r),l=this.getChainParent(h);if(o===Nm)m===Nm&&(h===r?(this.setChainParent_(h,this.m_universeChain),l=this.m_universeChain,m=l):(l===Nm&&(this.setChainParent_(h,this.m_universeChain),l=this.m_universeChain),this.setChainParent_(r,h),m=h));else{const t=this.getHalfEdgeChain(o);if(l===Nm){if(this.getChainArea(t)<=0){const e=this.getChainParent(t);this.setChainParent_(h,e),l=e}else this.setChainParent_(h,t),l=t;h===r&&(m=l)}}m===Nm&&(this.trySetChainParentFromTwin_(r,h),m=this.getChainParent(r)),t(m!==Nm),i===Gl.enumInputModeBuildGraph?this.propagateParentageBuildGraph_(e,s,n,o):i===Gl.enumInputModeSimplifyWinding?this.propagateParentageWinding_(e,s,n,o,a,r,h):i===Gl.enumInputModeSimplifyAlternate&&this.propagateParentageAlternate_(e,s,n,o,a,r,h)}propagateParentageBuildGraph_(t,e,s,i){let n,r=e;i===Nm?(r=t.getNext(r),n=this.getHalfEdgeChain(s)):n=this.getHalfEdgeChain(i);let o=null,a=this.getChainParentage(n);for(this.m_bBuildGeometryParentageSets&&(o=this.getChainBitSet(n));-1!==r;r=t.getNext(r)){const e=t.getElement(r),s=this.getHalfEdgeTwin(e);n=this.getHalfEdgeChain(e);const i=this.getHalfEdgeChain(s);if(this.m_bBuildGeometryParentageSets){let t=this.getChainBitSet(i);t=new Hl({copy:t}),t.assignOr(o),this.setChainBitSet_(i,t);let s=this.getChainBitSet(n);const r=this.getLeftEdgeBitSet_(e),a=new Hl({copy:o});if(a.assignSubtract(r),a.isZero())break;s=new Hl({copy:s}),s.assignOr(a),this.setChainBitSet_(n,s),o=s}const h=this.getChainParentage(i),m=h|a;m!==h&&this.setChainParentage_(i,m);let l=this.getChainParentage(n);const u=a&~this.getHalfEdgeUserIndex(e,this.m_tmpHalfEdgeParentageIndexLeft);if(u&&(l|=u,this.setChainParentage_(n,l)),0===u)break;a=l}}propagateParentageWinding_(e,s,i,n,r,o,a){if(o===a)return;let h=this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeWindingNumberIndex);h+=this.getHalfEdgeUserIndex(r,this.m_tmpHalfEdgeWindingNumberIndex);let m=0;const l=[],u=[];u.push(0);for(let c=e.getFirst();c!==s;c=e.getNext(c)){const s=e.getElement(c),i=this.getHalfEdgeTwin(s),n=this.getHalfEdgeChain(s),r=this.getHalfEdgeChain(i);if(n!==r){let e=this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeWindingNumberIndex);e+=this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeWindingNumberIndex),m+=e;let o=!1;0!==l.length&&l.at(-1)===r&&(u.pop(),l.pop(),o=!0),t(this.getChainParent(r)!==Nm),o&&this.getChainParent(r)===n||(u.push(m),l.push(n))}}if(m+=h,0!==l.length&&l.at(-1)===a&&(u.pop(),l.pop()),0!==m){if(0===u.at(-1)){const t=this.m_simplifiedGeometry,e=this.getGeometryID(t);this.setChainParentage_(o,e)}}else if(0!==u.at(-1)){const t=this.m_simplifiedGeometry,e=this.getGeometryID(t);this.setChainParentage_(o,e)}}propagateParentageAlternate_(t,e,s,i,n,r,o){const a=this.m_simplifiedGeometry,h=this.getGeometryID(a);if(i===Nm){this.setChainParentage_(o,this.m_universeGeomID);1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,h):this.setChainParentage_(r,this.m_universeGeomID)}else{const t=this.getChainParentage(o);if(0===t){const t=this.getHalfEdgeChain(i),e=this.getChainParentage(t);this.setChainParentage_(o,e);1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,e===h?this.m_universeGeomID:h):this.setChainParentage_(r,e)}else{1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,t===h?this.m_universeGeomID:h):this.setChainParentage_(r,t)}}}tryOptimizedInsertion_(t,e,s,i,n){let r=n,o=-1,a=Nm,h=0;do{if(2===h)return!1;const t=this.getHalfEdgeUserIndex(r,e);if(-1!==t){if(-1!==o)return!1;o=t}else{if(a!==Nm)return!1;a=r}h++,r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(n!==r);return a!==Nm&&-1!==o&&(this.setHalfEdgeUserIndex(t.getElement(o),e,is.impossibleIndex2()),t.setElement(o,a),s.push(o),!0)}trySetChainParentFromTwin_(t,e){const s=this.getChainArea(t);if(0===s)return!1;const i=this.getChainArea(e);if(s>0&&i<0||s<0&&i>0)return this.setChainParent_(t,e),!0;{const s=this.getChainParent(e);if(s!==Nm)return this.setChainParent_(t,s),!0}return!1}createHalfEdges_(t,e){this.m_halfEdgeIndex=this.m_shape.createUserIndex();for(let i=0,n=e.size();i<n;i++){const n=e.read(i),r=this.m_shape.getUserIndex(n,this.m_clusterIndex),o=this.m_shape.getPathFromVertex(n),a=this.m_shape.getGeometryFromPath(o),h=this.m_shape.getGeometryType(a);if(p(h)){const e=this.m_shape.getNextVertex(n);if(e===Nm)continue;const i=this.m_shape.getUserIndex(e,this.m_clusterIndex);if(r===i)continue;const o=this.newHalfEdgePair_(),m=this.getHalfEdgeTwin(o),l=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(l,0,n),this.m_clusterVertices.setField(l,1,-1),this.setHalfEdgeVertexIterator_(o,l),this.m_shape.setUserIndex(n,this.m_halfEdgeIndex,o),this.setHalfEdgeOrigin_(o,r);const u=this.getClusterHalfEdge(r);if(u===Nm)this.setClusterHalfEdge_(r,o),this.setHalfEdgePrev_(o,m),this.setHalfEdgeNext_(m,o);else{const t=this.getHalfEdgePrev(u);this.setHalfEdgePrev_(u,m),this.setHalfEdgeNext_(m,u),this.setHalfEdgeNext_(t,o),this.setHalfEdgePrev_(o,t)}this.setHalfEdgeOrigin_(m,i);const c=this.getClusterHalfEdge(i);if(c===Nm)this.setClusterHalfEdge_(i,m),this.setHalfEdgeNext_(o,m),this.setHalfEdgePrev_(m,o);else{const t=this.getHalfEdgePrev(c);this.setHalfEdgePrev_(c,o),this.setHalfEdgeNext_(o,c),this.setHalfEdgeNext_(t,m),this.setHalfEdgePrev_(m,t)}const g=this.getGeometryID(a);if(t===Gl.enumInputModeBuildGraph){const t=h===s.enumPolygon?g:0;if(this.setHalfEdgeUserIndex(m,this.m_tmpHalfEdgeParentageIndex,0),this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndex,t),this.setHalfEdgeUserIndex(m,this.m_tmpHalfEdgeParentageIndexLeft,t),this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndexLeft,0),this.m_bBuildGeometryParentageSets){const t=new Hl,e=this.m_shape.getGeometryUserIndex(a,this.m_geometryIDIndex);t.setBit(e),this.setEdgeBitSet_(o,t),this.setEdgeBitSet_(m,null),this.setLeftEdgeBitSet_(m,t),this.setLeftEdgeBitSet_(o,null)}}else if(t===Gl.enumInputModeSimplifyWinding){const t=this.m_shape.getXY(n),s=this.m_shape.getXY(e);let i=0,r=0;t.compare(s)<0?i=1:r=-1,this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeWindingNumberIndex,i),this.setHalfEdgeUserIndex(m,this.m_tmpHalfEdgeWindingNumberIndex,r)}else t===Gl.enumInputModeSimplifyAlternate&&(this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeOddEvenNumberIndex,1),this.setHalfEdgeUserIndex(m,this.m_tmpHalfEdgeOddEvenNumberIndex,1));const _=h===s.enumPolygon?Kl.c_EdgeBitMask:0;this.setHalfEdgeParentage_(o,g|_),this.setHalfEdgeParentage_(m,g|_)}}if(this.m_shape.hasCurves()){this.m_segmentIndexHe=this.createUserIndexForHalfEdges();for(let t=0,s=e.size();t<s;t++){const s=e.read(t);if(this.m_shape.getSegment(s)){const t=this.m_shape.getUserIndex(s,this.m_halfEdgeIndex);t!==Nm&&(this.setHalfEdgeUserIndex(t,this.m_segmentIndexHe,this.m_shape.getVertexIndex(s)),this.setHalfEdgeUserIndex(this.getHalfEdgeTwin(t),this.m_segmentIndexHe,-2))}}}}mergeVertexListsOfEdges_(t,e){{const s=this.getHalfEdgeVertexIterator(e);if(s!==Nm){const i=this.getHalfEdgeVertexIterator(t);this.m_clusterVertices.setField(s,1,i),this.setHalfEdgeVertexIterator_(t,s),this.setHalfEdgeVertexIterator_(e,Nm)}}const s=this.getHalfEdgeTwin(t),i=this.getHalfEdgeTwin(e);{const t=this.getHalfEdgeVertexIterator(i);if(t!==Nm){const e=this.getHalfEdgeVertexIterator(s);this.m_clusterVertices.setField(t,1,e),this.setHalfEdgeVertexIterator_(s,t),this.setHalfEdgeVertexIterator_(i,Nm)}}if(-1!==this.m_segmentIndexHe){let n=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(-1!==n){if(-2===n){const s=this.getHalfEdgeUserIndex(e,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(t,this.m_segmentIndexHe,s)}if(n=this.getHalfEdgeUserIndex(s,this.m_segmentIndexHe),-2===n){const t=this.getHalfEdgeUserIndex(i,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(s,this.m_segmentIndexHe,t)}}}}sortHalfEdgesByAngle_(t){const e=[];for(let s=this.getFirstCluster();s!==Nm;s=this.getNextCluster(s)){e.length=0;const i=this.getClusterHalfEdge(s);if(i!==Nm){let n=i;do{e.push(n),n=this.getHalfEdgeNext(this.getHalfEdgeTwin(n))}while(n!==i);if(e.length>1){let n=!0;e.length>2?(e.sort(((t,e)=>this.compareEdgeAngles_(t,e))),e.push(e[0])):this.compareEdgeAnglesForPair_(e[0],e[1])>0?e[1]=q(e[0],e[0]=e[1]):n=!1;let r=e[0],o=r,a=this.getHalfEdgeTo(o),h=this.getHalfEdgeTwin(o),m=Nm;for(let s=1,i=e.length;s<i;s++){const i=e[s],n=this.getHalfEdgeTwin(i),l=this.getHalfEdgeOrigin(n);if(l!==a||i===o)this.updateVertexToHalfEdgeConnection_(m,!1),m=Nm,o=i,a=l,h=n;else{if(t===Gl.enumInputModeBuildGraph){const t=this.getHalfEdgeParentageMask_(o)|this.getHalfEdgeParentageMask_(i);if(this.setHalfEdgeParentage_(o,t),this.setHalfEdgeParentage_(h,t),this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeParentageIndexLeft)),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeParentageIndexLeft)),this.m_bBuildGeometryParentageSets){let t,e,s;t=this.getEdgeBitSet_(o),e=this.getEdgeBitSet_(i),s=new Hl({copy:t}),s.assignOr(e),this.setEdgeBitSet_(o,s),t=this.getEdgeBitSet_(h),e=this.getEdgeBitSet_(n),s=new Hl({copy:t}),s.assignOr(e),this.setEdgeBitSet_(h,s),t=this.getLeftEdgeBitSet_(o),e=this.getLeftEdgeBitSet_(i),s=new Hl({copy:t}),s.assignOr(e),this.setLeftEdgeBitSet_(o,s),t=this.getLeftEdgeBitSet_(h),e=this.getLeftEdgeBitSet_(n),s=new Hl({copy:t}),s.assignOr(e),this.setLeftEdgeBitSet_(h,s)}}else if(-1!==this.m_tmpHalfEdgeWindingNumberIndex){const t=this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeWindingNumberIndex),e=this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeWindingNumberIndex);this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeWindingNumberIndex,t),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeWindingNumberIndex,e)}else if(-1!==this.m_tmpHalfEdgeOddEvenNumberIndex){const t=this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeOddEvenNumberIndex),e=this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeOddEvenNumberIndex);this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeOddEvenNumberIndex,t),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeOddEvenNumberIndex,e)}this.mergeVertexListsOfEdges_(o,i),this.deleteEdgeImpl_(i),m=o,e[s]=Nm,i===r&&(e[0]=Nm,r=Nm)}}if(this.updateVertexToHalfEdgeConnection_(m,!1),m=Nm,!n){r=Nm;for(let t=0,s=e.length;t<s;t++){const s=e[t];if(s!==Nm){r=s;break}}i!==r&&this.setClusterHalfEdge_(s,r);continue}r=Nm;for(let t=0,s=e.length;t<s;t++){const s=e[t];if(s===Nm)continue;if(r===Nm){r=s,o=r,a=this.getHalfEdgeTo(o),h=this.getHalfEdgeTwin(o);continue}if(s===o)continue;const i=this.getHalfEdgeTwin(s),n=this.getHalfEdgeOrigin(i);this.setHalfEdgeNext_(h,s),this.setHalfEdgePrev_(s,h),o=s,a=n,h=i}this.setClusterHalfEdge_(s,r)}}}}sortHalfEdgesByAngleHelper_(e){t(0)}sortHalfEdgesByAngle3D_(e){t(0)}buildChains_(t){this.m_universeChain=this.newChain_(),this.setChainHalfEdge_(this.m_universeChain,Nm);let e=this.m_universeChain;const s=this.createUserIndexForHalfEdges();for(let i=this.getFirstCluster();i!==Nm;i=this.getNextCluster(i)){const t=this.getClusterHalfEdge(i);if(t!==Nm){let i=t;do{if(1!==this.getHalfEdgeUserIndex(i,s)){const t=this.newChain_();this.setChainHalfEdge_(t,i),this.setChainPrev_(t,e),this.setChainNext_(e,t);let n=null;this.m_bBuildGeometryParentageSets&&(n=new Hl),e=t;let r=0,o=i;do{-1!==this.m_tmpHalfEdgeParentageIndex&&(r|=this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndex)),this.m_bBuildGeometryParentageSets&&n.assignOr(this.getEdgeBitSet_(o)),this.setHalfEdgeChain_(o,t),this.setHalfEdgeUserIndex(o,s,1),o=this.getHalfEdgeNext(o)}while(o!==i);this.m_bBuildGeometryParentageSets&&this.setChainBitSet_(t,n),this.setChainParentage_(t,r)}i=this.getHalfEdgeNext(this.getHalfEdgeTwin(i))}while(i!==t)}}this.m_chainAreas=new Je(this.m_chainData.size(),Number.NaN),this.m_chainPerimeters=new Je(this.m_chainData.size(),Number.NaN),this.setChainArea_(this.m_universeChain,Number.POSITIVE_INFINITY),this.setChainPerimeter_(this.m_universeChain,Number.POSITIVE_INFINITY),this.deleteUserIndexForHalfEdges(s)}simplify_(e){t(0)}simplifyAlternate_(){t(0)}simplifyWinding_(){t(0)}setEditShapeImpl_(t,e,s,i,n){this.removeShape(),this.m_bBuildChains=n,this.m_shape=t,this.m_geometryIDIndex=this.m_shape.createGeometryUserIndex();let r=this.m_shape.getTotalPointCount();if(s){r=0;for(let t=0,e=s.length;t<e;t++)r+=this.m_shape.getPointCount(s[t])}const o=new Qe(0);let a=0,h=0;{let t=null!=s?s[0]:this.m_shape.getFirstGeometry(),e=1;for(;t!==Nm;){this.m_shape.setGeometryUserIndex(t,this.m_geometryIDIndex,h++);for(let e=this.m_shape.getFirstPath(t);e!==Nm;e=this.m_shape.getNextPath(e)){let t=this.m_shape.getFirstVertex(e);for(let s=0,i=this.m_shape.getPathSize(e);s<i;s++)o.add(t),t=this.m_shape.getNextVertex(t)}u(this.m_shape.getGeometryType(t))||(a+=this.m_shape.getPathCount(t)),null!=s?(t=e<s.length?s[e]:Nm,e++):t=this.m_shape.getNextGeometry(t)}}this.m_universeGeomID=1<<Math.min(h,31),this.m_pointCount=o.size(),this.m_shape.sortVerticesSimpleByY(o,0,this.m_pointCount),this.m_clusterVertices.setCapacity(this.m_pointCount),this.progress_(i,!0),this.m_clusterData.setCapacity(this.m_pointCount+10),this.m_halfEdgeData.setCapacity(2*this.m_pointCount+32),this.m_chainData.setCapacity(Math.max(32,a)),this.m_clusterIndex=this.m_shape.createUserIndex();const m=w.getNAN();let l=0;const c=w.getNAN();for(let u=0;u<=this.m_pointCount;u++){if(u<this.m_pointCount){const t=o.read(u);this.m_shape.queryXY(t,c)}else c.setNAN();if(!m.isEqualPoint2D(c)){if(l<u){const t=this.newCluster_();let e=Nm,s=-1;for(let i=l;i<u;i++){s=o.read(i),this.m_shape.setUserIndex(s,this.m_clusterIndex,t);const n=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(n,0,s),this.m_clusterVertices.setField(n,1,e),e=n;const r=this.m_shape.getPathFromVertex(s),a=this.m_shape.getGeometryFromPath(r),h=this.getGeometryID(a);this.setClusterParentage_(t,this.getClusterParentage(t)|h)}this.setClusterVertexIterator_(t,e),this.setClusterVertexIndex_(t,this.m_shape.getVertexIndex(s)),this.m_lastCluster!==Nm&&this.setNextCluster_(this.m_lastCluster,t),this.setPrevCluster_(t,this.m_lastCluster),this.m_lastCluster=t,this.m_firstCluster===Nm&&(this.m_firstCluster=t)}l=u,m.setCoordsPoint2D(c)}}if(this.m_shape.hasSegmentParentage()){-1===this.m_clusterBreakNodeIndex&&(this.m_clusterBreakNodeIndex=this.createUserIndexForClusters());for(let t=0;t<this.m_pointCount;t++){const e=o.read(t);if(this.m_shape.getSegmentParentageBreakVertex(e)){const t=this.getClusterFromVertex(e);this.setBreakNode(t,!0)}}}this.progress_(i,!0);{let t=null!=s?s[0]:this.m_shape.getFirstGeometry(),e=1;for(;t!==Nm;){for(let e=this.m_shape.getFirstPath(t);e!==Nm;e=this.m_shape.getNextPath(e)){if(this.m_shape.isStrongPathStart(e)){const t=this.m_shape.getFirstVertex(e),s=this.getClusterFromVertex(t);this.setStrongPathNode(s,!0)}if(this.m_shape.isStrongPathEnd(e)){const t=this.m_shape.isClosedPath(e)?this.m_shape.getFirstVertex(e):this.m_shape.getLastVertex(e),s=this.getClusterFromVertex(t);this.setStrongPathNode(s,!0)}}null!=s?(t=e<s.length?s[e]:Nm,e++):t=this.m_shape.getNextGeometry(t)}}if(e===Gl.enumInputModeBuildGraph&&(this.m_tmpHalfEdgeParentageIndex=this.createUserIndexForHalfEdges(),this.m_tmpHalfEdgeParentageIndexLeft=this.createUserIndexForHalfEdges()),e===Gl.enumInputModeSimplifyWinding&&(this.m_tmpHalfEdgeWindingNumberIndex=this.createUserIndexForHalfEdges()),e===Gl.enumInputModeSimplifyAlternate&&(this.m_tmpHalfEdgeOddEvenNumberIndex=this.createUserIndexForHalfEdges()),this.createHalfEdges_(e,o),this.dbgNavigate_(),this.sortHalfEdgesByAngle_(e),!Number.isNaN(this.m_checkDirtyPlanesweepTolerance)&&!this.checkStructureAfterDirtySweep_())return this.m_bDirtyCheckFailed=!0,void this.cleanSetEditShapeImpl_();this.buildChains_(e),-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),this.m_bBuildChains&&this.planeSweepParentage_(e,i),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),this.dbgChkChainParents_(),this.dbgDumpChains_(),this.mergeSegmentParentage_(),this.dbgNavigate_(),this.dbgDumpChains_(),this.cleanSetEditShapeImpl_()}setEditShapeImpl3D_(e,s,i,n,r){t(0)}cleanSetEditShapeImpl_(){-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),-1!==this.m_tmpHalfEdgeWindingNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),-1!==this.m_tmpHalfEdgeOddEvenNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1)}cleanSetEditShapeImpl3D_(){t(0)}dbgNavigate_(){}dbgChkChainParents_(){}deleteEdgeImpl_(t){const e=this.getHalfEdgeNext(t),s=this.getHalfEdgePrev(t),i=this.getHalfEdgeTwin(t),n=this.getHalfEdgeNext(i),r=this.getHalfEdgePrev(i);e!==i&&(this.setHalfEdgeNext_(r,e),this.setHalfEdgePrev_(e,r)),s!==i&&(this.setHalfEdgeNext_(s,n),this.setHalfEdgePrev_(n,s));const o=this.getHalfEdgeOrigin(t);this.getClusterHalfEdge(o)===t&&(n!==t?this.setClusterHalfEdge_(o,n):this.setClusterHalfEdge_(o,Nm));const a=this.getHalfEdgeOrigin(i);this.getClusterHalfEdge(a)===i&&(e!==i?this.setClusterHalfEdge_(a,e):this.setClusterHalfEdge_(a,Nm)),this.m_halfEdgeData.deleteElement(t),this.m_halfEdgeData.deleteElement(i)}getLeftSkipPolylines_(t,e){let s=e;for(;;){if(s=t.getPrev(s),-1===s)return Nm;{const e=t.getElement(s);if(this.getHalfEdgeChain(e)!==this.getHalfEdgeChain(this.getHalfEdgeTwin(e)))return e}}}checkStructureAfterDirtySweep_(){const t=M(this.m_checkDirtyPlanesweepTolerance),e=new w,s=new w,i=new w,n=new w,r=new w;for(let o=this.getFirstCluster();o!==Nm;o=this.getNextCluster(o)){const a=this.getClusterHalfEdge(o);if(a!==Nm){let o=a;this.getHalfEdgeFromXY(o,e),this.getHalfEdgeToXY(o,s),i.setSub(s,e);let h=i.sqrLength();do{const a=o;if(o=this.getHalfEdgeNext(this.getHalfEdgeTwin(o)),o!==a){this.getHalfEdgeToXY(o,n),r.setSub(n,e);const a=r.sqrLength(),m=r.crossProduct(i),l=m*m/(a*h);if(Math.min(a,h)*l<=t){if(r.dotProduct(i)>=0)return!1}i.assign(r),h=a,s.assign(n)}}while(o!==a)}}return!0}extractPolygonPathFromChain_(t,e,s,i,n){const r=this.m_shape.hasSegmentParentage(),o=this.getChainHalfEdge(s);let a=o,h=Nm;const m=new Ge;do{const o=this.getHalfEdgeTwin(a);if(this.getHalfEdgeChain(o)!==s){let s=Nm;const o=this.getHalfEdgeOrigin(a);if(i===Nm){const t=this.getClusterVertexIterator(o);s=this.getVertexFromVertexIterator(t)}else for(let t=this.getClusterVertexIterator(o);t!==Nm;t=this.incrementVertexIterator(t)){const e=this.getVertexFromVertexIterator(t);s===Nm&&(s=e);const n=this.m_shape.getPathFromVertex(e);if(this.m_shape.getGeometryFromPath(n)===i){s=e;break}}let l;if(h===Nm&&(h=t.insertPath(e,Nm),t.setClosedPath(h,!0)),this.m_shape===t?l=t.addVertex(h,s):(this.m_shape.queryPoint(s,m),l=t.addPoint(h,m)),this.isHalfEdgeCurve(a)&&(this.querySegmentXY(a,n),t.setSegmentToIndex(t.getVertexIndex(l),n.get().clone())),r){const e=this.getSegmentParentage(a);t.setSegmentParentageAndBreak(l,e,this.isBreakNode(o))}}a=this.getHalfEdgeNext(a)}while(a!==o)}mergeSegmentParentage_(){if(!this.m_shape.hasSegmentParentage())return;t(-1!==this.m_clusterBreakNodeIndex),t(-1===this.m_segmentParentageIndex);for(let t=this.getFirstCluster();t!==Nm;t=this.getNextCluster(t)){let e=0;const s=this.getClusterHalfEdge(t);if(s!==Nm){let t=s;do{e++,t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(t!==s&&e<3)}2!==e&&this.setBreakNode(t,!0)}let e=[],s=[];this.m_segmentParentageIndex=this.createUserIndexForHalfEdges();const i=this.createUserIndexForHalfEdges();for(let t=this.getFirstCluster();t!==Nm;t=this.getNextCluster(t)){const n=this.getClusterHalfEdge(t);if(n!==Nm){let t=!1,r=n;do{let n=r;for(;-1===this.getHalfEdgeUserIndex(n,i);){const r=this.getHalfEdgeNext(n),o=this.getHalfEdgeTwin(n);Zl(this,n,s);const a=s.at(-1).parentage;if(!t){const s=this.getHalfEdgeOrigin(n);if(!this.isBreakNode(s)){const s=this.getHalfEdgePrev(n);n!==s&&(Zl(this,s,e),t=!0)}}if(t&&!jl(s,e)){const t=this.getHalfEdgeOrigin(n);this.setBreakNode(t,!0)}e=q(s,s=e),t=!0;const h=this.getHalfEdgeOrigin(r);this.isBreakNode(h)&&(t=!1),this.setHalfEdgeUserIndex(n,this.m_segmentParentageIndex,a),this.setHalfEdgeUserIndex(o,this.m_segmentParentageIndex,a),this.setHalfEdgeUserIndex(n,i,1),this.setHalfEdgeUserIndex(o,i,1),n=r}r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(r!==n)}}this.deleteUserIndexForHalfEdges(i)}registerNewBitSet(t){if(null===this.m_uniqueBitSets&&(this.m_uniqueBitSets=Ql(),this.m_uniqueBitSets.add(this.getEmptySet())),null===t)return this.getEmptySet();return this.m_uniqueBitSets.has(t)?this.m_uniqueBitSets.get(t):(this.m_uniqueBitSets.add(t),t)}getLeftEdgeBitSet_(e){const s=this.getHalfEdgeUserIndex(e,this.m_edgeBitSetIndexLeft);return t(s>=0),t(this.m_edgeBitSets.at(s)),this.m_edgeBitSets.at(s)}getEdgeBitSet_(e){const s=this.getHalfEdgeUserIndex(e,this.m_edgeBitSetIndex);return t(s>=0),this.m_edgeBitSets.at(s)}setEdgeBitSet_(e,s){t(this.m_bBuildGeometryParentageSets),s=this.registerNewBitSet(s),-1===this.m_edgeBitSetIndex&&(this.m_edgeBitSetIndex=this.createUserIndexForHalfEdges());const i=this.getHalfEdgeUserIndex(e,this.m_edgeBitSetIndex);-1!==i?this.m_edgeBitSets[i]=s:(this.setHalfEdgeUserIndex(e,this.m_edgeBitSetIndex,this.m_edgeBitSets.length),this.m_edgeBitSets.push(s))}setLeftEdgeBitSet_(e,s){t(this.m_bBuildGeometryParentageSets),s=this.registerNewBitSet(s),-1===this.m_edgeBitSetIndexLeft&&(this.m_edgeBitSetIndexLeft=this.createUserIndexForHalfEdges());const i=this.getHalfEdgeUserIndex(e,this.m_edgeBitSetIndexLeft);-1!==i?this.m_edgeBitSets[i]=s:(this.setHalfEdgeUserIndex(e,this.m_edgeBitSetIndexLeft,this.m_edgeBitSets.length),this.m_edgeBitSets.push(s))}setChainBitSet_(e,s){t(this.m_bBuildGeometryParentageSets),s=this.registerNewBitSet(s),-1===this.m_chainBitSetIndex&&(this.m_chainBitSetIndex=this.createUserIndexForChains());const i=this.getChainUserIndex(e,this.m_chainBitSetIndex);-1!==i?this.m_chainBitSets[i]=s:(this.setChainUserIndex(e,this.m_chainBitSetIndex,this.m_chainBitSets.length),this.m_chainBitSets.push(s))}getEmptySet(){return this.m_emptyBitSet||(this.m_emptyBitSet=new Hl),this.m_emptyBitSet}deleteEdgeBitSets_(){-1!==this.m_edgeBitSetIndex&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndex),this.m_edgeBitSetIndex=-1),-1!==this.m_edgeBitSetIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndexLeft),this.m_edgeBitSetIndexLeft=-1),this.m_edgeBitSets.length=0,this.m_uniqueBitSets=null}deleteChainBitSets_(){-1!==this.m_chainBitSetIndex&&(this.deleteUserIndexForChains(this.m_chainBitSetIndex),this.m_chainBitSetIndex=-1,this.m_chainBitSets.length=0)}dbgPrintEdge_(e){t(0)}dbgVerifyEdgeSegment(e){t(0)}}Kl.c_EdgeParentageMask=~(1<<31),Kl.c_EdgeBitMask=1<<31;class Jl{freeNode_(t){this.m_listNodes.deleteElement(t)}newNode_(){return this.m_listNodes.newElement()}freeList_(t){this.m_lists.deleteElement(t)}newList_(){return this.m_lists.newElement()}Init_(e){t(0)}constructor(t){this.m_listNodes=new is(2),this.m_listOfLists=Jl.st_nullNode(),this.m_bAllowNavigationBetweenLists=!0,void 0===t&&(t=!0),this.m_bAllowNavigationBetweenLists=t,this.m_lists=new is(this.m_bAllowNavigationBetweenLists?4:2)}createList(){const t=this.newList_();return this.m_bAllowNavigationBetweenLists&&(this.m_lists.setField(t,3,this.m_listOfLists),this.m_listOfLists!==Jl.st_nullNode()&&this.m_lists.setField(this.m_listOfLists,2,t),this.m_listOfLists=t),t}deleteList(t){let e=this.getFirst(t);for(;e!==Jl.st_nullNode();){const t=e;e=this.getNext(e),this.freeNode_(t)}if(this.m_bAllowNavigationBetweenLists){const e=this.m_lists.getField(t,2),s=this.m_lists.getField(t,3);e!==Jl.st_nullNode()?this.m_lists.setField(e,3,s):this.m_listOfLists=s,s!==Jl.st_nullNode()&&this.m_lists.setField(s,2,e)}this.freeList_(t)}reserveLists(t){this.m_lists.setCapacity(t)}addElement(t,e){this.m_lists.getField(t,0);const s=this.m_lists.getField(t,1),i=this.newNode_();return s!==Jl.st_nullNode()?(this.m_listNodes.setField(s,1,i),this.m_lists.setField(t,1,i)):(this.m_lists.setField(t,0,i),this.m_lists.setField(t,1,i)),this.m_listNodes.setField(i,0,e),i}reserveNodes(t){this.m_listNodes.setCapacity(t)}deleteElementDirect(t,e,s){e!==Jl.st_nullNode()?(this.m_listNodes.setField(e,1,this.m_listNodes.getField(s,1)),this.m_lists.getField(t,1)===s&&this.m_lists.setField(t,1,e)):(this.m_lists.setField(t,0,this.m_listNodes.getField(s,1)),this.m_lists.getField(t,1)===s&&this.m_lists.setField(t,1,Jl.st_nullNode())),this.freeNode_(s)}deleteElementSearch(t,e){let s=-1,i=this.getFirst(t);for(;i!==e;)s=i,i=this.getNext(i);this.deleteElementDirect(t,s,e)}concatenateLists(t,e){const s=this.m_lists.getField(t,1),i=this.m_lists.getField(e,0);if(i!==Jl.st_nullNode()&&(s!==Jl.st_nullNode()?(this.m_listNodes.setField(s,1,i),this.m_lists.setField(t,1,this.m_lists.getField(e,1))):(this.m_lists.setField(t,0,i),this.m_lists.setField(t,1,this.m_lists.getField(e,1)))),this.m_bAllowNavigationBetweenLists){const t=this.m_lists.getField(e,2),s=this.m_lists.getField(e,3);t!==Jl.st_nullNode()?this.m_lists.setField(t,3,s):this.m_listOfLists=s,s!==Jl.st_nullNode()&&this.m_lists.setField(s,2,t)}return this.freeList_(e),t}getElement(t){return this.m_listNodes.getField(t,0)}getData(t){return this.getElement(t)}setElement(e,s){t(0)}getNext(t){return this.m_listNodes.getField(t,1)}getFirst(t){return this.m_lists.getField(t,0)}getFirstElement(t){const e=this.getFirst(t);return this.getElement(e)}static st_nullNode(){return-1}clear(){this.m_listNodes.deleteAll(!0),this.m_lists.deleteAll(!0),this.m_listOfLists=Jl.st_nullNode()}isEmpty(e){return t(0),!1}getNodeCount(){return this.m_listNodes.size()}getListCount(){return this.m_lists.size()}getFirstList(){return this.m_listOfLists}getNextList(t){return this.m_lists.getField(t,3)}}function $l(t=-1){return{m_value:t,m_line:new CE,m_segment:null,m_segmentInfo:new Gm(-1),m_env:new A(0,0),m_dxdy:55555555,m_bHorizontal:!1,m_bCurve:!1}}const tu=67;class eu extends hs{constructor(t,e,s){super(!0),this.m_bIntersectionDetected=!1,this.m_nonSimpleResult=new ci,this.m_tempSimpleEdge1=$l(),this.m_tempSimpleEdge2=$l(),this.m_prev1=Nm,this.m_prev2=Nm,this.m_vertex1=Nm,this.m_vertex2=Nm,this.m_currentNode=-1,this.m_prevX1=Number.NaN,this.m_prevX2=Number.NaN,this.m_prevY=Number.NaN,this.m_prevX=0,this.m_sweepY=Number.NaN,this.m_sweepX=0,this.m_ptSweep=new w,this.m_simpleEdgesCache=[],this.m_simpleEdgesRecycle=[],this.m_cOutstandingConstructedEdges=0,this.m_shape=t,this.m_bShapeHasSegments=this.m_shape.hasCurves(),this.m_tolerance=e,this.m_tolerance10=10*e,this.m_bIsSimple=s;const i=Math.trunc(Math.min(3*t.getTotalPointCount()/2,tu)),n=Math.min(7,i);this.m_simpleEdgesCache.length=n}tryGetCachedEdge_(t){const e=this.m_simpleEdgesCache[(t&L())%this.m_simpleEdgesCache.length];return e&&e.m_value===t?e:null}tryDeleteCachedEdge_(t){const e=(t&L())%this.m_simpleEdgesCache.length,s=this.m_simpleEdgesCache[e];s&&s.m_value===t&&(this.m_simpleEdgesRecycle.push(s),this.m_simpleEdgesCache[e]=null)}tryCreateCachedEdge_(t){const e=(t&L())%this.m_simpleEdgesCache.length;let s=this.m_simpleEdgesCache[e];return s?null:(0===this.m_simpleEdgesRecycle.length?(s=$l(),this.m_cOutstandingConstructedEdges++):s=this.m_simpleEdgesRecycle.pop(),s.m_value=t,this.m_simpleEdgesCache[e]=s,s)}initSimpleEdge_(t,e){this.m_bShapeHasSegments&&this.initSimpleEdgeHelper_(t,e)||t.m_bCurve||(this.m_shape.queryLineConnector(e,t.m_line,!0),t.m_segment=t.m_line,t.m_env.setCoordsNoNAN(t.m_line.getStartX(),t.m_line.getEndX()),t.m_env.vmax+=this.m_tolerance,t.m_line.orientBottomUp(),t.m_bHorizontal=t.m_line.getEndY()===t.m_line.getStartY(),t.m_bHorizontal||(t.m_dxdy=(t.m_line.getEndX()-t.m_line.getStartX())/(t.m_line.getEndY()-t.m_line.getStartY())))}initSimpleEdgeHelper_(t,e){if(t.m_segment=this.m_shape.getSegment(e),t.m_segmentInfo=this.m_shape.getOriginalSegmentInfo(e),t.m_bCurve=null!==t.m_segment,t.m_bCurve){const e=t.m_segment.clone();return e.orientBottomUp(),t.m_segment=e,t.m_env=t.m_segment.queryInterval(0,0),t.m_env.vmax+=this.m_tolerance,!0}return!1}compareTwoSegments_(t,e){const s=t.getStartXY(),i=t.getEndXY(),n=e.getStartXY(),r=e.getEndXY();if(this.m_ptSweep.setCoords(this.m_sweepX,this.m_sweepY),s.isEqualPoint2D(n)&&this.m_sweepY===s.y){this.m_ptSweep.assign(i.compare(r)<0?i:r);const s=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),n=e.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x);if(Math.abs(s-n)>this.m_tolerance)return s<n?-1:1}const o=s.compare(n)<0?n:s,a=i.compare(r)<0?i:r;let h=0,m=0;for(let l=1;l<5;l++){lt(o,a,l/5,this.m_ptSweep);const s=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),i=e.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),n=Math.abs(s-i);n>h&&(h=n,m=s<i?-1:1)}return 0===m?this.errorCracking():m}compareNonHorizontal_(t,e){if(t.m_line.getStartY()===e.m_line.getStartY()&&t.m_line.getStartX()===e.m_line.getStartX())return t.m_line.getEndY()===e.m_line.getEndY()&&t.m_line.getEndX()===e.m_line.getEndX()?this.m_bIsSimple?this.errorCoincident():0:this.compareNonHorizontalUpperEnd_(t,e);if(t.m_line.getEndY()===e.m_line.getEndY()&&t.m_line.getEndX()===e.m_line.getEndX())return this.compareNonHorizontalLowerEnd_(t,e);const s=this.compareNonHorizontalLowerEnd_(t,e),i=this.compareNonHorizontalUpperEnd_(t,e);return s<0&&i<0?-1:s>0&&i>0?1:this.errorCracking()}compareHorizontal1Case1_(t,e){if(t.getEndX()>e.getEndX()){if(e.getEndX()>e.getStartX()&&e.getEndY()-e.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(e.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else{if((e.getEndY()-e.getStartY())/(e.getEndX()-e.getStartX())*(t.getEndX()-t.getStartX())<this.m_tolerance10&&e.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}return 1}compareHorizontal1Case2_(t,e){if(t.getStartX()<e.getStartX()){if(e.getEndX()>e.getStartX()&&e.getEndY()-e.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(e.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else{if((e.getEndY()-e.getStartY())/(e.getEndX()-e.getStartX())*(t.getStartX()-t.getEndX())<this.m_tolerance10&&e.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking()}return-1}compareHorizontal1Case3_(t,e){const s=w.getNAN();s.setSub(e.getEndXY(),e.getStartXY()),s.rightPerpendicularThis(),s.normalize();const i=w.getNAN();i.setSub(t.getStartXY(),e.getStartXY());const n=w.getNAN();n.setSub(t.getEndXY(),e.getStartXY());const r=i.dotProduct(s),o=n.dotProduct(s),a=Math.abs(r),h=Math.abs(o);if(a<h){if(a<this.m_tolerance10&&e.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking()}else if(h<this.m_tolerance10&&e.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return r<0&&o<0?-1:r>0&&o>0?1:this.errorCracking()}compareHorizontal1_(t,e){return t.getStartY()===e.getStartY()&&t.getStartX()===e.getStartX()?this.compareHorizontal1Case1_(t,e):t.getEndY()===e.getEndY()&&t.getEndX()===e.getEndX()?this.compareHorizontal1Case2_(t,e):this.compareHorizontal1Case3_(t,e)}compareHorizontal2_(t,e){return t.getEndY()===e.getEndY()&&t.getEndX()===e.getEndX()&&t.getStartY()===e.getStartY()&&t.getStartX()===e.getStartX()?this.m_bIsSimple?this.errorCoincident():0:this.errorCracking()}compareNonHorizontalLowerEnd_(t,e){let s=1;if(t.m_line.getStartY()<e.m_line.getStartY()){s=-1;const i=t;t=e,e=i}const i=t.m_line,n=e.m_line,r=i.getStartX()-n.getStartX(),o=e.m_dxdy*(i.getStartY()-n.getStartY()),a=this.m_tolerance10;return r<o-a?-s:r>o+a?s:n.isIntersectingPoint(i.getStartXY(),this.m_tolerance,!0)?this.errorCracking():r<o?-s:s}compareNonHorizontalUpperEnd_(t,e){let s=1;if(e.m_line.getEndY()<t.m_line.getEndY()){s=-1;const i=t;t=e,e=i}const i=t.m_line,n=e.m_line,r=i.getEndX()-n.getStartX(),o=e.m_dxdy*(i.getEndY()-n.getStartY()),a=this.m_tolerance10;return r<o-a?-s:r>o+a?s:n.isIntersectingPoint(i.getEndXY(),this.m_tolerance,!0)?this.errorCracking():r<o?-s:s}errorCoincident(){this.m_bIntersectionDetected=!0;const t=7;return this.m_nonSimpleResult=new ci(t,this.m_vertex1,this.m_vertex2),-1}errorCracking(){if(this.m_bIntersectionDetected=!0,this.m_bIsSimple){const t=6;this.m_nonSimpleResult=new ci(t,this.m_vertex1,this.m_vertex2)}else this.m_prev1=Nm,this.m_prev2=Nm,this.m_vertex1=Nm,this.m_vertex2=Nm;return-1}compareSegments_(t,e,s,i){if(s.m_env.vmax<i.m_env.vmin)return-1;if(i.m_env.vmax<s.m_env.vmin)return 1;if(!s.m_bCurve&&!i.m_bCurve){let t=s.m_bHorizontal?1:0;return t|=i.m_bHorizontal?2:0,0===t?this.compareNonHorizontal_(s,i):1===t?this.compareHorizontal1_(s.m_line,i.m_line):2===t?-1*this.compareHorizontal1_(i.m_line,s.m_line):this.compareHorizontal2_(s.m_line,i.m_line)}if(this.m_bIntersectionDetected)return-1;const n=this.m_prevY===this.m_sweepY&&this.m_prevX===this.m_sweepX;let r,o;if(n&&t===this.m_prev1?r=this.m_prevX1:(r=Number.NaN,this.m_prev1=Nm),n&&e===this.m_prev2?o=this.m_prevX2:(o=Number.NaN,this.m_prev2=Nm),this.m_prevY=this.m_sweepY,this.m_prevX=this.m_sweepX,Number.isNaN(r)){this.m_prev1=t;const e=s.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);r=e,this.m_prevX1=e}if(Number.isNaN(o)){this.m_prev2=e;const t=i.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);o=t,this.m_prevX2=t}const a=cE(!0,!0,s.m_segment,i.m_segment,this.m_tolerance,!0);return 0!==a?2===a?this.m_bIsSimple?this.errorCoincident():s.m_segmentInfo.equals(i.m_segmentInfo)?0:this.errorCracking():this.errorCracking():Math.abs(r-o)<=this.m_tolerance?this.compareTwoSegments_(s.m_segment,i.m_segment):r<o?-1:r>o?1:0}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1}intersectionDetected(){return this.m_bIntersectionDetected}getLastComparedNode(){return this.m_currentNode}getResult(){return this.m_nonSimpleResult}setSweepY(t,e){this.m_sweepY=t,this.m_sweepX=e,this.m_prev1=Nm,this.m_prev2=Nm,this.m_vertex1=Nm,this.m_vertex2=Nm}compare(t,e,s){if(this.m_bIntersectionDetected)return-1;const i=t.getElement(s),n=e;return this.m_currentNode=s,this.compareSegments(n,n,i,i)}compareSegments(t,e,s,i){let n=this.tryGetCachedEdge_(t);null===n?this.m_vertex1===e?n=this.m_tempSimpleEdge1:(this.m_vertex1=e,n=this.tryCreateCachedEdge_(t),null===n&&(n=this.m_tempSimpleEdge1,this.m_tempSimpleEdge1.m_value=t),this.initSimpleEdge_(n,e)):this.m_vertex1=e;let r=this.tryGetCachedEdge_(s);return null===r?this.m_vertex2===i?r=this.m_tempSimpleEdge2:(this.m_vertex2=i,r=this.tryCreateCachedEdge_(s),null===r&&(r=this.m_tempSimpleEdge2,this.m_tempSimpleEdge2.m_value=s),this.initSimpleEdge_(r,i)):this.m_vertex2=i,this.compareSegments_(e,i,n,r)}onDelete(t){this.tryDeleteCachedEdge_(t)}onSet(t){this.tryDeleteCachedEdge_(t)}onEndSearch(t){this.tryDeleteCachedEdge_(t)}onAddUniqueElementFailed(t){this.tryDeleteCachedEdge_(t)}}class su{constructor(t,e){this.m_bIntersectionDetected=!1,this.m_pointOfInterest=w.getNAN(),this.m_line1=new CE,this.m_seg1=null,this.m_env=A.constructEmpty(),this.m_vertex1=-1,this.m_currentNode=-1,this.m_minDist=Number.MAX_VALUE,this.m_shape=t,this.m_tolerance=e}getCurrentNode(){return this.m_currentNode}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1,this.m_minDist=Number.MAX_VALUE}intersectionDetected(){return this.m_bIntersectionDetected}setPoint(t){this.m_pointOfInterest.assign(t)}compare(t,e){const s=t.getElement(e);return this.compareVertex(t,e,s)}compareVertex(t,e,s){let i,n=this.m_shape.getSegment(s),r=!0;if(null==n)this.m_shape.queryLineConnector(s,this.m_line1,!0),this.m_env.setCoordsNoNAN(this.m_line1.getStartX(),this.m_line1.getEndX()),n=this.m_line1,i=this.m_line1.getStartY()===this.m_line1.getEndY();else{const t=ge.constructEmpty();n.queryLooseEnvelope(t),t.queryIntervalX(this.m_env),i=0===t.height(),r=!1}if(this.m_pointOfInterest.x+this.m_tolerance<this.m_env.vmin)return-1;if(this.m_pointOfInterest.x-this.m_tolerance>this.m_env.vmax)return 1;if(i)return this.m_currentNode=e,this.m_bIntersectionDetected=!0,0;let o=0;if(r){Ji(this.m_line1);const t=this.m_line1.getStartXY(),e=new w;e.setSub(this.m_line1.getEndXY(),t),e.rightPerpendicularThis();const s=new w;s.setSub(this.m_pointOfInterest,t),o=e.dotProduct(s),o/=e.length()}else{o=n.intersectionOfYMonotonicWithAxisX(this.m_pointOfInterest.y,this.m_pointOfInterest.x)-this.m_pointOfInterest.x}if(o<10*-this.m_tolerance)return-1;if(o>10*this.m_tolerance)return 1;if(n.isIntersectingPoint(this.m_pointOfInterest,this.m_tolerance)){Math.abs(o)<this.m_minDist&&(this.m_currentNode=e,this.m_minDist=o),this.m_bIntersectionDetected=!0}return o<0?-1:o>0?1:0}}class iu{constructor(t,e){this.m_lists=new Jl(!1),this.m_hash=e,this.m_hashBuckets=new Int32Array(t),this.m_hashBuckets.fill(iu.st_nullNode()),this.m_bitFilter=new Int32Array(10*t+31>>5)}reserveElements(t){this.m_lists.reserveLists(Math.min(this.m_hashBuckets.length,t)),this.m_lists.reserveNodes(t)}addElement(t,e){void 0===e&&(e=this.m_hash.getHash(t));const s=e%(this.m_bitFilter.length<<5);this.m_bitFilter[s>>5]|=1<<(31&s);const i=e%this.m_hashBuckets.length;let n=this.m_hashBuckets[i];n===Jl.st_nullNode()&&(n=this.m_lists.createList(),this.m_hashBuckets[i]=n);return this.m_lists.addElement(n,t)}deleteElement(t,s){void 0===s&&(s=this.m_hash.getHash(t));const i=s%this.m_hashBuckets.length,n=this.m_hashBuckets[i];n===Jl.st_nullNode()&&e("");let r=this.m_lists.getFirst(n),o=Jl.st_nullNode();for(;r!==Jl.st_nullNode();){const e=this.m_lists.getData(r),s=this.m_lists.getNext(r);e===t?(this.m_lists.deleteElementDirect(n,o,r),this.m_lists.getFirst(n)===Jl.st_nullNode()&&(this.m_lists.deleteList(n),this.m_hashBuckets[i]=Jl.st_nullNode())):o=r,r=s}}getFirstInBucket(t){const e=t%(this.m_bitFilter.length<<5);if(!(this.m_bitFilter[e>>5]&1<<(31&e)))return Jl.st_nullNode();const s=t%this.m_hashBuckets.length,i=this.m_hashBuckets[s];return i===Jl.st_nullNode()?Jl.st_nullNode():this.m_lists.getFirst(i)}getNextInBucket(t){return this.m_lists.getNext(t)}findNode(t){const e=this.m_hash.getHash(t);let s=this.getFirstInBucket(e);for(;s!==Jl.st_nullNode();){const e=this.m_lists.getData(s);if(this.m_hash.equal(e,t))return s;s=this.m_lists.getNext(s)}return Jl.st_nullNode()}getNextNode(e){return t(0),0}deleteNode(t){const s=this.getElement(t),i=this.m_hash.getHash(s)%this.m_hashBuckets.length,n=this.m_hashBuckets[i];n===Jl.st_nullNode()&&e(""),this.m_lists.deleteElementSearch(n,t),this.m_lists.getFirst(n)===Jl.st_nullNode()&&(this.m_lists.deleteList(n),this.m_hashBuckets[i]=Jl.st_nullNode())}getElement(t){return this.m_lists.getData(t)}static st_nullNode(){return Jl.st_nullNode()}clear(){t(0)}size(){return this.m_lists.getNodeCount()}dbgPrintBucketHistogram(){t(0)}}function nu(t,e,s,i,n){const r=new cu(n);return r.m_shape=t,r.m_sqrTolerance=e*e,r.m_cellSize=2*e,r.m_invCellSize=1/r.m_cellSize,r.m_geometry=s,r.m_bTrackChanges=i,r.m_bHasSegmentParentage=t.hasSegmentParentage(),r.clusterNonReciprocal()}function ru(t,e,s,i,n){const r=t-s,o=e-i;return r*r+o*o<=n}function ou(){return{pt:new w,weight:0,rank:0,bMerged:!1}}function au(t,e,s,i,n,r){const o=ou(),a=s+n;let h=!1,m=t.x;t.x!==e.x&&(i===r&&(m=(t.x*s+e.x*n)/a),h=!0);let l=t.y;return t.y!==e.y&&(i===r&&(l=(t.y*s+e.y*n)/a),h=!0),i!==r?i>r?(o.rank=i,o.weight=s,o.pt=t):(o.rank=r,o.weight=n,o.pt=e):(o.pt.setCoords(m,l),o.weight=a,o.rank=i),o.bMerged=h,o}function hu(t,e,s,i,n,r,o,a,h){const m=t.equals(e);if(i>r)return o.assignCopy(t),h[0]=i,a[0]=s,m;if(r>i)return o=e,h[0]=r,a[0]=n,m;o.assignCopy(t);const l=au(t.getXY(),e.getXY(),s,i,n,r);return o.setXY(l.pt),a[0]=l.weight,h[0]=l.rank,m}function mu(t,e,s,i,n){const r=new cu(n);return r.m_shape=t,r.m_sqrTolerance=e*e,r.m_cellSize=2*e,r.m_invCellSize=1/r.m_cellSize,r.m_geometry=s,r.m_bTrackChanges=!1,r.needsClustering()}function lu(t,e){const s=he(t);return oe(s,e)}class uu{constructor(t,e,s,i,n){this.m_workPt=new w,this.m_shape=t,this.m_sqrTolerance=s,this.m_invCellSize=i,this.m_origin=e.clone(),this.m_hashValues=n}getHash(t){return this.m_shape.getUserIndex(t,this.m_hashValues)}calculateHash(e){return t(0),0}calculateHashFromVertex(t){this.m_shape.queryXY(t,this.m_workPt);const e=this.m_workPt.x-this.m_origin.x,s=Math.trunc(e*this.m_invCellSize+.5),i=this.m_workPt.y-this.m_origin.y;return lu(s,Math.trunc(i*this.m_invCellSize+.5))}dbgCalculateHashFromXy(e,s){return t(0),0}equal(e,s){return t(0),!1}}class cu{constructor(t){this.m_origin=w.getNAN(),this.m_sqrTolerance=0,this.m_cellSize=0,this.m_invCellSize=0,this.m_geometry=Nm,this.m_bucketArray=new Array(4),this.m_bucketHash=new Array(4),this.m_dbgCandidateCheckCount=0,this.m_nsr=new ci,this.m_hashValues=-1,this.m_newClusters=-1,this.m_bTrackChanges=!1,this.m_bHasSegmentParentage=!1,this.m_shape=null,this.m_clusters=new Jl,this.m_hashFunction=null,this.m_hashTable=null,this.m_progressCounter=0,this.m_progressTracker=t}progress_(){}getNearestNeighbourCandidate(e,s,i,n,r){t(0)}findClusterCandidate(e,s){t(0)}collectClusterCandidates(t,e){const s=w.getNAN();this.m_shape.queryXY(t,s);const i=(s.x-this.m_origin.x)*this.m_invCellSize,n=(s.y-this.m_origin.y)*this.m_invCellSize,r=Math.trunc(i),o=Math.trunc(n);let a=0;for(let h=0;h<=1;h+=1)for(let t=0;t<=1;t+=1){const e=lu(r+h,o+t),s=this.m_hashTable.getFirstInBucket(e);s!==iu.st_nullNode()&&(this.m_bucketArray[a]=s,this.m_bucketHash[a]=e,a++)}for(let h=a-1;h>=1;h--){const t=this.m_bucketArray[h];for(let e=h-1;e>=0;e--)if(t===this.m_bucketArray[e]){this.m_bucketHash[e]=-1,a--,h!==a&&(this.m_bucketHash[h]=this.m_bucketHash[a],this.m_bucketArray[h]=this.m_bucketArray[a]);break}}for(let h=0;h<a;h++)this.collectNearestNeighbourCandidates(t,this.m_bucketHash[h],s,this.m_bucketArray[h],e)}collectNearestNeighbourCandidates(t,e,s,i,n){const r=w.getNAN();for(let o=i;o!==iu.st_nullNode();o=this.m_hashTable.getNextInBucket(o)){const i=this.m_hashTable.getElement(o);t===i||-1!==e&&this.m_shape.getUserIndex(i,this.m_hashValues)!==e||(this.m_shape.queryXY(i,r),ru(s.x,s.y,r.x,r.y,this.m_sqrTolerance)&&n.push(o))}}mergeClusters(t,e,s){let i=this.m_shape.getUserIndex(t,this.m_newClusters);const n=this.m_shape.getUserIndex(e,this.m_newClusters);-1===i&&(i=this.m_clusters.createList(),this.m_clusters.addElement(i,t),this.m_shape.setUserIndex(t,this.m_newClusters,i)),-1===n?this.m_clusters.addElement(i,e):this.m_clusters.concatenateLists(i,n),this.m_shape.setUserIndex(e,this.m_newClusters,is.impossibleIndex2());const r=this.mergeVertices(t,e);if(s){const e=this.m_hashFunction.calculateHashFromVertex(t);this.m_shape.setUserIndex(t,this.m_hashValues,e)}return r}mergeVertices(t,e){const s=w.getNAN();this.m_shape.queryXY(t,s);const i=w.getNAN();this.m_shape.queryXY(e,i);const n=this.m_shape.getRank(t),r=this.m_shape.getRank(e),o=this.m_shape.getWeight(t),a=this.m_shape.getWeight(e);let h,m,l,u,c=!1;if(n===r?(h=n,m=o+a,l=s.x,s.x!==i.x&&(l=(s.x*o+i.x*a)/m,c=!0),u=s.y,s.y!==i.y&&(u=(s.y*o+i.y*a)/m,c=!0)):(n>r?(l=s.x,u=s.y,m=o,h=n):(l=i.x,u=i.y,m=a,h=r),c=!s.equals(i)),c&&(this.m_shape.setXYMonotonic(t,l,u),this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(t,!0),this.m_bHasSegmentParentage)){const s=this.m_shape.getSegmentParentageBreakVertex(t)||this.m_shape.getSegmentParentageBreakVertex(e);this.m_shape.setSegmentParentageBreakVertex(t,s),this.m_shape.setSegmentParentageBreakVertex(e,s)}return this.m_shape.setWeight(t,m),this.m_shape.setRank(t,h),c}clusterReciprocal(){return t(0),!1}needsClustering(){const t={stack:[],error:void 0,hasError:!1};try{me(t,Bt((()=>{this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters)})),!1);const e=this.m_shape.getSelectedCount(),s=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin.assign(s.getLowerLeft());const i=Math.max(s.height(),s.width())/(k()-1);this.m_cellSize<i&&(this.m_cellSize=i,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(this.m_shape.getSelectedCount()/3+1),this.m_clusters.reserveNodes(this.m_shape.getSelectedCount()/3+1),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new uu(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new iu(4*e/3,this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let n=!1;for(let t=0;t<2;t++){const e=[],s=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let i=s.next();i!==Nm;i=s.next()){if(this.progress_(),t>0&&this.m_shape.getUserIndex(i,this.m_newClusters)===is.impossibleIndex2())continue;let s;if(0===t?(s=this.m_hashFunction.calculateHashFromVertex(i),this.m_shape.setUserIndex(i,this.m_hashValues,s)):s=this.m_shape.getUserIndex(i,this.m_hashValues),this.collectClusterCandidates(i,e),0!==e.length){for(let t=0,s=e.length;t<s;t++){this.progress_();const s=e[t],r=this.m_hashTable.getElement(s);if(this.m_hashTable.deleteNode(s),!this.m_shape.isEqualXY(i,r))return this.m_nsr=new ci(5,this.m_shape.getVertexIndex(i),this.m_shape.getVertexIndex(r)),n=!0,n;this.mergeClusters(i,r,!1)}e.length=0}0===t&&this.m_hashTable.addElement(i,s)}}return n}catch(e){t.error=e,t.hasError=!0}finally{le(t)}}clusterNonReciprocal(){const t=this.m_shape.getSelectedCount(),e=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin=e.getLowerLeft();const s=Math.max(e.height(),e.width())/(k()-1);this.m_cellSize<s&&(this.m_cellSize=s,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_clusters.reserveNodes(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new uu(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new iu(Math.trunc(4*t/3),this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let i=!1;{const t=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let e=t.next();e!==Nm;e=t.next()){this.progress_();const t=this.m_hashFunction.calculateHashFromVertex(e);this.m_shape.setUserIndex(e,this.m_hashValues,t),this.m_hashTable.addElement(e,t)}}{const t=[],e=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let s=e.next();s!==Nm;s=e.next()){if(this.m_shape.getUserIndex(s,this.m_newClusters)===is.impossibleIndex2())continue;let e=this.m_shape.getUserIndex(s,this.m_hashValues);this.m_hashTable.deleteElement(s,e);let n=!1;for(;this.collectClusterCandidates(s,t),0!==t.length;){let e=0;for(let i=0,n=t.length;i<n;i++){this.progress_();const r=t[i],o=this.m_hashTable.getElement(r);this.m_hashTable.deleteNode(r);const a=i+1===n;e|=this.mergeClusters(s,o,a)?1:0}if(n||=0!==e,i||=0!==e,t.length=0,!e)break}n&&(e=this.m_shape.getUserIndex(s,this.m_hashValues)),this.m_hashTable.addElement(s,e)}t.length=0}return i&&this.applyClusterPositions_(),this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters),i}applyClusterPositions_(){const t=w.getNAN();for(let e=this.m_clusters.getFirstList();e!==Jl.st_nullNode();e=this.m_clusters.getNextList(e)){let s=this.m_clusters.getFirst(e);const i=this.m_clusters.getElement(s);this.m_shape.queryXY(i,t);const n=this.m_shape.getRank(i),r=this.m_shape.getWeight(i);for(s=this.m_clusters.getNext(s);s!==Jl.st_nullNode();s=this.m_clusters.getNext(s)){const e=this.m_clusters.getElement(s);if(this.m_bTrackChanges?this.m_shape.isEqualXYPoint2D(e,t)||(this.m_shape.setXYMonotonicPoint2D(e,t),this.m_shape.setGeometryModifiedWithVertex(e,!0)):this.m_shape.setXYMonotonicPoint2D(e,t),this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentageBreakVertex(i)||this.m_shape.getSegmentParentageBreakVertex(e);this.m_shape.setSegmentParentageBreakVertex(i,t),this.m_shape.setSegmentParentageBreakVertex(e,t)}this.m_shape.setWeight(e,r),this.m_shape.setRank(e,n)}}}}class gu{constructor(){this.m_inputParts=[],this.m_resultParts1=[],this.m_resultParts2=[],this.m_resultSegments=[],this.m_freeSegments=[],this.m_inputSegments=[],this.m_param1=[],this.m_param2=[],this.m_tolerance=0,this.m_toleranceZ=0,this.m_point=new Ge,this.m_pointWeight=1,this.m_maxDensifyLimit=0,this.m_pointRank=0,this.m_changed1=!1,this.m_changed2=!1,this.m_adaptiveDensify=!1}clear(){this.freeAllResultSegments(),this.m_inputSegments.length=0,this.m_inputParts.length=0,this.m_resultParts1.length=0,this.m_resultParts2.length=0,this.m_param1.length=0,this.m_param2.length=0,this.m_adaptiveDensify=!1,this.m_changed1=!1,this.m_changed2=!1}newIntersectionPart_(t,e,s,i,n,r,o,a,h,m){return du(t,e,s,i,n,r,o,a,h,m)}pushSegment(t,e,s,i,n,r,o,a,h,m){return this.m_inputParts.push(this.newIntersectionPart_(this.m_inputSegments.length,e,s,i,n,r,o,a,h,m)),this.m_inputSegments.push(t),this.m_inputParts.length-1}getResultSegmentCount(t){return this.m_adaptiveDensify?0===t?this.m_param1.length-1:this.m_param2.length-1:0===t?this.m_resultParts1.length:this.m_resultParts2.length}getResultPart_(t,e){return 0===t?this.m_resultParts1[e]:this.m_resultParts2[e]}getResultSegment(t,e){return this.m_resultSegments[this.getResultPart_(t,e).segmentIndex].get()}getSegmentChanged(t){return 0===t?this.m_changed1:this.m_changed2}getResultSegmentStartPointWeight(t,e){return this.getResultPart_(t,e).weightStart}getResultSegmentStartPointRank(t,e){return this.getResultPart_(t,e).rankStart}getResultSegmentSegmentParentage(t,e){return this.getResultPart_(t,e).segmentParentage}getResultSegmentStartPointIsBreak(t,e){return this.getResultPart_(t,e).u.bBreakStart}getResultSegmentEndPointWeight(t,e){return this.getResultPart_(t,e).weightEnd}getResultSegmentEndPointRank(t,e){return this.getResultPart_(t,e).rankEnd}getResultSegmentEndPointIsBreak(t,e){return this.getResultPart_(t,e).u.bBreakEnd}getResultSegmentInteriorRank(t,e){return this.getResultPart_(t,e).rankInterior}getResultSegmentInteriorWeight(t,e){return this.getResultPart_(t,e).weightInterior}getResultPoint(){return this.m_point}getResultPointWeight(){return this.m_pointWeight}getResultPointRank(){return this.m_pointRank}getResultPointChanged(){return this.m_changed2}intersectLines(t,e){2!==this.m_inputSegments.length&&m(""),this.m_changed1=!1,this.m_changed2=!1,this.m_tolerance=t;const s=M(t*gu.c_smallToleranceFactor);let i=!1;const n=this.m_inputParts[0],r=this.m_inputParts[1],o=this.m_inputSegments[n.segmentIndex],a=this.m_inputSegments[r.segmentIndex];if(e||5&uE(!0,o,a,t,!0)){const e=dE(!0,o,a,null,this.m_param1,this.m_param2,t);0===e&&m("");const h=new Array(e);for(let t=0;t<e;++t)h[t]=w.getNAN();const l=new Float64Array(e),u=new Int32Array(e),c=new Array(e),g=new Array(e);for(let t=0;t<e;++t)c[t]=pu(),g[t]=pu();for(let t=0;t<e;t++){const e=this.m_param1[t],m=this.m_param2[t];let _,d=n.rankInterior,p=n.weightInterior;0===e?(d=n.rankStart,p=n.weightStart,_=n.u.bBreakStart):1===e?(d=n.rankEnd,p=n.weightEnd,_=n.u.bBreakEnd):(this.m_changed1=!0,_=!1);let f,x=r.rankInterior,y=r.weightInterior;0===m?(x=r.rankStart,y=r.weightStart,f=r.u.bBreakStart):1===m?(x=r.rankEnd,y=r.weightEnd,f=r.u.bBreakEnd):(this.m_changed2=!0,f=!1);const P=d,E=x;let C=1,S=0,v=w.getNAN();if(P===E){const i=o.getCoord2D(e),n=a.getCoord2D(m);C=p+y;S=d,lt(i,n,y/C,v);const r=w.sqrDistance(v,i),h=w.sqrDistance(v,n);c[t].bBigMove=r>s,g[t].bBigMove=h>s,this.m_changed1||i.equals(v)||(this.m_changed1=!0),this.m_changed2||n.equals(v)||(this.m_changed2=!0)}else if(P>E){v=o.getCoord2D(e);const i=a.getCoord2D(m);C=p,S=d;const n=w.sqrDistance(v,i);c[t].bBigMove=!1,g[t].bBigMove=n>s,this.m_changed2||i.equals(v)||(this.m_changed2=!0)}else{v=a.getCoord2D(m),C=y,S=x;const i=o.getCoord2D(e),n=w.sqrDistance(v,i);c[t].bBigMove=n>s,g[t].bBigMove=!1,this.m_changed1||i.equals(v)||(this.m_changed1=!0)}h[t].assign(v),l[t]=C,u[t]=S,c[t].bIsBreak=_||f,g[t].bIsBreak=_||f,i||=c[t].bBigMove||g[t].bBigMove}const _=n.rankInterior,d=n.weightInterior;let p=0,f=-1;for(let s=0;s<=e;s++){const i=s<e?this.m_param1[s]:1;if(i!==p){const r=this.allocResultSegment(),a=this.m_resultSegments[r];let m,g,x,y;o.queryCut(p,i,a,!1),a.get().snapControlPoints(t*t);let P=!1,E=!1,C=!1,S=!1,v=!1,b=w.getNAN(),I=w.getNAN();-1!==f?(g=u[f],m=l[f],P=c[f].bBigMove,b.assign(h[f]),C=c[f].bIsBreak,v=!0):(m=n.weightStart,g=n.rankStart,b=a.get().getStartXY(),C=n.u.bBreakStart),s<e?(y=u[s],x=l[s],E=c[s].bBigMove,I.assign(h[s]),S=c[s].bIsBreak,v=!0):(x=n.weightEnd,y=n.rankEnd,I=a.get().getEndXY(),S=n.u.bBreakEnd),v&&a.get().setCoordsForIntersector(b,I,!0),this.m_resultParts1.push(this.newIntersectionPart_(r,m,g,x,y,d,_,C,S,n.segmentParentage));const D=this.m_resultParts1.at(-1);D.u.bBigMoveStart=P,D.u.bBigMoveEnd=E,p=i,f=s}else-1===f&&(f=s)}const x=new Array(e);for(let t=0;t<e;t++)x[t]=t;e>2?(x.sort(((t,e)=>this.m_param2[t]<this.m_param2[e]?-1:this.m_param2[t]>this.m_param2[e]?1:0)),J(this.m_param2)):2===e&&this.m_param2[0]>this.m_param2[1]&&(this.m_param2[1]=q(this.m_param2[0],this.m_param2[0]=this.m_param2[1]),x[1]=q(x[0],x[0]=x[1]));const y=r.rankInterior,P=r.weightInterior;p=0,f=-1;for(let s=0;s<=e;s++){const i=s<e?this.m_param2[s]:1;if(i!==p){const n=this.allocResultSegment(),o=this.m_resultSegments[n];let m,c,_,d;a.queryCut(p,i,o,!1),o.get().snapControlPoints(t*t);let E=w.getNAN(),C=w.getNAN(),S=!1,v=!1,b=!1,I=!1,D=!1;if(-1!==f){const t=x[f];m=l[t],c=u[t],E.assign(h[t]),b=g[t].bBigMove,S=g[t].bIsBreak,D=!0}else m=r.weightStart,c=r.rankStart,E=o.get().getStartXY(),S=r.u.bBreakStart;if(s!==e){const t=x[s];_=l[t],d=u[t],C.assign(h[t]),I=g[t].bBigMove,v=g[t].bIsBreak,D=!0}else _=r.weightEnd,d=r.rankEnd,C=o.get().getEndXY(),v=r.u.bBreakEnd;D&&o.get().setCoordsForIntersector(E,C,!0),this.m_resultParts2.push(this.newIntersectionPart_(n,m,c,_,d,P,y,S,v,r.segmentParentage));const T=this.m_resultParts2.at(-1);T.u.bBigMoveStart=b,T.u.bBigMoveEnd=I,p=i,f=s}else-1===f&&(f=s)}return i?3:2}return 0}intersectLines3D(e,s,i,n){return t(0),1}intersect2D(t,e){const i=this.m_inputParts[0],n=this.m_inputParts[1],r=this.m_inputSegments[i.segmentIndex].getGeometryType(),o=this.m_inputSegments[n.segmentIndex].getGeometryType();if(r!==s.enumLine||o!==s.enumLine){return new Pu(this).intersectCurves(t,e)}return this.intersectLines(t,e)}intersect2DEx(t,e,s,i,n){this.m_point.assignCopy(e),1!==this.m_inputSegments.length&&m(""),this.m_tolerance=t,this.m_changed1=!1,this.m_changed2=!1;const r=M(t*gu.c_smallToleranceFactor);let o=!1;const a=this.m_inputParts[0],h=this.m_inputSegments[a.segmentIndex];if(n||h.isIntersectingPoint(e.getXY(),t,!0)){this.m_param1=H(16,Number.NaN);const n=h.getClosestCoordinate(e.getXY(),!1);this.m_param1[0]=n;let m=a.rankInterior,l=a.weightInterior;0===n?(m=a.rankStart,l=a.weightStart):1===n?(m=a.rankEnd,l=a.weightEnd):this.m_changed1=!0;let u=m;const c=s,g=i;u===c&&h.isCurve()&&(u=c+1);let _=1,d=0;const p=new w;if(u===c){const t=h.getCoord2D(n),s=e.getXY();_=l+g,d=m;lt(t,s,g/_,p),this.m_changed1||t.equals(p)||(this.m_changed1=!0),this.m_changed2||s.equals(p)||(this.m_changed2=!0);o=w.sqrDistance(p,t)>r}else if(u>c)p.assign(h.getCoord2D(n)),_=l,d=m,this.m_changed2||p.equals(e.getXY())||(this.m_changed2=!0);else{p.assign(h.getCoord2D(n)),_=g,d=c,this.m_changed1||p.equals(e.getXY())||(this.m_changed1=!0);o=w.sqrDistance(p,e.getXY())>r}let f=0,x=-1;const y=1;for(let e=0;e<=y;e++){const s=e<y?this.m_param1[0]:1;if(s!==f){const i=this.allocResultSegment(),n=this.m_resultSegments[i];h.queryCut(f,s,n),n.get().snapControlPoints(t*t);let r=a.weightStart,o=a.weightEnd,m=a.rankStart,l=a.rankEnd;const u=a.rankInterior,c=a.weightInterior;let g=a.u.bBreakStart,P=a.u.bBreakEnd;-1!==x&&(r=_,m=d,g=!0,n.get().setCoordsForIntersector(p,n.get().getEndXY(),!0)),e!==y&&(o=_,l=d,P=!0,n.get().setCoordsForIntersector(n.get().getStartXY(),p,!0)),f=s,this.m_resultParts1.push(this.newIntersectionPart_(i,r,m,o,l,c,u,g,P,a.segmentParentage))}x=e}return this.m_point.setXY(p),this.m_pointWeight=_,this.m_pointRank=d,o?3:2}return 0}intersect_3D(e,s,i,n){return t(0),1}intersect3DEx(e,s,i,n,r,o,a){return t(0),1}getTolerance(){return this.m_tolerance}getToleranceZ(){return t(0),0}freeAllResultSegments(){this.m_resultSegments.length=0,this.m_freeSegments.length=0}freeResultSegment(t){this.m_freeSegments.push(t)}allocResultSegment(){if(this.m_freeSegments.length){return this.m_freeSegments.pop()}const t=new SE,e=this.m_resultSegments.length;return this.m_resultSegments.push(t),e}allocResultSegmentFromBuffer(t){if(this.m_freeSegments.length){return this.m_freeSegments.pop()}const e=new SE({copy:t}),s=this.m_resultSegments.length;return this.m_resultSegments.push(e),s}allocResultSegmentFromSegment(t){if(this.m_freeSegments.length){return this.m_freeSegments.pop()}const e=new SE({segment:t}),s=this.m_resultSegments.length;return this.m_resultSegments.push(e),s}}function _u(t,e){return{bBigMoveStart:!1,bBigMoveEnd:!1,bBreakStart:t,bBreakEnd:e}}function du(t,e,s,i,n,r,o,a,h,m){return{segmentIndex:t,weightStart:e,rankStart:s,weightEnd:i,rankEnd:n,weightInterior:r,rankInterior:o,segmentParentage:m,u:_u(a,h)}}function pu(){return{bBigMove:!1,bIsBreak:!1}}gu.maxWeight=.1*Number.MAX_VALUE,gu.c_smallToleranceFactor=.01,gu.c_maxGeometryTypeToRankDelta=8;let fu=class{constructor(){this.start=null,this.end=null,this.equalEdge=null,this.segmentIndex=-1,this.segmentParentage=-1,this.weight=0,this.rank=0}hasSegment(){return this.segmentIndex>=0}transferAttributes(t,e,s){if(1===e.getDescription().getAttributeCount())return;const i=t.parent.m_resultSegments[this.segmentIndex].get().getStartXY(),n=t.parent.m_resultSegments[this.segmentIndex].get().getEndXY(),r=new Ge;e.queryStart(r),s?(r.setXY(i),t.parent.m_resultSegments[this.segmentIndex].get().setStart(r)):(r.setXY(n),t.parent.m_resultSegments[this.segmentIndex].get().setEnd(r)),e.queryEnd(r),s?(r.setXY(n),t.parent.m_resultSegments[this.segmentIndex].get().setEnd(r)):(r.setXY(i),t.parent.m_resultSegments[this.segmentIndex].get().setStart(r))}copyFromWhenOverlap(t,e,s){this.equalEdge=e,e.equalEdge=this,this.segmentIndex=t.parent.allocResultSegmentFromBuffer(t.parent.m_resultSegments[e.segmentIndex]),this.segmentParentage=e.segmentParentage,this.weight=e.weight,this.rank=e.rank,s?(this.start.copyFrom(e.start),this.end.copyFrom(e.end)):(this.start.copyFrom(e.end),this.end.copyFrom(e.start),t.parent.m_resultSegments[this.segmentIndex].get().reverse())}getEnd(){return t(0),{}}getNextInChain(){return this.end.nextInChain}getPrevInChain(){return this.start.prevInChain}};class xu{constructor(){this.hash=0,this.pt=new w,this.prevInChain=null,this.nextInChain=null,this.prevInHash=null,this.nextInHash=null,this.prevEqual=null,this.nextEqual=null,this.weight=0,this.rank=0,this.bBigMove=!1,this.bIsBreak=!1}copyFrom(t){this.pt.assign(t.pt),this.weight=t.weight,this.rank=t.rank,this.bBigMove=t.bBigMove,this.bIsBreak=t.bIsBreak}nextNode(){return t(0),{}}prevNode(){return t(0),{}}equalListHead(){let t=this;for(;null!==t.prevEqual;t=t.prevEqual);return t}}function yu(t,e,s,i){return{edge1:t,edge2:e,recursion:s,bIsIntersecting:i}}class Pu{constructor(t){this.m_pairs=[],this.m_chainOrigin1=null,this.m_chainOrigin2=null,this.m_newNodes=[],this.m_hashTableOfEquals=[],this.m_hashTableOfEqualsSize=0,this.m_origin=new w,this.m_cell=new w,this.parent=t}addSegment(e,s,i,n,r,o,a,h,m,l,u){const c=this.newNode(this.parent.m_resultSegments[e].get().getStartXY(),i,n,m),g=this.newNode(this.parent.m_resultSegments[e].get().getEndXY(),r,o,l);this.newEdge(c,g,e,a,h,u),null===this.m_chainOrigin1?this.m_chainOrigin1=c:null===this.m_chainOrigin2?this.m_chainOrigin2=c:t(0)}intersectCurvesHelper(e,i,n,r,o){const a=this.getSegment(e).get(),h=this.getSegment(i).get();if(a.isDegenerate(0)||h.isDegenerate(0))return 0;const l=this.tryOverlapIntersectCurves(e,i,n,r);if(0!==l)return l;const u=M(.01*n);let c=!1,g=this.processSharpCorners(a,h,n,o>4);const _=g>0;if(!_){if(!(r||5&cE(!0,!1,a,h,n,!0)))return 0;g=dE(!0,a,h,null,this.parent.m_param1,this.parent.m_param2,n)}0===g&&m("");const d=a.getGeometryType(),p=h.getGeometryType(),f=D(w,g),x=D(w,g),y=new Array(g),P=new Array(g),E=new Array(g),C=new Array(g),S=ie(pu,g),v=ie(pu,g);let b=!1,I=!1;for(let t=0;t<g;t++){const s=this.parent.m_param1[t],r=this.parent.m_param2[t];let o=e.rank,m=e.weight,l=!0,g=!1;0===s?(o=e.start.rank,m=e.start.weight,g=e.start.bIsBreak):1===s?(o=e.end.rank,m=e.end.weight,g=e.end.bIsBreak):(b=!0,l=!1);let D=i.rank,T=i.weight,N=!1,A=!0;0===r?(D=i.start.rank,T=i.start.weight,N=i.start.bIsBreak):1===r?(D=i.end.rank,T=i.end.weight,N=i.end.bIsBreak):(I=!0,A=!1);let q=o,F=D;if(q===F&&(q*=gu.c_maxGeometryTypeToRankDelta,F*=gu.c_maxGeometryTypeToRankDelta,q+=Eu(d,a,!1),F+=Eu(p,h,!1)),l&&A&&F===q){const t=a.getCoord2D(s),e=h.getCoord2D(r);t.equals(e)&&(F=q-1)}let M=1,G=0,V=1,Y=0;const X=new w,k=new w,R=a.getCoord2D(s),B=h.getCoord2D(r);if(_&&w.distance(R,B)>n)X.setCoordsPoint2D(R),k.setCoordsPoint2D(B),M=m,V=T,G=o,Y=D,S[t].bBigMove=!1,v[t].bBigMove=!1,g=!0,N=!0;else if(q===F){V=M=m+T,Y=G=o;lt(R,B,T/M,X),k.setCoordsPoint2D(X);const e=w.sqrDistance(X,R),s=w.sqrDistance(X,B);S[t].bBigMove=e>u,v[t].bBigMove=s>u,b||R.equals(X)||(b=!0),I||B.equals(k)||(I=!0)}else if(q>F){X.setCoordsPoint2D(R),k.setCoordsPoint2D(X),V=M=m,Y=G=o;const e=w.sqrDistance(X,B);S[t].bBigMove=!1,v[t].bBigMove=e>u,I||B.equals(k)||(I=!0)}else{k.setCoordsPoint2D(B),X.setCoordsPoint2D(k),V=M=T,Y=G=D;const e=w.sqrDistance(X,R);S[t].bBigMove=e>u,v[t].bBigMove=!1,b||R.equals(X)||(b=!0)}f[t].assign(X),x[t].assign(k),y[t]=M,P[t]=V,E[t]=G,C[t]=Y,S[t].bIsBreak=g||N,v[t].bIsBreak=g||N,c||=S[t].bBigMove||v[t].bBigMove,t>0&&(s!==this.parent.m_param1[t-1]&&r!==this.parent.m_param2[t-1]||(E[t]<=E[t-1]?(f[t].assign(x[t-1]),y[t]=P[t-1],E[t]=C[t-1],x[t].assign(x[t-1]),P[t]=P[t-1],C[t]=C[t-1],S[t].bBigMove||=S[t-1].bBigMove,v[t].bBigMove||=v[t-1].bBigMove,S[t].bIsBreak||=S[t-1].bIsBreak,v[t].bIsBreak||=v[t-1].bIsBreak):(f[t-1].assign(f[t]),y[t-1]=y[t],E[t-1]=E[t],x[t-1].assign(x[t]),P[t-1]=P[t],C[t-1]=C[t],S[t-1].bBigMove||=S[t].bBigMove,v[t-1].bBigMove||=v[t].bBigMove,S[t-1].bIsBreak||=S[t].bIsBreak,v[t-1].bIsBreak||=v[t].bIsBreak)))}if(!b&&!I&&2===g){if(d!==s.enumLine||p!==s.enumLine){if(this.processDoublyConnectedEdges(e,i,o+1,n))return this.parent.m_changed1=!0,this.parent.m_changed2=!0,2;t(0)}t(0)}this.parent.m_changed1||=b,this.parent.m_changed2||=I;let T=e,N=e.end.weight,A=e.end.rank,F=e.end.bBigMove,G=e.end.bIsBreak,V=0,Y=-1;for(let t=0;t<=g;t++){const s=t<g?this.parent.m_param1[t]:1;if(s!==V){const i=this.parent.allocResultSegment(),r=this.parent.m_resultSegments[i];let o,h,m,l;a.queryCut(V,s,r,!1),r.get().snapControlPoints(n*n);let u=!1,c=!1,_=!1,d=!1;const p=new w,x=new w;-1!==Y?(h=E[Y],o=y[Y],_=S[Y].bBigMove,u=S[Y].bIsBreak,p.assign(f[Y])):(o=e.start.weight,h=e.start.rank,_=e.start.bBigMove,u=e.start.bIsBreak,p.assign(r.get().getStartXY())),t<g?(l=E[t],m=y[t],d=S[t].bBigMove,c=S[t].bIsBreak,x.assign(f[t])):(m=N,l=A,d=F,c=G,x.assign(r.get().getEndXY()));let P=T;s<1&&(this.splitEdgeInPlace(T),P=T.getNextInChain()),this.updateSegmentOnly(T,i),0===T.start.hash||T.start.pt.equals(p)||(this.m_newNodes.push(T.start),this.removeNodeFromHash(T.start),T.start.hash=0),0===T.end.hash||T.end.pt.equals(x)||(this.m_newNodes.push(T.end),this.removeNodeFromHash(T.end),T.end.hash=0),T.start.pt.assign(p),T.end.pt.assign(x),T.start.bBigMove||=_,T.end.bBigMove||=d,T.start.bIsBreak||=u,T.end.bIsBreak||=c,T.start.weight=o,T.start.rank=h,T.end.weight=m,T.end.rank=l,T=P,V=s,Y=t}else-1===Y&&(Y=t)}const X=T.getNextInChain(),k=[];k.length=g;for(let t=0;t<g;t++)k[t]=t;g>2?(k.sort(((t,e)=>Ft(this.parent.m_param2[t],this.parent.m_param2[e]))),this.parent.m_param2.sort(Ft)):2===g&&this.parent.m_param2[0]>this.parent.m_param2[1]&&(this.parent.m_param2[1]=q(this.parent.m_param2[0],this.parent.m_param2[0]=this.parent.m_param2[1]),k[1]=q(k[0],k[0]=k[1])),T=i,N=i.end.weight,A=i.end.rank,F=i.end.bBigMove,G=i.end.bIsBreak,V=0,Y=-1;for(let t=0;t<=g;t++){const e=t<g?this.parent.m_param2[t]:1;if(e!==V){const s=this.parent.allocResultSegment(),r=this.parent.m_resultSegments[s];let o,a,m,l;h.queryCut(V,e,r,!1),r.get().snapControlPoints(n*n);const u=new w,c=new w;let _=!1,d=!1,p=!1,f=!1;if(-1!==Y){const t=k[Y];o=P[t],a=C[t],u.assign(x[t]),p=v[t].bBigMove,_=v[t].bIsBreak}else o=i.start.weight,a=i.start.rank,p=i.start.bBigMove,_=i.start.bIsBreak,u.assign(r.get().getStartXY());if(t!==g){const e=k[t];m=P[e],l=C[e],c.assign(x[e]),f=v[e].bBigMove,d=v[e].bIsBreak}else m=N,l=A,f=F,d=G,c.assign(r.get().getEndXY());let y=T;e<1&&(this.splitEdgeInPlace(T),y=T.getNextInChain()),this.updateSegmentOnly(T,s),0===T.start.hash||T.start.pt.equals(u)||(this.m_newNodes.push(T.start),this.removeNodeFromHash(T.start),T.start.hash=0),0===T.end.hash||T.end.pt.equals(c)||(this.m_newNodes.push(T.end),this.removeNodeFromHash(T.end),T.end.hash=0),T.start.pt.assign(u),T.end.pt.assign(c),T.start.bBigMove||=p,T.end.bBigMove||=f,T.start.bIsBreak||=_,T.end.bIsBreak||=d,T.start.weight=o,T.start.rank=a,T.end.weight=m,T.end.rank=l,T=y,V=e,Y=t}else-1===Y&&(Y=t)}const R=T.getNextInChain();return this.postProcessResultPartsForCurves(e,X,i,R,o+1),c?3:2}intersectCurves(e,s){2!==this.parent.m_inputSegments.length&&m(""),this.parent.m_changed1=!1,this.parent.m_changed2=!1,this.parent.m_tolerance=e,this.m_hashTableOfEqualsSize=0,this.m_hashTableOfEquals=K(16);const i=ge.constructEmpty();for(let t=0;t<2;t++){const e=this.parent.allocResultSegmentFromSegment(this.parent.m_inputSegments[this.parent.m_inputParts[t].segmentIndex]),s=ge.constructEmpty();this.parent.m_inputSegments[this.parent.m_inputParts[t].segmentIndex].queryLooseEnvelope(s),i.mergeEnvelope2D(s);const n=this.parent.m_inputParts[t];this.addSegment(e,0,n.weightStart,n.rankStart,n.weightEnd,n.rankEnd,n.weightInterior,n.rankInterior,n.u.bBreakStart,n.u.bBreakEnd,n.segmentParentage)}i.inflateCoords(100*e,100*e),this.m_origin.assign(i.getLowerLeft()),this.m_cell.setCoords(2*e,2*e),this.m_pairs.push(yu(this.m_chainOrigin1.nextInChain,this.m_chainOrigin2.nextInChain,0,s));let n=0,r=!0;for(;this.m_pairs.length;){const s=this.m_pairs.at(-1);this.m_pairs.pop(),t(s.recursion>=0),t(s.recursion<=256),this.clusterNodes(e);const i=this.intersectCurvesHelper(s.edge1,s.edge2,e,s.bIsIntersecting,s.recursion);r&&(r=!1,n=i)}for(let t=0;t<2;t++){const e=0===t?this.parent.m_resultParts1:this.parent.m_resultParts2;for(let s=(0===t?this.m_chainOrigin1:this.m_chainOrigin2).nextInChain;null!=s;s=s.getNextInChain())e.push(this.parent.newIntersectionPart_(s.segmentIndex,s.start.weight,s.start.rank,s.end.weight,s.end.rank,s.weight,s.rank,s.start.bIsBreak,s.end.bIsBreak,s.segmentParentage)),e.at(-1).u.bBigMoveStart=s.start.bBigMove,e.at(-1).u.bBigMoveEnd=s.end.bBigMove}return n}tryOverlapIntersectCurves(e,s,i,n){const r=this.parent.m_resultSegments[e.segmentIndex].get(),o=this.parent.m_resultSegments[s.segmentIndex].get(),a=r.getStartXY().equals(o.getStartXY())&&r.getEndXY().equals(o.getEndXY()),h=r.getStartXY().equals(o.getEndXY())&&r.getEndXY().equals(o.getStartXY());if(!a&&!h)return 0;const m=gE(r,o,!0);if(0!==m&&_E(r,o)&&e.segmentParentage===s.segmentParentage){let e=!1;if(m>0)e=r.equals(o);else{t(-1===m);const s=new SE({segment:o});s.get().reverse(),e=r.equals(s.get())}if(e)return 1}const l=i*gu.c_smallToleranceFactor;let u=!1;if(0===m){const t=[.5,.25,.75,.125,.375,.625,.875,.5625,.3125];for(let e=0,s=t.length;e<s;++e){const s=t[e],n=new w;r.queryCoord2D(s,n);const a=o.getClosestCoordinate(n,!1),h=new w;o.queryCoord2D(a,h);const m=w.distance(n,h);if(m>i)return 0;u||=m>l}for(let e=0,s=t.length;e<s;++e){const s=t[e],n=new w;o.queryCoord2D(s,n);const a=r.getClosestCoordinate(n,!1),h=new w;r.queryCoord2D(a,h);const m=w.distance(n,h);if(m>i)return 0;u||=m>l}}let c=e.rank,g=s.rank;return c===g&&(c*=gu.c_maxGeometryTypeToRankDelta,g*=gu.c_maxGeometryTypeToRankDelta,c+=Eu(r.getGeometryType(),r,!0),g+=Eu(o.getGeometryType(),o,!0)),c>g?(s.copyFromWhenOverlap(this,e,a),s.transferAttributes(this,r,a)):g>c?(e.copyFromWhenOverlap(this,s,a),e.transferAttributes(this,o,a)):e.segmentParentage<=s.segmentParentage?(e.weight=e.weight+s.weight,s.copyFromWhenOverlap(this,e,a),s.transferAttributes(this,r,a)):(s.weight=e.weight+s.weight,e.copyFromWhenOverlap(this,s,a),e.transferAttributes(this,o,a)),u?3:2}postProcessResultPartsForCurves(t,e,s,i,n){n===ne()&&m("curve_helper");for(let r=t;r!==e;r=r.getNextInChain())this.updateSegmentToNodes(r);for(let r=s;r!==i;r=r.getNextInChain())this.updateSegmentToNodes(r);for(let r=t;r!==e;r=r.getNextInChain()){const t=r.end.pt.sub(r.start.pt);for(let e=s;e!==i;e=e.getNextInChain()){let s=0;if(r.start.pt.equals(e.start.pt)&&r.end.pt.equals(e.end.pt)?s=1:r.start.pt.equals(e.end.pt)&&r.end.pt.equals(e.start.pt)&&(s=-1),!s){let s=r.start.pt.equals(e.start.pt)?1:0;if(s||(s=r.end.pt.equals(e.end.pt)?2:0,s||(s=r.end.pt.equals(e.start.pt)?3:0,s||(s=r.start.pt.equals(e.end.pt)?4:0))),s){const i=e.end.pt.sub(e.start.pt),o=t.dotProduct(i);let a;switch(s){case 1:case 2:a=o>0;break;case 3:case 4:a=o<0;break;default:m("post_process_result_parts_for_curves_")}a&&this.m_pairs.push(yu(r,e,n,!1))}continue}const i=this.parent.m_resultSegments[r.segmentIndex],o=this.parent.m_resultSegments[e.segmentIndex],a=[.5,.25,.75];for(let t=0,e=a.length;t<e;++t){const e=a[t],n=new w;i.get().queryCoord2D(e,n);const r=o.get().getClosestCoordinate(n,!1),h=new w;o.get().queryCoord2D(r,h);if(w.distance(n,h)>this.parent.m_tolerance){s=0;break}}if(!s){this.m_pairs.push(yu(r,e,n,!1));continue}for(let t=0,e=a.length;t<e;++t){const e=a[t],n=new w;o.get().queryCoord2D(e,n);const r=i.get().getClosestCoordinate(n,!1),h=new w;i.get().queryCoord2D(r,h);if(w.distance(n,h)>this.parent.m_tolerance){s=0;break}}if(!s){this.m_pairs.push(yu(r,e,n,!1));continue}r.equalEdge=e,e.equalEdge=r;let h=r.rank,l=e.rank;h===l&&(h*=gu.c_maxGeometryTypeToRankDelta,l*=gu.c_maxGeometryTypeToRankDelta,h+=Eu(i.get().getGeometryType(),i.get(),!0),l+=Eu(o.get().getGeometryType(),o.get(),!0)),h>l||h===l&&r.segmentParentage<=e.segmentParentage?(i.copyTo(o,!1),e.segmentParentage=r.segmentParentage,-1===s&&o.get().reverse()):(o.copyTo(i,!1),r.segmentParentage=e.segmentParentage,-1===s&&i.get().reverse());break}}this.updateAttachedEdgesAfterNodeChange(t.start),e&&this.updateAttachedEdgesAfterNodeChange(e.start),this.updateAttachedEdgesAfterNodeChange(s.start),i&&this.updateAttachedEdgesAfterNodeChange(i.start)}processDoublyConnectedEdges(t,e,s,i){s===ne()&&m("curve_helper");const n=this.getSegment(t).get(),r=this.getSegment(e).get(),o=n.getStartXY().equals(r.getStartXY())&&n.getEndXY().equals(r.getEndXY())?1:n.getEndXY().equals(r.getStartXY())&&n.getStartXY().equals(r.getEndXY())?-1:0;if(0!==o){const a=new SE;n.queryCut(0,.5,a),a.get().snapControlPoints(i*i);const h=new SE;n.queryCut(.5,1,h),h.get().snapControlPoints(i*i),this.splitEdgeInPlace(t),t.end.pt=a.get().getEndXY(),t.segmentIndex=this.parent.allocResultSegmentFromBuffer(a),t.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(h);let m=r.getClosestCoordinate(t.end.pt,!1);return Math.abs(m-.5)>.2&&(m=.5),r.queryCut(0,m,a),a.get().snapControlPoints(i*i),r.queryCut(m,1,h),h.get().snapControlPoints(i*i),this.splitEdgeInPlace(e),e.end.pt=a.get().getEndXY(),e.segmentIndex=this.parent.allocResultSegmentFromBuffer(a),e.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(h),o>0?(this.m_pairs.push(yu(t,e,s,!1)),this.m_pairs.push(yu(t.getNextInChain(),e.getNextInChain(),s,!1))):(this.m_pairs.push(yu(t,e.getNextInChain(),s,!1)),this.m_pairs.push(yu(t.getNextInChain(),e,s,!1))),!0}return!1}getNext(e){return t(0),{}}newNode(t,e,s,i){const n=new xu;return this.m_newNodes.push(n),n.pt=t,n.rank=s,n.weight=e,n.bIsBreak=i,n}newEdge(t,e,s,i,n,r){const o=new fu;return o.start=t,o.end=e,t.nextInChain=o,e.prevInChain=o,o.segmentIndex=s,o.segmentParentage=r,o.rank=n,o.weight=i,o}splitEdgeInPlace(t){t.segmentIndex=-1;const e=new fu,s=new xu;this.m_newNodes.push(s),s.pt.setNAN(),s.nextInChain=e,s.prevInChain=t,s.prevInHash=null,s.nextInHash=null,s.prevEqual=null,s.nextEqual=null,s.weight=t.weight,s.rank=t.rank,s.bIsBreak=!1,s.bBigMove=!1,e.start=s,e.segmentIndex=-1,e.end=t.end,e.end.prevInChain=e,e.rank=t.rank,e.weight=t.weight,e.segmentParentage=t.segmentParentage,t.end=s,t.equalEdge&&(t.equalEdge.equalEdge=null),t.equalEdge=null}updateSegmentOnly(t,e){t.segmentIndex=e}updateAttachedEdgesAfterNodeChange(t){for(let e=t.equalListHead();null!==e;e=e.nextEqual)this.updateAttachedEdgesAfterNodeChangeImpl(e)}updateAttachedEdgesAfterNodeChangeImpl(t){const e=t.prevInChain;if(e&&e.hasSegment()){const s=this.getSegment(e).get();t.pt.equals(s.getEndXY())||(s.setCoordsForIntersector(e.start.pt,e.end.pt,!1),s.ensureXYMonotone())}const s=t.nextInChain;if(s&&s.hasSegment()){const e=this.getSegment(s).get();t.pt.equals(e.getStartXY())||(e.setCoordsForIntersector(s.start.pt,s.end.pt,!1),e.ensureXYMonotone())}}updateSegmentToNodes(t){const e=this.getSegment(t).get();t.start.pt.equals(e.getStartXY())&&t.end.pt.equals(e.getEndXY())||(e.setCoordsForIntersector(t.start.pt,t.end.pt,!1),e.ensureXYMonotone()),this.updateAttachedEdgesAfterNodeChange(t.start),this.updateAttachedEdgesAfterNodeChange(t.end)}getSegment(t){return this.parent.m_resultSegments[t.segmentIndex]}clusterNodes(t){let e=!1;const s=[],i=[],n=[];for(let r=0,o=this.m_newNodes.length;r<o;r++){const t=this.m_newNodes[r];if(null===t)continue;let e=t;for(let s=r+1;s<o;s++){const i=this.m_newNodes[s];null!==i&&(t.pt.equals(i.pt)&&(e.nextInHash=i,i.prevInHash=e,e=i,this.m_newNodes[s]=null))}}for(let r=0,o=this.m_newNodes.length;r<o;r++){const o=this.m_newNodes[r];if(null==o)continue;for(o.hash=this.calculateHash(o.pt);;){const r=K(4),a=this.hashTableBinsToCheck(o,r);for(let e=0;e<a;e++)if(null!==r[e])for(let a=r[e];null!==a;){const e=a.nextInHash;w.distance(o.pt,a.pt)<=t&&(s.push(a),this.removeNodeFromHash(a),a.hash=0,n.push(a),i.push(a)),a=e}let h=!1;for(const t of s)if(!o.pt.equals(t.pt)){const s=au(o.pt,t.pt,o.weight,o.rank,t.weight,t.rank);o.pt.assign(s.pt),o.weight=s.weight,o.rank=s.rank,h=!0,e=!0}if(s.length=0,!h)break;o.hash=this.calculateHash(o.pt)}n.push(o),i.push(o);for(let t=o.nextInHash;null!==t;){t.prevInHash=null;const e=t.nextInHash;t.nextInHash=null,n.push(t),i.push(t),t=e}const a=o.hash;let h=null,m=null;for(const t of i)o!==t&&(t.hash=a,t.pt.assign(o.pt),t.rank=o.rank,t.weight=o.weight),t.prevInHash=h,h&&(h.nextInHash=t),t.prevEqual=m,t.nextEqual=null,m&&(m.nextEqual=t),m=t,h=t;const l=a%this.m_hashTableOfEquals.length;h.nextInHash=this.m_hashTableOfEquals[l],null!==this.m_hashTableOfEquals[l]&&(this.m_hashTableOfEquals[l].prevInHash=h),this.m_hashTableOfEquals[l]=i[0],this.m_hashTableOfEqualsSize+=i.length,i.length=0,this.rehashIfNeeded()}if(this.m_newNodes.length=0,e)for(const r of n)this.updateAttachedEdgesAfterNodeChange(r)}addNodeToHash(e){t(0)}rehashIfNeeded(){if(2*this.m_hashTableOfEqualsSize>this.m_hashTableOfEquals.length){const t=this.m_hashTableOfEquals;this.m_hashTableOfEquals=K(2*t.length),this.m_hashTableOfEqualsSize=0;for(const e of t){let t=e;for(;t;){const e=t.nextInHash;t.nextInHash=null,t.prevInHash=null,this.addNodeToHashImpl(t),t=e}}}}addNodeToHashImpl(t){const e=t.hash%this.m_hashTableOfEquals.length,s=this.m_hashTableOfEquals[e];t.nextInHash=s,null!==s&&(s.prevInHash=t),this.m_hashTableOfEquals[e]=t,this.m_hashTableOfEqualsSize++}removeNodeFromHash(t){const e=t.hash%this.m_hashTableOfEquals.length,s=t.prevInHash,i=t.nextInHash;s?s.nextInHash=i:this.m_hashTableOfEquals[e]=i,i&&(i.prevInHash=s),this.m_hashTableOfEqualsSize--,t.prevInHash=null,t.nextInHash=null}hashTableBinsToCheck(t,e){const s=(t.pt.x-this.m_origin.x)/this.m_cell.x,i=(t.pt.y-this.m_origin.y)/this.m_cell.y,n=k()-1,r=Math.round(T(s,-n,n)),o=Math.round(T(i,-n,n));let a=r|o<<32;a=W(a),e[0]=this.m_hashTableOfEquals[a%this.m_hashTableOfEquals.length];let h=r+1|o<<32;h=W(h);let m=1;e[1]=this.m_hashTableOfEquals[h%this.m_hashTableOfEquals.length],e[1]!==e[0]&&(m=2);let l=r+1|o+1<<32;l=W(l),e[m]=this.m_hashTableOfEquals[l%this.m_hashTableOfEquals.length];for(let c=0;c<m;c++)if(e[m]===e[c]){m--;break}m++;let u=r|o+1<<32;u=W(u),e[m]=this.m_hashTableOfEquals[u%this.m_hashTableOfEquals.length];for(let c=0;c<m;c++)if(e[m]===e[c]){m--;break}return m++,m}calculateHash(t){const e=(t.x-this.m_origin.x)/this.m_cell.x,s=(t.y-this.m_origin.y)/this.m_cell.y,i=k()-1;let n=Math.round(T(e,-i,i))|Math.round(T(s,-i,i))<<32;return n=W(n),0===n&&(n=1),n}processSharpCorners(t,e,s,i){if(this.parent.m_param1.length=0,this.parent.m_param2.length=0,t.getStartXY().equals(e.getStartXY())){const n=[0,0],r=[0,0],o=yE(t,e,0,0,s,2,n,r,i);if(o){this.parent.m_param1.push(0),this.parent.m_param2.push(0);for(let t=0;t<o;t++)this.parent.m_param1.push(n[t]),this.parent.m_param2.push(r[t]);return o+1}}if(t.getEndXY().equals(e.getEndXY())){const n=[0,0],r=[0,0],o=yE(t,e,1,1,s,2,n,r,i);if(o){for(let t=0;t<o;t++)this.parent.m_param1.push(n[t]),this.parent.m_param2.push(r[t]);return this.parent.m_param1.push(1),this.parent.m_param2.push(1),o+1}}if(t.getStartXY().equals(e.getEndXY())){const n=[0,0],r=[0,0],o=yE(t,e,0,1,s,2,n,r,i);if(o){this.parent.m_param1.push(0),this.parent.m_param2.push(1);for(let t=0;t<o;t++)this.parent.m_param1.push(n[t]),this.parent.m_param2.push(r[t]);return o+1}}if(t.getEndXY().equals(e.getStartXY())){const n=[0,0],r=[0,0],o=yE(t,e,1,0,s,2,n,r,i);if(o){for(let t=0;t<o;t++)this.parent.m_param1.push(n[t]),this.parent.m_param2.push(r[t]);return this.parent.m_param1.push(1),this.parent.m_param2.push(0),o+1}}return 0}}function Eu(t,e,i){let n=0;switch(t){case s.enumLine:n=0;break;case s.enumBezier:n=2;break;case s.enumRationalBezier2:n=3;break;case s.enumBezier2:n=1;break;case s.enumEllipticArc:n=0===e.projectionBehavior()?5:4;break;default:m("")}return i?5-n:n}class Cu extends eu{constructor(t){super(t.m_shape,t.m_tolerance,!1),this.m_parent=t}compare(t,e,s){if(this.m_bIntersectionDetected)return-1;const i=t.getElement(s),n=this.m_parent.getEdgeOriginVertices(e),r=this.m_parent.m_edgeVertices.getFirstElement(n),o=this.m_parent.getEdgeOriginVertices(i),a=this.m_parent.m_edgeVertices.getFirstElement(o);return this.m_currentNode=s,this.compareSegments(e,r,i,a)}}class Su extends su{constructor(t){super(t.m_shape,t.m_tolerance),this.m_parent=t}compare(t,e){if(this.m_bIntersectionDetected)return-1;const s=t.getElement(e),i=this.m_parent.getEdgeOriginVertices(s),n=this.m_parent.m_edgeVertices.getFirstElement(i);return this.m_currentNode=e,this.compareVertex(t,e,n)}}class vu extends hs{constructor(t){super(),this.pt1=w.getNAN(),this.pt2=w.getNAN(),this.m_shape=t}compare(t,e,s){this.m_shape.queryXY(e,this.pt1);const i=t.getElement(s);return this.m_shape.queryXY(i,this.pt2),this.pt1.compare(this.pt2)}}class bu{constructor(t){this.m_point=w.getNAN(),this.m_pt=w.getNAN(),this.m_shape=t}setPoint(t){this.m_point.setCoordsPoint2D(t)}compare(t,e){const s=t.getElement(e);return this.m_shape.queryXY(s,this.m_pt),this.m_point.compare(this.m_pt)}}class Iu{constructor(t,e){this.m_shape=null,this.m_progressTracker=null,this.m_edges=new is(8),this.m_clusters=new is(5),this.m_clusterVertices=new Jl(!1),this.m_edgeVertices=new Jl(!1),this.m_helperPoint=new Ge,this.m_eventQ=new ms,this.m_sweepStructure=new ms,this.m_bComplications=!1,this.m_sweepComparator=null,this.m_tempEdgeBuffer=[],this.m_modifiedClusters=[],this.m_edgesToInsertInSweepStructure=[],this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1,this.m_progressCounter=0,this.m_segmentIntersector=new gu,this.m_segBuf1=new SE,this.m_segBuf2=new SE,this.m_sweepPoint=new w(0,0),this.m_tolerance=0,this.m_toleranceSqr=0,this.m_sweepPointCluster=-1,this.m_vertexClusterIndex=-1,this.m_bCracked=!1,this.m_bSweepPointClusterWasModified=!1,this.m_progressTracker=t,this.m_bTrackChanges=e}hadComplications(){return this.m_bComplications}sweep(t,e){const s=new Y;s.setSwapCoordinates(),t.applyTransformation(s),this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=e,this.m_toleranceSqr=e*e;let i=this.sweepImpl_();return t.applyTransformation(s),i||(this.fillEventQueuePass2(),i=this.sweepImpl_()||i),this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_shape=null,this.m_bCracked}sweepVertical(t,e){this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=e,this.m_toleranceSqr=e*e,this.m_bComplications=!1;let s=this.sweepImpl_();if(!this.m_bComplications){const i=t.filterClosePoints(e,!0,!1,this.m_bTrackChanges,Nm);this.m_bComplications=1===i,s||=1===i}return-1!==this.m_vertexClusterIndex&&(this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_vertexClusterIndex=-1),this.m_shape=null,s}getEdgeCluster(t,e){return this.m_edges.getField(t,0+e)}setEdgeCluster_(t,e,s){this.m_edges.setField(t,0+e,s)}getEdgeOriginVertices(t){return this.m_edges.getField(t,2)}setEdgeOriginVertices_(t,e){this.m_edges.setField(t,2,e)}getNextEdgeEx(t,e){return this.m_edges.getField(t,3+e)}setNextEdgeEx_(t,e,s){this.m_edges.setField(t,3+e,s)}getEdgeSweepNode(t){return this.m_edges.getField(t,7)}setEdgeSweepNode_(t,e){this.m_edges.setField(t,7,e)}getNextEdge(t,e){const s=this.getEdgeEnd(t,e);return this.m_edges.getField(t,3+s)}setNextEdge_(t,e,s){const i=this.getEdgeEnd(t,e);this.m_edges.setField(t,3+i,s)}getPrevEdge(t,e){const s=this.getEdgeEnd(t,e);return this.m_edges.getField(t,5+s)}setPrevEdge_(t,e,s){const i=this.getEdgeEnd(t,e);this.m_edges.setField(t,5+i,s)}getClusterVertices(t){return this.m_clusters.getField(t,0)}setClusterVertices_(t,e){this.m_clusters.setField(t,0,e)}getClusterSweepEdgeList(t){return this.m_clusters.getField(t,2)}setClusterSweepEdgeList_(t,e){this.m_clusters.setField(t,2,e)}getClusterFirstEdge(t){return this.m_clusters.getField(t,1)}setClusterFirstEdge_(t,e){this.m_clusters.setField(t,1,e)}getClusterEventQNode(t){return this.m_clusters.getField(t,3)}setClusterEventQNode_(t,e){this.m_clusters.setField(t,3,e)}newCluster_(t){const e=this.m_clusters.newElement(),s=this.m_clusterVertices.createList();return this.setClusterVertices_(e,s),t!==Nm&&(this.m_clusterVertices.addElement(s,t),this.m_shape.setUserIndex(t,this.m_vertexClusterIndex,e)),e}deleteCluster_(t){this.m_clusters.deleteElement(t)}addVertexToCluster_(t,e){const s=this.getClusterVertices(t);this.m_clusterVertices.addElement(s,e),this.m_shape.setUserIndex(e,this.m_vertexClusterIndex,t)}newEdge_(t){const e=this.m_edges.newElement(),s=this.m_edgeVertices.createList();return this.setEdgeOriginVertices_(e,s),-1!==t&&this.m_edgeVertices.addElement(s,t),e}addVertexToEdge_(t,e){const s=this.getEdgeOriginVertices(t);this.m_edgeVertices.addElement(s,e)}deleteEdge_(t){this.m_edges.deleteElement(t);const e=this.m_edgesToInsertInSweepStructure.findIndex((e=>e===t));e>=0&&Rt(this.m_edgesToInsertInSweepStructure,e)}addEdgeToCluster(t,e){-1===this.getEdgeCluster(t,0)?this.setEdgeCluster_(t,0,e):-1===this.getEdgeCluster(t,1)?this.setEdgeCluster_(t,1,e):m(""),this.addEdgeToClusterImpl_(t,e)}addEdgeToClusterImpl_(t,e){const s=this.getClusterFirstEdge(e);if(-1!==s){const i=this.getNextEdge(s,e);this.setPrevEdge_(i,e,t),this.setNextEdge_(t,e,i),this.setNextEdge_(s,e,t),this.setPrevEdge_(t,e,s)}else this.setPrevEdge_(t,e,t),this.setNextEdge_(t,e,t),this.setClusterFirstEdge_(e,t)}getEdgeEnd(t,e){return this.getEdgeCluster(t,0)===e?0:1}mergeClusters_(t,e){this.dbgCheckCluster_(t),this.dbgCheckCluster_(e);const s=this.getClusterEventQNode(e);-1!==s&&(this.m_eventQ.deleteNode(s),this.setClusterEventQNode_(e,-1));let i=this.getClusterFirstEdge(t),n=this.getClusterFirstEdge(e);if(-1!==n){let s=n,r=n,o=!1;do{this.dbgCheckEdge_(s),o=!1;const i=this.getEdgeEnd(s,e),a=this.getNextEdgeEx(s,i);if(this.getEdgeCluster(s,i+1&1)===t){this.disconnectEdge_(s);const t=this.getEdgeOriginVertices(s);if(this.m_edgeVertices.deleteList(t),this.deleteEdge_(s),s===a){n=-1;break}n===s&&(n=this.getClusterFirstEdge(e),r=a,o=!0)}s=a}while(s!==r||o);if(-1!==n){do{const i=this.getEdgeEnd(s,e),n=this.getNextEdgeEx(s,i);this.setEdgeCluster_(s,i,t),s=n}while(s!==r);if(i=this.getClusterFirstEdge(t),-1!==i){const e=this.getNextEdge(i,t),s=this.getNextEdge(n,t);e===i?(this.setClusterFirstEdge_(t,n),this.addEdgeToClusterImpl_(i,t),this.setClusterFirstEdge_(t,i)):s===n&&this.addEdgeToClusterImpl_(n,t),this.setNextEdge_(n,t,e),this.setPrevEdge_(e,t,n),this.setNextEdge_(i,t,s),this.setPrevEdge_(s,t,i)}else this.setClusterFirstEdge_(t,n)}}const r=this.getClusterVertices(t),o=this.getClusterVertices(e);for(let a=this.m_clusterVertices.getFirst(o);-1!==a;a=this.m_clusterVertices.getNext(a)){const e=this.m_clusterVertices.getElement(a);this.m_shape.setUserIndex(e,this.m_vertexClusterIndex,t)}this.m_clusterVertices.concatenateLists(r,o),this.deleteCluster_(e),this.dbgCheckCluster_(t)}mergeEdges_(t,e){this.dbgCheckEdge_(t),this.dbgCheckEdge_(e);const s=this.getEdgeCluster(t,0),i=this.getEdgeCluster(t,1),n=this.getEdgeCluster(e,0),r=this.getEdgeCluster(e,1),o=this.getEdgeOriginVertices(t),a=this.getEdgeOriginVertices(e);if(this.m_edgeVertices.concatenateLists(o,a),e===this.getClusterFirstEdge(s)&&this.setClusterFirstEdge_(s,t),e===this.getClusterFirstEdge(i)&&this.setClusterFirstEdge_(i,t),this.disconnectEdge_(e),this.deleteEdge_(e),!(s===n&&i===r||i===n&&s===r)){const t=this.getClusterXY(s),e=this.getClusterXY(n);t.isEqualPoint2D(e)?(s!==n&&this.mergeClusters_(s,n),i!==r&&this.mergeClusters_(i,r)):(i!==n&&this.mergeClusters_(i,n),s!==r&&this.mergeClusters_(s,r))}this.dbgCheckEdge_(t)}disconnectEdge_(t){const e=this.getEdgeCluster(t,0),s=this.getEdgeCluster(t,1);this.disconnectEdgeFromCluster_(t,e),this.disconnectEdgeFromCluster_(t,s)}disconnectEdgeFromCluster_(t,e){const s=this.getNextEdge(t,e),i=this.getPrevEdge(t,e),n=this.getClusterFirstEdge(e);s!==t?(this.setNextEdge_(i,e,s),this.setPrevEdge_(s,e,i),n===t&&this.setClusterFirstEdge_(e,s)):this.setClusterFirstEdge_(e,-1)}applyIntersectorToEditShape_(t,e,s){let i=this.m_edgeVertices.getFirst(t);const n=this.m_edgeVertices.getElement(i),r=this.getClusterFromVertex(n),o=this.m_shape.getNextVertex(n),a=this.getClusterFromVertex(o),h=this.m_shape.getXY(n),m=this.m_shape.getXY(o);let l=!1,u=!1;const c=e.getResultSegment(s,0).getStartXY(),g=e.getResultSegment(s,e.getResultSegmentCount(s)-1).getEndXY();h.equals(c)||(l=!0),m.equals(g)||(u=!0),this.m_shape.splitSegmentWithIntersector(n,e,s,!0,!0);const _=this.m_bTrackChanges&&e.getSegmentChanged(s);for(_&&this.m_shape.setGeometryModifiedWithVertex(n,!0),i=this.m_edgeVertices.getNext(i);-1!==i;i=this.m_edgeVertices.getNext(i)){const t=this.m_edgeVertices.getElement(i),n=this.getClusterFromVertex(t)===r;this.m_shape.splitSegmentWithIntersector(t,e,s,n,!0),_&&this.m_shape.setGeometryModifiedWithVertex(t,!0)}if(l&&this.updateClusterXY(!0,r,c,e.getResultSegmentStartPointWeight(s,0),e.getResultSegmentStartPointRank(s,0)),u){const t=e.getResultSegmentCount(s)-1;this.updateClusterXY(!0,a,g,e.getResultSegmentEndPointWeight(s,t),e.getResultSegmentEndPointRank(s,t))}}createEdgesAndClustersFromSplitEdge_(t,e,s){this.dbgCheckNewEdgesArray_();const i=this.getEdgeOriginVertices(t),n=this.getEdgeCluster(t,0),r=this.getEdgeCluster(t,1);let o=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(o);const a=is.impossibleIndex3();this.setEdgeSweepNode_(o,a),this.m_tempEdgeBuffer.push(o),this.addEdgeToCluster(o,n);const h=e.getResultSegmentCount(s);for(let m=1;m<h;m++){const t=this.newCluster_(-1);this.m_modifiedClusters.push(t),this.m_tempEdgeBuffer.push(t),this.addEdgeToCluster(o,t);const e=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(e),this.setEdgeSweepNode_(e,a),this.m_tempEdgeBuffer.push(e),this.addEdgeToCluster(e,t),o=e}this.addEdgeToCluster(o,r);for(let m=this.m_edgeVertices.getFirst(i);-1!==m;m=this.m_edgeVertices.getNext(m)){let t=this.m_edgeVertices.getElement(m);if(this.getClusterFromVertex(t)===n){let e=0;const s=this.m_tempEdgeBuffer.length;do{if(e>0){const s=this.m_tempEdgeBuffer[e-1];this.addVertexToCluster_(s,t)}const s=this.m_tempEdgeBuffer[e];e+=2,this.addVertexToEdge_(s,t),t=this.m_shape.getNextVertex(t)}while(e<s)}else{let e=this.m_tempEdgeBuffer.length-1;do{if(e<this.m_tempEdgeBuffer.length-2){const s=this.m_tempEdgeBuffer[e+1];this.addVertexToCluster_(s,t)}const s=this.m_tempEdgeBuffer[e];e-=2,this.addVertexToEdge_(s,t),t=this.m_shape.getNextVertex(t)}while(e>=0)}}this.m_tempEdgeBuffer.length=0,this.dbgCheckNewEdgesArray_()}getVertexFromClusterIndex(t){const e=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(e)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_vertexClusterIndex)}processSplitHelper1_(t,e,s){const i=this.getEdgeCluster(e,0),n=this.getClusterXY(i),r=this.getEdgeCluster(e,1),o=this.getClusterXY(r),a=s.getResultSegmentCount(t);let h=s.getResultSegment(t,0);const m=h.getStartXY();if(!n.isEqualPoint2D(m)){if(!this.m_bComplications){n.compare(this.m_sweepPoint)*m.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0)}this.getAffectedEdges(i,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(i)}if(!this.m_bComplications&&a>1){const t=n.compare(o),e=h.getEndXY();(n.compare(e)!==t||e.compare(o)!==t||e.compare(this.m_sweepPoint)<0)&&(this.m_bComplications=!0)}h=s.getResultSegment(t,a-1);const l=h.getEndXY();if(!o.isEqualPoint2D(l)){if(!this.m_bComplications){o.compare(this.m_sweepPoint)*l.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0)}this.getAffectedEdges(r,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(r)}this.m_tempEdgeBuffer.push(e);for(let u=0,c=this.m_tempEdgeBuffer.length;u<c;u++){const t=this.m_tempEdgeBuffer[u],s=this.getEdgeSweepNode(t);is.isValidElement(s)&&(this.m_sweepStructure.deleteNode(s),this.setEdgeSweepNode_(t,-1));const i=is.impossibleIndex3();t!==e&&this.getEdgeSweepNode(t)!==i&&(this.m_edgesToInsertInSweepStructure.push(t),this.setEdgeSweepNode_(t,i))}this.m_tempEdgeBuffer.length=0}checkAndFixIntersection_(t,e){const s=this.m_sweepStructure.getElement(t);return this.m_sweepComparator.compare(this.m_sweepStructure,s,e),!!this.m_sweepComparator.intersectionDetected()&&(this.m_sweepComparator.clearIntersectionDetectedFlag(),this.fixIntersection_(t,e),!0)}fixIntersection_(e,s){this.m_bCracked=!0;const i=this.m_sweepStructure.getElement(e),n=this.m_sweepStructure.getElement(s);let r=null,o=null;const a=this.getEdgeOriginVertices(i),h=this.m_edgeVertices.getFirstElement(a),m=this.getEdgeOriginVertices(n),l=this.m_edgeVertices.getFirstElement(m),u=this.m_shape.querySegment(h,this.m_segBuf1,!1,!1);t(u),r=this.m_segBuf1.get();const c=this.m_shape.getNextVertex(h),g=this.m_shape.getWeight(h),_=this.m_shape.getSegmentParentageBreakVertex(h),d=this.m_shape.getWeight(c),p=this.m_shape.getSegmentParentageBreakVertex(c),f=this.m_shape.getSegmentWeight(h),x=this.m_shape.getRank(h),y=this.m_shape.getRank(c),P=this.m_shape.getSegmentRank(h),E=this.m_shape.getSegmentParentage(h),C=this.m_shape.querySegment(l,this.m_segBuf2,!1,!1);t(C),o=this.m_segBuf2.get();const S=this.m_shape.getNextVertex(l),v=this.m_shape.getWeight(l),b=this.m_shape.getSegmentParentageBreakVertex(l),I=this.m_shape.getWeight(S),w=this.m_shape.getSegmentParentageBreakVertex(S),D=this.m_shape.getSegmentWeight(l),T=this.m_shape.getRank(l),N=this.m_shape.getRank(S),A=this.m_shape.getSegmentRank(l),q=this.m_shape.getSegmentParentage(l);this.m_segmentIntersector.pushSegment(r,g,x,d,y,f,P,_,p,E),this.m_segmentIntersector.pushSegment(o,v,T,I,N,D,A,b,w,q),3===this.m_segmentIntersector.intersect2D(this.m_tolerance,!0)&&(this.m_bComplications=!0),this.splitEdge_(i,n,-1,this.m_segmentIntersector),this.m_segmentIntersector.clear()}fixIntersectionPointSegment_(e,s){this.m_bCracked=!0;const i=this.m_sweepStructure.getElement(s);let n=null;const r=this.getEdgeOriginVertices(i),o=this.m_edgeVertices.getFirstElement(r),a=this.m_shape.querySegment(o,this.m_segBuf1,!1,!1);t(a),n=this.m_segBuf1.get();const h=this.m_shape.getNextVertex(o),m=this.m_shape.getWeight(o),l=this.m_shape.getSegmentParentageBreakVertex(o),u=this.m_shape.getWeight(h),c=this.m_shape.getSegmentParentageBreakVertex(h),g=this.m_shape.getSegmentWeight(o),_=this.m_shape.getRank(o),d=this.m_shape.getRank(h),p=this.m_shape.getSegmentRank(o),f=this.m_shape.getSegmentParentage(o),x=this.getClusterFirstVertex(e);this.m_segmentIntersector.pushSegment(n,m,_,u,d,g,p,l,c,f),this.m_shape.queryPoint(x,this.m_helperPoint);const y=this.m_shape.getWeight(x),P=this.m_shape.getRank(x);this.m_segmentIntersector.intersect2DEx(this.m_tolerance,this.m_helperPoint,P,y,!0),this.splitEdge_(i,-1,e,this.m_segmentIntersector),this.m_segmentIntersector.clear()}insertNewEdges_(){if(0===this.m_edgesToInsertInSweepStructure.length)return!0;this.dbgCheckNewEdgesArray_();let t=!0,e=0;const s=this.m_edgesToInsertInSweepStructure.length,i=Math.max(2*s+200,this.m_sweepStructure.size()+200);for(;this.m_edgesToInsertInSweepStructure.length;){if(this.m_edgesToInsertInSweepStructure.length>Math.max(100,this.m_shape.getTotalPointCount())||e>i){this.m_edgesToInsertInSweepStructure.length=0,this.m_bComplications=!0,t=!1;break}const s=this.m_edgesToInsertInSweepStructure.at(-1);this.m_edgesToInsertInSweepStructure.pop(),this.setEdgeSweepNode_(s,-1);const n=this.isEdgeOnSweepLine_(s);is.isValidElement(n)?(this.insertNewEdgeToSweepStructure_(s,n),e++):n!==is.impossibleIndex2()&&(t=!1),this.m_bContinuingSegmentChainOptimization=!1}return t}insertNewEdgeToSweepStructure_(t,e){let s;if(this.m_bContinuingSegmentChainOptimization?(s=this.m_sweepStructure.addElementAtPosition(this.m_prevNeighbour,this.m_nextNeighbour,t,!0,!0),this.m_bContinuingSegmentChainOptimization=!1):s=this.m_sweepStructure.addUniqueElement(t),-1===s){const e=this.m_sweepStructure.getDuplicateElement(),s=this.m_sweepStructure.getElement(e);return this.mergeEdges_(s,t),!1}if(this.setEdgeSweepNode_(t,s),this.m_sweepComparator.intersectionDetected()){this.m_sweepComparator.clearIntersectionDetectedFlag();const t=this.m_sweepComparator.getLastComparedNode();return this.m_prevNeighbour===t&&(this.m_prevNeighbour=-1),this.m_nextNeighbour===t&&(this.m_nextNeighbour=-1),this.fixIntersection_(t,s),!0}return!1}isEdgeOnSweepLine_(t){const e=this.getEdgeCluster(t,0),s=this.getEdgeCluster(t,1),i=this.getClusterXY(e),n=this.getClusterXY(s);if(w.sqrDistance(i,n)<=this.m_toleranceSqr)return this.m_bComplications=!0,-1;const r=i.compare(this.m_sweepPoint),o=n.compare(this.m_sweepPoint);return r<=0&&o>0?s:o<=0&&r>0?e:r>0&&o>0?is.impossibleIndex2():-1}fillEventQueue(){const t=new Qe(0),e=this.m_shape.queryVertexIteratorOnSelection();for(let n=e.next();n!==Nm;n=e.next())-1!==this.m_shape.getUserIndex(n,this.m_vertexClusterIndex)&&t.add(n);this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0),this.m_eventQ.clear(),this.m_eventQ.setCapacity(t.size()),this.m_eventQ.setComparator(new vu(this.m_shape));const s=w.getNAN();s.setNAN();let i=-1;for(let n=0,r=t.size();n<r;n++){const e=t.read(n);if(this.m_shape.getXY(e).isEqualPoint2D(s)){const t=this.m_shape.getUserIndex(e,this.m_vertexClusterIndex);this.mergeClusters_(i,t);continue}i=this.getClusterFromVertex(e),this.m_shape.queryXY(e,s);const r=this.m_eventQ.addBiggestElement(e);this.setClusterEventQNode_(i,r)}}fillEventQueuePass2(){const t=new Qe(0);for(let e=this.m_eventQ.getFirst();-1!==e;e=this.m_eventQ.getNext(e)){const s=this.m_eventQ.getElement(e);t.add(s)}this.m_eventQ.clear(),this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0);for(let e=0,s=t.size();e<s;e++){const s=t.read(e),i=this.getClusterFromVertex(s),n=this.m_eventQ.addBiggestElement(s);this.setClusterEventQNode_(i,n)}}getAffectedEdges(t,e){const s=this.getClusterFirstEdge(t);if(-1===s)return;let i=s;do{const s=this.getEdgeSweepNode(i);is.isValidElement(s)&&e.push(i),i=this.getNextEdge(i,t)}while(i!==s)}updateClusterXY(t,e,s,i,n){const r=this.getClusterVertices(e);for(let o=this.m_clusterVertices.getFirst(r);-1!==o;o=this.m_clusterVertices.getNext(o)){const e=this.m_clusterVertices.getElement(o);this.m_shape.setXYMonotonicPoint2D(e,s),this.m_shape.setWeight(e,i),this.m_shape.setRank(e,n),t&&this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(e,!0),this.m_shape.setSegmentParentageBreakVertex(e,!0)}}splitEdge_(t,e,s,i){this.dbgCheckEdge_(t),-1!==e&&this.dbgCheckEdge_(e),this.disconnectEdge_(t),-1!==e&&this.disconnectEdge_(e),this.processSplitHelper1_(0,t,i),-1!==e&&this.processSplitHelper1_(1,e,i),-1!==s&&i.getResultPointChanged()&&this.m_modifiedClusters.push(s);for(let o=0,a=this.m_modifiedClusters.length;o<a;o++){const t=this.m_modifiedClusters[o],e=this.getClusterEventQNode(t);-1!==e&&(this.m_eventQ.deleteNode(e),this.setClusterEventQNode_(t,-1))}const n=this.getEdgeOriginVertices(t),r=-1!==e?this.getEdgeOriginVertices(e):-1;if(this.applyIntersectorToEditShape_(n,i,0),-1!==r)this.applyIntersectorToEditShape_(r,i,1);else{const t=i.getResultPoint().getXY();this.updateClusterXY(i.getResultPointChanged(),s,t,i.getResultPointWeight(),i.getResultPointRank())}this.createEdgesAndClustersFromSplitEdge_(t,i,0),-1!==e&&this.createEdgesAndClustersFromSplitEdge_(e,i,1),this.m_edgeVertices.deleteList(n),this.deleteEdge_(t),-1!==e&&(this.m_edgeVertices.deleteList(r),this.deleteEdge_(e));for(let o=0,a=this.m_modifiedClusters.length;o<a;o++){const t=this.m_modifiedClusters[o];t===this.m_sweepPointCluster&&(this.m_bSweepPointClusterWasModified=!0);let e=this.getClusterEventQNode(t);if(-1===e){const s=this.getClusterFirstVertex(t);if(e=this.m_eventQ.addUniqueElement(s),-1===e){const e=this.m_eventQ.getDuplicateElement(),s=this.m_eventQ.getElement(e),i=this.getClusterFromVertex(s);this.mergeClusters_(i,t)}else this.setClusterEventQNode_(t,e)}}this.m_modifiedClusters.length=0}getClusterXY(t){const e=this.getClusterFirstVertex(t);return this.m_shape.getXY(e)}getClusterFirstVertex(t){const e=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(e)}dbgCheckEdge_(t){}dbgCheckCluster_(t){}dbgCheckNewEdgesArray_(){}dbgSaveSweepStructure_(e){t(0)}sweepImpl_(){this.progress_(!0),this.m_bSweepPointClusterWasModified=!1,this.m_sweepPointCluster=-1,null===this.m_sweepComparator&&(this.m_sweepStructure.disableBalancing(),this.m_sweepComparator=new Cu(this),this.m_sweepStructure.setComparator(this.m_sweepComparator));const t=[];let e=null,s=null;this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1;const i=is.impossibleIndex2(),n=is.impossibleIndex3();for(let r=this.m_eventQ.getFirst();-1!==r;){this.progress_(),this.dbgCheckSweepStructure_(),this.m_bContinuingSegmentChainOptimization=!1,this.m_prevNeighbour=-1,this.m_nextNeighbour=-1;const o=this.m_eventQ.getElement(r);this.m_sweepPointCluster=this.getClusterFromVertex(o),this.m_shape.queryXY(o,this.m_sweepPoint),this.m_sweepComparator.setSweepY(this.m_sweepPoint.y,this.m_sweepPoint.x);let a=!1;{const e=this.getClusterFirstEdge(this.m_sweepPointCluster);if(a=-1===e,!a){let s=e;do{const e=this.getEdgeSweepNode(s);-1===e?(this.m_edgesToInsertInSweepStructure.push(s),this.setEdgeSweepNode_(s,n)):e!==n&&t.push(e),s=this.getNextEdge(s,this.m_sweepPointCluster)}while(s!==e)}}if(!this.m_sweepStructure.isAutoBalancing()&&(this.m_sweepStructure.getMaxDepthEver()>4||this.m_edgesToInsertInSweepStructure.length>10)&&this.m_sweepStructure.enableBalancing(),t.length>0){this.m_bContinuingSegmentChainOptimization=1===t.length&&1===this.m_edgesToInsertInSweepStructure.length;for(let n=0,r=t.length;n<r;n++){const e=this.m_sweepStructure.getElement(t[n]);this.setEdgeSweepNode_(e,i)}let e=i,s=i;for(let n=0,r=t.length;n<r;n++){const r=t[n];if(e===i){const t=this.m_sweepStructure.getPrev(r);if(-1!==t){const s=this.m_sweepStructure.getElement(t);this.getEdgeSweepNode(s)!==i&&(e=t)}else e=-1}if(s===i){const t=this.m_sweepStructure.getNext(r);if(-1!==t){const e=this.m_sweepStructure.getElement(t);this.getEdgeSweepNode(e)!==i&&(s=t)}else s=-1}if(e!==i&&s!==i)break}for(let i=0,n=t.length;i<n;i++){const e=t[i],s=this.m_sweepStructure.getElement(e);this.m_sweepStructure.deleteNode(e),this.setEdgeSweepNode_(s,-1)}t.length=0,this.m_prevNeighbour=e,this.m_nextNeighbour=s,-1!==e&&-1!==s?this.m_bContinuingSegmentChainOptimization||this.checkAndFixIntersection_(e,s):-1===e&&-1===s&&(this.m_bContinuingSegmentChainOptimization=!1)}else a&&(null===e&&(e=new Su(this)),e.setPoint(this.m_sweepPoint),this.m_sweepStructure.searchUpperBound(e),e.intersectionDetected()&&(e.clearIntersectionDetectedFlag(),this.fixIntersectionPointSegment_(this.m_sweepPointCluster,e.getCurrentNode())));const h=this.m_bContinuingSegmentChainOptimization;!this.insertNewEdges_()&&h&&-1!==this.m_prevNeighbour&&-1!==this.m_nextNeighbour&&this.checkAndFixIntersection_(this.m_prevNeighbour,this.m_nextNeighbour),this.m_bSweepPointClusterWasModified?(this.m_bSweepPointClusterWasModified=!1,null===s&&(s=new bu(this.m_shape)),s.setPoint(this.m_sweepPoint),r=this.m_eventQ.searchUpperBound(s)):r=this.m_eventQ.getNext(r)}return this.m_bCracked}setEditShape_(t){this.m_shape=t,this.m_vertexClusterIndex=this.m_shape.createUserIndex(),this.m_edges.setCapacity(t.getSelectedCount()+32),this.m_clusters.setCapacity(t.getSelectedCount()),this.m_clusterVertices.reserveLists(t.getSelectedCount()),this.m_clusterVertices.reserveNodes(t.getSelectedCount()),this.m_edgeVertices.reserveLists(t.getSelectedCount()+32),this.m_edgeVertices.reserveNodes(t.getSelectedCount()+32);for(let e=this.m_shape.getFirstGeometry();e!==Nm;e=this.m_shape.getNextGeometry(e)){if(p(this.m_shape.getGeometryType(e)))for(let s=this.m_shape.getFirstPath(e);s!==Nm;s=this.m_shape.getNextPath(s)){const e=this.m_shape.getPathSize(s),i=this.m_shape.getFirstVertex(s);if(i===Nm)continue;let n=this.m_shape.getNextVertex(i);if(n===Nm||n===i)continue;let r=-1;t.selected(i)&&(r=this.newCluster_(i));let o=-1;-1!==r&&t.selected(n)&&(o=this.newEdge_(i),this.addEdgeToCluster(o,r));let a=o;for(let t=0,s=e-2;t<s;t++){const t=this.m_shape.getNextVertex(n);let e=-1;if(this.m_shape.selected(n)){const s=this.newCluster_(n);-1!==a&&this.addEdgeToCluster(a,s),this.m_shape.selected(t)&&(e=this.newEdge_(n),this.addEdgeToCluster(e,s))}a=e,n=t}if(this.m_shape.isClosedPath(s)){const t=this.m_shape.getNextVertex(n);if(this.m_shape.selected(n)){const e=this.newCluster_(n);if(-1!==a&&this.addEdgeToCluster(a,e),this.m_shape.selected(t)){const t=this.newEdge_(n);this.addEdgeToCluster(t,e),this.addEdgeToCluster(t,r)}}}else{let t=-1;this.m_shape.selected(n)&&(t=this.newCluster_(n),-1!==a&&this.addEdgeToCluster(a,t))}}else for(let t=this.m_shape.getFirstPath(e);t!==Nm;t=this.m_shape.getNextPath(t)){let e=this.m_shape.getFirstVertex(t);for(let s=0,i=this.m_shape.getPathSize(t);s<i;s++)this.m_shape.selected(e)&&this.newCluster_(e),e=this.m_shape.getNextVertex(e)}}this.fillEventQueue()}progress_(t=!1){}dbgCheckSweepStructure_(){}}function wu(t,e,s,i){s>0&&nu(t,s,e,!1,i);new Tu(i).executeImpl_(t,e)}function Du(t,e,s){return{vertex0:t,vertex1:e,dir:s}}class Tu{constructor(t){this.m_shape=null,this.m_spikes=[],this.m_points=new Qe(0),this.m_pointsIndex=-1,this.m_dissolvedEdges=0,this.m_progressTracker=t}executeImpl_(e,s){if(this.m_shape=e,e.getPathCount(s)<2&&e.getPointCount(s)<6)return;this.m_points.resize(0);for(let t=e.getFirstPath(s);t!==Nm;t=e.getNextPath(t)){let s=e.getFirstVertex(t);for(let i=0,n=e.getPathSize(t);i<n;i++,s=e.getNextVertex(s))this.m_points.add(s)}this.m_pointsIndex=e.createUserIndex();for(let t=0,u=this.m_points.size();t<u;++t)e.setUserIndex(this.m_points.read(t),this.m_pointsIndex,t);e.sortVerticesSimpleByY(this.m_points,0,this.m_points.size());let i=this.m_points.read(0);const n=e.getXY(i);let r=1,o=0;const a=[];for(let t=1;t<this.m_points.size();t++){const s=this.m_points.read(t);if(s===Nm)continue;if(-1===e.getUserIndex(s,this.m_pointsIndex))continue;const h=e.getXY(s);if(h.isEqualPoint2D(n))r++;else{if(r>1){for(let s=o;s<t;s++){const t=this.m_points.read(s);if(-1===e.getUserIndex(t,this.m_pointsIndex))continue;const i=e.getNextVertex(t),r=e.getPrevVertex(t);if(t!==i&&!e.isEqualXYPoint2D(i,n)){const e=Du(t,i,1);a.push(e)}if(t!==r&&r!==i&&!e.isEqualXYPoint2D(r,n)){const e=Du(t,r,-1);a.push(e)}}a.length>0&&this.processBunch_(a,n)}i=s,n.assign(h),r=1,o=t}}if(0===this.m_dissolvedEdges)return e.removeUserIndex(this.m_pointsIndex),void(this.m_pointsIndex=-1);let h=e.getPointCount(s);for(let t=0;t<this.m_points.size();t++){const s=this.m_points.read(t);if(s===Nm)continue;if(-1!==e.getUserIndex(s,this.m_pointsIndex)){e.setUserIndex(s,this.m_pointsIndex,-1);continue}const i=e.getPathFromVertex(s);e.getFirstVertex(i)===s&&e.setFirstVertex(i,Nm),e.freeVertex(s),this.m_points.write(t,Nm),h--}const m=e.createPathUserIndex();let l=e.getPathCount(s);for(let u=0,c=this.m_points.size();u<c;++u){if(this.m_points.read(u)===Nm)continue;let i=this.m_points.read(u);if(-1!==e.getUserIndex(i,this.m_pointsIndex))continue;let n=e.getPathFromVertex(i),r=-1;if(2===e.getPathUserIndex(n,m)){n=Nm;for(let t=e.getNextVertex(i);t!==i;t=e.getNextVertex(t)){const s=e.getPathFromVertex(t);if(2!==e.getPathUserIndex(s,m)){n=s,i=t;break}}n===Nm&&(n=e.insertPath(s,Nm),e.setClosedPath(n,!0),l++),t(n!==Nm)}e.setPathUserIndex(n,m,2),r=e.getFirstVertex(n);let o=0,a=!1,h=i;do{r===h&&(a=!0),e.setUserIndex(h,this.m_pointsIndex,1);const t=e.getPathFromVertex(h);t!==n&&(2!==e.getPathUserIndex(t,m)&&(e.setPathUserIndex(t,m,1),e.setFirstVertex(t,Nm)),e.setPathToVertex(h,n)),o++,h=e.getNextVertex(h)}while(h!==i);a||e.setFirstVertex(n,i),e.setPathSize(n,o)}for(let t=e.getFirstPath(s);t!==Nm;){const s=e.getNextPath(t);1!==e.getPathUserIndex(t,m)&&e.getFirstVertex(t)!==Nm||(e.removePathOnly(t),l--),t=s}e.setGeometryVertexCount(s,h),e.setGeometryPathCount(s,l),e.removePathUserIndex(m),e.removeUserIndex(this.m_pointsIndex),this.m_pointsIndex=-1,e.dbgVerifyVertexCounts(),e.filterClosePoints(0,!0,!1,!1,s)}processBunch_(t,e){t.sort(((t,s)=>{const i=this.m_shape.getXY(t.vertex1).sub(e),n=this.m_shape.getXY(s.vertex1).sub(e),r=w.compareVectors(i,n);return 0===r?t.dir<s.dir?-1:1:r}));let s=0;const i=this.m_shape.getXY(t[0].vertex1);let n=1;const r=this.m_shape.hasCurves();for(let o=1,a=t.length;o<a;o++){const e=this.m_shape.getXY(t[o].vertex1);if(!(e.isEqualPoint2D(i)&&(n++,o+1<a))){if(2===n){const e=t[s],i=t[s+1],n=e.dir;if(n!==i.dir){let t=!0;if(r&&(t=!this.m_shape.isCurve(1===e.dir?e.vertex0:e.vertex1)&&!this.m_shape.isCurve(1===i.dir?i.vertex0:i.vertex1)),t){if(1===n){const t=e.vertex0,s=i.vertex0;this.m_shape.setNextVertex(t,s),this.m_shape.setPrevVertex(s,t),this.m_shape.getPrevVertex(t)===s&&(this.m_shape.setUserIndex(t,this.m_pointsIndex,-1),this.m_shape.setUserIndex(s,this.m_pointsIndex,-1));const n=e.vertex1,r=i.vertex1;this.m_shape.setPrevVertex(n,r),this.m_shape.setNextVertex(r,n),this.m_shape.getNextVertex(n)===r&&(this.m_shape.setUserIndex(n,this.m_pointsIndex,-1),this.m_shape.setUserIndex(r,this.m_pointsIndex,-1))}else{const t=e.vertex0,s=i.vertex0;this.m_shape.setPrevVertex(t,s),this.m_shape.setNextVertex(s,t),this.m_shape.getNextVertex(t)===s&&(this.m_shape.setUserIndex(t,this.m_pointsIndex,-1),this.m_shape.setUserIndex(s,this.m_pointsIndex,-1));const n=e.vertex1,r=i.vertex1;this.m_shape.setNextVertex(n,r),this.m_shape.setPrevVertex(r,n),this.m_shape.getPrevVertex(n)===r&&(this.m_shape.setUserIndex(n,this.m_pointsIndex,-1),this.m_shape.setUserIndex(r,this.m_pointsIndex,-1))}this.m_dissolvedEdges+=2}}}i.assign(e),s=o,n=1}}t.length=0}}function Nu(t){for(let e=t.getFirstGeometry();e!==Nm;e=t.getNextGeometry(e))if(p(t.getGeometryType(e)))return!0;return!1}function Au(t,e,s,i){if(!Nu(t))return!1;const n=new Gu(i);n.m_shape=t,n.m_tolerance=e,n.m_bTrackChanges=s;let r=!1;const o=t.hasCurves()?5:15;return r=t.getTotalPointCount()<o?n.crackBruteForce_():n.crackerPlaneSweep_(),r}function qu(t,e,s,i,n){if(!Nu(e))return!1;let r=new Gu(n);if(r.m_shape=e,r.m_tolerance=s,r.m_bAllowCoincident=t,r.m_bNeedsNonSimpleResult=null!==i,r.needsCrackingImpl_())return i&&i.assign(r.m_nonSimpleResult),!0;const o=new Y;o.setSwapCoordinates(),e.applyTransformation(o),r=new Gu(n),r.m_shape=e,r.m_tolerance=s,r.m_bAllowCoincident=t,r.m_bNeedsNonSimpleResult=null!==i;const a=r.needsCrackingImpl_();return e.applyTransformation(o),!!a&&(i&&i.assign(r.m_nonSimpleResult),!0)}function Fu(t,e,s,i){const r=e.getGeometryType();if(p(r)){return new Gu(i).crackAWithBMultiPath_(t,e,s)}n("crack_A_with_B")}function Mu(t,e){return{t,index:e}}class Gu{crackBruteForce_(){let t=this.crackBruteForceImpl_();if(!t&&this.m_shape.hasCurves()){const e=new Y;e.setSwapCoordinates(),this.m_shape.applyTransformation(e),t=this.crackBruteForceImpl_(),this.m_shape.applyTransformation(e)}return t}crackBruteForceImpl_(){let e=!1;const s=new SE,i=new SE,n=ge.constructEmpty(),r=ge.constructEmpty(),o=!1,a=new Ge,h=new gu,m=this.m_shape.getTotalPointCount(),l=m*m*2,c=this.m_shape.queryVertexIteratorOnSelection();for(let g=c.next();g!==Nm;g=c.next()){const m=this.m_shape.getGeometryType(c.currentGeometry());let _=1,d=1,p=1,f=0,x=0,y=0;const P=this.m_shape.getSegmentParentage(g);let E=!1,C=!1,S=null,v=!1;if(u(m))_=this.m_shape.getWeight(g),f=this.m_shape.getRank(g);else{if(S=this.getSegment_(g,s),null===S)continue;const t=this.m_shape.getVertexIndex(g);_=this.m_shape.getWeightWithIndex(t),f=this.m_shape.getRankWithIndex(t),p=this.m_shape.getSegmentWeightWithIndex(t),y=this.m_shape.getSegmentRankWithIndex(t),E=this.m_shape.getSegmentParentageBreakVertex(g);{const t=this.m_shape.getNextVertex(g);d=this.m_shape.getWeight(t),x=this.m_shape.getRank(t),C=this.m_shape.getSegmentParentageBreakVertex(t)}if(S.queryLooseEnvelope(n),n.inflateCoords(this.m_tolerance,this.m_tolerance),S.isDegenerate(this.m_tolerance)){if(!S.isDegenerate(0))continue;v=!0,S=null}}const b=new Mm({copy:c});let I=b.next();I!==Nm&&(I=b.next());let w=0;for(;I!==Nm;I=b.next()){if(0!==w){w--;continue}if(this.m_shape.getTotalPointCount()>l)return e;this.progress_();const m=this.m_shape.getGeometryType(b.currentGeometry());let D=null,T=!1,N=0,A=0,q=0,F=0,M=0,G=0,V=!1,Y=!1;const X=this.m_shape.getSegmentParentage(I);if(u(m))N=this.m_shape.getWeight(I),F=this.m_shape.getRank(I);else{if(D=this.getSegment_(I,i),null===D)continue;const t=this.m_shape.getVertexIndex(I);N=this.m_shape.getWeightWithIndex(t),F=this.m_shape.getRankWithIndex(t),q=this.m_shape.getSegmentWeightWithIndex(t),G=this.m_shape.getSegmentRankWithIndex(t),V=this.m_shape.getSegmentParentageBreakVertex(I);{const t=this.m_shape.getNextVertex(I);A=this.m_shape.getWeight(t),M=this.m_shape.getRank(t),Y=this.m_shape.getSegmentParentageBreakVertex(t)}if(D.queryLooseEnvelope(r),D.isDegenerate(this.m_tolerance)){if(!D.isDegenerate(0))continue;T=!0,D=null}}let k=0,R=0;if(null!==S&&null!==D){if(n.isIntersectingNe(r)){0!==cE(!0,!0,S,D,this.m_tolerance,!0)&&(h.pushSegment(S,_,f,d,x,p,y,E,C,P),h.pushSegment(D,N,F,A,M,q,G,V,Y,X),h.intersect2D(this.m_tolerance,!0),e||=h.getSegmentChanged(0)||h.getSegmentChanged(1),k=h.getResultSegmentCount(0),R=h.getResultSegmentCount(1),k+R>0&&(this.m_shape.splitSegmentWithIntersector(g,h,0,!0,!0),this.m_shape.splitSegmentWithIntersector(I,h,1,!0,!0),this.m_bTrackChanges&&(h.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(g,!0),h.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(I,!0))),R>1&&(w+=R-1),h.clear())}}else if(null!==S){const t=this.m_shape.getXY(I);if(n.contains(t)){if(h.pushSegment(S,_,f,d,x,p,y,E,C,P),this.m_shape.queryPoint(I,a),h.intersect2DEx(this.m_tolerance,a,F,N,o),e||=h.getSegmentChanged(0)||h.getResultPointChanged(),k=h.getResultSegmentCount(0),k>0)if(this.m_bTrackChanges&&(h.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(g,!0),h.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(I,!0)),this.m_shape.splitSegmentWithIntersector(g,h,0,!0,!0),T){let t=Nm;for(let e=this.m_shape.getNextVertex(I);e!==Nm&&e!==I&&(D=this.getSegment_(e,i),t=e,null!=D&&D.isDegenerate(0));e=this.m_shape.getNextVertex(e));for(let e=I;e!==Nm&&(this.m_shape.setPoint(e,h.getResultPoint(),!0),e!==t);e=this.m_shape.getNextVertex(e));}else this.m_shape.setPoint(I,h.getResultPoint(),!0);h.clear()}}else{if(null===D)continue;{const t=this.m_shape.getXY(g);if(r.inflateCoords(this.m_tolerance,this.m_tolerance),r.contains(t)){if(h.pushSegment(D,N,F,A,M,q,G,V,Y,X),this.m_shape.queryPoint(g,a),h.intersect2DEx(this.m_tolerance,a,f,_,o),e||=h.getSegmentChanged(0)||h.getResultPointChanged(),R=h.getResultSegmentCount(0),R>0)if(this.m_bTrackChanges&&(h.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(I,!0),h.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(g,!0)),this.m_shape.splitSegmentWithIntersector(I,h,0,!0,!0),w+=R-1,v){let t=Nm;for(let e=this.m_shape.getNextVertex(g);e!==Nm&&e!==g&&(D=this.getSegment_(e,i),t=e,null!=D&&D.isDegenerate(0));e=this.m_shape.getNextVertex(e));for(let e=g;e!==Nm&&(this.m_shape.setPoint(e,h.getResultPoint(),!0),e!==t);e=this.m_shape.getNextVertex(e));}else this.m_shape.setPoint(g,h.getResultPoint(),!0);h.clear()}}}if(k+R!==0&&0!==k){let e=!1;for(;S=this.getSegment_(g,s),null!=S&&(S.queryEnvelope(n),S.isDegenerate(this.m_tolerance));){if(!(k>1)){e=!0;break}g=c.next(),k--,t(g!==Nm)}if(e)break}}}return e}crackerPlaneSweep_(){return this.planesweep_()}planesweep_(){return new Iu(this.m_progressTracker,this.m_bTrackChanges).sweep(this.m_shape,this.m_tolerance)}needsCrackingImpl_(){let e=!1;const s=new Qe(0);s.resize(this.m_shape.getSelectedCount());const i=this.m_shape.queryVertexIteratorOnSelection();for(let t=0,u=i.next();u!==Nm;++t,u=i.next())s.write(t,u);this.m_shape.sortVerticesSimpleByY(s,0,s.size()),s.add(Nm);const n=this.m_shape.createUserIndex(),r=this.m_shape.createUserIndex();this.m_sweepComparator=new eu(this.m_shape,this.m_tolerance,!this.m_bAllowCoincident),this.m_sweepStructure.setComparator(this.m_sweepComparator);let o=null;const a=[],h=[];let m=0;const l=new w;for(let u=s.read(m++);u!==Nm;){this.m_shape.queryXY(u,l);let i=!1;do{let t=this.m_shape.getNextVertex(u),e=this.m_shape.getPrevVertex(u);i||=t!==Nm||e!==Nm,t===Nm||this.m_shape.selected(t)||(t=Nm),e===Nm||this.m_shape.selected(e)||(e=Nm),t!==Nm&&this.m_shape.compareVerticesSimpleY(u,t)<0&&(h.push(u),h.push(t)),e!==Nm&&this.m_shape.compareVerticesSimpleY(u,e)<0&&(h.push(e),h.push(e));const o=this.m_shape.getUserIndex(u,n);-1!==o&&(a.push(o),this.m_shape.setUserIndex(u,n,-1));const l=this.m_shape.getUserIndex(u,r);-1!==l&&(a.push(l),this.m_shape.setUserIndex(u,r,-1)),u=s.read(m++)}while(u!==Nm&&this.m_shape.isEqualXYPoint2D(u,l));if(!i&&(null===o&&(o=new su(this.m_shape,this.m_tolerance)),o.setPoint(l),this.m_sweepStructure.searchUpperBound(o),o.intersectionDetected())){e=!0,this.m_bNeedsNonSimpleResult&&(t(0),this.m_nonSimpleResult=new ci(6,-1,-1));break}let c=1===a.length&&2===h.length;const g=32;a.length>g&&J(a);let _=-1,d=-1;if(!c)for(let t=0,s=a.length;t<s;t++){const s=a[t],i=this.m_sweepStructure.getPrev(s);if(-1!==i&&-1===a.indexOf(i))if(-1===_)_=i;else{if(e=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new ci(6,-1,-1)}const n=this.m_sweepStructure.getNext(s);if(-1!==n&&-1===a.indexOf(n))if(-1===d)d=n;else{if(e=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new ci(6,-1,-1)}if(-1!==_&&-1!==d)break}if(e&&!this.m_bNeedsNonSimpleResult)break;if(this.m_sweepComparator.setSweepY(l.y,l.x),!c){for(let t=0,e=a.length;t<e;t++){const e=a[t];this.m_sweepStructure.deleteNode(e)}a.length=0}if(!c&&-1!==_&&-1!==d&&this.checkForIntersections_(_,d)){e=!0,this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult());break}for(let t=0,s=h.length;t<s;t+=2){const s=h[t],i=h[t+1];let o;if(c?(o=this.m_sweepStructure.replaceElementAtPosition(a[0],s,!0,!0),a.length=0,c=!1):o=this.m_sweepStructure.addElement(s),this.m_sweepComparator.intersectionDetected()){this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult()),e=!0;break}-1===this.m_shape.getUserIndex(i,n)?this.m_shape.setUserIndex(i,n,o):this.m_shape.setUserIndex(i,r,o)}if(e)break;h.length=0}return this.m_shape.removeUserIndex(n),this.m_shape.removeUserIndex(r),e}checkForIntersections_(t,e){const s=this.m_sweepStructure.getElement(t);this.m_sweepComparator.compare(this.m_sweepStructure,s,e);const i=this.m_sweepComparator.intersectionDetected();return this.m_sweepComparator.clearIntersectionDetectedFlag(),i}getSegment_(t,e){return Gu.st_getSegment(this.m_shape,t,e)}static st_getSegment(t,e,s){return t.querySegment(e,s,!1,!1)?s.get():null}dbgPrintSweepEdge(t){}dbgPrintSweepStructure(){}dbgSaveSweepStructure(t=null){}dbgCheckSweepStructure(){}progress_(t=!1){this.m_progressCounter++}crackAWithBMultiPath_(e,i,n){const r=ge.constructEmpty();e.queryLooseEnvelope(r);const o=ge.constructEmpty();if(i.queryLooseEnvelope(o),o.inflateCoords(n,n),!o.isIntersecting(r))return e;const a=e.getImpl(),h=a.getAccelerators();let m=null,l=null;h&&(l=h.getQuadTree()),Vu(e,_(i))&&(m=Hs(a,o),l=m);const u=l?l.getIteratorForQT():null,c=i.querySegmentIterator(),g=e.querySegmentIterator(),d=new Array(15),p=[];for(;c.nextPath();)for(;c.hasNextSegment();){const t=c.nextSegment();if(l){u.resetIterator(t,n);for(let e=u.next();-1!==e;e=u.next()){this.progress_();const s=l.getElement(e);if(g.resetToVertex(s,-1),g.hasNextSegment()){const e=g.nextSegment().intersect(t,null,d,null,n);for(let t=0;t<e;t++){const e=d[t];if(0===e||1===e)continue;const s=Mu(e,g.getStartPointIndex());p.push(s)}}}}else{const e=ge.constructEmpty();if(t.queryLooseEnvelope(e),e.inflateCoords(n,n),!r.isIntersecting(e))continue;for(g.resetToFirstPath();g.nextPath();)for(;g.hasNextSegment();){const s=g.nextSegment(),i=ge.constructEmpty();if(s.queryLooseEnvelope(i),!i.isIntersecting(e))continue;const r=s.intersect(t,null,d,null,n);for(let t=0;t<r;t++){const e=d[t];if(0===e||1===e)continue;const s=Mu(e,g.getStartPointIndex());p.push(s)}}}}if(0===p.length)return e;p.sort(((t,e)=>t.index<e.index?-1:t.index>e.index?1:t.t<e.t?-1:t.t>e.t?1:0));const f=e.createInstance();if(f.getGeometryType()===s.enumPolygon){f.setFillRule(e.getFillRule())}for(g.resetToFirstPath();g.nextPath()&&!g.hasNextSegment(););t(g.hasNextSegment());let x=g.nextSegment();const y=new SE;let P=-1;for(let s=0,_=p.length;s<_;){const e=p[s].index;let i=s+1;for(;i<_&&p[i].index===e;)++i;for(;g.getStartPointIndex()<e;){this.progress_();const e=g.hasNextSegment(),s=g.getPathIndex();if((e||!g.isClosingSegment()||g.isCurve())&&(t(null!==x),f.addSegment(x,P!==s)),P=s,!e){for(g.isPathClosed();g.nextPath()&&!g.hasNextSegment(););t(g.hasNextSegment())}x=g.nextSegment()}let n=0;for(let o=s;o<i;o++){const e=p[o].t;if(e===n)continue;t(null!==x),x.queryCut(n,e,y),n=e;const s=g.getPathIndex();f.addSegment(y.get(),P!==s),P=s}const r=g.hasNextSegment();if((r||!g.isClosingSegment()||g.isCurve())&&(t(null!=x),x.queryCut(n,1,y),f.addSegment(y.get(),!1)),r)x=g.nextSegment();else{for(;g.nextPath()&&!g.hasNextSegment(););x=g.hasNextSegment()?g.nextSegment():null}s=i}if(null!==x){const t=g.getPathIndex();(g.hasNextSegment()||!g.isClosingSegment()||g.isCurve())&&f.addSegment(x,P!==t),P=t}let E=g.hasNextSegment();for(;;){if(!E){for(;g.nextPath()&&(E=g.hasNextSegment(),!E););if(!E)break}x=g.nextSegment();const t=g.getPathIndex();E=g.hasNextSegment();(E||!g.isClosingSegment()||g.isCurve())&&f.addSegment(x,P!==t),P=t}return f}constructor(t){this.m_shape=null,this.m_progressTracker=null,this.m_nonSimpleResult=new ci,this.m_tolerance=0,this.m_sweepComparator=null,this.m_progressCounter=0,this.m_bTrackChanges=!1,this.m_bNeedsNonSimpleResult=!1,this.m_bAllowCoincident=!0,this.m_sweepStructure=new ms,this.m_progressTracker=t}}function Vu(t,e){const s=t.getPointCount();if(s<16)return!1;const i=1;return 2*s+1*(Math.log(s)/Math.log(2))*e<i*s*e}Gu.s_bForceBruteForce=!0;class Yu{constructor(t,e){this.m_monotoneParts=D(SE,16),this.m_xOrds=H(16,Number.NaN),this.m_inputPoint=w.getNAN(),this.m_miny=0,this.m_maxy=0,this.m_windnum=0,this.m_bAlternate=t,this.m_tolerance=e,this.m_toleranceSqr=e*e,this.m_bTestBorder=!!e,this.m_bBreak=!1}_DoOne(t){if(!this.m_bTestBorder&&(this.m_bAlternate&&this.m_inputPoint.equals(t.getStartXY())||this.m_inputPoint.equals(t.getEndXY())))return void(this.m_bBreak=!0);if(t.getStartY()===this.m_inputPoint.y&&t.getStartY()===t.getEndY()){if(this.m_bAlternate&&!this.m_bTestBorder){const e=Math.min(t.getStartX(),t.getEndX()),s=Math.max(t.getStartX(),t.getEndX());this.m_inputPoint.x>e&&this.m_inputPoint.x<s&&(this.m_bBreak=!0)}return}let e=!1;const s=Math.max(t.getStartX(),t.getEndX());if(this.m_inputPoint.x>s)e=!0;else if(this.m_inputPoint.x>=Math.min(t.getStartX(),t.getEndX())){const i=t.intersectionOfYMonotonicWithAxisX(this.m_inputPoint.y,s);e=!Number.isNaN(i)&&i<=this.m_inputPoint.x}if(e){if(this.m_inputPoint.y===t.getStartY()){if(this.m_inputPoint.y<t.getEndY())return}else if(this.m_inputPoint.y===t.getEndY()&&this.m_inputPoint.y<t.getStartY())return;this.m_bAlternate?this.m_windnum^=1:this.m_windnum+=t.getStartY()>t.getEndY()?1:-1}}_Result(){return!!this.m_windnum}testBorder(t){const e=t.getClosestCoordinate(this.m_inputPoint,!1),s=t.getCoord2D(e);return w.sqrDistance(s,this.m_inputPoint)<=this.m_toleranceSqr}setInputPoint(t){this.m_inputPoint.setCoordsPoint2D(t),this.m_miny=t.y-this.m_tolerance,this.m_maxy=t.y+this.m_tolerance}processSegment(e){const s=e.queryInterval(0,1);if(s.vmin>this.m_maxy||s.vmax<this.m_miny)return!1;if(this.m_bTestBorder&&this.testBorder(e))return!0;if(s.vmin>this.m_inputPoint.y||s.vmax<this.m_inputPoint.y)return!1;let i=0;if(e.isCurve()&&(0===this.m_monotoneParts.length&&(this.m_monotoneParts.length=128),i=e.getMonotonicParts(this.m_monotoneParts,!0),t(this.m_monotoneParts.length>=i)),i>0)for(let t=0;t<i;t++){const e=this.m_monotoneParts[t].get(),s=A.construct(e.getStartY(),e.getEndY());if(!(s.vmin>this.m_inputPoint.y||s.vmax<this.m_inputPoint.y)&&(this._DoOne(e),this.m_bBreak))return!0}else if(this._DoOne(e),this.m_bBreak)return!0;return!1}result(){return t(0),2}}function Xu(t,e,s,i){const n=new ge;t.queryLooseEnvelope(n),n.inflateCoords(i,i);const r=0===t.getFillRule(),o=new Yu(r,i);o.setInputPoint(s);const a=n.clone();a.xmax=s.x+i,a.ymin=s.y-i,a.ymax=s.y+i;const h=t.getImpl().querySegmentIterator(),m=e.getIterator(a,i);for(let l=m.next();-1!==l;l=m.next())if(h.resetToVertex(e.getElement(l),-1),h.hasNextSegment()){const t=h.nextSegment();if(o.processSegment(t))return-1}return o._Result()?1:0}function ku(t,e,s){const i=0===t.getFillRule(),n=new Yu(i,s);n.setInputPoint(e);const r=t.getImpl().querySegmentIterator();for(;r.nextPath();)for(;r.hasNextSegment();){const t=r.nextSegment();if(n.processSegment(t))return-1}return n._Result()?1:0}function Ru(t,e,s){return e.isEmpty()?0:Bu(t,e.getXY(),s)}function Bu(e,s,i){if(e.isEmpty())return 0;const n=ge.constructEmpty();if(e.queryLooseEnvelope(n),n.inflateCoords(i,i),!n.contains(s))return 0;const r=e.getImpl().getAccelerators();if(r){r.getRasterizedGeometry()&&t(0);const n=r.getQuadTree();if(n)return Xu(e,n,s,i)}return ku(e,s,i)}function Lu(t,e){const s=t.getPointCount();if(s<16)return!1;const i=1;return 2*s+1*(Math.log(s)/Math.log(2))*e<i*s*e}function Hu(t,e,s,i,n){const r=new ju(n);return r.m_shape=t,r.m_geometry=e,r.m_sortedVertices=s,r.m_bFixSelfTangency=i,r.fixRingOrientation_()}function zu(t,e,s){const i=new ju(s);return i.m_shape=t,i.m_geometry=e,i.m_sortedVertices=null,i.m_bFixSelfTangency=!1,i.fixRingOrientationForMp2sp_()}class Uu{getDirection_(t){return this.m_shape.getNextVertex(this.getEnd1(t))===this.getEnd2(t)}getEnd_(t){const e=this.getEnd1(t),s=this.getEnd2(t);return this.m_shape.getNextVertex(e)===s?s:e}constructor(t){this.m_end1Nodes=[],this.m_end2Nodes=[],this.m_directions=[],this.m_shape=t,this.m_firstFree=-1}getSegment(t){return this.m_shape.getSegment(this.getStart(t))}isBottomUp(e){let s=this.getEnd1(e),i=this.getEnd2(e);this.m_shape.getPrevVertex(s)===i&&(i=q(s,s=i));const n=w.getNAN(),r=w.getNAN();return this.m_shape.queryXY(s,n),this.m_shape.queryXY(i,r),t(!n.equals(r)),n.y<r.y}getStart(t){const e=this.getEnd1(t),s=this.getEnd2(t);return this.m_shape.getNextVertex(e)===s?e:s}getEnd1(t){return this.m_end1Nodes[t]}getEnd2(t){return this.m_end2Nodes[t]}freeEdge(t){this.m_end1Nodes[t]=this.m_firstFree,this.m_firstFree=t}newEdge(t){if(-1!==this.m_firstFree){const e=this.m_firstFree;return this.m_firstFree=this.m_end1Nodes[e],this.m_end1Nodes[e]=t,this.m_end2Nodes[e]=this.m_shape.getNextVertex(t),e}const e=this.m_end1Nodes.length;return this.m_end1Nodes.push(t),this.m_end2Nodes.push(this.m_shape.getNextVertex(t)),e}getShape(){return this.m_shape}getPath(t){return this.m_shape.getPathFromVertex(this.getEnd1(t))}}let Ou=class extends hs{constructor(t){super(),this.m_line1=new CE,this.m_line2=new CE,this.m_leftElm=-1,this.m_leftx=0,this.m_seg1=null,this.m_helper=t}compare(t,e,s){const i=t.getElement(s),n=this.m_helper.m_edges;let r;if(this.m_leftElm===e)r=this.m_leftx;else{if(this.m_seg1=n.getSegment(e),this.m_seg1)r=this.m_seg1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0);else{n.getShape().queryLineConnector(n.getStart(e),this.m_line1,!0),this.m_seg1=this.m_line1,r=this.m_line1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)}this.m_leftx=r,this.m_leftElm=e}let o,a=n.getSegment(i);if(a)o=a.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0);else{n.getShape().queryLineConnector(n.getStart(i),this.m_line2,!0),a=this.m_line2,o=this.m_line2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)}if(r===o){const t=n.isBottomUp(e),s=n.isBottomUp(i),h=t?this.m_seg1.getEndY():this.m_seg1.getStartY(),m=s?a.getEndY():a.getStartY(),l=Math.min(h,m);let u=.5*(l+this.m_helper.m_yScanline);u===this.m_helper.m_yScanline&&(u=l),r=this.m_seg1.intersectionOfYMonotonicWithAxisX(u,0),o=a.intersectionOfYMonotonicWithAxisX(u,0),r===o&&I("")}return r<o?-1:r>o?1:0}reset(){this.m_leftElm=-1}};class Wu{constructor(t){this.m_node=-1,this.m_index=0,this.m_sortedVertices=t.m_sortedVertices,this.m_sortedVerticesArray=t.m_sortedVerticesArray,this.m_sortedVertices&&(this.m_node=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()))}next(){if(this.m_sortedVertices){const t=this.m_node;if(-1===t)return Nm;const e=this.m_sortedVertices.getData(t);return this.m_node=this.m_sortedVertices.getNext(t),e}if(this.m_index<this.m_sortedVerticesArray.size()){const t=this.m_sortedVerticesArray.read(this.m_index);return this.m_index++,t}return Nm}}class ju{constructor(t){this.m_edges=null,this.m_shape=null,this.m_AET=new ms,this.m_yScanline=0,this.m_geometry=Nm,this.m_unknownRingOrientationCount=-1,this.m_sortedVertices=null,this.m_sortedVerticesArray=null,this.m_unknownNodes=[],this.m_node1UserIndex=-1,this.m_node2UserIndex=-1,this.m_pathOrientationIndex=-1,this.m_pathParentageIndex=-1,this.m_pathParentsIndex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_progressTracker=t,this.m_AET.disableBalancing(),this.m_sweepComparator=new Ou(this),this.m_AET.setComparator(this.m_sweepComparator)}fixRingOrientation_(){const t=this.fixRingOrientationImplMain_();return-1===this.m_pathOrientationIndex||this.fixRingOrientationImplSimplify_(),t}fixRingOrientationForMp2sp_(){return this.fixRingOrientationImplMain_(),-1===this.m_pathOrientationIndex?-1:this.fixRingOrientationImplMp2sp_()}processBunchForRingOrientationTest_(t){return this.processBunchForRingOrientationTestOddEven_(t)}processBunchForRingOrientationTestOddEven_(e){let s=!1;if(this.m_edges||(this.m_edges=new Uu(this.m_shape)),this.m_unknownNodes.length=0,this.processBunchForRingOrientationRemoveEdges_(e),!this.m_AET.isAutoBalancing()){let t=0;for(let s=0,i=e.length;s<i;s++){-1!==e[s]&&t++}(t>10||this.m_AET.getMaxDepthEver()>4)&&this.m_AET.enableBalancing()}for(let t=0,i=e.length;t<i;t++){const s=e[t];s!==Nm&&this.insertEdge_(s,-1)}for(let i=0;i<this.m_unknownNodes.length&&this.m_unknownRingOrientationCount>0;i++){const e=this.m_unknownNodes[i],n=this.m_AET.getElement(e),r=this.m_edges.getPath(n),o=this.m_shape.getPathUserIndex(r,this.m_pathOrientationIndex);let a=Nm;if(0===o){let i=this.m_AET.getPrev(e),n=e,r=!1;for(;i!==ms.st_nullNode();){const t=this.m_AET.getElement(i),e=this.m_edges.getPath(t);if(0!==this.m_shape.getPathUserIndex(e,this.m_pathOrientationIndex)){a=e;break}n=i,i=this.m_AET.getPrev(i)}if(i===ms.st_nullNode())r=!0,i=n;else{const t=this.m_AET.getElement(i);r=this.m_edges.isBottomUp(t),i=this.m_AET.getNext(i),r=!r}do{const e=this.m_AET.getElement(i),o=this.m_edges.getPath(e);if(0===this.m_shape.getPathUserIndex(o,this.m_pathOrientationIndex)){if(r!==this.m_edges.isBottomUp(e)){const t=this.m_shape.getFirstVertex(o);this.m_shape.reverseRingInternal(t),this.m_shape.setLastVertex(o,this.m_shape.getPrevVertex(t)),s=!0}if(this.m_shape.setPathUserIndex(o,this.m_pathOrientationIndex,r?3:2),!r){let e=this.m_shape.getPathUserIndex(a,this.m_pathOrientationIndex);2===e?(a=this.m_shape.getPathUserIndex(a,this.m_pathParentsIndex),e=this.m_shape.getPathUserIndex(a,this.m_pathOrientationIndex),t(3===e)):t(3===e);const s=this.m_shape.getPathUserIndex(a,this.m_pathParentageIndex);this.m_shape.setPathUserIndex(a,this.m_pathParentageIndex,o),this.m_shape.setPathUserIndex(o,this.m_pathParentageIndex,s),this.m_shape.setPathUserIndex(o,this.m_pathParentsIndex,a)}if(this.m_unknownRingOrientationCount--,!this.m_unknownRingOrientationCount)return s}a=o,n=i,i=this.m_AET.getNext(i),r=!r}while(n!==e)}}return s}processBunchForRingOrientationRemoveEdges_(t){for(let e=0,s=t.length;e<s;e++){const s=t[e],i=this.m_shape.getUserIndex(s,this.m_node1UserIndex),n=this.m_shape.getUserIndex(s,this.m_node2UserIndex);if(-1!==i){const t=this.m_AET.getElement(i);this.m_edges.freeEdge(t),this.m_shape.setUserIndex(s,this.m_node1UserIndex,-1)}if(-1!==n){const t=this.m_AET.getElement(n);this.m_edges.freeEdge(t),this.m_shape.setUserIndex(s,this.m_node2UserIndex,-1)}let r=-1;-1!==i&&-1!==n?(this.m_AET.deleteNode(i),this.m_AET.deleteNode(n),t[e]=Nm):r=-1!==i?i:n,-1!==r&&(this.insertEdge_(s,r)||this.m_AET.deleteNode(r),t[e]=Nm)}}dbgVerifyRingOrientation_(){}insertEdge_(t,e){const s=w.getNAN(),i=w.getNAN();this.m_shape.queryXY(t,s);const n=this.m_shape.getNextVertex(t);this.m_shape.queryXY(n,i);let r=!1;if(s.y<i.y){r=!0;const s=this.m_edges.newEdge(t);let i;-1===e?i=this.m_AET.addElement(s):(i=e,this.m_AET.setElement(i,s));-1===this.m_shape.getUserIndex(n,this.m_node1UserIndex)?this.m_shape.setUserIndex(n,this.m_node1UserIndex,i):this.m_shape.setUserIndex(n,this.m_node2UserIndex,i);const o=this.m_shape.getPathFromVertex(t);0===this.m_shape.getPathUserIndex(o,this.m_pathOrientationIndex)&&this.m_unknownNodes.push(i)}const o=this.m_shape.getPrevVertex(t);if(this.m_shape.queryXY(o,i),s.y<i.y){r=!0;const s=this.m_edges.newEdge(o);let i;-1===e?i=this.m_AET.addElement(s):(i=e,this.m_AET.setElement(i,s));-1===this.m_shape.getUserIndex(o,this.m_node1UserIndex)?this.m_shape.setUserIndex(o,this.m_node1UserIndex,i):this.m_shape.setUserIndex(o,this.m_node2UserIndex,i);const n=this.m_shape.getPathFromVertex(t);0===this.m_shape.getPathUserIndex(n,this.m_pathOrientationIndex)&&this.m_unknownNodes.push(i)}return r}fixRingSelfTangency_(){const e=[],s=[];let i=-1,n=-1;const r=new w;let o=Nm,a=Nm,h=-1;const m=new Wu(this);for(let t=m.next();t!==Nm;t=m.next()){const m=new w;this.m_shape.queryXY(t,m);const l=this.m_shape.getPathFromVertex(t);if(r.equals(m)&&a===l){if(-1===n&&(i=this.m_shape.createPathUserIndex(),this.m_shape.fillPathUserIndexForGeometry(this.m_geometry,i,-1),n=this.m_shape.createUserIndex(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,n,-1)),-1===h){h=s.length,this.m_shape.setUserIndex(o,n,h),s.push(1);-1===this.m_shape.getPathUserIndex(l,i)&&(this.m_shape.setPathUserIndex(l,i,o),e.push(l))}this.m_shape.setUserIndex(t,n,h),s[s.length-1]++}else h=-1,r.assign(m);o=t,a=l}if(0===e.length)return!1;t(-1!==i);for(let t=0,l=e.length;t<l;t++){const r=e[t];let o=this.m_shape.getPathUserIndex(r,i);const a=this.m_shape.getUserIndex(o,n),h=[],m=[];h.push(o),m.push(a);for(let t=this.m_shape.getNextVertex(o);t!==o;t=this.m_shape.getNextVertex(t)){const e=t,i=this.m_shape.getUserIndex(e,n);if(-1!==i){if(0===m.length){m.push(i),h.push(e);continue}if(m.at(-1)===i){const r=h.at(-1);this.m_shape.peelALoopIntoAPath(r,e),this.m_shape.setUserIndex(t,n,-1),s[i]--,1===s[i]&&(s[i]=0,m.pop(),h.pop()),o=r,t=r}else h.push(t),m.push(i)}}}return this.m_shape.removePathUserIndex(i),this.m_shape.removeUserIndex(n),this.m_shape.dbgVerifyVertexCounts(),!0}progress_(t=!1){}fixRingOrientationImplMain_(){const t={stack:[],error:void 0,hasError:!1};try{let e,s=!1;const i=me(t,Bt((()=>{this.m_sortedVerticesArray=null})),!1);if(null===this.m_sortedVertices){const t=this.m_shape.getPointCount(this.m_geometry);e=new Qe(0);for(let s=this.m_shape.getFirstPath(this.m_geometry);s!==Nm;s=this.m_shape.getNextPath(s)){let t=this.m_shape.getFirstVertex(s);for(let i=0,n=this.m_shape.getPathSize(s);i<n;i++)e.add(t),t=this.m_shape.getNextVertex(t)}this.m_shape.sortVerticesSimpleByY(e,0,t),this.progress_(!0),this.m_sortedVerticesArray=e}else i.bForget=!0;if(this.m_bFixSelfTangency&&(s=this.fixRingSelfTangency_()),1===this.m_shape.getPathCount(this.m_geometry)){const t=this.m_shape.getFirstPath(this.m_geometry),e=this.m_shape.getRingArea(t);if(this.m_shape.setExterior(t,!0),e<0){const e=this.m_shape.getFirstVertex(t);return this.m_shape.reverseRingInternal(e),this.m_shape.setLastVertex(t,this.m_shape.getPrevVertex(e)),!0}return!1}this.m_shape.dbgVerifyCurves(),this.m_pathOrientationIndex=this.m_shape.createPathUserIndex(),this.m_pathParentageIndex=this.m_shape.createPathUserIndex(),this.m_pathParentsIndex=this.m_shape.createPathUserIndex();for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==Nm;t=this.m_shape.getNextPath(t))this.m_shape.setPathUserIndex(t,this.m_pathOrientationIndex,0),this.m_shape.setPathUserIndex(t,this.m_pathParentageIndex,-1),this.m_shape.setPathUserIndex(t,this.m_pathParentsIndex,-1);const n=[];this.m_yScanline=Number.NaN;const r=w.getNAN();this.m_unknownRingOrientationCount=this.m_shape.getPathCount(this.m_geometry),this.m_node1UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node1UserIndex,-1),this.m_node2UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node2UserIndex,-1);const o=new Wu(this);for(let t=o.next();t!==Nm&&(this.progress_(),this.m_shape.queryXY(t,r),r.y!==this.m_yScanline&&n.length&&(s=this.processBunchForRingOrientationTest_(n)||s,this.m_sweepComparator.reset(),n.length=0),n.push(t),this.m_yScanline=r.y,0!==this.m_unknownRingOrientationCount);t=o.next());return this.m_unknownRingOrientationCount>0&&(s=this.processBunchForRingOrientationTest_(n)||s,n.length=0),this.m_shape.removeUserIndex(this.m_node1UserIndex),this.m_shape.removeUserIndex(this.m_node2UserIndex),this.dbgVerifyRingOrientation_(),s}catch(e){t.error=e,t.hasError=!0}finally{le(t)}}fixRingOrientationImplSimplify_(){const t=[];for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Nm;)if(this.progress_(),3===this.m_shape.getPathUserIndex(e,this.m_pathOrientationIndex)){this.m_shape.setExterior(e,!0);for(let n=this.m_shape.getPathUserIndex(e,this.m_pathParentageIndex);n!==Nm;){const s=this.m_shape.getPathUserIndex(n,this.m_pathParentageIndex);t.push(n),this.m_shape.setExterior(n,!1),this.m_shape.setPathUserIndex(n,this.m_pathParentageIndex,e),n=s}let s=e,i=t.length;for(let t=this.m_shape.getNextPath(e);i>0&&t!==Nm;t=this.m_shape.getNextPath(t),--i){if(this.m_shape.getPathUserIndex(t,this.m_pathParentageIndex)!==e){s=Nm;break}s=t}if(0!==i){s=e;for(let e=0,i=t.length;e<i;e++){const i=t[e];this.m_shape.setPathUserIndex(i,this.m_pathParentageIndex,Re),this.m_shape.movePath(this.m_geometry,this.m_shape.getNextPath(s),i),s=i}}t.length=0,e=this.m_shape.getNextPath(s)}else e=this.m_shape.getNextPath(e);this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex)}fixRingOrientationImplMp2sp_(){const t=this.m_shape.createPathUserIndex();let e=0;const s=[];for(let i=this.m_shape.getFirstPath(this.m_geometry);i!==Nm;)if(this.progress_(),3===this.m_shape.getPathUserIndex(i,this.m_pathOrientationIndex)){this.m_shape.setExterior(i,!0),this.m_shape.setPathUserIndex(i,t,e),e++;for(let t=this.m_shape.getPathUserIndex(i,this.m_pathParentageIndex);t!==Nm;){const e=this.m_shape.getPathUserIndex(t,this.m_pathParentageIndex);s.push(t),this.m_shape.setExterior(t,!1),this.m_shape.setPathUserIndex(t,this.m_pathParentageIndex,i),t=e}let n=i,r=s.length,o=e;for(let e=this.m_shape.getNextPath(i);r>0&&e!==Nm;e=this.m_shape.getNextPath(e),--r){if(this.m_shape.getPathUserIndex(e,this.m_pathParentageIndex)!==i){n=Nm;break}n=e,this.m_shape.setPathUserIndex(e,t,-o),o++}if(0!==r){n=i,o=e;for(let e=0,i=s.length;e<i;e++){const i=s[e];this.m_shape.setPathUserIndex(i,t,-o),o++,this.m_shape.setPathUserIndex(i,this.m_pathParentageIndex,Re)}n=i}e=o,s.length=0,i=this.m_shape.getNextPath(n)}else i=this.m_shape.getNextPath(i);return this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex),t}}function Zu(t,e,s,i,n,r){const o=new Qu(r);return o.m_shape=t,o.m_geometry=e,o.m_knownSimpleResult=s,o.m_bFixSelfTangency=i,o.m_polylineDegeneracies=n,o.m_bHasSegmentParentage=t.hasSegmentParentage(),o.m_bHasSegments=t.hasCurves(),o.simplify_()}class Qu{constructor(t){this.m_shape=null,this.m_geometry=Nm,this.m_sortedVertices=new ls,this.m_bunchEdgeEndPoints=[],this.m_bunchEdgeCenterPoints=[],this.m_bunchEdgeIndices=[],this.m_knownSimpleResult=-1,this.m_sortedVerticesListIndex=-1,this.m_polylineDegeneracies=Nm,this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_bHasSegmentParentage=!1,this.m_bHasSegments=!1,this.m_progressTracker=t}compareAngles_(t,e){if(this.m_bHasSegments)return this.compareAnglesCurves_(t,e);const s=this.m_bunchEdgeEndPoints[t],i=new w;this.m_shape.queryXY(s,i);const n=new w,r=this.m_bunchEdgeEndPoints[e];if(this.m_shape.queryXY(r,n),i.equals(n))return 0;const o=this.m_bunchEdgeCenterPoints[t],a=new w;this.m_shape.queryXY(o,a);const h=this.m_bunchEdgeCenterPoints[e],m=new w;this.m_shape.queryXY(h,m);const l=new w;l.setSub(i,a);const u=new w;u.setSub(n,m),(l.isZero()||u.isZero())&&I("");return w.compareVectors(l,u)}compareAnglesCurves_(t,e){const s=this.m_bunchEdgeEndPoints[t],i=this.m_bunchEdgeEndPoints[e],n=this.m_bunchEdgeCenterPoints[t],r=this.m_bunchEdgeCenterPoints[e],o=this.m_shape.getNextVertex(n)===s,a=this.m_shape.getNextVertex(r)===i,h=new SE,m=new w;o?(this.m_shape.querySegment(n,h,!1,!0),m.assign(h.get().getTangent(0))):(this.m_shape.querySegment(s,h,!1,!0),m.assign(h.get().getTangent(1)),m.negateThis());const l=new w;a?(this.m_shape.querySegment(r,h,!1,!0),l.assign(h.get().getTangent(0))):(this.m_shape.querySegment(i,h,!1,!0),l.assign(h.get().getTangent(1)),l.negateThis()),(m.isZero()||l.isZero())&&I("");return w.compareVectors(m,l)}beforeRemoveVertex_(t,e){const s=this.m_shape.getUserIndex(t,this.m_userIndexSortedIndexToVertex);if(this.m_nextVertexToProcess===s&&(this.m_nextVertexToProcess=this.m_sortedVertices.getNext(this.m_nextVertexToProcess)),this.m_firstCoincidentVertex===s&&(this.m_firstCoincidentVertex=this.m_sortedVertices.getNext(this.m_firstCoincidentVertex)),this.m_sortedVertices.deleteElement(this.m_sortedVerticesListIndex,s),this.removeAngleSortInfo_(t),e){const e=this.m_shape.getPathFromVertex(t);if(e!==Nm){if(this.m_shape.getFirstVertex(e)===t){const s=this.m_shape.getNextVertex(t);if(s!==t){if(this.m_shape.getPathFromVertex(s)===e)return void this.m_shape.setFirstVertex(e,s);{const s=this.m_shape.getPrevVertex(t);if(s!==t){if(this.m_shape.getPathFromVertex(s)===e)return void this.m_shape.setFirstVertex(e,s)}}}this.m_shape.setFirstVertex(e,Nm),this.m_shape.setLastVertex(e,Nm)}}}}processBunch_(){let t=!1;const e=new w(0,0);for(;;){this.m_bunchEdgeEndPoints.length=0,this.m_bunchEdgeCenterPoints.length=0,this.m_bunchEdgeIndices.length=0;let s=this.m_firstCoincidentVertex,i=0,n=!0;for(;s!==this.m_nextVertexToProcess;){const t=this.m_sortedVertices.getData(s);n&&(this.m_shape.queryXY(t,e),n=!1);const r=this.m_shape.getPrevVertex(t),o=this.m_shape.getNextVertex(t);this.m_shape.getUserIndex(r,this.m_userIndexSortedAngleIndexToVertex)!==Re&&(this.m_bunchEdgeEndPoints.push(r),this.m_shape.setUserIndex(r,this.m_userIndexSortedAngleIndexToVertex,Re),this.m_bunchEdgeCenterPoints.push(t),this.m_bunchEdgeIndices.push(i++));this.m_shape.getUserIndex(o,this.m_userIndexSortedAngleIndexToVertex)!==Re&&(this.m_bunchEdgeEndPoints.push(o),this.m_shape.setUserIndex(o,this.m_userIndexSortedAngleIndexToVertex,Re),this.m_bunchEdgeCenterPoints.push(t),this.m_bunchEdgeIndices.push(i++)),s=this.m_sortedVertices.getNext(s)}if(this.m_bunchEdgeEndPoints.length<2){1===this.m_bunchEdgeEndPoints.length&&this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[0],this.m_userIndexSortedAngleIndexToVertex,-1);break}this.m_bunchEdgeIndices.sort(((t,e)=>this.compareAngles_(t,e)));for(let t=0,e=this.m_bunchEdgeIndices.length;t<e;t++){const e=this.m_bunchEdgeIndices[t],s=this.m_bunchEdgeEndPoints[e];this.m_shape.setUserIndex(s,this.m_userIndexSortedAngleIndexToVertex,t)}const r=this.processCrossOvers_(e);for(let t=0,e=this.m_bunchEdgeIndices.length;t<e;t++){const e=this.m_bunchEdgeIndices[t];if(-1===e)continue;const s=this.m_bunchEdgeEndPoints[e];this.m_shape.setUserIndex(s,this.m_userIndexSortedAngleIndexToVertex,-1)}if(!r)break;t=!0}return t}processCrossOvers_(t){let e=!1,s=!0;for(;s;){s=!1;let i=0;-1===this.m_bunchEdgeIndices[i]&&(i=this.getNextEdgeIndex_(i));let n=this.getNextEdgeIndex_(i);for(let r=0,o=this.m_bunchEdgeIndices.length;r<o&&-1!==i&&-1!==n&&i!==n;r++){const r=this.m_bunchEdgeIndices[i],o=this.m_bunchEdgeIndices[n],a=this.m_bunchEdgeEndPoints[r],h=this.m_bunchEdgeEndPoints[o];let m=this.m_shape.getNextVertex(a),l=!1;this.m_shape.isEqualXYPoint2D(m,t)||(m=this.m_shape.getPrevVertex(a),l=!0);let u=this.m_shape.getNextVertex(h),c=!1;this.m_shape.isEqualXYPoint2D(u,t)||(u=this.m_shape.getPrevVertex(h),c=!0);const g=l?this.m_shape.getPrevVertex(m):this.m_shape.getNextVertex(m),_=c?this.m_shape.getPrevVertex(u):this.m_shape.getNextVertex(u);let d=!1;(this.removeSpike_(m)||this.removeSpike_(u)||this.removeSpike_(a)||this.removeSpike_(h)||this.removeSpike_(g)||this.removeSpike_(_))&&(d=!0),m!==u&&(!d&&this.m_shape.isEqualXY(a,h)&&(d=this.resolveOverlap_(l,c,m,a,u,h)),!d&&this.m_shape.isEqualXY(g,_)&&(d=this.resolveOverlap_(!l,!c,m,g,u,_)),!d&&this.m_shape.isEqualXY(a,_)&&(d=this.resolveOverlap_(l,!c,m,a,u,_)),!d&&this.m_shape.isEqualXY(g,h)&&(d=this.resolveOverlap_(!l,c,m,g,u,h))),d&&(e=!0),s||=d,i=d?this.getNextEdgeIndex_(i):n,n=this.getNextEdgeIndex_(i)}}if(!e){let s=0;-1===this.m_bunchEdgeIndices[s]&&(s=this.getNextEdgeIndex_(s));let i=this.getNextEdgeIndex_(s);for(let n=0,r=this.m_bunchEdgeIndices.length;n<r&&-1!==s&&-1!==i&&s!==i;n++){const n=this.m_bunchEdgeIndices[s],r=this.m_bunchEdgeIndices[i],o=this.m_bunchEdgeEndPoints[n],a=this.m_bunchEdgeEndPoints[r];let h=this.m_shape.getNextVertex(o);this.m_shape.isEqualXYPoint2D(h,t)||(h=this.m_shape.getPrevVertex(o));let m=this.m_shape.getNextVertex(a);this.m_shape.isEqualXYPoint2D(m,t)||(m=this.m_shape.getPrevVertex(a));const l=this.getDirection_(h,o),u=this.getDirection_(m,a),c=l?this.m_shape.getPrevVertex(h):this.m_shape.getNextVertex(h),g=u?this.m_shape.getPrevVertex(m):this.m_shape.getNextVertex(m),_=this.detectAndResolveCrossOver_(l,u,o,h,c,a,m,g);1!==_?0===_?(s=this.getNextEdgeIndex_(s),i=this.getNextEdgeIndex_(s)):(s=this.getPrevEdgeIndex_(s),i=this.getNextEdgeIndex_(s)):e=!0}}return e}simplify_(){if(this.m_shape.getGeometryType(this.m_geometry)===s.enumPolygon&&1===this.m_shape.getFillRule(this.m_geometry)){new Hd(this.m_progressTracker).planarSimplifyNoCrackingAndCluster(this.m_bFixSelfTangency,this.m_shape,this.m_geometry,0)}let t=!1;this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=this.m_shape.createUserIndexUninitialized();const e=this.m_shape.getPointCount(this.m_geometry),i=new Qe(0);this.m_shape.dbgVerifyMonotone();for(let s=this.m_shape.getFirstPath(this.m_geometry);s!==Nm;s=this.m_shape.getNextPath(s)){let t=this.m_shape.getFirstVertex(s);for(let e=0,n=this.m_shape.getPathSize(s);e<n;e++)this.m_shape.setUserIndex(t,this.m_userIndexSortedAngleIndexToVertex,-1),i.add(t),t=this.m_shape.getNextVertex(t)}this.m_shape.sortVerticesSimpleByY(i,0,e),this.progress_(!0),this.m_userIndexSortedIndexToVertex=this.m_shape.createUserIndexUninitialized(),this.m_sortedVertices.reserveNodes(e),this.m_sortedVerticesListIndex=this.m_sortedVertices.createList(0);for(let s=0;s<e;s++){const t=i.read(s),e=this.m_sortedVertices.addElement(this.m_sortedVerticesListIndex,t);this.m_shape.setUserIndex(t,this.m_userIndexSortedIndexToVertex,e)}this.m_nextVertexToProcess=-1,this.cleanupSpikes_()&&(t=!0);let n=0,r=!1;do{r=!1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=this.m_sortedVertices.getFirst(this.m_sortedVerticesListIndex);const e=new w(0,0);this.m_firstCoincidentVertex!==ls.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(this.m_firstCoincidentVertex),e);let s=0,i=this.m_firstCoincidentVertex;for(;i!==ls.st_nullNode()&&(i=this.m_sortedVertices.getNext(i),i!==ls.st_nullNode());){this.progress_();const t=this.m_sortedVertices.getData(i),n=w.getNAN();if(this.m_shape.queryXY(t,n),e.equals(n))s++;else{if(s>0){this.m_nextVertexToProcess=i;const t=this.processBunch_();i=this.m_nextVertexToProcess,i!==ls.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(i),n),t&&(r=!0)}e.setCoordsPoint2D(n),this.m_firstCoincidentVertex=i,s=0}}if(this.m_nextVertexToProcess=-1,s>0){this.processBunch_()&&(r=!0)}n++>10&&m(""),r&&this.fixOrphanVertices_(),this.cleanupSpikes_()&&(r=!0),t||=r}while(r);return this.m_shape.dbgVerifyMonotone(),this.m_shape.dbgVerifyCurves(),this.m_shape.removeUserIndex(this.m_userIndexSortedIndexToVertex),this.m_shape.removeUserIndex(this.m_userIndexSortedAngleIndexToVertex),t=Hu(this.m_shape,this.m_geometry,this.m_sortedVertices,this.m_bFixSelfTangency,this.m_progressTracker)||t,this.m_shape.dbgVerifyCurves(),t}getDirection_(t,e){return this.m_shape.getNextVertex(e)!==t}detectAndResolveCrossOver_(t,e,s,i,n,r,o,a){if(i===o)return this.removeAngleSortInfo_(s),this.removeAngleSortInfo_(r),-1;const h=this.m_shape.getUserIndex(s,this.m_userIndexSortedAngleIndexToVertex),m=this.m_shape.getUserIndex(n,this.m_userIndexSortedAngleIndexToVertex),l=this.m_shape.getUserIndex(r,this.m_userIndexSortedAngleIndexToVertex),u=this.m_shape.getUserIndex(a,this.m_userIndexSortedAngleIndexToVertex),c=new Array(8),g=new Array(4);c[0]=0,g[0]=h,c[1]=0,g[1]=m,c[2]=1,g[2]=l,c[3]=1,g[3]=u;for(let d=1;d<4;d++){const t=g[d],e=c[d];let s=d-1;for(;s>=0&&g[s]>t;)g[s+1]=g[s],c[s+1]=c[s],s--;g[s+1]=t,c[s+1]=e}let _=0;if(c[0]&&(_|=1),c[1]&&(_|=2),c[2]&&(_|=4),c[3]&&(_|=8),5!==_&&10!==_)return 0;if(t!==e&&(a=q(r,r=a)),t)this.m_shape.setNextVertex(a,i),this.m_shape.setPrevVertex(i,a),this.m_shape.setNextVertex(n,o),this.m_shape.setPrevVertex(o,n),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(i,!0),this.m_shape.setSegmentParentageBreakVertex(o,!0));else{if(this.m_shape.setPrevVertex(a,i),this.m_shape.setNextVertex(i,a),this.m_shape.setPrevVertex(n,o),this.m_shape.setNextVertex(o,n),this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(i),e=this.m_shape.getSegmentParentage(o);this.m_shape.setSegmentParentageAndBreak(i,e,!0),this.m_shape.setSegmentParentageAndBreak(o,t,!0)}if(this.m_bHasSegments){const t=this.m_shape.getVertexIndex(i),e=this.m_shape.getVertexIndex(o),s=this.m_shape.getSegmentFromIndex(t);this.m_shape.setSegmentToIndex(t,null);const n=this.m_shape.getSegmentFromIndex(e);this.m_shape.setSegmentToIndex(e,null),this.m_shape.setSegmentToIndex(t,n),this.m_shape.setSegmentToIndex(e,s)}}return 1}resolveOverlap_(t,e,s,i,n,r){return this.resolveOverlapOddEven_(t,e,s,i,n,r)}resolveOverlapOddEven_(t,e,s,i,n,r){if(t!==e){t||(n=q(s,s=n),r=q(i,i=r));const e=this.m_shape.getNextVertex(n),o=this.m_shape.getNextVertex(s);if(this.m_shape.setNextVertex(s,e),this.m_shape.setPrevVertex(e,s),this.m_shape.setNextVertex(n,o),this.m_shape.setPrevVertex(o,n),this.m_bHasSegments){const t=this.m_shape.getVertexIndex(s),e=this.m_shape.getVertexIndex(n),i=this.m_shape.getSegmentFromIndex(t);this.m_shape.setSegmentToIndex(t,null);const r=this.m_shape.getSegmentFromIndex(e);this.m_shape.setSegmentToIndex(e,null),this.m_shape.setSegmentToIndex(t,r),this.m_shape.setSegmentToIndex(e,i)}if(this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(s),e=this.m_shape.getSegmentParentage(n);this.m_shape.setSegmentParentageAndBreak(s,e,!0),this.m_shape.setSegmentParentageAndBreak(n,t,!0),this.m_shape.setSegmentParentageBreakVertex(i,!0),this.m_shape.setSegmentParentageBreakVertex(r,!0)}this.removeSpike_(n)}else{const o=t?s:i,a=e?n:r,h=t?i:s,m=e?r:n;let l=null;if(this.m_bHasSegments){const t=this.m_shape.getVertexIndex(m);l=this.m_shape.getSegmentFromIndex(t),this.m_shape.setSegmentToIndex(t,null);const e=this.m_shape.getVertexIndex(a);this.m_shape.setSegmentToIndex(e,null);const s=this.m_shape.getVertexIndex(o);this.m_shape.setSegmentToIndex(s,null)}let u=-1;this.m_bHasSegmentParentage&&(u=this.m_shape.getSegmentParentage(m));let c=!1;this.m_shape.setNextVertex(o,a),this.m_shape.setNextVertex(a,o),this.m_shape.setPrevVertex(h,m),this.m_shape.setPrevVertex(m,h);let g=m;for(;g!==a;){const t=this.m_shape.getPrevVertex(g),e=this.m_shape.getNextVertex(g);if(this.m_shape.setPrevVertex(g,e),this.m_shape.setNextVertex(g,t),c||=g===o,this.m_bHasSegments&&g!==o){const t=this.m_shape.getVertexIndex(e),s=l;l=this.m_shape.getSegmentFromIndex(t),null!==s&&s.reverse(),this.m_shape.setSegmentToIndex(t,s)}if(this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(e);this.m_shape.setSegmentParentagePreserveBreak(e,u),u=t}g=e}let _=null;if(!c){const t=this.m_shape.getPrevVertex(a),e=this.m_shape.getNextVertex(a);if(this.m_shape.setPrevVertex(a,e),this.m_shape.setNextVertex(a,t),this.m_bHasSegments){const t=this.m_shape.getVertexIndex(a);_=this.m_shape.getSegmentFromIndex(t),this.m_shape.setSegmentToIndex(t,null)}}let d=-1,p=-1;if(this.m_bHasSegmentParentage&&(d=c?this.m_shape.getSegmentParentage(o):this.m_shape.getSegmentParentage(a),p=this.m_shape.getSegmentParentage(h)),this.transferVertexData_(a,o),this.beforeRemoveVertex_(a,!0),this.m_shape.removeVertexInternal(a,!0),this.removeAngleSortInfo_(o),this.transferVertexData_(m,h),this.beforeRemoveVertex_(m,!0),this.m_shape.removeVertexInternal(m,!0),this.removeAngleSortInfo_(h),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageAndBreak(o,d,!0),this.m_shape.setSegmentParentageAndBreak(h,p,!0)),_){const t=this.m_shape.getVertexIndex(o);this.m_shape.setSegmentToIndex(t,_)}}return!0}cleanupSpikes_(){let t=!1;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Nm;){const s=this.m_shape.getNextPath(e);let i=this.m_shape.getFirstVertex(e);for(let n=0,r=this.m_shape.getPathSize(e);n<r&&r>1;){this.progress_();const{v:s,bModified:o}=this.checkAndCleanupSpike_(e,i);if(s===Nm)break;o?(t=!0,i=s,n=0,r=this.m_shape.getPathSize(e)):(i=s,n++)}e=s}return t}checkAndCleanupSpike_(t,e){const s={v:Nm,bModified:!1};let i=this.m_shape.getPrevVertex(e),n=this.m_shape.getNextVertex(e),r=Nm,o=Nm;for(;this.m_shape.isEqualXY(i,n)&&(r=i,o=n,n!==e);)i=this.m_shape.getPrevVertex(i),n=this.m_shape.getNextVertex(n);if(r===Nm)return s.v=n,s;s.bModified=!0;for(let a=this.m_shape.getNextVertex(r);this.beforeRemoveVertex_(a,!1),a!==o;a=this.m_shape.getNextVertex(a));if(r===e)return this.m_polylineDegeneracies!==Nm?this.m_shape.movePath(this.m_polylineDegeneracies,Nm,t):this.m_shape.removePath(t),s.v=Nm,s;{const t=this.m_shape.peelALoopIntoAPath(r,o);this.m_polylineDegeneracies!==Nm?this.m_shape.movePath(this.m_polylineDegeneracies,Nm,t):this.m_shape.removePath(t)}return s.v=r,s}removeSpike_(t){let e=this.m_shape.getPrevVertex(t),s=this.m_shape.getNextVertex(t),i=Nm,n=Nm;for(;this.m_shape.isEqualXY(e,s)&&(i=e,n=s,s!==t);)e=this.m_shape.getPrevVertex(e),s=this.m_shape.getNextVertex(s);if(i===Nm)return!1;if(this.m_shape.peelALoop(i,n),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(i,!0),this.m_shape.setSegmentParentageBreakVertex(n,!0)),this.removeAngleSortInfo_(i),this.m_polylineDegeneracies===Nm)for(let r=this.m_shape.getNextVertex(n);;){const t=this.m_shape.getNextVertex(r);if(this.removeAngleSortInfo_(r),this.beforeRemoveVertex_(r,!0),this.m_shape.setSegmentToIndex(this.m_shape.getVertexIndex(r),null),this.m_shape.removeVertexInternal(r,!1),r===n)break;r=t}else{for(let e=n;;){const t=this.m_shape.getNextVertex(e);if(this.removeAngleSortInfo_(e),this.beforeRemoveVertex_(e,!1),e=t,e===n)break}const t=[!1];this.m_shape.insertClosedPath(this.m_polylineDegeneracies,Nm,n,n,t)}return!0}fixOrphanVertices_(){let t=0;for(let i=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());-1!==i;i=this.m_sortedVertices.getNext(i)){const t=this.m_sortedVertices.getData(i);this.m_shape.setPathToVertex(t,Nm)}let e=0;for(let i=this.m_shape.getFirstPath(this.m_geometry);i!==Nm;){const s=this.m_shape.getFirstVertex(i);if(s===Nm||this.m_shape.getPathFromVertex(s)!==Nm){const t=i;i=this.m_shape.getNextPath(i),this.m_shape.removePathOnly(t);continue}this.m_shape.setPathToVertex(s,i);let n=1;for(let t=this.m_shape.getNextVertex(s);t!==s;t=this.m_shape.getNextVertex(t))this.m_shape.setPathToVertex(t,i),n++;this.m_shape.setRingAreaValid(i,!1),this.m_shape.setPathSize(i,n),this.m_shape.setLastVertex(i,this.m_shape.getPrevVertex(s)),e+=n,t++,i=this.m_shape.getNextPath(i)}for(let i=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());-1!==i;i=this.m_sortedVertices.getNext(i)){const s=this.m_sortedVertices.getData(i);if(this.m_shape.getPathFromVertex(s)!==Nm)continue;const n=[!1],r=this.m_shape.insertClosedPath(this.m_geometry,Nm,s,s,n);e+=this.m_shape.getPathSize(r),t++}this.m_shape.setGeometryPathCount(this.m_geometry,t),this.m_shape.setGeometryVertexCount(this.m_geometry,e);let s=0;for(let i=this.m_shape.getFirstGeometry();i!==Nm;i=this.m_shape.getNextGeometry(i))s+=this.m_shape.getPointCount(i);this.m_shape.setTotalPointCount(s)}getNextEdgeIndex_(t){if(-1===t)return-1;for(let e=0,s=this.m_bunchEdgeIndices.length-1;e<s;e++)if(t=(t+1)%this.m_bunchEdgeIndices.length,-1!==this.m_bunchEdgeIndices[t])return t;return-1}getPrevEdgeIndex_(t){if(-1===t)return-1;for(let e=0,s=this.m_bunchEdgeIndices.length-1;e<s;e++)if(t=(this.m_bunchEdgeIndices.length+t-1)%this.m_bunchEdgeIndices.length,-1!==this.m_bunchEdgeIndices[t])return t;return-1}transferVertexData_(t,e){const s=this.m_shape.getUserIndex(e,this.m_userIndexSortedIndexToVertex),i=this.m_shape.getUserIndex(e,this.m_userIndexSortedAngleIndexToVertex);this.m_shape.transferAllDataToTheVertex(t,e),this.m_shape.setUserIndex(e,this.m_userIndexSortedIndexToVertex,s),this.m_shape.setUserIndex(e,this.m_userIndexSortedAngleIndexToVertex,i)}removeAngleSortInfo_(t){const e=this.m_shape.getUserIndex(t,this.m_userIndexSortedAngleIndexToVertex);-1!==e&&(this.m_bunchEdgeIndices[e]=-1,this.m_shape.setUserIndex(t,this.m_userIndexSortedAngleIndexToVertex,-1))}progress_(t=!1){}}function Ku(t,i,n,r,o,a=!0){switch(tc(r)){case 0:break;case 1:e("relation string length has to be 9 characters");break;default:e("relation string")}if(a){const e=gc(r,t.getDimension(),i.getDimension());if(0!==e)return Nc(t,i,n,e,o)}let h=0;if("number"==typeof n)h=n;else{const e=ge.constructEmpty();t.queryEnvelope(e);const s=ge.constructEmpty();i.queryEnvelope(s);const r=ge.constructEmpty();r.setCoords({env2D:e}),r.mergeEnvelope2D(s),h=Is(n,r,!1)}const m=vc(t,h),l=vc(i,h);if(m.isEmpty()||l.isEmpty())return cc(m,l,r);const u=m.getGeometryType(),c=l.getGeometryType();let g=!1;switch(u){case s.enumPolygon:switch(c){case s.enumPolygon:g=ec(m,l,h,r,o);break;case s.enumPolyline:g=sc(m,l,h,r,o);break;case s.enumPoint:g=ac(m,l,h,r);break;case s.enumMultiPoint:g=ic(m,l,h,r,o)}break;case s.enumPolyline:switch(c){case s.enumPolygon:g=sc(l,m,h,bc(r),o);break;case s.enumPolyline:g=nc(m,l,h,r,o);break;case s.enumPoint:g=hc(m,l,h,r,o);break;case s.enumMultiPoint:g=rc(m,l,h,r,o)}break;case s.enumPoint:switch(c){case s.enumPolygon:g=ac(l,m,h,bc(r));break;case s.enumPolyline:g=hc(l,m,h,bc(r),o);break;case s.enumPoint:g=lc(m,l,h,r);break;case s.enumMultiPoint:g=mc(l,m,h,bc(r))}break;case s.enumMultiPoint:switch(c){case s.enumPolygon:g=ic(l,m,h,bc(r),o);break;case s.enumPolyline:g=rc(l,m,h,bc(r),o);break;case s.enumMultiPoint:g=oc(m,l,h,r,o);break;case s.enumPoint:g=mc(m,l,h,r)}break;default:g=!1}return g}function Ju(t,e,s,i){const n=new Cc;n.resetMatrix_(),n.setPredicates_("T*****F**"),n.setAreaAreaPredicates_();const r=ge.constructEmpty(),o=ge.constructEmpty();t.queryEnvelope(r),e.queryEnvelope(o);let a=!1;if(Mc(r,o,s)&&(n.areaAreaDisjointPredicates_(t,e),a=!0),a||Gc(t,e),a){return uc(n.m_matrix,n.m_scl)}let h=new Vm,m=h.addGeometry(t),l=h.addGeometry(e),u=null,c=0;if(t.hasNonLinearSegments()||e.hasNonLinearSegments()){u=new ld;const t=ad(s,h.getEnvelope2D(i));c=md(t,0),ed(h,t,s,12e3,u,null,i)}cd(h,new ps(s,0).add(c),i,!1,!1);const g=h.getGeometry(l).getBoundary();if(h.filterClosePoints(0,!0,!0,!1,Nm),Zu(h,m,-1,!1,Nm,i),0===h.getPointCount(m))return!1;Zu(h,l,-1,!1,Nm,i),n.setEditShape_(h,i);const _=0===h.getPointCount(l);if(!_){n.computeMatrixTopoGraphHalfEdges_(m,l),n.m_topoGraph.removeShape();const t=uc(n.m_matrix,n.m_scl);if(!t)return t}const d=h.getGeometry(m);h=new Vm,m=h.addGeometry(d),l=h.addGeometry(g),n.setEditShape_(h,i),n.m_predicateCount=0,n.resetMatrix_(),n.setPredicates_(_?"T*****F**":"******F**"),n.setAreaLinePredicates_(),n.computeMatrixTopoGraphHalfEdges_(m,l),n.m_topoGraph.removeShape();return uc(n.m_matrix,n.m_scl)}function $u(t,e,s,i){const n=new Cc;n.resetMatrix_(),n.setPredicates_("T*****F**"),n.setAreaLinePredicates_();const r=ge.constructEmpty(),o=ge.constructEmpty();t.queryEnvelope(r),e.queryEnvelope(o);let a=!1;if(Mc(r,o,s)&&(n.areaLineDisjointPredicates_(t,e),a=!0),a||Gc(t,e),a){return uc(n.m_matrix,n.m_scl)}const h=new Vm,m=h.addGeometry(t),l=h.addGeometry(e);if(n.setEditShapeCrackAndCluster_(h,new ps(s,0),i),0===h.getPointCount(m))return!1;n.computeMatrixTopoGraphHalfEdges_(m,l),n.m_topoGraph.removeShape();return uc(n.m_matrix,n.m_scl)}function tc(t){if(9!==t.length)return 1;for(let e=0;e<9;e++){const s=t[e];if("*"!==s&&"T"!==s&&"F"!==s&&"0"!==s&&"1"!==s&&"2"!==s)return 2}return 0}function ec(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setAreaAreaPredicates_();const o=ge.constructEmpty(),a=ge.constructEmpty();t.queryEnvelope(o),e.queryEnvelope(a);let h=!1;if(Mc(o,a,s)&&(r.areaAreaDisjointPredicates_(t,e),h=!0),h||Gc(t,e),!h){const i=new Vm,o=i.addGeometry(t),a=i.addGeometry(e);r.setEditShapeCrackAndCluster_(i,new ps(s,0),n),r.computeMatrixTopoGraphHalfEdges_(o,a),r.m_topoGraph.removeShape()}return uc(r.m_matrix,r.m_scl)}function sc(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setAreaLinePredicates_();const o=ge.constructEmpty(),a=ge.constructEmpty();t.queryEnvelope(o),e.queryEnvelope(a);let h=!1;if(Mc(o,a,s)&&(r.areaLineDisjointPredicates_(t,e),h=!0),h||Gc(t,e),!h){const i=new Vm,o=i.addGeometry(t),a=i.addGeometry(e);r.setEditShapeCrackAndCluster_(i,new ps(s,0),n),r.m_clusterIndexB=r.m_topoGraph.createUserIndexForClusters(),Ec(a,r.m_topoGraph,r.m_clusterIndexB),r.computeMatrixTopoGraphHalfEdges_(o,a),r.m_topoGraph.deleteUserIndexForClusters(r.m_clusterIndexB),r.m_topoGraph.removeShape()}return uc(r.m_matrix,r.m_scl)}function ic(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setAreaPointPredicates_();const o=ge.constructEmpty(),a=ge.constructEmpty();t.queryEnvelope(o),e.queryEnvelope(a);let h=!1;if(Mc(o,a,s)&&(r.areaPointDisjointPredicates_(t),h=!0),h||Gc(t,e),!h){const i=new Vm,o=i.addGeometry(t),a=i.addGeometry(e);r.setEditShapeCrackAndCluster_(i,new ps(s,0),n),r.computeMatrixTopoGraphClusters_(o,a),r.m_topoGraph.removeShape()}return uc(r.m_matrix,r.m_scl)}function nc(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setLineLinePredicates_();const o=ge.constructEmpty(),a=ge.constructEmpty();t.queryEnvelope(o),e.queryEnvelope(a);let h=!1;if(Mc(o,a,s)&&(r.lineLineDisjointPredicates_(t,e),h=!0),h||Gc(t,e),!h){const i=new Vm,o=i.addGeometry(t),a=i.addGeometry(e);r.setEditShapeCrackAndCluster_(i,new ps(s,0),n),r.m_clusterIndexA=r.m_topoGraph.createUserIndexForClusters(),r.m_clusterIndexB=r.m_topoGraph.createUserIndexForClusters(),Ec(o,r.m_topoGraph,r.m_clusterIndexA),Ec(a,r.m_topoGraph,r.m_clusterIndexB),r.computeMatrixTopoGraphHalfEdges_(o,a),r.m_topoGraph.deleteUserIndexForClusters(r.m_clusterIndexA),r.m_topoGraph.deleteUserIndexForClusters(r.m_clusterIndexB),r.m_topoGraph.removeShape()}return uc(r.m_matrix,r.m_scl)}function rc(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setLinePointPredicates_();const o=ge.constructEmpty(),a=ge.constructEmpty();t.queryEnvelope(o),e.queryEnvelope(a);let h=!1;if(Mc(o,a,s)&&(r.linePointDisjointPredicates_(t),h=!0),h||Gc(t,e),!h){const i=new Vm,o=i.addGeometry(t),a=i.addGeometry(e);r.setEditShapeCrackAndCluster_(i,new ps(s,0),n),r.m_clusterIndexA=r.m_topoGraph.createUserIndexForClusters(),Ec(o,r.m_topoGraph,r.m_clusterIndexA),r.computeMatrixTopoGraphClusters_(o,a),r.m_topoGraph.deleteUserIndexForClusters(r.m_clusterIndexA),r.m_topoGraph.removeShape()}return uc(r.m_matrix,r.m_scl)}function oc(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setPointPointPredicates_();const o=new ge,a=new ge;t.queryEnvelope(o),e.queryEnvelope(a);let h=!1;if(Mc(o,a,s)&&(r.pointPointDisjointPredicates_(),h=!0),!h){const i=new Vm,o=i.addGeometry(t),a=i.addGeometry(e);r.setEditShapeCrackAndCluster_(i,new ps(s,0),n),r.computeMatrixTopoGraphClusters_(o,a),r.m_topoGraph.removeShape()}return uc(r.m_matrix,r.m_scl)}function ac(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setAreaPointPredicates_();const o=ge.constructEmpty();t.queryEnvelope(o);const a=e.getXY();let h=!1;if(Vc(a,o,s)&&(r.areaPointDisjointPredicates_(t),h=!0),!h){const e=k_(t,a,s);if(1===e)r.m_matrix[0]=0,r.m_matrix[2]=2,r.m_matrix[3]=-1,r.m_matrix[5]=1,r.m_matrix[6]=-1;else if(2===e){r.m_matrix[6]=-1;if(0!==t.calculateArea2D())r.m_matrix[0]=-1,r.m_matrix[3]=0,r.m_matrix[2]=2,r.m_matrix[5]=1;else{r.m_matrix[0]=0,r.m_matrix[3]=-1,r.m_matrix[5]=-1;const e=ge.constructEmpty();t.queryEnvelope(e),r.m_matrix[2]=e.height()||e.width()?1:-1}}else r.areaPointDisjointPredicates_(t)}return uc(r.m_matrix,i)}function hc(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setLinePointPredicates_();const o=ge.constructEmpty();t.queryEnvelope(o);let a=!1;if(Vc(e.getXY(),o,s)&&(r.linePointDisjointPredicates_(t),a=!0),!a){let i=null,o=!1,a=!1;if(r.m_performPredicates[0]||r.m_performPredicates[6]){!Nc(t,e,s,4,n)?(r.m_performPredicates[0]&&(i=lm(t),a=!Nc(i,e,s,4,n),o=!0,r.m_matrix[0]=a?-1:0),r.m_matrix[6]=-1):(r.m_matrix[0]=-1,r.m_matrix[6]=0)}if(r.m_performPredicates[3]&&(null!==i&&i.isEmpty()?r.m_matrix[3]=-1:(o||(null==i&&(i=lm(t)),a=!Nc(i,e,s,4,n),o=!0),r.m_matrix[3]=a?0:-1)),r.m_performPredicates[5])if(null!==i&&i.isEmpty())r.m_matrix[5]=-1;else if(o&&!a)r.m_matrix[5]=0;else{null===i&&(i=lm(t));const o=Nc(i,e,s,3,n);r.m_matrix[5]=o?-1:0}if(r.m_performPredicates[2]){if(0!==t.calculateLength2D())r.m_matrix[2]=1;else{const i=new ii({vd:t.getDescription()});i.addPoints(t,0,t.getPointCount());const o=Nc(i,e,s,3,n);r.m_matrix[2]=o?-1:0}}}return uc(r.m_matrix,r.m_scl)}function mc(t,e,s,i,n){const r=new Cc;r.resetMatrix_(),r.setPredicates_(i),r.setPointPointPredicates_();const o=ge.constructEmpty();t.queryEnvelope(o);const a=e.getXY(),h=new w;let m=!1;if(Vc(a,o,s)&&(r.pointPointDisjointPredicates_(),m=!0),!m){let e=!1,i=!0;const n=s*s;for(let s=0;s<t.getPointCount()&&(t.queryXY(s,h),w.sqrDistance(h,a)<=n?e=!0:i=!1,!e||i);s++);e?(r.m_matrix[0]=0,r.m_matrix[2]=i?-1:0,r.m_matrix[6]=-1):(r.m_matrix[0]=-1,r.m_matrix[2]=0,r.m_matrix[6]=0)}return uc(r.m_matrix,i)}function lc(t,e,s,i,n){const r=t.getXY(),o=e.getXY(),a=H(9,-1);w.sqrDistance(r,o)<=s*s?a[0]=0:(a[2]=0,a[6]=0),a[8]=2;return uc(a,i)}function uc(t,e){for(let s=0;s<9;s++)switch(e[s]){case"T":if(-1===t[s])return!1;break;case"F":if(-1!==t[s])return!1;break;case"0":if(0!==t[s])return!1;break;case"1":if(1!==t[s])return!1;break;case"2":if(2!==t[s])return!1}return!0}function cc(t,e,i){const n=H(9,-1);if(t.isEmpty()&&e.isEmpty())return uc(n,i);let r,o=!1;t.isEmpty()?(r=e,o=!0):r=t,n[0]=-1,n[1]=-1,n[3]=-1,n[4]=-1,n[6]=-1,n[7]=-1,n[8]=2;const a=r.getGeometryType();if(p(a))if(a===s.enumPolygon){if(0!==r.calculateArea2D())n[2]=2,n[5]=1;else{n[5]=-1;const t=ge.constructEmpty();r.queryEnvelope(t),n[2]=t.height()||t.width()?1:0}}else{const t=0!==r.calculateLength2D();n[2]=t?1:0,n[5]=mm(r)?0:-1}else n[2]=0,n[5]=-1;return o&&Sc(n),uc(n,i)}function gc(t,e,s){return _c(t)?3:dc(t)?4:pc(t,e,s)?8:fc(t,e,s)?16:yc(t)?64:xc(t)?1:Pc(t,e,s)?32:0}function _c(t){return"T*F**FFF*"===t}function dc(t){return"FF*FF****"===t}function pc(t,e,s){return(0!==e||0!==s)&&(2===e&&2===s?"F***T****"===t:(2===e||1===e)&&0===s&&"F**T*****"===t)}function fc(t,e,s){return e>s?"T*****T**"===t:1===e&&1===s&&"0********"===t}function xc(t){return"T*****FF*"===t}function yc(t){return"T**FF*FF*"===t}function Pc(t,e,s){return e===s&&(1!==e?"T*T***T**"===t:"1*T***T**"===t)}function Ec(t,e,s){const i=e.getGeometryID(t);for(let n=e.getFirstCluster();n!==Nm;n=e.getNextCluster(n)){if(!(e.getClusterParentage(n)&i))continue;const t=e.getClusterHalfEdge(n);if(t===Nm){e.setClusterUserIndex(n,s,0);continue}let r=t,o=0;do{const t=r;e.getHalfEdgeParentage(t)&i&&o++,r=e.getHalfEdgeNext(e.getHalfEdgeTwin(t))}while(r!==t);e.setClusterUserIndex(n,s,o)}}class Cc{nullFunc(){return t(0),!1}constructor(){this.m_clusterIndexA=-1,this.m_clusterIndexB=-1,this.m_visitedIndex=-1,this.m_topoGraph=new Kl,this.m_matrix=H(9,0),this.m_maxDim=H(9,0),this.m_performPredicates=H(9,!1),this.m_scl="",this.m_predicateCount=0,this.m_predicatesHalfEdge=this.nullFunc,this.m_predicatesCluster=this.nullFunc}resetMatrix_(){this.m_matrix.fill(-2),this.m_maxDim.fill(-2)}setPredicates_(t){this.m_scl=t;for(let e=0;e<9;e++)"*"!==this.m_scl[e]?(this.m_performPredicates[e]=!0,this.m_predicateCount++):this.m_performPredicates[e]=!1}setRemainingPredicatesToFalse_(){for(let t=0;t<9;t++)this.m_performPredicates[t]&&-2===this.m_matrix[t]&&(this.m_matrix[t]=-1,this.m_performPredicates[t]=!1)}isPredicateKnown_(t){return-2!==this.m_matrix[t]&&(-1===this.m_matrix[t]?(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0):"T"!==this.m_scl[t]&&"F"!==this.m_scl[t]?!(this.m_matrix[t]<this.m_maxDim[t])&&(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0):(this.m_performPredicates[t]=!1,this.m_predicateCount--,!0))}setAreaAreaPredicates_(){this.m_predicatesHalfEdge=this.areaAreaPredicates_,this.m_maxDim[0]=2,this.m_maxDim[1]=1,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=1,this.m_maxDim[5]=1,this.m_maxDim[6]=2,this.m_maxDim[7]=1,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaLinePredicates_(){this.m_predicatesHalfEdge=this.areaLinePredicates_,this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=0,this.m_maxDim[5]=1,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLineLinePredicates_(){this.m_predicatesHalfEdge=this.lineLinePredicates_,this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=0,this.m_maxDim[5]=0,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaPointPredicates_(){this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=2,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLinePointPredicates_(){this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=0,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setPointPointPredicates_(){this.m_predicatesCluster=this.pointPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=0,this.m_maxDim[3]=-1,this.m_maxDim[4]=-1,this.m_maxDim[5]=-1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[3]&&(this.m_matrix[3]=-1,this.m_performPredicates[3]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[5]&&(this.m_matrix[5]=-1,this.m_performPredicates[5]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}areaAreaDisjointPredicates_(t,e){this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5]),this.areaGeomContainsOrDisjointPredicates_(e,this.m_performPredicates[6]?6:-1,this.m_scl[6],this.m_performPredicates[7]?7:-1,this.m_scl[7])}areaGeomContainsOrDisjointPredicates_(t,e,s,i,n){const r=-1!==e,o=-1!==i;if(r||o){if(!("T"!==s&&"F"!==s&&r||"T"!==n&&"F"!==n&&o)||0!==t.calculateArea2D())r&&(this.m_matrix[e]=2),o&&(this.m_matrix[i]=1);else if(o&&(this.m_matrix[i]=-1),r){const s=ge.constructEmpty();t.queryEnvelope(s),this.m_matrix[e]=s.height()||s.width()?1:0}}}areaAreaContainsPredicates_(e){t(0)}areaAreaWithinPredicates_(e){t(0)}areaLineDisjointPredicates_(t,e){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[6]){const t=this.m_scl[6],s="T"===t||"F"===t||0!==e.calculateLength2D();this.m_matrix[6]=s?1:0}if(this.m_performPredicates[7]){const t=mm(e);this.m_matrix[7]=t?0:-1}this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaLineContainsPredicates_(e,s){t(0)}areaPointDisjointPredicates_(t){this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_matrix[6]=0,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaPointContainsPredicates_(e){t(0)}lineLineDisjointPredicates_(t,e){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[2]){const e=this.m_scl[2],s="T"===e||"F"===e||0!==t.calculateLength2D();this.m_matrix[2]=s?1:0}if(this.m_performPredicates[5]){const e=mm(t);this.m_matrix[5]=e?0:-1}if(this.m_performPredicates[6]){const t=this.m_scl[6],s="T"===t||"F"===t||0!==e.calculateLength2D();this.m_matrix[6]=s?1:0}if(this.m_performPredicates[7]){const t=mm(e);this.m_matrix[7]=t?0:-1}}linePointDisjointPredicates_(t){if(this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_performPredicates[2]){const e=this.m_scl[2],s="T"===e||"F"===e||0!==t.calculateLength2D();this.m_matrix[2]=s?1:0}if(this.m_performPredicates[5]){const e=mm(t);this.m_matrix[5]=e?0:-1}this.m_matrix[6]=0}pointPointDisjointPredicates_(){this.m_matrix[0]=-1,this.m_matrix[2]=0,this.m_matrix[6]=0}areaAreaPredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorArea_(t,e,s);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[1]){this.interiorAreaBoundaryArea_(t,e,1);const s=this.isPredicateKnown_(1);i&&=s}if(this.m_performPredicates[2]){this.interiorAreaExteriorArea_(t,e,s,2);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.interiorAreaBoundaryArea_(t,s,3);const e=this.isPredicateKnown_(3);i&&=e}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryArea_(t,e,s);const n=this.isPredicateKnown_(4);i&&=n}if(this.m_performPredicates[5]){this.boundaryAreaExteriorArea_(t,e,s,5);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.interiorAreaExteriorArea_(t,s,e,6);const n=this.isPredicateKnown_(6);i&&=n}if(this.m_performPredicates[7]){this.boundaryAreaExteriorArea_(t,s,e,7);const n=this.isPredicateKnown_(7);i&&=n}return i}areaLinePredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorLine_(t,e,s);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[1]){this.interiorAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const n=this.isPredicateKnown_(1);i&&=n}if(this.m_performPredicates[2]){this.interiorAreaExteriorLine_(t,e,s);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.boundaryAreaInteriorLine_(t,e,s,this.m_clusterIndexB);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const n=this.isPredicateKnown_(4);i&&=n}if(this.m_performPredicates[5]){this.boundaryAreaExteriorLine_(t,e,s);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.exteriorAreaInteriorLine_(t,e);const s=this.isPredicateKnown_(6);i&&=s}if(this.m_performPredicates[7]){this.exteriorAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const n=this.isPredicateKnown_(7);i&&=n}return i}lineLinePredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[1]){this.interiorLineBoundaryLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB,1);const n=this.isPredicateKnown_(1);i&&=n}if(this.m_performPredicates[2]){this.interiorLineExteriorLine_(t,e,s,2);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.interiorLineBoundaryLine_(t,s,e,this.m_clusterIndexB,this.m_clusterIndexA,3);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[4]){this.boundaryLineBoundaryLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB);const n=this.isPredicateKnown_(4);i&&=n}if(this.m_performPredicates[5]){this.boundaryLineExteriorLine_(t,e,s,this.m_clusterIndexA,5);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.interiorLineExteriorLine_(t,s,e,6);const n=this.isPredicateKnown_(6);i&&=n}if(this.m_performPredicates[7]){this.boundaryLineExteriorLine_(t,s,e,this.m_clusterIndexB,7);const n=this.isPredicateKnown_(7);i&&=n}return i}areaPointPredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorPoint_(t,e);const s=this.isPredicateKnown_(0);i&&=s}if(this.m_performPredicates[2]){this.interiorAreaExteriorPoint_(t,e);const s=this.isPredicateKnown_(2);i&&=s}if(this.m_performPredicates[3]){this.boundaryAreaInteriorPoint_(t,e,s);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[5]){this.boundaryAreaExteriorPoint_(t,e);const s=this.isPredicateKnown_(5);i&&=s}if(this.m_performPredicates[6]){this.exteriorAreaInteriorPoint_(t,e);const s=this.isPredicateKnown_(6);i&&=s}return i}linePointPredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorPoint_(t,e,s,this.m_clusterIndexA);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[2]){this.interiorLineExteriorPoint_(t,e,s,this.m_clusterIndexA);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[3]){this.boundaryLineInteriorPoint_(t,e,s,this.m_clusterIndexA);const n=this.isPredicateKnown_(3);i&&=n}if(this.m_performPredicates[5]){this.boundaryLineExteriorPoint_(t,e,s,this.m_clusterIndexA);const n=this.isPredicateKnown_(5);i&&=n}if(this.m_performPredicates[6]){this.exteriorLineInteriorPoint_(t,e,s);const n=this.isPredicateKnown_(6);i&&=n}return i}pointPointPredicates_(t,e,s){let i=!0;if(this.m_performPredicates[0]){this.interiorPointInteriorPoint_(t,e,s);const n=this.isPredicateKnown_(0);i&&=n}if(this.m_performPredicates[2]){this.interiorPointExteriorPoint_(t,e,s,2);const n=this.isPredicateKnown_(2);i&&=n}if(this.m_performPredicates[6]){this.interiorPointExteriorPoint_(t,s,e,6);const n=this.isPredicateKnown_(6);i&&=n}return i}interiorAreaInteriorArea_(t,e,s){if(2===this.m_matrix[0])return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t);i&e&&i&s&&(this.m_matrix[0]=2)}interiorAreaBoundaryArea_(t,e,s){if(1===this.m_matrix[s])return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t),n=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));i&e&&n&e&&(this.m_matrix[s]=1)}interiorAreaExteriorArea_(t,e,s,i){if(2===this.m_matrix[i])return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t);n&e&&!(n&s)&&(this.m_matrix[i]=2)}boundaryAreaBoundaryArea_(t,e,s){if(1===this.m_matrix[4])return;const i=this.m_topoGraph.getHalfEdgeParentage(t);if(i&e&&i&s)this.m_matrix[4]=1;else if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),n=this.m_topoGraph.getClusterParentage(i);if(n&e&&n&s)return void(this.m_matrix[4]=0)}}boundaryAreaExteriorArea_(t,e,s,i){if(1===this.m_matrix[i])return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t),r=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));n&s||r&s||(this.m_matrix[i]=1)}interiorAreaInteriorLine_(t,e,s){if(1===this.m_matrix[0])return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t),n=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));i&e&&n&e&&(this.m_matrix[0]=1)}interiorAreaBoundaryLine_(t,e,s,i){if(0!==this.m_matrix[1]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const n=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(n);if(!(r&e)){if(this.m_topoGraph.getHalfEdgeFaceParentage(t)&e){const t=this.m_topoGraph.getClusterUserIndex(n,i);if(r&s&&t%2!=0)return void(this.m_matrix[1]=0)}}}}interiorAreaExteriorLine_(t,e,s){if(2===this.m_matrix[2])return;this.m_topoGraph.getHalfEdgeParentage(t)&e&&(this.m_matrix[2]=2)}boundaryAreaInteriorLine_(t,e,s,i){if(1===this.m_matrix[3])return;const n=this.m_topoGraph.getHalfEdgeParentage(t);if(n&e&&n&s)this.m_matrix[3]=1;else if(0!==this.m_matrix[3]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const n=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(n);if(r&e){const t=this.m_topoGraph.getClusterUserIndex(n,i);if(r&s&&t%2==0)return void(this.m_matrix[3]=0)}}}boundaryAreaBoundaryLine_(t,e,s,i){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const n=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(n);if(r&e){const t=this.m_topoGraph.getClusterUserIndex(n,i);if(r&s&&t%2!=0)return void(this.m_matrix[4]=0)}}}boundaryAreaExteriorLine_(t,e,s){if(1===this.m_matrix[5])return;const i=this.m_topoGraph.getHalfEdgeParentage(t);i&e&&!(i&s)&&(this.m_matrix[5]=1)}exteriorAreaInteriorLine_(t,e){if(1===this.m_matrix[6])return;const s=this.m_topoGraph.getHalfEdgeFaceParentage(t),i=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));s&e||i&e||(this.m_matrix[6]=1)}exteriorAreaBoundaryLine_(t,e,s,i){if(0!==this.m_matrix[7]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const n=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(n);if(!(r&e)){if(!(this.m_topoGraph.getHalfEdgeFaceParentage(t)&e)){const t=this.m_topoGraph.getClusterUserIndex(n,i);if(r&s&&t%2!=0)return void(this.m_matrix[7]=0)}}}}interiorLineInteriorLine_(t,e,s,i,n){if(1===this.m_matrix[0])return;const r=this.m_topoGraph.getHalfEdgeParentage(t);if(r&e&&r&s)this.m_matrix[0]=1;else if(0!==this.m_matrix[0]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const r=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(r);if(o&e&&o&s){const t=this.m_topoGraph.getClusterUserIndex(r,i),e=this.m_topoGraph.getClusterUserIndex(r,n);if(t%2==0&&e%2==0)return void(this.m_matrix[0]=0)}}}interiorLineBoundaryLine_(t,e,s,i,n,r){if(0!==this.m_matrix[r]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const o=this.m_topoGraph.getHalfEdgeTo(t),a=this.m_topoGraph.getClusterParentage(o);if(a&e&&a&s){const t=this.m_topoGraph.getClusterUserIndex(o,i),e=this.m_topoGraph.getClusterUserIndex(o,n);if(t%2==0&&e%2!=0)return void(this.m_matrix[r]=0)}}}interiorLineExteriorLine_(t,e,s,i){if(1===this.m_matrix[i])return;const n=this.m_topoGraph.getHalfEdgeParentage(t);n&e&&!(n&s)&&(this.m_matrix[i]=1)}boundaryLineBoundaryLine_(t,e,s,i,n){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const r=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(r);if(o&e&&o&s){const t=this.m_topoGraph.getClusterUserIndex(r,i),e=this.m_topoGraph.getClusterUserIndex(r,n);if(t%2!=0&&e%2!=0)return void(this.m_matrix[4]=0)}}}boundaryLineExteriorLine_(t,e,s,i,n){if(0!==this.m_matrix[n]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const e=this.m_topoGraph.getHalfEdgeTo(t);if(!(this.m_topoGraph.getClusterParentage(e)&s)){if(this.m_topoGraph.getClusterUserIndex(e,i)%2!=0)return void(this.m_matrix[n]=0)}}}interiorAreaInteriorPoint_(t,e){if(0===this.m_matrix[0])return;if(!(this.m_topoGraph.getClusterParentage(t)&e)){const s=this.m_topoGraph.getClusterChain(t);if(this.m_topoGraph.getChainParentage(s)&e)return void(this.m_matrix[0]=0)}}interiorAreaExteriorPoint_(t,e){if(2===this.m_matrix[2])return;this.m_topoGraph.getClusterParentage(t)&e&&(this.m_matrix[2]=2)}boundaryAreaInteriorPoint_(t,e,s){if(0===this.m_matrix[3])return;const i=this.m_topoGraph.getClusterParentage(t);i&e&&i&s&&(this.m_matrix[3]=0)}boundaryAreaExteriorPoint_(t,e){if(1===this.m_matrix[5])return;this.m_topoGraph.getClusterParentage(t)&e&&(this.m_matrix[5]=1)}exteriorAreaInteriorPoint_(t,e){if(0===this.m_matrix[6])return;if(!(this.m_topoGraph.getClusterParentage(t)&e)){const s=this.m_topoGraph.getClusterChain(t);if(!(this.m_topoGraph.getChainParentage(s)&e))return void(this.m_matrix[6]=0)}}interiorLineInteriorPoint_(t,e,s,i){if(0===this.m_matrix[0])return;const n=this.m_topoGraph.getClusterParentage(t);if(n&e&&n&s){if(this.m_topoGraph.getClusterUserIndex(t,i)%2==0)return void(this.m_matrix[0]=0)}}interiorLineExteriorPoint_(t,e,s,i){if(1===this.m_matrix[2])return;if(-1===this.m_topoGraph.getClusterHalfEdge(t)){if(0!==this.m_matrix[2]){if(!(this.m_topoGraph.getClusterParentage(t)&s))return void(this.m_matrix[2]=0)}}else this.m_matrix[2]=1}boundaryLineInteriorPoint_(t,e,s,i){if(0===this.m_matrix[3])return;const n=this.m_topoGraph.getClusterParentage(t);if(n&e&&n&s){if(this.m_topoGraph.getClusterUserIndex(t,i)%2!=0)return void(this.m_matrix[3]=0)}}boundaryLineExteriorPoint_(t,e,s,i){if(0===this.m_matrix[5])return;const n=this.m_topoGraph.getClusterParentage(t);if(n&e&&!(n&s)){if(this.m_topoGraph.getClusterUserIndex(t,i)%2!=0)return void(this.m_matrix[5]=0)}}exteriorLineInteriorPoint_(t,e,s){if(0===this.m_matrix[6])return;const i=this.m_topoGraph.getClusterParentage(t);i&e||!(i&s)||(this.m_matrix[6]=0)}interiorPointInteriorPoint_(t,e,s){if(0===this.m_matrix[0])return;const i=this.m_topoGraph.getClusterParentage(t);i&e&&i&s&&(this.m_matrix[0]=0)}interiorPointExteriorPoint_(t,e,s,i){if(0===this.m_matrix[i])return;const n=this.m_topoGraph.getClusterParentage(t);!(n&e)||n&s||(this.m_matrix[i]=0)}computeMatrixTopoGraphHalfEdges_(t,e){let s=!1;const i=this.m_topoGraph.getGeometryID(t),n=this.m_topoGraph.getGeometryID(e);this.m_visitedIndex=this.m_topoGraph.createUserIndexForHalfEdges();for(let r=this.m_topoGraph.getFirstCluster();r!==Nm;r=this.m_topoGraph.getNextCluster(r)){const t=this.m_topoGraph.getClusterHalfEdge(r);if(t===Nm){if(null!==this.m_predicatesCluster&&(s=this.m_predicatesCluster(r,i,n),s))break;continue}let e=t;do{let t=e;if(1!==this.m_topoGraph.getHalfEdgeUserIndex(t,this.m_visitedIndex))do{if(s=this.m_predicatesHalfEdge(t,i,n),s)break;this.m_topoGraph.setHalfEdgeUserIndex(t,this.m_visitedIndex,1),t=this.m_topoGraph.getHalfEdgeNext(t)}while(t!==e&&!s);if(s)break;e=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t))}while(e!==t);if(s)break}s||this.setRemainingPredicatesToFalse_(),this.m_topoGraph.deleteUserIndexForHalfEdges(this.m_visitedIndex)}computeMatrixTopoGraphClusters_(t,e){let s=!1;const i=this.m_topoGraph.getGeometryID(t),n=this.m_topoGraph.getGeometryID(e);for(let r=this.m_topoGraph.getFirstCluster();r!==Nm&&(s=this.m_predicatesCluster(r,i,n),!s);r=this.m_topoGraph.getNextCluster(r));s||this.setRemainingPredicatesToFalse_()}setEditShape_(t,e){this.m_topoGraph.setEditShape(t,e)}setEditShapeCrackAndCluster_(t,e,i){let n=0;if(t.hasCurves()){const s=new ld,r=t.getEnvelope2D(i),o=ad(e.total(),r);n=md(o,0),ed(t,o,e.total(),12e3,s,null,i),s.clearStitcher(t)}cd(t,e.add(n),i,!1,!1),t.filterClosePoints(0,!0,!0,!1,Nm);for(let r=t.getFirstGeometry();r!==Nm;r=t.getNextGeometry(r))t.getGeometryType(r)===s.enumPolygon&&Zu(t,r,-1,!1,Nm,i);this.setEditShape_(t,i)}}function Sc(t){const e=t[1],s=t[2],i=t[5];t[1]=t[3],t[2]=t[6],t[5]=t[7],t[3]=e,t[6]=s,t[7]=i}function vc(t,e,i){const n=t.getGeometryType();if(l(n)){const e=new am({vd:t.getDescription()});return e.addSegment(t,!0),e}if(n===s.enumEnvelope){const s=t,i=ge.constructEmpty();if(t.queryEnvelope(i),i.height()<=e&&i.width()<=e){const e=new Ge({vd:t.getDescription()});return s.getCenter(e),e}if(i.height()<=e||i.width()<=e){const e=new am({vd:t.getDescription()}),i=new Ge;return s.queryCornerByVal(0,i),e.startPathPoint(i),s.queryCornerByVal(2,i),e.lineToPoint(i),e}const n=new Sm({vd:t.getDescription()});return n.addEnvelope(s,!1),n}return t}function bc(t){return`${t[0]}${t[3]}${t[6]}${t[1]}${t[4]}${t[7]}${t[2]}${t[5]}${t[8]}`}class Ic{nullFunc(){return t(0),!1}constructor(t,e,s,i=!1){this.m_bDone=!1,this.m_tolerance=0,this.m_elementHandle=-1,this.m_query=ge.constructEmpty(),this.m_envInter=ge.constructEmpty(),this.m_quadTree=null,this.m_intersector=null,this.m_function=this.nullFunc;const n=t.getAccelerators();let r=null;null!=n&&(r=i?n.getQuadTreeForPaths():n.getQuadTree());const o=e.getAccelerators();let a=null;if(null!=o&&(a=i?o.getQuadTreeForPaths():o.getQuadTree()),null===r&&null===a&&!i){const i=t.getPointCount(),n=e.getPointCount();if(i>10&&n>10){const o=ge.constructEmpty(),h=ge.constructEmpty(),m=ge.constructEmpty();t.queryLooseEnvelope(o),e.queryLooseEnvelope(h),o.inflateCoords(s,s),h.inflateCoords(s,s),m.setCoords({env2D:o}),m.intersect(h),i>=n?r=p(t.getGeometryType())?Hs(t,m):zs(t,m):a=p(e.getGeometryType())?Hs(e,m):zs(e,m)}}this.construct_(t,r,e,a,s,i)}next(){if(this.m_bQuadTree){if(this.m_bDone)return!1;for(;this.m_function(););return!this.m_bDone}return!!this.m_intersector&&this.m_intersector.next()}getRedElement(){return this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElement(this.m_elementHandle):p(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_bSwapElements?this.m_intersector.getBlueElement(this.m_intersector.getHandleB()):this.m_intersector.getRedElement(this.m_intersector.getHandleA())}getBlueElement(){return this.m_bQuadTree?this.m_bSwapElements?p(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_quadTree.getElement(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedElement(this.m_intersector.getHandleA()):this.m_intersector.getBlueElement(this.m_intersector.getHandleB())}getRedEnvelope(){return this.m_bPaths||h(""),this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_query:this.m_bSwapElements?this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB()):this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA())}getBlueEnvelope(){return this.m_bPaths||h(""),this.m_bQuadTree?this.m_bSwapElements?this.m_query:this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA()):this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB())}construct_(t,e,i,n,r,o){const a=ge.constructEmpty(),h=ge.constructEmpty();t.queryLooseEnvelope(a),i.queryLooseEnvelope(h),a.inflateCoords(r,r),h.inflateCoords(r,r),this.m_envInter.setCoords({env2D:a}),this.m_envInter.intersect(h),this.m_multiVertexImplA=t,this.m_multiVertexImplB=i;const m=t.getGeometryType(),l=i.getGeometryType();this.m_bPaths=o,this.m_pathIndex=-1,this.m_pointIndex=-1,this.m_bSwapElements=!1,this.m_queryType=s.enumUnknown,this.m_bQuadTree=!1,null!==e&&(this.m_bDone=!1,this.m_tolerance=r,this.m_quadTree=e,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!0,p(l)?(this.m_queryType=l,this.m_function=this.nextPath_,o?this.m_pathIndex=i.getPathCount():this.m_segIter=i.querySegmentIterator()):(this.m_queryType=l,this.m_function=this.nextPoint_,this.m_pointIndex=i.getPointCount())),this.m_bQuadTree||null!==n&&(this.m_bDone=!1,this.m_tolerance=r,this.m_quadTree=n,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!1,p(m)?(this.m_queryType=m,this.m_function=this.nextPath_,o?this.m_pathIndex=t.getPathCount():this.m_segIter=t.querySegmentIterator()):(this.m_queryType=m,this.m_function=this.nextPoint_,this.m_pointIndex=t.getPointCount())),this.m_bQuadTree||(o&&p(m)&&p(l)?this.m_intersector=Xs(t,i,r):p(m)&&p(l)?(this.m_intersector=Ys(t,i,r),this.m_bSwapElements=!1):p(m)&&!p(l)?(this.m_intersector=ks(t,i,r),this.m_bSwapElements=!1):!p(m)&&p(l)?(this.m_intersector=ks(i,t,r),this.m_bSwapElements=!0):(this.m_intersector=Rs(t,i,r),this.m_bSwapElements=!1))}nextPath_(){return this.m_bPaths?-1==--this.m_pathIndex?(this.m_bDone=!0,!1):(this.m_bSwapElements?this.m_multiVertexImplB.queryPathEnvelope(this.m_pathIndex,this.m_query):this.m_multiVertexImplA.queryPathEnvelope(this.m_pathIndex,this.m_query),this.m_qtIter.resetIterator(this.m_query,this.m_tolerance),this.m_function=this.iterate_,!0):this.m_segIter.nextPath()?(this.m_function=this.nextSegment_,!0):(this.m_bDone=!0,!1)}nextSegment_(){if(!this.m_segIter.hasNextSegment())return this.m_function=this.nextPath_,!0;const t=this.m_segIter.nextSegment(),e=new ge;return t.queryLooseEnvelope(e),!e.isIntersecting(this.m_envInter)||(this.m_qtIter.resetIterator(t,this.m_tolerance),this.m_function=this.iterate_,!0)}nextPoint_(){if(-1==--this.m_pointIndex)return this.m_bDone=!0,!1;const t=new w;if(this.m_bSwapElements){const e=this.m_multiVertexImplB.getXY(this.m_pointIndex);t.setCoordsPoint2D(e)}else{const e=this.m_multiVertexImplA.getXY(this.m_pointIndex);t.setCoordsPoint2D(e)}return!this.m_envInter.contains(t)||(this.m_qtIter.resetIterator(ge.construct(t.x,t.y,t.x,t.y),this.m_tolerance),this.m_function=this.iterate_,!0)}iterate_(){return this.m_elementHandle=this.m_qtIter.next(),-1===this.m_elementHandle&&(p(this.m_queryType)?(this.m_function=this.m_bPaths?this.nextPath_:this.nextSegment_,!0):(this.m_function=this.nextPoint_,!0))}}function wc(t){return 2===t?1:1===t?2:128===t?64:64===t?128:t}function Dc(t,e,s){let i;if(t instanceof tC||null===t){const n=ge.constructEmpty();n.setCoords({pt:e}),n.mergeEnvelope2D(s),i=Is(t,n,!1)}else i=t;return i}function Tc(t,e,s){let i;if(t instanceof tC||null===t){const n=ge.constructEmpty();n.setCoords({env2D:e}),n.mergeEnvelope2D(s),i=Is(t,n,!1)}else i=t;return i}function Nc(t,e,i,n,r){if(t.isEmpty()||e.isEmpty())return 4===n;g(t),g(e);let o=t.getGeometryType(),a=e.getGeometryType();if(o===s.enumEnvelope){if(a===s.enumEnvelope)return Ac(t,e,i,n);if(a===s.enumPoint)return qc(e,t,i,wc(n))}else if(o===s.enumPoint){if(a===s.enumEnvelope)return qc(t,e,i,n);if(a===s.enumPoint)return Fc(t,e,i,n)}const h=ge.constructEmpty();t.queryEnvelope(h);const m=ge.constructEmpty();e.queryEnvelope(m);const u=Tc(i,h,m);if(Mc(h,m,u))return 4===n;let c=!1,_=null,d=null,p=null,f=null;switch(l(o)?(_=new am({vd:t.getDescription()}),_.addSegment(t,!0),p=_,o=s.enumPolyline):p=t,l(a)?(d=new am({vd:e.getDescription()}),d.addSegment(e,!0),f=d,a=s.enumPolyline):f=e,o!==s.enumEnvelope&&a!==s.enumEnvelope?(p.getDimension()<f.getDimension()||o===s.enumPoint&&a===s.enumMultiPoint)&&(n=wc(n)):o!==s.enumPolygon&&a!==s.enumEnvelope&&(n=wc(n)),o){case s.enumPolygon:switch(a){case s.enumPolygon:c=Yc(p,f,u,n,r);break;case s.enumPolyline:c=Xc(p,f,u,n,r);break;case s.enumPoint:c=kc(p,f,u,n);break;case s.enumMultiPoint:c=Rc(p,f,u,n);break;case s.enumEnvelope:c=Bc(p,f,u,n,r)}break;case s.enumPolyline:switch(a){case s.enumPolygon:c=Xc(f,p,u,n,r);break;case s.enumPolyline:c=Lc(p,f,u,n,r);break;case s.enumPoint:c=Hc(p,f,u,n);break;case s.enumMultiPoint:c=zc(p,f,u,n);break;case s.enumEnvelope:c=Uc(p,f,u,n,r)}break;case s.enumPoint:switch(a){case s.enumPolygon:c=kc(f,p,u,n);break;case s.enumPolyline:c=Hc(f,p,u,n);break;case s.enumMultiPoint:c=Wc(f,p,u,n)}break;case s.enumMultiPoint:switch(a){case s.enumPolygon:c=Rc(f,p,u,n);break;case s.enumPolyline:c=zc(f,p,u,n);break;case s.enumMultiPoint:c=Oc(p,f,u,n);break;case s.enumPoint:c=Wc(p,f,u,n);break;case s.enumEnvelope:c=jc(p,f,u,n)}break;case s.enumEnvelope:switch(a){case s.enumPolygon:c=Bc(f,p,u,n,r);break;case s.enumPolyline:c=Uc(f,p,u,n,r);break;case s.enumMultiPoint:c=jc(f,p,u,n)}}return c}function Ac(t,e,s,i,n){if(t.isEmpty()||e.isEmpty())return 4===i;const r=ge.constructEmpty();t.queryEnvelope(r);const o=ge.constructEmpty();e.queryEnvelope(o);const a=Tc(s,r,o);switch(i){case 4:return Mc(r,o,a);case 2:return o_(o,r,a,!1);case 128:return o_(o,r,a,!0);case 1:return o_(r,o,a,!1);case 64:return o_(r,o,a,!0);case 3:return i_(r,o,a);case 8:return n_(r,o,a);case 32:return r_(r,o,a);case 16:return!1}return!1}function qc(t,e,s,i,n){if(t.isEmpty()||e.isEmpty())return 4===i;const r=t.getXY(),o=ge.constructEmpty();e.queryEnvelope(o);const a=Dc(s,r,o);switch(i){case 4:return Vc(r,o,a);case 2:case 128:return s_(r,o,a);case 1:case 64:return!1;case 3:return t_(r,o,a);case 8:return e_(r,o,a)}return!1}function Fc(t,e,s,i,n){if(t.isEmpty()||e.isEmpty())return 4===i;const r=t.getXY(),o=e.getXY();let a;if(s instanceof tC||null===s){const t=ge.constructEmpty();t.setCoords({pt:r}),t.merge(o),a=Is(s,t,!1)}else a=s;switch(i){case 4:return Jg(r,o,a);case 2:case 128:return $g(o,r,a);case 1:case 64:return $g(r,o,a);case 3:return Kg(r,o,a)}return!1}function Mc(t,e,s){const i=ge.constructEmpty();return i.setCoords({env2D:e}),i.inflateCoords(s,s),!t.isIntersecting(i)}function Gc(e,s,i,n=!1){const r=e.getGeometryType(),a=s.getGeometryType();if(o(r)){const s=e.getImpl().getAccelerators();if(null!==s){const e=s.getRasterizedGeometry();t(null===e)}}if(o(a)){const e=s.getImpl().getAccelerators();if(null!==e){const s=e.getRasterizedGeometry();t(null===s)}}return 0}function Vc(t,e,s,i){const n=ge.constructEmpty();return n.setCoords({env2D:e}),n.inflateCoords(s,s),!n.contains(t)}function Yc(t,e,s,i,n){switch(i){case 4:return Qc(t,e,s);case 2:return $c(e,t,s,n);case 128:return tg(e,t,s);case 1:return $c(t,e,s,n);case 64:return tg(t,e,s);case 3:return Zc(t,e,s,n);case 8:return Kc(t,e,s);case 32:return Jc(t,e,s,n)}return!1}function Xc(t,e,s,i,n){switch(i){case 4:return eg(t,e,s);case 1:return ng(t,e,s,n);case 64:return rg(t,e,s);case 8:return sg(t,e,s,n);case 16:return ig(t,e,s)}return!1}function kc(t,e,s,i,n){switch(i){case 4:return og(t,e,s);case 1:case 64:return hg(t,e,s);case 8:return ag(t,e,s)}return!1}function Rc(t,e,s,i,n){switch(i){case 4:return mg(t,e,s);case 1:return cg(t,e,s,!1);case 64:return cg(t,e,s,!0);case 8:return lg(t,e,s);case 16:return ug(t,e,s)}return!1}function Bc(t,e,s,i,n){if(_g(t,e,s))return 4===i;if(4===i)return!1;switch(i){case 2:return fg(t,e,s,!1);case 128:return fg(t,e,s,!0);case 1:return xg(t,e,s,!1,n);case 64:return xg(t,e,s,!0,n);case 3:return gg(t,e,s,n);case 8:return dg(t,e,s,n);case 32:return pg(t,e,s,n);case 16:return!1}return!1}function Lc(t,e,s,i,n){switch(i){case 4:return Pg(t,e,s);case 2:return vg(e,t,s,n);case 128:return bg(e,t,s,n);case 1:return vg(t,e,s,n);case 64:return bg(t,e,s,n);case 3:return yg(t,e,s,n);case 8:return Eg(t,e,s,n);case 32:return Sg(t,e,s,n);case 16:return Cg(t,e,s,n)}return!1}function Hc(t,e,s,i,n){switch(i){case 4:return Ig(t,e,s);case 1:case 64:return Dg(t,e,s);case 8:return wg(t,e,s)}return!1}function zc(t,e,s,i,n){switch(i){case 4:return Tg(t,e,s);case 1:case 64:return qg(t,e,s);case 8:return Ng(t,e,s);case 16:return Ag(t,e,s)}return!1}function Uc(t,e,s,i,n){if(Mg(t,e,s))return 4===i;if(4===i)return!1;switch(i){case 2:return Vg(t,e,s,!1);case 128:return Vg(t,e,s,!0);case 1:case 64:case 32:return!1;case 3:return Fg(t,e,s);case 8:return Gg(t,e,s,n);case 16:return Yg(t,e,s)}return!1}function Oc(t,e,s,i,n){switch(i){case 4:return kg(t,e,s);case 2:case 128:return Bg(e,t,s);case 1:case 64:return Bg(t,e,s);case 3:return Xg(t,e,s);case 32:return Rg(t,e,s)}return!1}function Wc(t,e,s,i,n){switch(i){case 4:return Hg(t,e,s);case 2:case 128:return zg(t,e,s);case 1:case 64:return Ug(t,e,s);case 3:return Lg(t,e,s)}return!1}function jc(t,e,s,i,n){switch(i){case 4:return Wg(t,e,s);case 2:return Zg(t,e,s,!1);case 128:return Zg(t,e,s,!0);case 1:case 64:return!1;case 3:return Og(t,e,s);case 8:return jg(t,e,s);case 16:return Qg(t,e,s)}return!1}function Zc(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();if(t.queryEnvelope(n),e.queryEnvelope(r),!i_(n,r,s))return!1;if(Gc(t,e),g_(t,e,s))return!0;const o=t.calculateLength2D(),a=e.calculateLength2D(),h=Math.max(t.getPointCount(),e.getPointCount());if(Math.abs(o-a)>4*h*s)return!1;if(t.hasNonLinearSegments()||e.hasNonLinearSegments()){return Ku(t,e,s,"**F**FFF*",i,!1)}return p_(t,e,s,!0)}function Qc(t,e,s,i){Gc(t,e,s,!0);return 1===a_(t,e,s,!0)}function Kc(t,e,s,i){return Gc(t,e),v_(t,e,s,null)}function Jc(t,e,s,i){return Gc(t,e),b_(t,e,s,i)}function $c(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!!l_(n,r,s)&&(Gc(t,e),I_(t,e,s,i))}function tg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!!l_(n,r,s)&&(Gc(t,e),2===a_(t,e,s,!1))}function eg(t,e,s,i){Gc(t,e,s,!0);return 1===a_(t,e,s,!0)}function sg(t,e,s,i){return Gc(t,e),w_(t,e,s,i)}function ig(t,e,s,i){return Gc(t,e),D_(t,e,s,null)}function ng(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!!l_(n,r,s)&&(Gc(t,e),T_(t,e,s,i))}function rg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!!l_(n,r,s)&&(Gc(t,e),2===a_(t,e,s,!1))}function og(t,e,s,i){return 0===X_(t,e,s)}function ag(t,e,s,i){return A_(t,e.getXY(),s)}function hg(t,e,s,i){return N_(t,e.getXY(),s)}function mg(t,e,s,i,n){Gc(t,e);return 1===h_(t,e,s)}function lg(t,e,s,i){Gc(t,e);const n=ge.constructEmpty();t.queryEnvelope(n),n.inflateCoords(s,s);const r=new w;let o=!1;const a=t.getImpl(),h=new Sm;let m=t,l=!1;for(let u=0;u<e.getPointCount();u++){if(e.queryXY(u,r),n.contains(r)){const t=k_(m,r,s);if(2===t)o=!0;else if(1===t)return!1}l||(!Lu(t,e.getPointCount()-1)||null!==a.getAccelerators()&&null!==a.getAccelerators().getQuadTree()?m=t:(t.copyTo(h),h.getImpl().buildQuadTreeAccelerator(1),m=h),l=!0)}return!!o}function ug(t,e,s,i){Gc(t,e);const n=new ge,r=new ge,o=new ge;t.queryEnvelope(n),e.queryEnvelope(o),r.setCoords({env2D:n}),r.inflateCoords(s,s);let a=!1,h=!1;const m=new w,l=t.getImpl(),u=new Sm;let c=t,g=!1;for(let _=0;_<e.getPointCount();_++){if(e.queryXY(_,m),r.contains(m)){const t=k_(c,m,s);0===t?h=!0:1===t&&(a=!0)}else h=!0;if(a&&h)return!0;g||(!Lu(t,e.getPointCount()-1)||null!==l.getAccelerators()&&null!==l.getAccelerators().getQuadTree()?c=t:(t.copyTo(u),u.getImpl().buildQuadTreeAccelerator(1),c=u),g=!0)}return!1}function cg(t,e,s,i,n){const r=ge.constructEmpty(),o=ge.constructEmpty();if(t.queryEnvelope(r),e.queryEnvelope(o),!l_(r,o,s))return!1;Gc(t,e);let a=!1;const h=new w,m=t.getImpl(),l=new Sm;let u=t,c=!1;for(let g=0;g<e.getPointCount();g++){if(e.queryXY(g,h),!r.contains(h))return!1;const n=k_(u,h,s);if(1===n)a=!0;else if(0===n)return!1;if(i&&2===n)return!1;c||(!Lu(t,e.getPointCount()-1)||null!==m.getAccelerators()&&null!==m.getAccelerators().getQuadTree()?u=t:(t.copyTo(l),l.getImpl().buildQuadTreeAccelerator(1),u=l),c=!0)}return a}function gg(t,e,s,i){const n=new ge,r=new ge;if(t.queryEnvelope(n),e.queryEnvelope(r),!i_(n,r,s))return!1;const o=new Sm;return o.addEnvelope(e,!1),Zc(t,o,s,i)}function _g(t,e,s,i){Gc(t,e);const n=ge.constructEmpty(),r=ge.constructEmpty();if(t.queryEnvelope(n),e.queryEnvelope(r),l_(r,n,s))return!1;return 0===k_(t,r.getLowerLeft(),0)&&(!r.contains(t.getXY(0))&&!S_(t,r,s))}function dg(t,e,s,i){Gc(t,e);const n=new ge,r=new ge;if(t.queryEnvelope(n),e.queryEnvelope(r),l_(r,n,s))return!1;if(r.height()<=s||r.width()<=s)return!1;const o=new Sm;return o.addEnvelope(e,!1),v_(t,o,s,i)}function pg(t,e,s,i){Gc(t,e);const n=new ge,r=new ge;if(t.queryEnvelope(n),e.queryEnvelope(r),l_(r,n,s))return!1;if(r.height()<=s||r.width()<=s)return!1;const o=new Sm;return o.addEnvelope(e,!1),b_(t,o,s,i)}function fg(t,e,s,i,n){const r=ge.constructEmpty(),o=ge.constructEmpty();return t.queryEnvelope(r),e.queryEnvelope(o),i?u_(o,r,s):l_(o,r,s)}function xg(t,e,s,i,n){const r=ge.constructEmpty(),o=ge.constructEmpty();if(t.queryEnvelope(r),e.queryEnvelope(o),!l_(r,o,s))return!1;Gc(t,e);const a=new Sm;return a.addEnvelope(e,!1),i?2===a_(t,a,s,!1):I_(t,a,s,n)}function yg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();if(t.queryEnvelope(n),e.queryEnvelope(r),!i_(n,r,s))return!1;if(Gc(t,e),g_(t,e,s))return!0;if(t.hasNonLinearSegments()||e.hasNonLinearSegments()){return Ku(t,e,s,"**F**FFF*",i,!1)}return p_(t,e,s,!1)}function Pg(t,e,s,i){Gc(t,e);const n=t.getImpl(),r=e.getImpl();return!new Ic(n,r,s,!0).next()||!x_(t,e,s)}function Eg(t,e,s,i){Gc(t,e);const n=[],r=y_(t,e,s,n);if(-2===r){const n=ge.constructEmpty(),r=ge.constructEmpty(),o=ge.constructEmpty();let a,h;if(t.queryEnvelope(n),e.queryEnvelope(r),n.inflateCoords(1e3*s,1e3*s),r.inflateCoords(1e3*s,1e3*s),o.setCoords({env2D:n}),o.intersect(r),t.getPointCount()>10){if(a=dl(t,o,s,0,i),a.isEmpty())return!1}else a=t;if(e.getPointCount()>10){if(h=dl(e,o,s,0,i),h.isEmpty())return!1}else h=e;return Ku(a,h,s,"F********",i,!1)}if(0!==r)return!1;const o=new ii;for(let m=0;m<n.length;m+=2){const t=n[m],e=n[m+1];o.addXY(t,e)}const a=t.getBoundary(),h=e.getBoundary();return a.addPoints(h,0,h.getPointCount()),!a.isEmpty()&&Bg(a,o,s)}function Cg(t,e,s,i){Gc(t,e);const n=[],r=y_(t,e,s,n);if(-2===r){const n=ge.constructEmpty(),r=ge.constructEmpty(),o=ge.constructEmpty();let a,h;if(t.queryEnvelope(n),e.queryEnvelope(r),n.inflateCoords(1e3*s,1e3*s),r.inflateCoords(1e3*s,1e3*s),o.setCoords({env2D:n}),o.intersect(r),t.getPointCount()>10){if(a=dl(t,o,s,0,i),a.isEmpty())return!1}else a=t;if(e.getPointCount()>10){if(h=dl(e,o,s,0,i),h.isEmpty())return!1}else h=e;return Ku(a,h,s,"0********",i,!1)}if(0!==r)return!1;const o=new ii;for(let m=0;m<n.length;m+=2){const t=n[m],e=n[m+1];o.addXY(t,e)}const a=t.getBoundary(),h=e.getBoundary();return a.addPoints(h,0,h.getPointCount()),!!a.isEmpty()||!Bg(a,o,s)}function Sg(t,e,s,i){Gc(t,e);const n=ge.constructEmpty(),r=ge.constructEmpty();t.queryEnvelope(n),e.queryEnvelope(r);const o=c_(n,r,s),a=c_(r,n,s),h=t.hasNonLinearSegments(),m=e.hasNonLinearSegments(),l=y_(t,e,s,null);if(-1===l)return!1;if(1===l){if(o&&a)return!0;if(!h&&!m)return o&&!a?!f_(e,t,s,!1):a&&!o?!f_(t,e,s,!1):!f_(t,e,s,!1)&&!f_(e,t,s,!1)}const u=ge.constructEmpty(),c=ge.constructEmpty(),g=ge.constructEmpty();let _,d;u.setCoords({env2D:n}),u.inflateCoords(1e3*s,1e3*s),c.setCoords({env2D:r}),c.inflateCoords(1e3*s,1e3*s),g.setCoords({env2D:u}),g.intersect(c);let p="";if(p+="1*",o){if(e.getPointCount()>10){if(d=dl(e,g,s,0,i),d.isEmpty())return!1}else d=e;p+="****"}else d=e,p+="T***";if(a){if(t.getPointCount()>10){if(_=dl(t,g,s,0,i),_.isEmpty())return!1}else _=t;p+="***"}else _=t,p+="T**";return Ku(_,d,s,p,i,!1)}function vg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();if(t.queryEnvelope(n),e.queryEnvelope(r),!l_(n,r,s))return!1;if(Gc(t,e),t.hasNonLinearSegments()||e.hasNonLinearSegments()){return Ku(t,e,s,"******FF*",i,!1)}return f_(e,t,s,!1)}function bg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();if(t.queryEnvelope(n),e.queryEnvelope(r),!l_(n,r,s))return!1;Gc(t,e);return Ku(t,e,s,"T**FF*FF*",i,!1)}function Ig(t,e,s,i){Gc(t,e);return!E_(t,e.getXY(),s)}function wg(t,e,s,i){Gc(t,e);return F_(t,e.getXY(),s)}function Dg(t,e,s,i){Gc(t,e);return C_(t,e.getXY(),s)}function Tg(t,e,s,i){return Gc(t,e),!P_(t,e,s,!1)}function Ng(t,e,s,i){Gc(t,e);const n=t.getImpl(),r=e.getImpl(),o=new ii,a=new Ic(n,r,s,!1),h=n.querySegmentIterator();let m=!1;for(;a.next();){const t=a.getRedElement(),e=a.getBlueElement();h.resetToVertex(t,-1);const i=h.nextSegment(),n=r.getXY(e);i.isIntersectingPoint(n,s)&&(m=!0,o.addPoint2D(n))}if(!m)return!1;const l=t.getBoundary();return!l.isEmpty()&&Bg(l,o,s)}function Ag(t,e,s,i){Gc(t,e);const n=t.getImpl(),r=e.getImpl(),o=r.getPointCount(),a=H(o,!1),h=new Ic(n,r,s,!1),m=n.querySegmentIterator();let l=!1;for(;h.next();){const t=h.getRedElement(),e=h.getBlueElement();m.resetToVertex(t,-1);const i=m.nextSegment(),n=r.getXY(e);i.isIntersectingPoint(n,s)&&(l=!0,a[e]=!0)}if(!l)return!1;let u=!1;for(let _=0;_<o;_++)if(!a[_]){u=!0;break}if(!u)return!1;const c=t.getBoundary();if(c.isEmpty())return!0;const g=new ii;for(let _=0;_<o;_++)a[_]&&g.addPoint2D(r.getXY(_));return!Bg(c,g,s)}function qg(t,e,s,i,n){const r=ge.constructEmpty(),o=ge.constructEmpty();if(t.queryEnvelope(r),e.queryEnvelope(o),!l_(r,o,s))return!1;Gc(t,e);const a=P_(t,e,s,!0);if(!a)return a;const h=t.getBoundary();return h.isEmpty()?a:!Bg(h,e,s)}function Fg(t,e,s,i){const n=new ge,r=new ge;return t.queryEnvelope(n),e.queryEnvelope(r),!(r.height()>s&&r.width()>s)&&i_(n,r,s)}function Mg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();t.queryEnvelope(n),e.queryEnvelope(r);const o=M_(r,n,s);return 0===o?!S_(t,r,s):4===o}function Gg(t,e,i,n){const r=new ge,o=new ge;if(t.queryEnvelope(r),e.queryEnvelope(o),o.height()<=i||o.width()<=i)return!1;const a=new ge,h=new ge;if(a.setCoords({env2D:o}),h.setCoords({env2D:o}),a.inflateCoords(i,i),h.inflateCoords(-i,-i),h.containsEnvelope(r)||!r.isIntersecting(a))return!1;const l=t.getImpl().querySegmentIterator();l.stripAttributes();const u=t.getImpl().getAccelerators();let c=null,g=null;null!==u&&(c=u.getQuadTree(),null!==c&&(g=c.getIterator(o,i))),g||l.nextPath()||m("relational_operations");let _=!1,d=null;const p=new w,f=new w,x=t.hasNonLinearSegments();let y=!1;for(;;){if(null!==g){const t=g.next();if(-1===t)break;l.resetToVertex(c.getElement(t),-1),d=l.nextSegment()}else{for(;!l.hasNextSegment()&&l.nextPath(););if(!l.hasNextSegment())break;d=l.nextSegment()}if(x&&d.getGeometryType()!==s.enumLine){const t=new ge;if(d.queryEnvelope(t),h.containsEnvelope(t))return!1;if(a.isIntersecting(t)){y=!0;break}}else{p.assign(d.getStartXY()),f.assign(d.getEndXY());let t=h.clipLine(p,f);if(0!==t)return!1;_||(t=a.clipLine(p,f),0!==t&&(_=!0))}}if(!y)return _;const P=new Sm;return P.addEnvelope(o,!1),sg(P,t,i,n)}function Vg(t,e,i,n,r){const o=ge.constructEmpty(),a=ge.constructEmpty();if(t.queryEnvelope(o),e.queryEnvelope(a),a.height()<=i||a.width()<=i)return!1;if(n)return u_(a,o,i);if(!l_(a,o,i))return!1;const h=ge.constructEmpty();h.setCoords({env2D:a}),h.inflateCoords(-i,-i);const l=ge.constructEmpty();if(l.setCoords({env2D:a}),l.inflateCoords(i,i),h.containsEnvelope(o))return!0;const u=t.getImpl().querySegmentIterator();u.stripAttributes(),u.nextPath()||m("relational_operations");let c,g,_,d,p,f,x=!1;const y=t.hasNonLinearSegments();for(y&&(_=new CE,d=new CE,p=new CE,f=new CE,h.querySide(0,_),h.querySide(1,d),h.querySide(2,p),h.querySide(3,f));;){for(;!u.hasNextSegment()&&u.nextPath(););if(!u.hasNextSegment())break;const t=u.nextSegment();if(y&&t.getGeometryType()!==s.enumLine){if(t.isIntersecting(_,i)){x=!0;break}if(t.isIntersecting(d,i)){x=!0;break}if(t.isIntersecting(p,i)){x=!0;break}if(t.isIntersecting(f,i)){x=!0;break}}else{c=t.getStartXY(),g=t.getEndXY();if(0!==h.clipLine(c,g)){x=!0;break}}}return x}function Yg(e,i,n,r){const o=new ge,a=new ge;if(e.queryEnvelope(o),i.queryEnvelope(a),a.height()<=n||a.width()<=n)return!1;const h=new ge;if(h.setCoords({env2D:a}),h.inflateCoords(n,n),h.containsEnvelope(o))return!1;const m=!0,l=new ge;if(l.setCoords({env2D:a}),l.inflateCoords(-n,-n),!l.isIntersecting(o))return!1;const u=e.getImpl().querySegmentIterator();u.stripAttributes();const c=e.getImpl().getAccelerators();let g=null,_=null;if(null!==c&&(g=c.getQuadTree(),null!==g&&(_=g.getIterator(a,n))),!_){const e=u.nextPath();t(e)}let d=!1,p=null;const f=new w,x=new w;let y=null,P=null,E=null,C=null;for(e.hasNonLinearSegments()&&(y=new CE,P=new CE,E=new CE,C=new CE,l.querySide(0,y),l.querySide(1,P),l.querySide(2,E),l.querySide(3,C));;){if(null!==_){const t=_.next();if(-1===t)break;u.resetToVertex(g.getElement(t),-1),p=u.nextSegment()}else{for(;!u.hasNextSegment()&&u.nextPath(););if(!u.hasNextSegment())break;p=u.nextSegment()}if(p.getGeometryType()===s.enumLine){f.assign(p.getStartXY()),x.assign(p.getEndXY());if(0!==l.clipLine(f,x)){d=!0;break}}else{if(y.isIntersecting(p,n)){d=!0;break}if(P.isIntersecting(p,n)){d=!0;break}if(E.isIntersecting(p,n)){d=!0;break}if(C.isIntersecting(p,n)){d=!0;break}}}return d&&m}function Xg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!!i_(n,r,s)&&(!!__(t,e,s)||d_(t,e,s,!1,!0,!1))}function kg(t,e,s,i){const n=t,r=e,o=new Ic(n,r,s,!1),a=s*s,h=new w,m=new w;for(;o.next();){const t=o.getRedElement(),e=o.getBlueElement();if(n.queryXY(t,h),r.queryXY(e,m),w.sqrDistance(h,m)<=a)return!1}return!0}function Rg(t,e,s,i){return d_(t,e,s,!1,!1,!0)}function Bg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),!!l_(n,r,s)&&d_(e,t,s,!0,!1,!1)}function Lg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();return t.queryEnvelope(n),e.queryEnvelope(r),i_(n,r,s)}function Hg(t,e,s,i){return q_(t,e.getXY(),s)}function zg(t,e,s,i){return Lg(t,e,s)}function Ug(t,e,s,i){return!Hg(t,e,s)}function Og(t,e,s,i){const n=new ge,r=new ge;return t.queryEnvelope(n),e.queryEnvelope(r),!(r.height()>s||r.width()>s)&&i_(n,r,s)}function Wg(t,e,s,i){const n=ge.constructEmpty(),r=ge.constructEmpty();if(t.queryEnvelope(n),e.queryEnvelope(r),l_(r,n,s))return!1;const o=ge.constructEmpty();o.setCoords({env2D:r}),o.inflateCoords(s,s);const a=new w;for(let h=0;h<t.getPointCount();h++)if(t.queryXY(h,a),o.contains(a))return!1;return!0}function jg(t,e,s,i){const n=new ge,r=new ge,o=new ge;if(e.queryEnvelope(n),n.height()<=s||n.width()<=s)return!1;r.setCoords({env2D:n}),o.setCoords({env2D:n}),r.inflateCoords(s,s),o.inflateCoords(-s,-s);const a=new w;let h=!1;for(let m=0;m<t.getPointCount();m++)if(t.queryXY(m,a),r.contains(a)){if(o.containsExclusive(a))return!1;h=!0}return h}function Zg(t,e,s,i,n){const r=ge.constructEmpty(),o=ge.constructEmpty();if(t.queryEnvelope(r),e.queryEnvelope(o),o.height()<=s||o.width()<=s)return!1;if(i)return u_(o,r,s);if(!l_(o,r,s))return!1;let a=!1;const h=ge.constructEmpty(),m=ge.constructEmpty();h.setCoords({env2D:o}),m.setCoords({env2D:o}),h.inflateCoords(-s,-s),m.inflateCoords(s,s);const l=new w;for(let u=0;u<t.getPointCount();u++){if(t.queryXY(u,l),!m.contains(l))return!1;h.containsExclusive(l)&&(a=!0)}return a}function Qg(t,e,s,i){const n=new ge,r=new ge;if(t.queryEnvelope(n),e.queryEnvelope(r),l_(r,n,s))return!1;if(r.height()<=s||r.width()<=s)return!1;const o=new ge,a=new ge;o.setCoords({env2D:r}),o.inflateCoords(-s,-s),a.setCoords({env2D:r}),a.inflateCoords(s,s);const h=new w;let m=!1,l=!1;for(let u=0;u<t.getPointCount();u++)if(t.queryXY(u,h),!m&&o.containsExclusive(h)&&(m=!0),l||a.contains(h)||(l=!0),m&&l)return!0;return!1}function Kg(t,e,s,i){return w.sqrDistance(t,e)<=s*s}function Jg(t,e,s,i){return w.sqrDistance(t,e)>s*s}function $g(t,e,s,i){return Kg(t,e,s)}function t_(t,e,s,i){const n=new ge;return n.setCoords({pt:t}),i_(n,e,s)}function e_(t,e,s,i){if(e.height()<=s||e.width()<=s)return!1;const n=new ge,r=new ge;return n.setCoords({env2D:e}),n.inflateCoords(s,s),!!n.contains(t)&&(r.setCoords({env2D:e}),r.inflateCoords(-s,-s),!r.containsExclusive(t))}function s_(t,e,s,i){if(e.height()<=s||e.width()<=s)return!1;const n=ge.constructEmpty();n.setCoords({env2D:e}),n.inflateCoords(-s,-s);return n.containsExclusive(t)}function i_(t,e,s,i){return l_(t,e,s)&&l_(e,t,s)}function n_(t,e,s,i){if(t.height()<=s||t.width()<=s||e.height()<=s||e.width()<=s)return!1;const n=new ge;return n.setCoords({env2D:t}),n.inflateCoords(-s,-s),n.intersect(e),!(!n.isEmpty()&&n.height()>s&&n.width()>s)&&(n.setCoords({env2D:t}),n.inflateCoords(s,s),n.intersect(e),!n.isEmpty())}function r_(t,e,s,i){if(t.height()<=s||t.width()<=s||e.height()<=s||e.width()<=s)return!1;if(l_(t,e,s))return!1;if(l_(e,t,s))return!1;const n=new ge;return n.setCoords({env2D:t}),n.inflateCoords(-s,-s),n.intersect(e),!n.isEmpty()&&(n.height()>s||n.width()>s)}function o_(t,e,s,i,n){if(t.height()<=s||t.width()<=s)return!1;if(i)return u_(t,e,s);if(!l_(t,e,s))return!1;const r=ge.constructEmpty();return r.setCoords({env2D:t}),r.inflateCoords(-s,-s),r.intersect(e),!r.isEmpty()}function a_(t,e,i,n,r){const o=new w,a=new w,h=ge.constructEmpty(),m=ge.constructEmpty(),l=t.getImpl(),u=e.getImpl(),c=u.getGeometryType(),g=new Ic(l,u,i,!0);if(!g.next())return 1;if(x_(t,e,i))return n?4:0;const _=new Sm;let d=t;const p=new Sm;let f=null;c===s.enumPolygon&&(f=e);const x=c===s.enumPolygon?H(l.getPathCount(),!1):[],y=H(u.getPathCount(),!1);let P=!1,E=!1,C=!1,S=!1,v=!1,b=!1;do{if(C&&v||S&&b)break;if(C&&S)break;const r=g.getRedElement(),I=g.getBlueElement();if(!y[I]&&(a.assign(e.getXY(e.getPathStart(I))),h.setCoords({env2D:g.getRedEnvelope()}),h.inflateCoords(i,i),h.contains(a))){if(0!==k_(d,a,0)){if(S=!0,n)return 4}else b=!0;y[I]=!0}if(c===s.enumPolygon&&!x[r]&&(o.assign(t.getXY(t.getPathStart(r))),m.setCoords({env2D:g.getBlueEnvelope()}),m.inflateCoords(i,i),m.contains(o))){if(0!==k_(f,o,0)){if(C=!0,n)return 4}else v=!0;x[r]=!0}if(P||(!Lu(t,e.getPathCount()-1)||null!==l.getAccelerators()&&null!==l.getAccelerators().getQuadTree()?d=t:(t.copyTo(_),_.getImpl().buildQuadTreeAccelerator(1),d=_),P=!0),c===s.enumPolygon&&!E){const s=e;!Lu(s,t.getPathCount()-1)||null!==u.getAccelerators()&&null!==u.getAccelerators().getQuadTree()?f=e:(s.copyTo(p),p.getImpl().buildQuadTreeAccelerator(1),f=p),E=!0}}while(g.next());if(!C&&!S)return 1;if(!v||!b){if(c===s.enumPolygon)for(let t=0,e=l.getPathCount();t<e;t++)if(!x[t]){v=!0;break}for(let t=0,e=u.getPathCount();t<e;t++)if(!y[t]){b=!0;break}}return C&&v||S&&b||C&&S?4:S?2:3}function h_(t,e,s,i,n){const r=ge.constructEmpty();t.queryEnvelope(r),r.inflateCoords(s,s);const o=new w,a=t.getImpl(),h=new Sm;let m=t,l=!1,u=!1,c=!1;for(let g=0;g<e.getPointCount();g++){if(e.queryXY(g,o),r.contains(o)){const t=k_(m,o,s);if(1===t)return u=!0,4;if(2===t)return 4;c=!0}else c=!0;l||(!Lu(t,e.getPointCount()-1)||null!==a.getAccelerators()&&null!=a.getAccelerators().getQuadTree()?m=t:(t.copyTo(h),h.getImpl().buildQuadTreeAccelerator(1),m=h),l=!0)}return u?c?4:2:1}function m_(e,i,n,r,o){r[0]=!1;const a=e.getImpl(),h=i.getImpl(),m=a.querySegmentIterator(),l=h.querySegmentIterator(),u=[0,0],c=[0,0],g=new Ic(a,h,n);let _=!1;for(;g.next();){const t=g.getRedElement(),e=g.getBlueElement();m.resetToVertex(t,-1),l.resetToVertex(e,-1);const s=m.nextSegment(),i=l.nextSegment();let o=0;if(G_(s,i)?!_&&i.isIntersecting(s,n)&&(_=!0):o=i.intersect(s,null,c,u,n),0!==o&&(_=!0,1===o)){const t=u[0],e=c[0];if(t>0&&t<1&&e>0&&e<1)return r[0]=!0,!1}}if(!_){r[0]=!0;const o=ge.constructEmpty();e.queryEnvelope(o),o.inflateCoords(n,n);const m=new Sm;let l=e,u=!1;for(let s=0,n=i.getPathCount();s<n;s++)if(i.getPathSize(s)>0){const n=ge.constructEmpty();if(i.queryPathEnvelope(s,n),!o.isIntersecting(n))return!1;{const e=Bu(l,i.getXY(i.getPathStart(s)),0);if(t(-1!==e),0===e)return!1}u||(!Lu(e,i.getPathCount()-1)||null!==a.getAccelerators()&&null!==a.getAccelerators().getQuadTree()?l=e:(e.copyTo(m),m.getImpl().buildQuadTreeAccelerator(1),l=m),u=!0)}if(1===e.getPathCount()||i.getGeometryType()===s.enumPolyline)return!0;const c=i,g=ge.constructEmpty();c.queryEnvelope(g),g.inflateCoords(n,n);const _=new Sm;let d=c,p=!1;for(let s=0,i=e.getPathCount();s<i;s++)if(e.getPathSize(s)>0){const i=ge.constructEmpty();if(e.queryPathEnvelope(s,i),g.isIntersecting(i)){const i=Bu(d,e.getXY(e.getPathStart(s)),0);if(t(-1!==i),1===i)return!1}p||(!Lu(c,e.getPathCount()-1)||null!==h.getAccelerators()&&null!==h.getAccelerators().getQuadTree()?d=c:(c.copyTo(_),_.getImpl().buildQuadTreeAccelerator(1),d=_),p=!0)}return!0}return!1}function l_(t,e,s){const i=ge.constructEmpty();return i.setCoords({env2D:t}),i.inflateCoords(s,s),i.containsEnvelope(e)}function u_(t,e,s){const i=ge.constructEmpty();return i.setCoords({env2D:e}),i.inflateCoords(s,s),t.containsExclusiveEnvelope(i)}function c_(t,e,s){const i=ge.constructEmpty();return i.setCoords({env2D:e}),i.inflateCoords(s,s),!i.contains(t.getLowerLeft())||(!i.contains(t.getLowerRight())||(!i.contains(t.getUpperLeft())||!i.contains(t.getUpperRight())))}function g_(t,e,s,i){if(t.getPathCount()!==e.getPathCount()||t.getPointCount()!==e.getPointCount())return!1;if(t.hasNonLinearSegments()||e.hasNonLinearSegments())return t.equals(e);const n=new w,r=new w;let o=!0;const a=s*s;for(let h=0;h<t.getPathCount();h++){if(t.getPathEnd(h)!==e.getPathEnd(h)){o=!1;break}for(let s=t.getPathStart(h);s<e.getPathEnd(h);s++)if(t.queryXY(s,n),e.queryXY(s,r),w.sqrDistance(n,r)>a){o=!1;break}if(!o)break}return!!o}function __(t,e,s,i){if(t.getPointCount()!==e.getPointCount())return!1;const n=new w,r=new w;let o=!0;const a=s*s;for(let h=0;h<t.getPointCount();h++)if(t.queryXY(h,n),e.queryXY(h,r),w.sqrDistance(n,r)>a){o=!1;break}return!!o}function d_(t,e,s,i,n,r,o){const a=t.getImpl(),h=e.getImpl(),m=a.getPointCount(),l=h.getPointCount(),u=H(m,!1),c=n||r?H(l,!1):[],g=s*s,_=new Ic(a,h,s);for(;_.next();){const t=_.getRedElement(),e=_.getBlueElement(),s=a.getXY(t),i=h.getXY(e);w.sqrDistance(s,i)<=g&&(u[t]=!0,(n||r)&&(c[e]=!0))}let d=!1,p=!1;for(let y=0;y<m;y++){const t=u[y];if(d||=!t,p||=t,(n||i)&&d)return!1}if(i)return!0;let f=!1,x=!1;for(let y=0;y<l;y++){const t=c[y];if(f||=!t,x||=t,n&&f)return!1}return!!n||d&&p&&f&&x}function p_(t,e,s,i){return f_(t,e,s,i)&&f_(e,t,s,i)}function f_(t,e,s,i){if(c(t),c(e),e.isEmpty())return!1;let n=!0;const r=H(2,Number.NaN),o=H(2,Number.NaN),a=[],h=new Y_;let l;const u=ge.constructEmpty(),g=ge.constructEmpty(),_=ge.constructEmpty();t.queryEnvelope(u),e.queryEnvelope(g),u.inflateCoords(s,s),g.inflateCoords(s,s),_.setCoords({env2D:u}),_.intersect(g);const d=t.getImpl().querySegmentIterator(),p=e.getImpl().querySegmentIterator(),f=e.getImpl().getAccelerators();let x=null,y=null,P=null,E=null;if(null!==f&&(x=f.getQuadTree(),y=f.getQuadTreeForPaths(),null!==y&&(E=y.getIteratorForQT())),null===x){const s=t.getPointCount(),i=e.getPointCount();s>10&&i>10&&(x=Hs(e.getImpl(),_))}for(null!==x&&(P=x.getIteratorForQT());d.nextPath();)for(;d.hasNextSegment();){let t=d.nextSegment();if(t.queryEnvelope(u),!u.isIntersecting(_))return n=!1,!1;if(null!==E&&(E.resetIterator(u,s),-1===E.next()))continue;let e=0,c=null;if(null!=P)P.resetIterator(t,s);else if(p.resetToFirstPath(),!p.nextPath())return n=!1,!1;do{if(e=0,null!==P){const i=P.next();if(-1===i)return n=!1,!1;p.resetToVertex(x.getElement(i),-1),c=p.nextSegment(),e=t.intersect(c,null,r,o,s)}else{for(;!p.hasNextSegment();)if(!p.nextPath())return n=!1,!1;c=p.nextSegment(),c.queryEnvelope(g),g.inflateCoords(s,s),u.isIntersecting(g)&&(e=t.intersect(c,null,r,o,s))}}while(2!==e||0!==r[0]||i&&!(o[0]<=o[1]));let f=Number.NaN,y=!1;do{let i=!1;if(1===r[1]){if(!d.hasNextSegment()){y=!0;break}t=d.nextSegment(),i=!0}if(1===o[1]&&o[0]<=o[1]){if(-1===f)break;if(f=1,!p.hasNextSegment())break;c=p.nextSegment(),i=!0}if(0===o[1]&&o[0]>o[1]){if(1===f)break;if(Number.isNaN(f)){if(!p.hasPreviousSegment())break;p.previousSegment(),f=-1}if(!p.hasPreviousSegment())break;c=p.previousSegment(),i=!0}if(!i)break;e=t.intersect(c,null,r,o,s)}while(2===e&&(!i||o[0]<=o[1]));if(y)continue;const C=t.calculateLength2D();t.queryEnvelope(u),a.length=0,h.m_overlapEvents.length=0;let S=!1,v=!1,b=0;const I=Is(null,u,!0);for(null!==P?P.resetIterator(t,s):(p.resetToFirstPath(),p.nextPath()||m("relational_operations"));;){if(e=0,null!==P){const i=P.next();if(-1===i)break;p.resetToVertex(x.getElement(i),-1),c=p.nextSegment(),e=t.intersect(c,null,r,o,s)}else{for(;!p.hasNextSegment()&&p.nextPath(););if(!p.hasNextSegment())break;c=p.nextSegment(),c.queryEnvelope(g),g.inflateCoords(s,s),u.isIntersecting(g)&&(e=t.intersect(c,null,r,o,s))}if(2===e&&(!i||o[0]<=o[1])){const t=d.getStartPointIndex(),e=d.getPathIndex(),i=p.getStartPointIndex(),n=p.getPathIndex();if(l=V_(t,e,r[0],r[1],i,n,o[0],o[1]),h.m_overlapEvents.push(l),a.push(a.length),!(S||l.m_scalarA0<b&&l.m_scalarA1<b))if(0===b&&C*(l.m_scalarA0-b)>s)S=!0;else if(0!==b&&C*(l.m_scalarA0-b)>I)S=!0;else if(b=l.m_scalarA1,C*(1-b)<=s||1===b){v=!0;break}}}if(!v){if(!S)return n=!1,!1;a.length>1&&a.sort(((t,e)=>h.compareOverlapEvents(t,e))),b=0;for(let t=0;t<h.m_overlapEvents.length;t++)if(l=h.m_overlapEvents[a[t]],!(l.m_scalarA0<b&&l.m_scalarA1<b)){if(0===b&&C*(l.m_scalarA0-b)>s)return n=!1,!1;if(0!==b&&C*(l.m_scalarA0-b)>I)return n=!1,!1;if(b=l.m_scalarA1,C*(1-b)<=s||1===b)break}if(C*(1-b)>s)return n=!1,!1;a.length=0,h.m_overlapEvents.length=0}}return n}function x_(t,e,s){const i=t.getImpl(),n=e.getImpl(),r=i.querySegmentIterator(),o=n.querySegmentIterator(),a=new Ic(i,n,s);for(;a.next();){const t=a.getRedElement(),e=a.getBlueElement();r.resetToVertex(t,-1),o.resetToVertex(e,-1);const i=r.nextSegment();if(o.nextSegment().isIntersecting(i,s))return!0}return!1}function y_(t,e,s,i){const n=t.getImpl(),r=e.getImpl(),o=n.querySegmentIterator(),a=r.querySegmentIterator(),h=H(2,Number.NaN),m=new Ic(n,r,s);let l=!1,u=-1;for(;m.next();){const t=m.getRedElement(),e=m.getBlueElement();o.resetToVertex(t,-1),a.resetToVertex(e,-1);const n=o.nextSegment(),r=a.nextSegment();let c=0;if(G_(n,r)){if(r.isIntersecting(n,s))return-2}else c=n.intersect(r,null,h,null,s);if(c)if(2===c){const t=n.calculateLength2D(),e=h[0];if(t*(h[1]-e)>s)return u=1,u;l=!0}else if(u=0,i){const t=h[0],e=new w;n.queryCoord2D(t,e),i.push(e.x),i.push(e.y)}}return l?-2:u}function P_(t,e,s,i){const n=t.getImpl(),r=e,o=r.getPointCount(),a=i?H(o,!1):[],h=new Ic(n,r,s,!1),m=n.querySegmentIterator();for(;h.next();){const t=h.getRedElement(),e=h.getBlueElement();m.resetToVertex(t,-1);const n=m.nextSegment(),o=r.getXY(e);if(n.isIntersectingPoint(o,s)){if(!i)return!0;a[e]=!0}}if(!i)return!1;for(let l=0;l<o;l++)if(!a[l])return!1;return!0}function E_(t,e,s){const i=new w,n=s*s,r=t.querySegmentIterator(),o=t.getImpl().getAccelerators();if(null!==o){const t=o.getQuadTree();if(null!==t){const o=ge.constructEmpty();o.setCoords({pt:e});const a=t.getIterator(o,s);for(let s=a.next();-1!==s;s=a.next())if(r.resetToVertex(t.getElement(s),-1),r.hasNextSegment()){const t=r.nextSegment(),s=t.getClosestCoordinate(e,!1);if(t.queryCoord2D(s,i),w.sqrDistance(e,i)<=n)return!0}return!1}}const a=ge.constructEmpty();for(;r.nextPath();)for(;r.hasNextSegment();){const t=r.nextSegment();if(t.queryEnvelope(a),a.inflateCoords(s,s),!a.contains(e))continue;const o=t.getClosestCoordinate(e,!1);if(t.queryCoord2D(o,i),w.sqrDistance(e,i)<=n)return!0}return!1}function C_(t,e,s){return E_(t,e,s)&&!F_(t,e,s)}function S_(t,e,i,n){const r=t.querySegmentIterator(),o=t.getImpl().getAccelerators(),a=t.hasNonLinearSegments();let h=null,m=null,l=null,u=null;if(null!==o){const t=o.getQuadTree();if(null!==t){const n=t.getIterator(e,i);a&&(h=new CE,m=new CE,l=new CE,u=new CE,e.querySide(0,h),e.querySide(1,m),e.querySide(2,l),e.querySide(3,u));const o=ge.constructEmpty();o.setCoords({env2D:e}),o.inflateCoords(i,i);for(let a=n.next();-1!==a;a=n.next())if(r.resetToVertex(t.getElement(a),-1),r.hasNextSegment()){const t=r.nextSegment();if(t.getGeometryType()===s.enumLine){const e=t.getStartXY(),s=t.getEndXY();if(o.clipLine(e,s))return!0;continue}if(e.contains(t.getStartXY())||e.contains(t.getEndXY()))return!0;if(t.isIntersecting(h,i))return!0;if(t.isIntersecting(m,i))return!0;if(t.isIntersecting(l,i))return!0;if(t.isIntersecting(u,i))return!0}return!1}}if(a){h=new CE,m=new CE,l=new CE,u=new CE,e.querySide(0,h),e.querySide(1,m),e.querySide(2,l),e.querySide(3,u);const s=t.querySegmentIterator();for(;s.nextPath();)for(;s.hasNextSegment();){const t=s.nextSegment();if(e.contains(t.getStartXY())||e.contains(t.getEndXY()))return!0;if(t.isIntersecting(h,i))return!0;if(t.isIntersecting(m,i))return!0;if(t.isIntersecting(l,i))return!0;if(t.isIntersecting(u,i))return!0}}else{const s=ge.constructEmpty();s.setCoords({env2D:e}),s.inflateCoords(i,i);const n=t.getImpl(),r=n.getAttributeStreamRef(0),o=new w;for(let t=0,e=n.getPathCount();t<e;t++){let e=!0;const i=new w,a=new w,h=new w,m=n.getPathStart(t),l=new w;for(let u=m,c=n.getPathEnd(t);u<c;u++)if(e)r.queryPoint2D(2*u,i),l.assign(i),e=!1;else{if(r.queryPoint2D(2*u,o),a.setCoordsPoint2D(i),h.setCoordsPoint2D(o),s.clipLine(a,h))return!0;i.assign(o)}if(n.isClosedPath(t)&&!e&&(a.setCoordsPoint2D(i),h.setCoordsPoint2D(l),s.clipLine(a,h)))return!0}}return!1}function v_(t,e,s,i){const n=t.getImpl(),r=e.getImpl(),o=[0],a=As(n.getIsSimple(0,o))&&As(r.getIsSimple(0,o)),h=n.querySegmentIterator(),m=r.querySegmentIterator(),l=H(2,0),u=H(2,0),c=new Ic(n,r,s);let g=!1;for(;c.next();){const t=c.getRedElement(),e=c.getBlueElement();h.resetToVertex(t,-1),m.resetToVertex(e,-1);const i=h.nextSegment(),n=m.nextSegment();let r=0;if(G_(i,n)){if(n.isIntersecting(i,s)){g=!0;break}}else r=n.intersect(i,null,u,l,s);if(2===r){const t=l[0],e=l[1],n=i.calculateLength2D();if(a&&(e-t)*n>s)return!1;g=!0}else if(r){const t=l[0],e=u[0];if(t>0&&t<1&&e>0&&e<1)return!1;g=!0}}if(!g)return!1;const _=ge.constructEmpty(),d=ge.constructEmpty(),p=ge.constructEmpty();let f,x;if(t.queryEnvelope(_),e.queryEnvelope(d),_.inflateCoords(1e3*s,1e3*s),d.inflateCoords(1e3*s,1e3*s),p.setCoords({env2D:_}),p.intersect(d),t.getPointCount()>10){if(f=dl(t,p,s,0,i),f.isEmpty())return!1}else f=t;if(e.getPointCount()>10){if(x=dl(e,p,s,0,i),x.isEmpty())return!1}else x=e;return Ku(f,x,s,"F********",i,!1)}function b_(t,e,s,i){const n=t.getImpl(),r=e.getImpl(),o=[0],a=As(n.getIsSimple(0,o))&&As(r.getIsSimple(0,o)),h=ge.constructEmpty(),m=ge.constructEmpty(),l=ge.constructEmpty();t.queryEnvelope(h),e.queryEnvelope(m);let u=!1;const c=c_(h,m,s),g=c_(m,h,s),_=n.querySegmentIterator(),d=r.querySegmentIterator(),p=H(2,Number.NaN),f=H(2,Number.NaN),x=new Ic(n,r,s);for(;x.next();){const t=x.getRedElement(),e=x.getBlueElement();_.resetToVertex(t,-1),d.resetToVertex(e,-1);const i=_.nextSegment(),n=d.nextSegment();let r=0;if(G_(i,n)){if(n.isIntersecting(i,s))break}else r=n.intersect(i,null,f,p,s);if(2===r){const t=p[0],e=p[1],n=i.calculateLength2D();if(a&&(e-t)*n>s&&(u=!0,c&&g))return!0}else if(r){const t=p[0],e=f[0];if(t>0&&t<1&&e>0&&e<1)return!0}}const y=ge.constructEmpty(),P=ge.constructEmpty();let E,C;y.setCoords({env2D:h}),y.inflateCoords(1e3*s,1e3*s),P.setCoords({env2D:m}),P.inflateCoords(1e3*s,1e3*s),l.setCoords({env2D:y}),l.intersect(P);let S="";if(S+=u?"**":"T*",c){if(e.getPointCount()>10){if(C=dl(e,l,s,0,i),C.isEmpty())return!1}else C=e;S+="****"}else C=e,S+="T***";if(g){if(t.getPointCount()>10){if(E=dl(t,l,s,0,i),E.isEmpty())return!1}else E=t;S+="***"}else E=t,S+="T**";return Ku(E,C,s,S,i,!1)}function I_(t,e,s,i){const n=[!1],r=m_(t,e,s,n);if(n[0])return r;const o=ge.constructEmpty();let a;if(e.queryEnvelope(o),o.inflateCoords(1e3*s,1e3*s),t.getPointCount()>10){if(a=dl(t,o,s,0,i),a.isEmpty())return!1}else a=t;return Ju(a,e,s,i)}function w_(t,e,s,i){const n=t.getImpl(),r=e.getImpl(),o=n.querySegmentIterator(),a=r.querySegmentIterator(),h=H(2,Number.NaN),m=H(2,Number.NaN),l=new Ic(n,r,s);let u=!1;for(;l.next();){const t=l.getRedElement(),e=l.getBlueElement();o.resetToVertex(t,-1),a.resetToVertex(e,-1);const i=o.nextSegment(),n=a.nextSegment();let r=0;if(G_(i,n)?!u&&n.isIntersecting(i,s)&&(u=!0):r=n.intersect(i,null,m,h,s),2===r)u=!0;else if(r){const t=h[0],e=m[0];if(t>0&&t<1&&e>0&&e<1)return!1;u=!0}}if(!u)return!1;const c=ge.constructEmpty(),g=ge.constructEmpty(),_=ge.constructEmpty();let d,p;if(t.queryEnvelope(c),e.queryEnvelope(g),c.inflateCoords(1e3*s,1e3*s),g.inflateCoords(1e3*s,1e3*s),_.setCoords({env2D:c}),_.intersect(g),t.getPointCount()>10){if(d=dl(t,_,s,0,i),d.isEmpty())return!1}else d=t;if(e.getPointCount()>10){if(p=dl(e,_,s,0,i),p.isEmpty())return!1}else p=e;return Ku(d,p,s,"F********",i,!1)}function D_(t,e,s,i){const n=t.getImpl(),r=e.getImpl(),o=n.querySegmentIterator(),a=r.querySegmentIterator(),h=H(2,Number.NaN),m=H(2,Number.NaN),l=new Ic(n,r,s);let u=!1;for(;l.next();){const t=l.getRedElement(),e=l.getBlueElement();o.resetToVertex(t,-1),a.resetToVertex(e,-1);const i=o.nextSegment(),n=a.nextSegment();let r=0;if(G_(i,n)?!u&&n.isIntersecting(i,s)&&(u=!0):r=n.intersect(i,null,m,h,s),2===r)u=!0;else if(r){const t=h[0],e=m[0];if(t>0&&t<1&&e>0&&e<1)return!0;u=!0}}if(!u)return!1;const c=ge.constructEmpty(),g=ge.constructEmpty(),_=ge.constructEmpty(),d=ge.constructEmpty(),p=ge.constructEmpty();if(t.queryEnvelope(c),e.queryEnvelope(g),c_(g,c,s)){let n,r;if(_.setCoords({env2D:c}),_.inflateCoords(1e3*s,1e3*s),d.setCoords({env2D:g}),d.inflateCoords(1e3*s,1e3*s),p.setCoords({env2D:_}),p.intersect(d),t.getPointCount()>10){if(n=dl(t,p,s,0,i),n.isEmpty())return!1}else n=t;if(e.getPointCount()>10){if(r=dl(e,p,s,0,i),r.isEmpty())return!1}else r=e;return Ku(n,r,s,"T********",i,!1)}return Ku(t,e,s,"T*****T**",i,!1)}function T_(t,e,s,i){const n=[!1],r=m_(t,e,s,n);if(n[0])return r;const o=ge.constructEmpty();let a;if(e.queryEnvelope(o),o.inflateCoords(1e3*s,1e3*s),t.getPointCount()>10){if(a=dl(t,o,s,0,i),a.isEmpty())return!1}else a=t;return $u(a,e,s,i)}function N_(t,e,s,i){return 1===k_(t,e,s)}function A_(t,e,s,i){return 2===k_(t,e,s)}function q_(t,e,s,i){const n=new w,r=s*s;for(let o=0;o<t.getPointCount();o++)if(t.queryXY(o,n),w.sqrDistance(n,e)<=r)return!1;return!0}function F_(t,e,s){const i=t.getBoundary();return!i.isEmpty()&&!q_(i,e,s)}function M_(t,e,s){const i=ge.constructEmpty();return i.setCoords({env2D:t}),i.inflateCoords(s,s),i.containsEnvelope(e)?1073741824:i.isIntersecting(e)?t.isIntersecting(e)?t.xmin<e.xmin&&e.xmax<t.xmax?e.ymin<t.ymin&&e.ymax>t.ymax?0:1073741824:t.ymin<e.ymin&&e.ymax<t.ymax?e.xmin<t.xmin&&e.xmax>t.xmax?0:1073741824:0:0:4}function G_(t,e){return t.getGeometryType()!==s.enumLine||e.getGeometryType()!==s.enumLine}function V_(t,e,s,i,n,r,o,a){return{m_ivertexA:t,m_ipathA:e,m_scalarA0:s,m_scalarA1:i,m_ivertexB:n,m_ipathB:r,m_scalarB0:o,m_scalarB1:a}}class Y_{constructor(){this.m_overlapEvents=[]}compareOverlapEvents(t,e){const s=this.m_overlapEvents[t],i=this.m_overlapEvents[e];if(s.m_ipathA<i.m_ipathA)return-1;if(s.m_ipathA===i.m_ipathA){if(s.m_ivertexA<i.m_ivertexA)return-1;if(s.m_ivertexA===i.m_ivertexA){if(s.m_scalarA0<i.m_scalarA0)return-1;if(s.m_scalarA0===i.m_scalarA0){if(s.m_scalarA1<i.m_scalarA1)return-1;if(s.m_scalarA1===i.m_scalarA1&&s.m_ivertexB<i.m_ivertexB)return-1}}}return 1}}function X_(t,e,s){const i=Ru(t,e,s);return i?1===i?1:2:0}function k_(t,e,s){const i=Bu(t,e,s);return i?1===i?1:2:0}function R_(t,e,s,i,n){for(let r=0;r<s;r++)n[r]=k_(t,e[r],i)}function B_(t,e,i,n,r){if(t.getGeometryType()===s.enumPolygon)R_(t,e,i,n,r);else if(t.getGeometryType()===s.enumEnvelope){const s=ge.constructEmpty();t.queryEnvelope(s),H_(s,e,i,n,r)}else h("")}function L_(t,e,i,n,r){const o=t.getGeometryType();o===s.enumPolyline?W_(t,e,i,n,r):l(o)?O_():h("")}function H_(t,e,s,i,n){if(t.isEmpty()){for(let t=0;t<s;t++)n[t]=0;return}const r=t.clone();r.inflateCoords(.5*-i,.5*-i);const o=t.clone();o.inflateCoords(.5*i,.5*i);for(let a=0;a<s;a++)r.contains(e[a])?n[a]=1:o.contains(e[a])?n[a]=2:n[a]=0}function z_(t){if(t.isEmpty())return 0;switch(t.getGeometryType()){case s.enumMultiPoint:return t.getImpl().getPointCount();case s.enumPolyline:return t.getImpl().getPathCount();case s.enumPolygon:return t.getImpl().getOGCPolygonCount();case s.enumGeometryCollection:return t.getGeometryCount()}return 1}function U_(t,e,s){if(s.reset(),e<3)return;const i=t[0].clone(),n=i.x,r=i.y,o=t[1].clone(),a=new w;for(let h=2;h<e;h++)a.assign(t[h]),s.pe((a.x-i.x)*(o.y-r)),i.assign(o),o.assign(a);s.pe((n-i.x)*(o.y-r))}function O_(e,s,i,n,r){t(0)}function W_(e,s,i,n,r){const o=e.getImpl(),a=o.getAccelerators();let h=null;a&&(h=a.getRasterizedGeometry());let m=i;for(let l=0;l<i;l++)r[l]=1,h&&t(0);if(m){if(a){let t=null;null!==a&&null!==a.getQuadTree()&&(t=a.getQuadTree());const e=o.getPointCount();if(null===t&&e>20&&e*i>4*e+Math.log(e)*i&&(t=Hs(o)),t){let e=null;const a=o.querySegmentIterator(),h=new ge;for(let o=0;o<i&&m;o++)if(1===r[o]){h.setCoords(s[o]),null===e?e=t.getIterator(h,n):e.resetIterator(h,n);let i=-1;for(let h=e.next();-1!==h;h=e.next()){a.resetToVertex(t.getElement(h),i),i=a.getPathIndex();if(a.nextSegment().isIntersectingPoint(s[o],n)){r[o]=2,m--;break}r[o]=0}}return}}const t=o.querySegmentIterator();for(;t.nextPath()&&m;)for(;t.hasNextSegment()&&m;){const e=t.nextSegment();for(let t=0;t<i&&m;t++)1===r[t]&&e.isIntersectingPoint(s[t],n)&&(r[t]=2,m--)}}for(let t=0;t<i;t++)1===r[t]&&(r[t]=0)}function j_(t,e,s,i,n){const r=Yi(e),o=Math.max(4*r,s);return new td(e,null,o,Number.NaN,n).approximateWithCirclesImpl(t,i)}function Z_(){return Number.isNaN(this.radius.value())}function Q_(){return{ptStart:new w,ptEnd:new w,center:new pi,radius:new ot,fcenter:new pr,fradius2:new At,maxError:Number.NaN,isLine:Z_}}const K_=5,J_=1/8;function $_(t,e,s,i){return{pt:t.clone(),t:e,err:s,checkCount:i}}class td{constructor(t,e,s,i,n){this.m_left=t,this.m_tracker=n,this.m_eps=s,this.m_trackerCounter=0,this.m_tolerance=i,this.m_circleCheckCounter=0,this.m_bReversedLeft=!1,this.m_leftArc=Q_()}closeToCircularArc(t,e,s,i,n,r){if(this.m_circleCheckCounter++,r.maxError=0,!td.checkSweepAngle(t,e))return!1;if(r.ptStart.setCoordsPoint2D(s),r.ptEnd.setCoordsPoint2D(n),t.isCircular()){const e=t;return r.fradius2=At.constructDouble(e.getSemiMajorAxis()).mulDouble(e.getSemiMajorAxis()),r.radius.set(e.getSemiMajorAxis()),r.fcenter.assignPoint2D(e.getCenter()),r.center.set(e.getCenter()),!0}const o=r.ptEnd.sub(r.ptStart).clone();o.leftPerpendicularThis(),o.normalize();if(Math.abs(o.dotProduct(i.sub(r.ptStart)))<=this.m_eps)return!!this.confirmIsLine(r,o)&&(r.radius.set(Number.NaN),r.center.setCoords(0,0),!0);{const s=r.ptEnd.sub(r.ptStart),n=i.sub(r.ptStart),o=s.crossProduct(n);if(0===o)return!1;const a=.5*s.sqrLength(),h=.5*n.sqrLength();let m=a*n.y-h*s.y;m/=o;let l=s.x*h-n.x*a;l/=o;const u=Math.sqrt(m*m+l*l);if(4*Number.EPSILON*u>this.m_eps)return!1;const c=m+r.ptStart.x,g=l+r.ptStart.y;r.radius.set(u),r.center.setCoords(c,g);const _=this.maxCircleApproximationError(t,e,r);if(_>this.m_eps)return r.maxError=_,!1}const a=(new pr).assignPoint2D(r.ptStart),h=(new pr).assignPoint2D(r.ptEnd).sub(a),m=(new pr).assignPoint2D(i).sub(a),l=h.crossProduct(m);if(l.isZero())return!1;const u=h.sqrLength().mulDouble(.5),c=m.sqrLength().mulDouble(.5),g=u.mul(m.y).sub(c.mul(h.y)),_=h.x.mul(c).sub(m.x.mul(u)),d=g.mul(g).add(_.mul(_)),p=l.clone();p.invertThis(),r.fradius2=d.mul(p).mul(p),r.fcenter.setCoords(g.mul(p).add(a.x),_.mul(p).add(a.y)),r.center.setWithEps(r.fcenter.asPoint2D()),r.radius.setWithEps(Math.sqrt(r.fradius2.toDouble()));const f=pi.constructPoint2D(r.ptStart).subE(r.center),x=pi.constructPoint2D(r.ptEnd).subE(r.center);if(!f.dotProduct(x).gt(wt))return!1;const y=this.maxCircleApproximationError(t,e,r);return r.maxError=y,y<=this.m_eps}static checkSweepAngle(t,e){if(t.getGeometryType()===s.enumEllipticArc){const s=t,i=rP(s,e.vmin),n=rP(s,e.vmax);return!(Math.abs(n-i)>.5*xt)}return!0}confirmIsLine(e,s){return t(0),!1}maxCircleApproximationError(t,e,i){const n=[.25,.75],r=[.1,.25,.75,.9];let o,a;t.getGeometryType()===s.enumEllipticArc?(o=n,a=n.length):(o=r,a=r.length);let h=0;for(let s=0;s<a;++s){const n=new w;t.queryCoord2D(_t(e.vmin,e.vmax,o[s]),n);const r=n.sub(i.center.value()).length(),a=Math.abs(r-i.radius.value());a>h&&(h=a)}return h}approximateWithCirclesImpl(t,e){let s=1;e&&e.push(0);const i=H(9,Number.NaN);let n;t?n=this.m_left.getMonotonicPartParams(i.length,i):(i[0]=0,i[1]=1,n=2);const r=[],o=[],a=new w(0,0);for(let h=1;h<n;h++){const t=new A(i[h-1],i[h]);for(this.m_bReversedLeft=!td.goodOrientation(this.m_left,t),this.m_bReversedLeft?(r.push($_(a,t.vmin,0,0)),r.push($_(a,t.vmax,0,0))):(r.push($_(a,t.vmax,0,0)),r.push($_(a,t.vmin,0,0))),r[0].pt=this.m_left.getCoord2D(r[0].t),r[1].pt=this.m_left.getCoord2D(r[1].t);r.length>1;){this.progress_();const t=r.at(-1);let i=t.checkCount,n=t.err;const a=t.pt.clone(),h=t.t,m=r[r.length-2].t,l=.5*(h+m),u=this.m_left.getCoord2D(l);if(n<=this.m_eps||i>=K_){const t=new A;if(t.setCoords(h,m),this.closeToCircularArc(this.m_left,t,a,u,r[r.length-2].pt,this.m_leftArc)){e&&(this.m_bReversedLeft?o.push(h):e.push(m)),s++,r.pop();continue}i=0,n=this.m_leftArc.maxError}t.t=l,t.pt.setCoordsPoint2D(u),n*=J_,i++,t.err=n,t.checkCount=i,r.push($_(a,h,n,i))}this.m_bReversedLeft&&e&&(e.length=e.length+o.length,X(e,o.reverse(),e.length-o.length,0,o.length),o.length=0),r.length=0}return s}approximateWithCirclesImplPolyline(e){return t(0),{}}static goodOrientation(t,e){const s=t.getCoord2D(e.vmin),i=t.getCoord2D(e.vmax);return s.compare(i)<0}progress_(t=!1){}}function ed(t,e,s,i,n,r,o){id(t,e,s,n,r,o)}function sd(t,e,i,n){if(!p(t.getGeometryType()))return t;const r=t.getImpl();if(!r.hasNonLinearSegments())return t;const o=t.createInstance();if(o.getGeometryType()===s.enumPolygon){o.setFillRule(t.getFillRule())}new Vm;const a=new Ge,h=new SE,m=[],l=[],u=[],c=t.getDescription().getAttributeCount()>1,g=r.querySegmentIterator();for(;g.nextPath();){let t=!0;for(;g.hasNextSegment();){const n=g.isClosingSegment(),r=g.nextSegment();if(!r.isCurve()){o.addSegment(r,t,n),t=!1;continue}let _,d=!1;const p=!0,f=!0;switch(r.getGeometryType()){case s.enumEllipticArc:case s.enumRationalBezier2:_=vl(r,e,i,p,f,l,u,m),d=!0;break;default:_=Cl(r,e,i,!0,p,l,m)}const x=d?2:3;l[1].isNAN()?(h.createLine(),h.get().construct(l[0],l[x])):d?(h.createQuadraticRationalBezier(),h.get().constructArrayWeights(l,u)):(h.createCubicBezier(),h.get().constructPoints(l)),c&&t&&(r.queryCoord(m[0],a),h.get().setStart(a)),c&&(r.queryCoord(m[1],a),h.get().setEnd(a)),o.addSegment(h.get(),t,n&&1===_),t=!1;for(let t=1,e=_,s=x;t<e;++t,s+=x)l[s+1].isNAN()?(h.createLine(),h.get().construct(l[s],l[s+x])):d?(h.createQuadraticRationalBezier(),h.get().constructArrayWeights(l.slice(s),u.slice(s))):(h.createCubicBezier(),h.get().constructPoints(l.slice(s))),c&&(r.queryCoord(m[t+1],a),h.get().setEnd(a)),o.addSegment(h.get(),!1,n&&t+1===e)}}return o}function id(t,e,s,i,n,r){t.hasCurves()?(t.setCurveStitcherPointer(i),i.m_impl=new ud(r,!1,null),i.m_impl.buildMonotonicCurveParentage(t,e,s,n)):i.m_impl=null}function nd(t,e,s,i,n,r,o,a){t.hasCurves()?(t.setCurveStitcherPointer(r),r.m_impl=new ud(a,!0,n),r.m_impl.buildMonotonicCurveParentage(t,e,s,o),pd(t,s,a)):r.m_impl=null}function rd(t){if(!t.hasSegmentParentage())return;const e=new Qe(0),s=t.queryVertexIteratorOnSelection();for(let o=s.next();o!==Nm;o=s.next())e.add(o);if(0===e.size())return;t.sortVerticesSimpleByY(e,0,e.size()),e.add(Nm);const i=w.getNAN();t.queryXY(e.read(0),i);let n=0;const r=w.getNAN();for(let o=1,a=e.size();o<a;o++){{const s=e.read(o);s!==Nm?t.queryXY(s,r):r.setNAN()}if(!r.isEqualPoint2D(i)){let s=!1,a=-2;for(let i=n;i<o;++i){const n=e.read(i);if(t.getSegmentParentageBreakVertex(n)){s=!0;break}let r=t.getSegmentParentage(n);const o=t.getPrevVertex(n);if(o!==Nm){let e=t.getSegmentParentage(o);if(-1===r&&(r=e),-1===e&&(e=r),r!==e){s=!0;break}}if(-2!==a&&r!==a){s=!0;break}a=r}if(s)for(let i=n;i<o;++i)t.setSegmentParentageBreakVertex(e.read(i),!0);i.setCoordsPoint2D(r),n=o}}}function od(t,e){let s=e.isEmpty()?t:Cs(null,e,!0).total();return s>t&&(s=t),.125*s}function ad(t,e){return e||(e=ge.constructEmpty()),od(t,e)}function hd(t,e){return.125*t}function md(t,e){return 3*t+3*e}class ld{constructor(){this.m_impl=null}stitchCurves(t,e,s,i){this.m_impl&&(this.m_impl.stitchCurves(t,e,s),i&&this.clearStitcher(t))}clearStitcher(t){this.m_impl&&(this.m_impl.clearStitcher(t),this.m_impl=null)}getOriginalVertexIndex(t,e){return this.m_impl.getOriginalVertexIndex(t,e)}getOriginalSegmentTypeInfo(t){return this.m_impl.getOriginalSegmentTypeInfo(t)}}class ud{constructor(t,e,s){this.m_originalPlanarSegments=[],this.m_progressTracker=null,this.m_nsr=null,this.m_progressTracker=t,this.m_nsr=s,this.m_tolerance=0,this.m_originalVertexIndex=-1,this.m_type=0,this.m_progressCounter=0,this.m_bIsSimple=e}buildSegmentParentage(e,s,i,n,r){t(0)}static processCurves(e,s,i,n){return t(0),e}buildMonotonicCurveParentage(e,i,n,r){const o=!1,a=!0;if(!e.hasCurves())return;t(!e.hasSegmentParentage()),this.m_type=1,this.m_originalPlanarSegments.length=0,this.m_bIsSimple&&(this.m_originalVertexIndex=e.createUserIndex()),this.m_tolerance=n;const h=new Ge,m=new SE,l=[],u=[],c=[];for(let g=e.getFirstGeometry();g!==Nm;g=e.getNextGeometry(g))for(let r=e.getFirstPath(g);r!==Nm;r=e.getNextPath(r)){let g=e.getPathSize(r),_=e.getFirstVertex(r),d=0,p=-1;for(let f=0;f<g;f++){let x=e.getNextVertex(_);if(!e.querySegment(_,m,!0,!1)){_=x;continue}if(0===d){p=e.getVertexIndex(_);const s=ud.regularizeCurve(e,m.get(),_,n);if(s>=0){this.m_nsr&&0===this.m_nsr.m_reason&&this.m_nsr.assign(new ci(13,p,-1)),d=s,g=e.getPathSize(r),x=e.getNextVertex(_);const i=e.querySegment(_,m,!0,!1);t(i)}}else d--;const y=e.getVertexIndex(_);let P;-1!==this.m_originalVertexIndex&&e.setUserIndex(_,this.m_originalVertexIndex,p),e.setSegmentToIndex(y,null);let E=!1;switch(m.get().getGeometryType()){case s.enumEllipticArc:case s.enumRationalBezier2:P=vl(m.get(),i,n,o,a,u,c,l),E=!0;break;default:{const t=!this.m_bIsSimple||!m.get().isMonotoneQuickAndDirty();P=Cl(m.get(),i,n,t,o,u,l)}}const C=this.m_originalPlanarSegments.length;if(e.setSegmentParentageAndBreak(_,C,!0),!u[1].isNAN()){let t=null;t=E?new Xa({points:u,weights:c}):new lo({cp:u}),t.snapControlPoints(n*n),e.setSegmentToIndex(y,t)}const S=E?2:3;for(let t=1,s=P,i=S;t<s;++t,i+=S){m.get().queryCoord(l[t],h);const s=e.insertVertex(r,x,h);if(-1!==this.m_originalVertexIndex&&e.setUserIndex(s,this.m_originalVertexIndex,p),!u[i+1].isNAN())if(E){const t=new Xa({points:u.slice(i),weights:c.slice(i)});t.snapControlPoints(n*n),e.setSegmentToIndex(e.getVertexIndex(s),t)}else{const t=new lo({cp:u.slice(i)});t.snapControlPoints(n*n),e.setSegmentToIndex(e.getVertexIndex(s),t)}e.setSegmentParentageAndBreak(s,C,!1)}P>1&&(f+=P-1,g=e.getPathSize(r)),this.m_originalPlanarSegments.push(m.releaseSegment()),_=x}}}stitchCurves(t,e,s){ud.st_stitchCurvesImpl(this,t,e,s,!1)}clearStitcher(t){this.m_originalPlanarSegments.length=0,-1!==this.m_originalVertexIndex&&(t.removeUserIndex(this.m_originalVertexIndex),this.m_originalVertexIndex=-1),t.deleteSegmentParentage()}static st_verifyParentage(t){ud.st_stitchCurvesImpl(null,t,Nm,0,!0)}getOriginalVertexIndex(t,e){return-1!==this.m_originalVertexIndex&&e!==Nm?t.getUserIndex(e,this.m_originalVertexIndex):-1}getOriginalSegmentTypeInfo(t){if(-1!==t){const e=this.m_originalPlanarSegments[t];switch(e.getGeometryType()){case s.enumEllipticArc:return 0===e.projectionBehavior()?0:1;case s.enumBezier:return 2;case s.enumBezier2:return 3;case s.enumLine:return-1;case s.enumRationalBezier2:return 4;default:n("")}}return-1}static st_curveRequiresRegularization(e,s){return t(0),!1}progress_(t=!1){this.m_progressCounter++}processSpan_(e,s,i,n,r,o,a){if(s===i&&0===n)return t(e.getNextVertex(s)===Nm),e.setSegmentToIndex(e.getVertexIndex(s),null),void e.setSegmentParentageAndBreak(s,-1);const h=e.getNextVertex(s);{let s=2;for(let t=h;t!==i;t=e.getNextVertex(t))s++;t(s===n)}if(null===r){e.setSegmentToIndex(e.getVertexIndex(s),null);for(let t=h;t!==i;)t=e.removeVertex(t,!0);return}const m=e.getXY(s),l=e.getXY(i);if(r.isClosed()){if(m.isEqualPoint2D(l)&&m.isEqualPoint2D(r.getStartXY())){let t;if(t=this.verifySegmentFitness(e,s,i,n,r,o,a)){const n=r.clone();return n.dropAllAttributes(),t<0&&n.reverse(),this.removeSpan(e,s,i),void e.setSegmentToIndex(e.getVertexIndex(s),n)}}}else if(m.isEqualPoint2D(r.getStartXY())){if(l.isEqualPoint2D(r.getEndXY())){const t=r.clone();if(t.dropAllAttributes(),this.verifySegmentFitness(e,s,i,n,t,o,a))return this.removeSpan(e,s,i),void e.setSegmentToIndex(e.getVertexIndex(s),t)}}else if(l.isEqualPoint2D(r.getStartXY())&&m.isEqualPoint2D(r.getEndXY())){const t=r.getReversed();if(t.dropAllAttributes(),this.verifySegmentFitness(e,s,i,n,t,o,a))return this.removeSpan(e,s,i),void e.setSegmentToIndex(e.getVertexIndex(s),t)}this.processSpanSplitSegment(e,s,i,n,r,o,a)}processSpanSplitSegment(t,e,s,i,n,r,o){if(n.isLine())return;if(this.fitSegmentToSpan(t,e,s,i,n,r,o))return;const a=o*o;let h=i,m=e;const l=t.getXY(e);let u=n.getClosestCoordinate(l,!1);const c=n.getCoord2D(u);let g=!1;const _=w.sqrDistance(l,c);if(_>a){const i=t.getNextVertex(e);if(this.approximateSpanSection(t,e,n,r,o),i===s)return;m=i,g=!0,h-=1}let d=s;const p=t.getXY(s);u=n.getClosestCoordinate(p,!1);const f=n.getCoord2D(u);let x=!1;const y=w.sqrDistance(p,f);if(y>a){const e=t.getPrevVertex(s);if(this.approximateSpanSection(t,e,n,r,o),e===m)return;d=e,x=!0,h-=1}if((g||x)&&this.fitSegmentToSpan(t,m,d,h,n,r,o))return;let P=!1;if(!g&&_>0){const s=t.getNextVertex(e);if(this.approximateSpanSection(t,e,n,r,o),s===d)return;m=s,g=!0,P=!0,h-=1}if(!x&&y>0){const e=t.getPrevVertex(s);if(this.approximateSpanSection(t,e,n,r,o),e===m)return;d=e,x=!0,P=!0,h-=1}if(P&&this.fitSegmentToSpan(t,m,d,h,n,r,o))return;let E=m;for(;;){const e=t.getNextVertex(E);if(this.approximateSpanSection(t,E,n,r,o),E=e,E===d)return}}fitSegmentToSpan(e,s,i,n,r,o,a){const h=0===this.m_type,m=[];if(m.push(e.getXY(s)),h){let r=s;const o=32;if(n>o){const s=BigInt(n-1),a=BigInt(o-1);let h=a,l=0n;for(let t=1;t<n;t++,h+=a)if(r=e.getNextVertex(r),h>=l+s){l+=s;const t=e.getXY(r);m.push(t)}t(r===i)}else{for(let t=1;t<n;t++){r=e.getNextVertex(r);const t=e.getXY(r);m.push(t)}t(r===i)}}else{let t=s;const r=new SE;for(;;){e.querySegment(t,r,!1,!0);const s=[.1,.25,.4,.5,.6,.75,.9,1];let o=0;for(const t of s){(2===n||1&o)&&m.push(r.get().getCoord2D(t)),o++}if(t=e.getNextVertex(t),t===i)break}}const l=(()=>{let t=m[0].compare(m.at(-1));if(0===t){const e=new Yt(0);U_(m,m.length,e),t=e.getResult()>=0?-1:1}return t>0})();l&&m.reverse();const u=r.clone();if(u.dropAllAttributes(),u.setSegmentFromCoords(m,m.length),l&&u.reverse(),u.snapControlPoints(this.m_tolerance*this.m_tolerance),this.verifySegmentFitness(e,s,i,n,u,o,a)){this.removeSpan(e,s,i);const t=e.getVertexIndex(s);return e.setSegmentToIndex(t,u),!0}return!1}approximateSpanSection(t,e,i,n,r){const o=new SE;if(!t.querySegment(e,o,!0,!1))return;const a=i.getGeometryType();if(a!==o.get().getGeometryType()){if(a===s.enumEllipticArc){if(o.get().getGeometryType()!==s.enumRationalBezier2)return;if(0===i.projectionBehavior()){const s=[];j_(!1,o.get(),r,s,this.m_progressTracker);const i=t.getNextVertex(e),n=t.getPathFromVertex(e),a=new Ge;let h=e;for(let e=1,r=s.length;e<r;e++){const r=s[e],m=o.get().getCoord2D(s[e-1]),l=o.get().getCoord2D(_t(s[e-1],r,.5));o.get().queryCoord(r,a);const u=a.getXY(),c=new Cm;c.constructCircularArcThreePoint(m,u,l);let g=Nm;r<1&&(g=t.insertVertex(n,i,a)),t.setSegmentToIndex(t.getVertexIndex(h),c),h=g}return}{const s=D(w,3);o.get().queryControlPoints(s);const i=[0,0,0];o.get().queryWeights(i);const n=Ta(i),r=new Cm;return MP(s,n*n,null,!1,r),void t.setSegmentToIndex(t.getVertexIndex(e),r)}}m("approximate_span_section_")}}verifySegmentFitness(t,e,s,i,n,r,o){return 0===this.m_type?this.verifySegmentFitnessLines(t,e,s,i,n,r,o):this.verifySegmentFitnessCurves(t,e,s,i,n,r,o)}verifySegmentFitnessCurves(t,e,s,i,n,r,o){const a=t.getXY(e),h=t.getXY(s);if(!a.isEqualPoint2D(n.getStartXY())||!h.isEqualPoint2D(n.getEndXY()))return 0;let m=0;if(n.isClosed()){const t=n.getCoord2D(.1).sub(a);m=n.getCoord2D(.7).sub(a).crossProduct(t)>=0?1:-1}const l=new Array(Li.s_maxMonotonicPartParams);let u=n.getMonotonicPartParams(l.length,l);u--;const c=new CE,g=[1,.5,.75,.25];let _=0,d=e;const p=a.clone();for(;;){const e=t.getNextVertex(d);let i=t.getSegment(d);null===i&&(t.queryLineConnector(d,c,!0),i=c);for(let t=e===s?1:0;t<g.length;t++){const e=i.getCoord2D(g[t]);if(!n.isCloserThanDistance(e,A.unit(),o))return 0}if(u>1)for(let t=1;t<u;){const e=n.getCoord2D(l[t]);i.isCloserThanDistance(e,A.unit(),o)?(l[u-1]=q(l[t],l[t]=l[u-1]),u--):t++}if(m){const t=i.getCoord2D(.25);_+=t.sub(a).crossProduct(p.sub(a)),p.assign(t),t.assign(i.getCoord2D(.75)),_+=t.sub(a).crossProduct(p.sub(a)),p.assign(t)}if(d=e,d===s)return u>1?0:m?_<0?-m:m:1}}verifySegmentFitnessLines(e,s,i,n,r,o,a){return t(0),0}removeSpan(t,e,s){t.setSegmentToIndex(t.getVertexIndex(e),null);const i=t.getNextVertex(e);i!==s&&t.removeVertices(i,s)}static st_stitchCurvesImpl(t,e,s,i,n){if(e.hasSegmentParentage())return e.hasCurves()?ud.st_stitchCurvesFromCurvesImpl(t,e,s,i,n):ud.st_stitchCurvesFromLinesImpl(t,e,s,i,n)}static st_stitchCurvesFromLinesImpl(e,s,i,n,r){let o=i===Nm?s.getFirstGeometry():i;for(;o!==Nm;){for(let i=s.getFirstPath(o);i!==Nm;i=s.getNextPath(i)){let o=s.getPathSize(i);s.isClosedPath(i)&&(o+=1);let a=!0,h=!1;const m=s.getFirstVertex(i);let l=m;for(let i=0;i<o&&l!==Nm;){let u=s.getSegmentParentage(l);if(-1===u||a){a=!1,i++,l=s.getNextVertex(l),h=!0;continue}let c,g,_=0;if(h?(c=s.getPrevVertex(l),g=l,t(c!==Nm),t(g!==c),t(-1===s.getSegmentParentage(c)||m===c)):(c=l,g=s.getNextVertex(c),i++,t(g!==Nm),t(g!==c),u=s.getSegmentParentage(g)),_=2,h=!1,-1===u||s.getSegmentParentageBreakVertex(g)){l=g;continue}let d=s.getNextVertex(g);for(i++;i<o&&d!==Nm;){g=d,_++;const e=s.getSegmentParentage(d);if(-1===e||s.getSegmentParentageBreakVertex(d))break;t(e===u),i++,d=s.getNextVertex(d)}if(!r){const t=e.m_originalPlanarSegments[u];e.processSpan_(s,c,g,_,t,u,n)}l=g}}if(i!==Nm)break;o=s.getNextGeometry(o)}}static st_stitchCurvesFromCurvesImpl(e,s,i,n,r){let o=i===Nm?s.getFirstGeometry():i;for(;o!==Nm;)if(v(s.getGeometryType(o))){for(let i=s.getFirstPath(o);i!==Nm;i=s.getNextPath(i)){let o=s.getPathSize(i);const a=s.isClosedPath(i);a&&(o+=1);let h=s.getFirstVertex(i);if(a){if(-1!==s.getSegmentParentage(h)){let t=h;for(let e=0;!s.getSegmentParentageBreakVertex(t);e++){if(e===o){h=s.getFirstVertex(i),s.setSegmentParentageBreakVertex(t,!0);break}t=s.getPrevVertex(t)}}}else t(-1===s.getSegmentParentage(h)||s.getSegmentParentageBreakVertex(h));let m=h;for(let i=0;i<o&&m!==Nm;){const a=s.getSegmentParentage(m);if(-1===a){i++,m=s.getNextVertex(m);continue}let h=0,l=Nm;const u=m;h=1;let c=s.getNextVertex(u);for(;i<o&&c!==Nm;){i++,l=c,h++;const e=s.getSegmentParentage(c);if(-1===e||s.getSegmentParentageBreakVertex(c))break;t(e===a),c=s.getNextVertex(c)}if(l===Nm)break;if(!r){const t=e.m_originalPlanarSegments[a];e.processSpan_(s,u,l,h,t,a,n)}m=l}}if(i!==Nm)break;o=s.getNextGeometry(o)}else o=i===Nm?s.getNextGeometry(o):Nm}static regularizeCurve(t,e,s,i){let n=e.snapControlPoints(i*i);if(n){const i=t.getVertexIndex(s),n=e.clone();t.setSegmentToIndex(i,n)}if(e.getGeometryType()===lo.type){const r=[],o=e.calculateSpecialPointsForCracking(i,r);if(o>0){t.splitSegment(s,r,o),n=t.snapControlPoints(s,o+1,i*i)||n;for(let e=0;e<o;e++)s=t.getNextVertex(s),t.setSegmentParentageBreakVertex(s,!0);return o}}return n?0:-1}}function cd(t,e,s,i,n){return new xd(t,s,e,i,n).do_()}function gd(t,e,s){const i=Ts(t);return ru(e.getX(),e.getY(),s.getX(),s.getY(),M(i))}function _d(t,e,s=1,i=1,n=1,r=1){if(i>r)return t;if(r>i)return e;const o=[0],a=[0],h=new Ge;return hu(t,e,s,i,n,r,h,a,o),h}function dd(t,e,s){const i=Ts(e),n=Ns(e);return!!mu(t,i,Nm,null,s)||qu(!0,t,n,null,s)}function pd(t,e,s){return xd.fixCurveTwoPointLoops(t,e,s)}function fd(t){return Ts(t)}class xd{constructor(t,e,s,i,n){this.m_shape=t,this.m_progressTracker=e,this.m_tolerance=s,this.m_bFilterDegenerateSegments=i,this.m_bTrackChanges=n,this.m_progressCounter=0}do_(){const t=new ps(this.m_tolerance.tolerance,this.m_tolerance.resolution),e=1e-5,s=1e-6,i=fd(t);let n=Ns(t);const r=n*(1+e);n*=1+s;let o=!1;const a=this.m_shape.getTotalPointCount()+10>30?1e3:(this.m_shape.getTotalPointCount()+10)*(this.m_shape.getTotalPointCount()+10),h=this.m_shape.hasPointFeatures();for(let l=0;;l++){this.m_shape.dbgCheckSelection(),l>a&&m("crack_and_cluster_iteration_exceeded"),this.m_shape.dbgVerifyMonotone();let t=-1;0===l&&(t=this.firstCrack_(),o||=t>0);const e=this.cluster_(i);if(this.m_shape.dbgVerifyMonotone(),o||=e,this.m_bFilterDegenerateSegments){const t=0!==this.m_shape.filterClosePoints(i,!0,!1,this.m_bTrackChanges,Nm);o||=t,this.m_shape.dbgVerifyMonotone()}const s=this.m_shape.snapControlPointsOnSelection(r*r);o||=s,this.m_shape.dbgCheckSelection();let u=!1;if((0===l&&-1===t||h||qu(!0,this.m_shape,n,null,this.m_progressTracker))&&(u=this.crack_(r),o||=u,this.m_shape.dbgVerifyMonotone()),!u&&!xd.fixCurveTwoPointLoops(this.m_shape,i,this.m_progressTracker)){this.m_shape.dbgVerifyMonotone();break}}return o&&rd(this.m_shape),o}cluster_(t){return nu(this.m_shape,t,Nm,this.m_bTrackChanges,this.m_progressTracker)}crack_(t){return Au(this.m_shape,t,this.m_bTrackChanges,this.m_progressTracker)}static fixCurveTwoPointLoops(e,s,i){if(!e.hasCurves())return!1;e.dbgVerifyCurves();const n=e.createUserIndexUninitialized(),r=new Qe(0),o=e.queryVertexIteratorOnSelection();for(let t=o.next();t!==Nm;t=o.next())r.add(t),e.setUserIndex(t,n,-1);if(0===r.size())return!1;r.add(Nm),e.sortVerticesSimpleByY(r,0,r.size()-1);let a=0;const h=e.getXY(r.read(a)),m=new w(Number.NaN,Number.NaN),l=[];for(let t=1,u=r.size();t<u;++t){const s=r.read(t),i=s!==Nm?e.getXY(s):m;if(i.equals(h))continue;const o=[];for(let m=a;m<t;m++){const t=r.read(m),s=e.getPrevVertex(t);if(s!==Nm&&-1===e.getUserIndex(s,n)){const t=yd(e.getXY(s),e.getSegment(s));0!==w.sqrDistance(h,t.otherPt)&&(t.vert=s,t.dir=-1,o.push(t)),e.setUserIndex(s,n,1)}const i=e.getNextVertex(t);if(i!==Nm&&-1===e.getUserIndex(t,n)){const s=yd(e.getXY(i),e.getSegment(t));0!==w.sqrDistance(h,s.otherPt)&&(s.vert=t,s.dir=1,o.push(s)),e.setUserIndex(t,n,1)}}if(o.length>1){o.sort(((t,e)=>Cd(t,e)));const t=yd(m.clone(),null);o.push(t);let e=0;for(let s=1,i=o.length;s<i;s++)if(!o[s].otherPt.equals(o[s-1].otherPt)){if(s-e>1&&null!==o[e].seg){let t=!1;const i=e;for(let n=e+1;n<s;n++)if(!Pd(o[i],o[n])){t=!0;break}if(t)for(let n=e;n<s&&null!==o[n].seg;n++)l.push(o[n].vert)}e=s}}a=t,h.setCoordsPoint2D(i)}for(const u of l){const i=e.getSegment(u);t(null!==i);const n=e.getXY(u),r=e.getXY(e.getNextVertex(u));if(w.distance(n,r)<3*s)e.setSegmentToIndex(e.getVertexIndex(u),null);else{const t=i.lengthToT(.5*i.calculateLength2D());e.splitSegment(u,[t],1)}}return e.removeUserIndex(n),l.length>0}firstCrack_(){const t=Cs(null,this.m_shape.getEnvelope2D(this.m_progressTracker),!0).total();if(4*t<this.m_tolerance.total()){let e=!1;const s=1.1*t,i=t,n=this.cluster_(s);e||=n;let r=0;this.m_bFilterDegenerateSegments&&(r=this.m_shape.filterClosePoints(0,!0,!1,this.m_bTrackChanges,Nm));const o=this.crack_(i);return e||=o,e?1:r?2:0}return-1}progress_(t=!1){this.m_progressCounter++,!t&&4095&this.m_progressCounter||(this.m_progressCounter=0)}}function yd(t,e){return{otherPt:t,seg:e,vert:-1,dir:0}}function Pd(e,i){if(t(e.otherPt.equals(i.otherPt)),null===e.seg)return null===i.seg;if(null===i.seg)return!1;const n=e.seg.getGeometryType();if(n!==i.seg.getGeometryType())return!1;if(n===s.enumBezier){const t=e.seg,s=i.seg;let n=t.getControlPoint1(),r=t.getControlPoint2();-1===e.dir&&(r=q(n,n=r));let o=s.getControlPoint1(),a=s.getControlPoint2();return-1===i.dir&&(a=q(o,o=a)),n.equals(o)&&r.equals(a)}if(n===s.enumRationalBezier2){const t=e.seg,s=i.seg,n=t.getControlPoint1(),r=s.getControlPoint1();if(!n.equals(r))return!1;const o=[0,0,0];t.queryWeights(o),-1===e.dir&&(o[2]=q(o[0],o[0]=o[2]));const a=[0,0,0];return s.queryWeights(a),-1===i.dir&&(a[2]=q(a[0],a[0]=a[2])),o[0]===a[0]&&o[1]===a[1]&&o[2]===a[2]}m("")}function Ed(t,e){if(null===t.seg||null===e.seg)return null!==t.seg?-1:null!==e.seg?1:0;const s=t.seg.getGeometryType(),i=e.seg.getGeometryType();return s<i?-1:s>i?1:0}function Cd(t,e){const s=t.otherPt.compare(e.otherPt);return 0!==s?s:Ed(t,e)}var Sd=p,vd=l,bd=P;function Id(e){switch(e){case 1:return 1;case 2:return 2;case 3:return 3;case 4:return 4;case 0:return 0;default:t(0,"unrecognized cut side")}return 3}function wd(){return{unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1}}function Dd(t,e,s,i){return new Hd(i).autoCompleteImpl(t,e,s)}function Td(t,e,i,n,r,o,a){const h=new Hd(r);h.m_bOGCOutput=!0;const m=t.getGeometryType()===s.enumPolygon&&1===t.getFillRule()&&!As(n);return h.planarSimplifyImpl_(t,e,m,i,n,r,o,a)}function Nd(t,e,s,i,n,r,o,a){return new Hd(r).planarSimplifyImpl_(t,e,s,i,n,r,o,a)}function Ad(e,s,i,n){return t(0),{}}function qd(e,s,i,n,r,o,a){return t(0),{}}function Fd(e,s,i,n){return t(0),{}}function Md(t,e,s){return Ud(t,e,s)}function Gd(t,e,i,n){if(t.isEmpty()||e.isEmpty()||t.getDimension()>e.getDimension())return Od(Wd(t),t,e,"-");const r=new ge;t.queryEnvelope(r);const o=new ge;e.queryEnvelope(o);const a=new ge;a.setCoords({env2D:r}),a.mergeEnvelope2D(o);const h=Cs(i,a,!0),m=o.clone(),l=Ts(h);if(m.inflateCoords(l,l),!r.isIntersecting(m))return Od(Wd(t),t,e,"-");const u=new Hd(n),c=new Vm,g=c.addGeometry(Wd(t)),_=c.addGeometry(Wd(e));let d=0,p=0,f=null;if(c.hasCurves()){f=new ld;const t=c.getEnvelope2D(n);p=hd(h.total());const e=ad(h.total(),t);d=md(e,p),ed(c,e,h.total(),12e3,f,null,n)}u.setEditShapeCrackAndCluster(c,h.add(d));const x=u.difference(g,_);null!==f&&f.stitchCurves(c,x,p,!0);const y=Od(c.getGeometry(x),t,e,"-");return Sd(y.getGeometryType())&&(y.getImpl().setIsSimple(4,h.total()),y.getGeometryType()===s.enumPolygon&&y.getImpl().updateOGCFlagsProtected()),y}function Vd(t,e,i,n){if(t.getDimension()>e.getDimension())return Od(Wd(t),t,e,"^");if(t.getDimension()<e.getDimension())return Od(Wd(e),t,e,"^");if(t.isEmpty())return Od(Wd(e),t,e,"^");if(e.isEmpty())return Od(Wd(t),t,e,"^");const r=new ge;t.queryEnvelope(r);const o=new ge;e.queryEnvelope(o);const a=new ge;a.setCoords({env2D:r}),a.mergeEnvelope2D(o);const h=Cs(i,a,!0),m=new Hd(n),l=new Vm,u=l.addGeometry(Wd(t)),c=l.addGeometry(Wd(e));let g=0,_=null;if(l.hasCurves()){_=new ld;const t=l.getEnvelope2D(n);g=hd(h.total());ed(l,ad(h.total(),t),h.total(),12e3,_,null,n)}m.setEditShapeCrackAndCluster(l,h);const d=m.symmetricDifference(u,c);null!==_&&_.stitchCurves(l,d,g,!0);const p=Od(l.getGeometry(d),t,e,"^");return Sd(p.getGeometryType())&&(p.getImpl().setIsSimple(4,h.total()),p.getGeometryType()===s.enumPolygon&&p.getImpl().updateOGCFlagsProtected()),p}function Yd(t,e,s){return zd(t,e,s,!0)}function Xd(t,e,s){return t.isEmpty()||e.isEmpty()?t.createInstance():gd(s,t,e)?new Ge({copy:_d(t,e)}):t.createInstance()}function kd(t,e,i,n){const r=ge.constructEmpty();t.queryEnvelope(r);const o=ge.constructEmpty();e.queryEnvelope(o);const a=ge.constructEmpty();a.setCoords({env2D:r}),a.mergeEnvelope2D(o);const h=Cs(i,a,!0),m=new ge(o),l=Ts(h);if(m.inflateCoords(l,l),!r.isIntersecting(m)){if(t.getDimension()<=e.getDimension())return Od(Wd(t.createInstance()),t,e,"&");if(t.getDimension()>e.getDimension())return Od(Wd(e.createInstance()),t,e,"&")}const u=new Hd(n),c=new Vm,g=c.addGeometry(Wd(t)),_=c.addGeometry(Wd(e));let d=0,p=0,f=null;if(c.hasCurves()){f=new ld;const t=c.getEnvelope2D(n);p=hd(h.total());const e=ad(h.total(),t);d=md(e,p),ed(c,e,h.total(),12e3,f,null,n)}u.setEditShapeCrackAndCluster(c,h.add(d));const x=u.intersection(g,_);null!==f&&f.stitchCurves(c,x,p,!0);const y=Od(c.getGeometry(x),t,e,"&");return Sd(y.getGeometryType())&&(y.getImpl().setIsSimple(4,h.total()),y.getGeometryType()===s.enumPolygon&&y.getImpl().updateOGCFlagsProtected()),y}function Rd(t,e,i,n){const r=new Array(3),o=ge.constructEmpty();t.queryEnvelope(o);const a=ge.constructEmpty();e.queryEnvelope(a);const h=ge.constructEmpty();h.setCoords({env2D:o}),h.mergeEnvelope2D(a);const m=Cs(i,h,!0),l=new ge(a),u=Ts(m);if(l.inflateCoords(u,u),!o.isIntersecting(l)){if(t.getDimension()<=e.getDimension()){const s=Od(Wd(t.createInstance()),t,e,"&");return r[s.getDimension()]=s,r}if(t.getDimension()>e.getDimension()){const s=Od(Wd(e.createInstance()),t,e,"&");return r[s.getDimension()]=s,r}}const c=new Hd(n),g=new Vm,_=g.addGeometry(Wd(t)),d=g.addGeometry(Wd(e));let p=0,f=0,x=null;if(g.hasCurves()){x=new ld;const t=g.getEnvelope2D(n);f=hd(m.total());const e=ad(m.total(),t);p=md(e,f),ed(g,e,m.total(),12e3,x,null,n)}c.setEditShapeCrackAndCluster(g,m.add(p)),g.dbgVerifyCurves();const y=c.intersectionEx(_,d);for(const P of y){null!==x&&x.stitchCurves(g,P,f,!1);const i=Od(g.getGeometry(P),t,e,"&");Sd(i.getGeometryType())&&(i.getImpl().setIsSimple(4,m.total()),i.getGeometryType()===s.enumPolygon&&i.getImpl().updateOGCFlagsProtected()),r[i.getDimension()]=i}return null!==x&&x.clearStitcher(g),r}function Bd(t,s,i,n,r,o=!1){0===s&&e("not enough geometries to dissolve");let a=0;for(let e=0,d=s;e<d;e++)a=Math.max(t[e].getDimension(),a);if(2===a||1===a)return new Hd(n).dissolveMultiPaths_(a,!1,t,s,i,r,o);let h=0,m=-1;for(let e=0,d=s;e<d;e++)t[e].getDimension()===a&&(-1===m&&(m=e),t[e].isEmpty()||(m=e,h++));if(h<2)return Wd(t[m]);const l=_e.constructEmpty(),u=new Vm;let c=Nm;for(let e=0,d=s;e<d;e++)if(t[e].getDimension()===a&&!t[e].isEmpty()){c===Nm?c=u.addGeometry(Wd(t[e])):u.appendGeometry(c,Wd(t[e]));const s=_e.constructEmpty();t[e].queryLooseEnvelope(s),l.mergeEnv3D(s)}const g=Cs(i,l.getEnvelope2D(),!0),_=new Hd(n);if(o){const t=Ss(i,l.getEnvelopeZs(),!0);return _.planarSimplify3DImpl_(u,g,t,0,!0)}return _.m_bOGCOutput=!0,_.planarSimplifyMultiPoints(u,g,!1,-1)}function Ld(t,s,i,n,r,o=!1){s<2&&e("not enough geometries to dissolve");let a=0;for(let e=0,p=s;e<p;e++)a=Math.max(t[e].getDimension(),a);if(2===a||1===a)return new Hd(n).dissolveMultiPaths_(a,!0,t,s,i,r,o);const h=_e.constructEmpty(),m=new Vm;let l=Nm,u=0,c=-1;for(let e=0,p=s;e<p;e++)if(t[e].getDimension()===a&&(-1===c&&(c=e),!t[e].isEmpty())){c=e,l===Nm?l=m.addGeometry(Wd(t[e])):m.appendGeometry(l,Wd(t[e]));const s=_e.constructEmpty();t[e].queryLooseEnvelope(s),h.mergeEnv3D(s),u++}if(u<2)return Wd(t[c]);const g=0===a?i:null,_=Cs(g,h.getEnvelope2D(),!0),d=new Hd(n);if(o){const t=Ss(g,h.getEnvelopeZs(),!0);return d.m_bOGCOutput=!0,d.planarSimplify3DImpl_(m,_,t,0,!0)}return d.planarSimplifyMultiPoints(m,_,!0,-1)}class Hd{constructor(t){this.m_topoGraph=null,this.m_maskLookup=[],this.m_dummyPt1=w.getNAN(),this.m_dummyPt2=w.getNAN(),this.m_fromEdgeForPolylines=Nm,this.m_progressCounter=0,this.m_bOGCOutput=!1,this.m_progressTracker=t}linesToPolygonsImpl(t,e){let s=0,i=0,n=null;if(t.hasCurves()){n=new ld;const r=t.getEnvelope2D(this.m_progressTracker);i=hd(e.total());const o=ad(e.total(),r);s=md(o,i),ed(t,o,e.total(),12e3,n,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,e.add(s));const r=this.m_topoGraph.createUserIndexForChains(),o=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(o,r,1);for(let h=this.m_topoGraph.getChainFirstIsland(o);h!==Nm;h=this.m_topoGraph.getChainNextInParent(h))this.m_topoGraph.setChainUserIndex(h,r,1);const a=[];for(let h=this.m_topoGraph.getFirstChain();h!==Nm;h=this.m_topoGraph.getChainNext(h)){if(1===this.m_topoGraph.getChainUserIndex(h,r))continue;this.m_topoGraph.setChainUserIndex(h,r,1);for(let t=this.m_topoGraph.getChainFirstIsland(h);t!==Nm;t=this.m_topoGraph.getChainNextInParent(t))this.m_topoGraph.setChainUserIndex(t,r,1);if(0===this.m_topoGraph.getChainArea(h))continue;const e=this.m_topoGraph.extractPolygonFromChainAndIslands(t,Nm,h,Nm);null!=n&&n.stitchCurves(t,e,i,!1);const s=t.getGeometry(e);a.push(s)}return new ce(a)}autoCompleteImpl(t,e,s){let i=0,n=0,r=null;if(t.hasCurves()){r=new ld;const e=t.getEnvelope2D(this.m_progressTracker);n=hd(s.total());const o=ad(s.total(),e);i=md(o,n),ed(t,o,s.total(),12e3,r,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,s.add(i));const o=this.m_topoGraph.getGeometryID(e),a=this.m_topoGraph.createUserIndexForChains(),h=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(h,a,1);for(let l=this.m_topoGraph.getChainFirstIsland(h);l!==Nm;l=this.m_topoGraph.getChainNextInParent(l))this.m_topoGraph.setChainUserIndex(l,a,1);const m=[];for(let l=this.m_topoGraph.getFirstChain();l!==Nm;l=this.m_topoGraph.getChainNext(l)){if(1===this.m_topoGraph.getChainUserIndex(l,a))continue;this.m_topoGraph.setChainUserIndex(l,a,1);for(let t=this.m_topoGraph.getChainFirstIsland(l);t!==Nm;t=this.m_topoGraph.getChainNextInParent(t))this.m_topoGraph.setChainUserIndex(t,a,1);if(0!==this.m_topoGraph.getChainParentage(l))continue;const e=this.m_topoGraph.getChainHalfEdge(l);let s=e,i=!1;do{const t=this.m_topoGraph.getHalfEdgeTwin(s);if(this.m_topoGraph.getHalfEdgeChain(t)!==l&&this.m_topoGraph.getHalfEdgeParentage(s)&o){i=!0;break}s=this.m_topoGraph.getHalfEdgeNext(s)}while(s!==e);if(!i)continue;if(0===this.m_topoGraph.getChainArea(l))continue;const h=this.m_topoGraph.extractPolygonFromChainAndIslands(t,Nm,l,Nm);null!==r&&r.stitchCurves(t,h,n,!1);const u=t.getGeometry(h);m.push(u)}return new ce(m)}setEditShape(t,e=!1){null===this.m_topoGraph&&(this.m_topoGraph=new Kl),this.m_topoGraph.setEditShape(t,this.m_progressTracker,!0,e)}setEditShapeCrackAndCluster(t,e){cd(t,e,this.m_progressTracker,!0,!1);for(let i=t.getFirstGeometry();i!==Nm;i=t.getNextGeometry(i))t.getGeometryType(i)===s.enumPolygon&&Zu(t,i,-1,this.m_bOGCOutput,Nm,this.m_progressTracker);this.setEditShape(t)}setHalfEdgeOrientations_(t,e){const s=this.m_topoGraph.getShape();for(let i=s.getFirstGeometry();i!==Nm;i=s.getNextGeometry(i))if(i===e)for(let e=s.getFirstPath(i);e!==Nm;e=s.getNextPath(e)){let i=s.getFirstVertex(e);if(i===Nm)continue;let n=s.getNextVertex(i);for(;n!==Nm;){const e=this.m_topoGraph.getClusterFromVertex(i),r=this.m_topoGraph.getClusterFromVertex(n),o=this.m_topoGraph.getHalfEdgeConnector(e,r);if(o!==Nm){const e=this.m_topoGraph.getHalfEdgeTwin(o);this.m_topoGraph.setHalfEdgeUserIndex(o,t,1),this.m_topoGraph.setHalfEdgeUserIndex(e,t,2)}i=n,n=s.getNextVertex(i)}}}flushVertices_(t,e){const s=this.m_topoGraph.getShape(),i=s.hasSegmentParentage(),n=new SE,r=s.insertPath(t,Nm);e.push(e[0]);const o=e.length;let a=Nm;for(let h=0;h<o;h++){const t=e[h];if(a=s.addVertex(r,t),!i)continue;const m=this.m_topoGraph.getClusterFromVertex(t);if(h>0&&this.m_topoGraph.isBreakNode(m)&&s.setSegmentParentageBreakVertex(a,!0),h<o-1){const t=this.m_topoGraph.getHalfEdgeConnector(m,this.m_topoGraph.getClusterFromVertex(e[h+1])),i=this.m_topoGraph.getSegmentParentage(t);s.setSegmentParentageAndBreak(a,i,h>0||this.m_topoGraph.isBreakNode(m)),this.m_topoGraph.isHalfEdgeCurve(t)&&(this.m_topoGraph.querySegmentXY(t,n),s.setSegmentToIndex(s.getVertexIndex(a),n.get().clone()))}}if(i){const t=this.m_topoGraph.getClusterFromVertex(e[o-1]);this.m_topoGraph.isBreakNode(t)&&s.setSegmentParentageBreakVertex(a,!0)}s.setClosedPath(r,!0)}processPolygonCuts_(t,e,i,n){const r=this.m_topoGraph.getGeometryID(i),o=this.m_topoGraph.getGeometryID(n),a=[],h=this.m_topoGraph.getShape(),m=this.m_topoGraph.createUserIndexForHalfEdges();for(let l=this.m_topoGraph.getFirstCluster();l!==Nm;l=this.m_topoGraph.getNextCluster(l)){const i=this.m_topoGraph.getClusterHalfEdge(l);if(i===Nm)continue;let n=i;do{if(1!==this.m_topoGraph.getHalfEdgeUserIndex(n,m)){let i=n,l=n,u=!1,c=0;do{if(this.m_topoGraph.setHalfEdgeUserIndex(i,m,1),!u){if(this.m_topoGraph.getHalfEdgeParentage(i)&o){this.m_topoGraph.getHalfEdgeFaceParentage(i)&r&&(l=i,u=!0)}}if(u){const e=this.m_topoGraph.getHalfEdgeOrigin(i),s=this.m_topoGraph.getClusterVertexIterator(e),n=this.m_topoGraph.getVertexFromVertexIterator(s);if(a.push(n),-1!==t){if(this.m_topoGraph.getHalfEdgeParentage(i)&o){c|=this.m_topoGraph.getHalfEdgeUserIndex(i,t)}}}i=this.m_topoGraph.getHalfEdgeNext(i)}while(i!==l);if(u&&this.m_topoGraph.getChainArea(this.m_topoGraph.getHalfEdgeChain(l))>0){const t=h.createGeometry(s.enumPolygon);this.flushVertices_(t,a),-1!==e&&h.setGeometryUserIndex(t,e,c)}a.length=0}n=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(n))}while(n!==i)}this.m_topoGraph.deleteUserIndexForHalfEdges(m)}cutPolygonPolyline_(t,e,s,i){this.m_topoGraph.removeSpikes_();let n=-1;-1!==t&&(n=this.m_topoGraph.createUserIndexForHalfEdges(),this.setHalfEdgeOrientations_(n,s)),this.processPolygonCuts_(n,t,e,s),-1!==n&&(this.m_topoGraph.deleteUserIndexForHalfEdges(n),n=-1);const r=this.m_topoGraph.getShape();for(let o=r.getFirstGeometry();o!==Nm;o=r.getNextGeometry(o))o!==e&&o!==s&&i.push(o);i.sort(((t,e)=>{const s=r.getFirstPath(t),i=r.getRingArea(s),n=r.getFirstPath(e),o=r.getRingArea(n);return i<o?-1:i>o?1:0}))}cut(t,e,s,i,n){const r=this.m_topoGraph.getShape().getGeometryType(s),o=this.m_topoGraph.getShape().getGeometryType(i),a=P(r),h=P(o);if(2!==a||1!==h)if(1!==a||1!==h)m("");else{new Zd(this,t,e,s,i,n).Do()}else this.cutPolygonPolyline_(e,s,i,n)}progress_(t=!1){}isGoodParentage(t){return t>=0&&t<this.m_maskLookup.length&&this.m_maskLookup[t]}normalizeInputGeometry(t){const i=t.getGeometryType();if(i===s.enumEnvelope){const e=new Sm({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(i===s.enumPoint){const e=new ii({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if(l(i)){const e=new am({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}return i!==s.enumMultiPoint&&i!==s.enumPolyline&&i!==s.enumPolygon&&e("Unexpected geometry type"),t}dissolveNonSimplePolygons(e,s,i,n){t(s>0);const r=new Vm;let o=0,a=-1;for(let t=0,h=s;t<h;t++)2===e[t].getDimension()&&(-1===a&&(a=t),e[t].isEmpty()||(o++,r.addGeometry(e[t])));return 0===o?(t(a>=0),this.normalizeInputGeometry(e[a])):this.planarSimplifyPolygons(r,i,!0,!1,-1,!0)}dissolveMultiPaths_(e,i,n,r,o,a,h){t(e>=1&&e<=2),t(r>0);const m=8&a?1:2,u=_e.constructEmpty();let c=0,g=-1,d=!0;for(let t=0,l=r;t<l;t++)if(n[t].getDimension()===e&&(-1===g&&(g=t),!n[t].isEmpty())){g=t,c++;const i=_e.constructEmpty();if(n[t].queryLooseEnvelope(i),u.mergeEnv3D(i),2===e&&d&&n[t].getGeometryType()===s.enumPolygon)if(16&a){const e=[0],s=n[t].getImpl().getIsSimple(0,e),i=this.m_bOGCOutput?5===s:Gs(s);d&&=i}else{const e=qs(n[t],0);d&&=e}}if(c<2&&(t(g>=0),0===c||!(16&a)))return this.normalizeInputGeometry(n[g]);if(!d){const t=Cs(i?null:o,u.getEnvelope2D(),!0);return this.dissolveNonSimplePolygons(n,r,t,a)}const f=n.slice(0,r),x=Cs(o,u.getEnvelope2D(),!0),y=10*Ts(x);let P=new ps(0,0);if(h&&(P=Ss(o,u.getEnvelopeZs(),!0)),1===c&&1===e&&2===m&&!i)return h?qd():this.m_bOGCOutput?Td(f[g],x,!1,-1,this.m_progressTracker,m,!1):Nd(f[g],x,!1,!1,-1,this.m_progressTracker,m,!1);const E=new _s;E.startConstruction();let C=2===e?3:4,S=0;for(let _=0,M=r;_<M;_++){if(f[_].getDimension()!==e||f[_].isEmpty())continue;let n=f[_].getGeometryType();if(n!==s.enumEnvelope){if(l(n)?(f[_]=this.normalizeInputGeometry(f[_]),n=s.enumPolyline):t(p(n)),1===e){t(n===s.enumPolyline);let e=-1;if(h)t(0,"3d not implemented yet");else{const t=[0];e=f[_].getImpl().getIsSimple(x.total(),t)}if(this.m_bOGCOutput?5!==e:!Gs(e))if(i)C=-1;else{h?t(0,"3d not implemented yet"):this.m_bOGCOutput?f[_]=Td(f[_],x,!1,-1,this.m_progressTracker,m,!1):f[_]=Nd(f[_],x,!1,!1,-1,this.m_progressTracker,m,!1);const e=[0];t(Gs(f[_].getImpl().getIsSimple(x.total(),e)))}}else{t(n===s.enumPolygon);const e=[0],i=f[_].getImpl().getIsSimple(0,e);t(As(i))}const r=f[_].getImpl();for(let t=0,e=r.getPathCount();t<e;t++){const e=ge.constructEmpty();r.queryLoosePathEnvelope(t,e),e.inflateCoords(y,y),E.addEnvelope(S,e),S++}}else{t(n===s.enumEnvelope);const e=ge.constructEmpty();f[_].queryLooseEnvelope(e),e.inflateCoords(y,y),E.addEnvelope(S,e),S++,C=-1}}E.endConstruction();const v=S,b=H(v,-2147483647),I=H(v,-1);let w=0;g=-1,S=0;for(let l=0,_=r;l<_;l++){if(f[l].getDimension()!==e)continue;if(-1===g&&(g=l),f[l].isEmpty())continue;g=l,w++;const i=f[l].getGeometryType();if(p(i)){for(let t=0,e=f[l].getPathCount();t<e;t++)I[S]=l,b[S]=-t-1,S++}else t(i===s.enumEnvelope),I[S]=l,b[S]=-1,S++}if(w<2&&2===e)return t(g>=0),this.normalizeInputGeometry(f[g]);let D=v;for(;E.next()&&D>0;){this.progress_();const t=E.getHandleA(),e=E.getHandleB(),s=E.getElement(t),i=E.getElement(e);I[s]!==I[i]&&(b[s]<0&&(D--,b[s]=-(b[s]+1)),b[i]<0&&(D--,b[i]=-(b[i]+1)))}const T=new Vm;let N=!1,A=0;for(let l=0,M=r;l<M;l++){if(f[l].getDimension()!==e||f[l].isEmpty())continue;const i=f[l].getGeometryType(),n=A;let r=0,o=0;const a=p(i)?f[l]:null;for(let t=n,e=b.length;t<e&&I[t]===l;t++)b[t]>=0&&(r++,o+=a?a.getPathSize(b[t]):_(f[l])),A++;if(o>.95*_(f[l])){T.addGeometry(this.normalizeInputGeometry(f[l]));for(let t=n;t<A;t++)b[t]<0&&(b[t]=-(b[t]+1))}else{if(0===r){N=!0;continue}{N=!0,t(p(i)),t(null!=a);const e=new Sm({vd:f[l].getDescription()}),r=new am({vd:f[l].getDescription()}),o=i===s.enumPolygon?e:r;for(let t=n;t<A;t++)b[t]>=0&&o.addPath(a,b[t],!0);T.addGeometry(o)}}}let q;if(T.getFirstGeometry()!==Nm){const t=2===e,s=i?Cs(null,u.getEnvelope2D(),!0):x;let n=new ps(0,0);if(h&&(n=i?Ss(null,u.getEnvelopeZs(),!0):P),2===e&&!(2&a)){T.collapseAllGeometriesToFirst();let t=0,e=null;if(T.hasCurves()&&!T.hasSegmentParentage()){e=new ld;const i=T.getEnvelope2D(this.m_progressTracker);t=hd(s.total());ed(T,ad(s.total(),i),s.total(),12e3,e,null,this.m_progressTracker)}wu(T,T.getFirstGeometry(),s.total(),this.m_progressTracker),null!==e&&e.stitchCurves(T,Nm,t,!0)}if(h)q=this.planarSimplify3DImpl_(T,s,n,m,!0);else if(2===e)q=this.planarSimplifyPolygons(T,s,t,i,-1,!1);else{const t=wd();t.ogcRule=this.m_bOGCOutput,t.allCrossRoadsImpassable=!0,t.unsplitBehavior=m,q=this.planarSimplifyPolylines(T,s,i,t,-1)}if(!N){const t=[0];C=q.getImpl().getIsSimple(s.total(),t)}}else t(N),t(g>=0),q=2===e?new Sm({vd:f[g].getDescription()}):new am({vd:f[g].getDescription()});if(N){let e=0;for(let t=0,s=b.length;t<s;t++){const s=I[t];if(!(s<0)&&b[t]<0){const i=f[s].getGeometryType(),n=p(i)?f[s]:null;if(n){const s=-(b[t]+1);e+=n.getPathSize(s)}else e+=4}}q.reserve(q.getPointCount()+e);for(let i=0,n=b.length;i<n;i++){const e=I[i];if(!(e<0)&&b[i]<0){const n=f[e].getGeometryType(),r=p(n)?f[e]:null;if(r){const t=-(b[i]+1);q.addPath(r,t,!0)}else n===s.enumEnvelope?q.addEnvelope(f[e],!1):(t(l(n)),q.addSegment(f[e],!0))}}}let F=0;if(2===e?-1!==C&&(C=3,F=i?0:x.total()):(t(1===e),i||-1===C||(F=x.total())),h||q.getImpl().setIsSimple(C,F),!i&&N)if(2===e){if(!h)return(new _p).execute(q,o,!1,this.m_progressTracker);t(0,"3d not yet implemented")}else 1===e&&1!==m&&(q=h?Fd():Ad(),q.getImpl().setIsSimple(C,F));return q}dissolveTopoGraphCommonEdges_(){const t=this.m_topoGraph.createUserIndexForHalfEdges(),e=[];for(let s=this.m_topoGraph.getFirstCluster();s!==Nm;s=this.m_topoGraph.getNextCluster(s)){const i=this.m_topoGraph.getClusterHalfEdge(s);let n=i;if(i!==Nm)do{this.progress_();if(1!==this.m_topoGraph.getHalfEdgeUserIndex(n,t)){const s=this.m_topoGraph.getHalfEdgeTwin(n);this.m_topoGraph.setHalfEdgeUserIndex(s,t,1),this.m_topoGraph.setHalfEdgeUserIndex(n,t,1);const i=this.m_topoGraph.getHalfEdgeFaceParentage(n);if(this.isGoodParentage(i)){const t=this.m_topoGraph.getHalfEdgeFaceParentage(s);this.isGoodParentage(t)&&e.push(n)}}n=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(n))}while(n!==i)}this.m_topoGraph.deleteUserIndexForHalfEdges(t),this.m_topoGraph.deleteEdgesBreakFaces_(e)}chooseVertexByOrder(e,s,i,n){let r=L(),o=Nm;for(let t=this.m_topoGraph.getClusterVertexIterator(e);t!==Nm;t=this.m_topoGraph.incrementVertexIterator(t)){const e=this.m_topoGraph.getVertexFromVertexIterator(t),n=s.getUserIndex(e,i);n>=0&&n<r&&(r=n,o=e)}t(o!==Nm);let a=s.getUserIndex(o,n);return a>0&&(s.setUserIndex(o,n,--a),0===a&&s.setUserIndex(o,i,-1)),o}chooseVertexFromCluster_(t,e){return this.m_topoGraph.getVertexDominantFromCluster(t,e)}chooseVertexFromVertexCluster_(t,e){return this.m_topoGraph.getVertexDominant(t,e)}collectPolygonPathsPreservingFrom_(t,e,i,n,r){const o=this.m_topoGraph.getShape();if(o.getGeometryType(t)!==s.enumPolygon)return;const a=o.hasSegmentParentage(),h=new SE;for(let s=o.getFirstPath(t);s!==Nm;s=o.getNextPath(s)){const t=o.getFirstVertex(s);this.m_topoGraph.getClusterFromVertex(t);const m=this.m_topoGraph.getHalfEdgeFromVertex(t);if(m===Nm)continue;const l=this.m_topoGraph.getHalfEdgeUserIndex(m,i);if(1===l||2===l)continue;const u=this.m_topoGraph.getHalfEdgeFaceParentage(m);if(!this.isGoodParentage(u)){this.m_topoGraph.setHalfEdgeUserIndex(m,i,2);continue}this.m_topoGraph.setHalfEdgeUserIndex(m,i,1);const c=o.insertPath(e,Nm);o.setClosedPath(c,!0);let g=m,_=t,d=this.m_topoGraph.getClusterFromVertex(_),p=1;do{this.progress_();const t=this.chooseVertexFromVertexCluster_(_,r),e=o.addVertex(c,t);if(this.m_topoGraph.isHalfEdgeCurve(g)&&(this.m_topoGraph.querySegmentXY(g,h),o.setSegmentToIndex(o.getVertexIndex(e),h.get().clone())),a){const t=this.m_topoGraph.getSegmentParentage(g);o.setSegmentParentageAndBreak(e,t,this.m_topoGraph.isBreakNode(d))}let s,m;-1!==n&&this.m_topoGraph.setClusterUserIndex(d,n,1),this.m_topoGraph.setHalfEdgeUserIndex(g,i,1),g=this.m_topoGraph.getHalfEdgeNext(g);do{s=1===p?o.getNextVertex(_):o.getPrevVertex(_),m=s!==Nm?this.m_topoGraph.getClusterFromVertex(s):Nm}while(m===d);const l=this.m_topoGraph.getHalfEdgeOrigin(g);if(l!==m){do{s=1===p?o.getPrevVertex(_):o.getNextVertex(_),m=s!==Nm?this.m_topoGraph.getClusterFromVertex(s):Nm}while(m===d);if(l!==m){m=l;const t=this.m_topoGraph.getClusterVertexIterator(m);s=this.m_topoGraph.getVertexFromVertexIterator(t)}else p=-p}d=m,_=s}while(g!==m)}}topoOperationPolygonPolygonHelper_(t,e,s,i,n,r){this.progress_(!0),t!==Nm&&this.collectPolygonPathsPreservingFrom_(t,s,n,r,i),e!==Nm&&this.collectPolygonPathsPreservingFrom_(e,s,n,r,i);const o=new SE,a=this.m_topoGraph.getShape();a.dbgVerifyCurves();const h=a.hasSegmentParentage();for(let m=this.m_topoGraph.getFirstCluster();m!==Nm;m=this.m_topoGraph.getNextCluster(m)){const t=this.m_topoGraph.getClusterHalfEdge(m);if(t===Nm)continue;let e=t;do{this.progress_();const t=this.m_topoGraph.getHalfEdgeUserIndex(e,n);if(1!==t&&2!==t){const t=this.m_topoGraph.getHalfEdgeFaceParentage(e);if(this.isGoodParentage(t)){const t=a.insertPath(s,Nm);a.setClosedPath(t,!0);let m=e;do{const e=this.m_topoGraph.getHalfEdgeVertexIterator(m);let s=Nm;if(e!==Nm)s=this.m_topoGraph.getVertexFromVertexIterator(e);else{const t=this.m_topoGraph.getHalfEdgeVertexIterator(this.m_topoGraph.getHalfEdgeTwin(m));s=this.m_topoGraph.getVertexFromVertexIterator(t),s=a.getNextVertex(s)}const l=this.chooseVertexFromVertexCluster_(s,i),u=a.addVertex(t,l);if(h){const t=this.m_topoGraph.getSegmentParentage(m),e=this.m_topoGraph.getHalfEdgeOrigin(m);a.setSegmentParentageAndBreak(u,t,this.m_topoGraph.isBreakNode(e))}if(this.m_topoGraph.isHalfEdgeCurve(m)&&(this.m_topoGraph.querySegmentXY(m,o),a.setSegmentToIndex(a.getVertexIndex(u),o.get().clone())),this.m_topoGraph.setHalfEdgeUserIndex(m,n,1),-1!==r){const t=this.m_topoGraph.getClusterFromVertex(l);this.m_topoGraph.setClusterUserIndex(t,r,1)}m=this.m_topoGraph.getHalfEdgeNext(m)}while(m!==e)}else this.m_topoGraph.setHalfEdgeUserIndex(e,n,2)}e=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(e))}while(e!==t)}}topoOperationPolygonPolygon_(t,e,i,n=!1){this.dissolveTopoGraphCommonEdges_();const r=this.m_topoGraph.getShape(),o=r.createGeometry(s.enumPolygon),a=this.m_topoGraph.createUserIndexForHalfEdges();return this.topoOperationPolygonPolygonHelper_(t,e,o,i,a,-1),this.m_topoGraph.deleteUserIndexForHalfEdges(a),n||Zu(r,o,3,this.m_bOGCOutput,Nm,this.m_progressTracker),o}topoOperationPolyline_(t,e){const s=wd();return s.allCrossRoadsImpassable=!1,s.ogcRule=e,s.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(Nm,t,!1,s).first}topoOperationMultiPoint_(){const t=this.m_topoGraph.getShape(),e=t.createGeometry(s.enumMultiPoint),i=t.insertPath(e,Nm);for(let s=this.m_topoGraph.getFirstCluster();s!==Nm;s=this.m_topoGraph.getNextCluster(s)){const e=this.m_topoGraph.getClusterParentage(s);if(this.isGoodParentage(e)){let e=Nm;for(let i=this.m_topoGraph.getClusterVertexIterator(s);i!==Nm;i=this.m_topoGraph.incrementVertexIterator(i)){const s=this.m_topoGraph.getVertexFromVertexIterator(i);e===Nm&&(e=s);const n=t.getGeometryFromPath(t.getPathFromVertex(s)),r=this.m_topoGraph.getGeometryID(n);if(this.isGoodParentage(r)){e=s;break}}t.addVertex(i,e)}}return e}intersection(e,s){const i=this.m_topoGraph.getShape().getGeometryType(e),n=this.m_topoGraph.getShape().getGeometryType(s),r=P(i),o=P(n),a=this.m_topoGraph.getGeometryID(e),h=this.m_topoGraph.getGeometryID(s);t(a>=0),t(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a|h]=!0;let l=Nm;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(l=e),2===r&&2===o?this.topoOperationPolygonPolygon_(e,s,l):1===r&&o>0||1===o&&r>0?this.topoOperationPolyline_(l,this.m_bOGCOutput):0===r||0===o?this.topoOperationMultiPoint_():void m("")}topoOperationPolygonPolygonEx(t,e,i){const n=this.m_topoGraph.getShape(),r=n.createGeometry(s.enumPolygon),o=n.createGeometry(s.enumPolyline),a=n.createGeometry(s.enumMultiPoint);this.dissolveTopoGraphCommonEdges_();let h=Nm;const m=this.m_topoGraph.createUserIndexForHalfEdges(),l=this.m_topoGraph.createUserIndexForClusters();n.dbgVerifyCurves(),this.topoOperationPolygonPolygonHelper_(t,e,r,i,m,l),n.dbgVerifyCurves();const u=n.hasSegmentParentage(),c=new SE;for(let s=this.m_topoGraph.getFirstCluster();s!==Nm;s=this.m_topoGraph.getNextCluster(s)){const t=this.m_topoGraph.getClusterHalfEdge(s);if(t===Nm)continue;let e=t;do{let t=this.m_topoGraph.getHalfEdgeUserIndex(e,m),r=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(e),m),a=t|r;if(2===a){let h=this.m_topoGraph.getHalfEdgeParentage(e);if(this.isGoodParentage(h)){const g=n.insertPath(o,Nm);let _=e;const d=this.chooseVertexFromCluster_(s,i);let p=n.addVertex(g,d);if(u){const t=this.m_topoGraph.getSegmentParentage(e),s=this.m_topoGraph.getHalfEdgeOrigin(e);n.setSegmentParentageAndBreak(p,t,this.m_topoGraph.isBreakNode(s))}this.m_topoGraph.isHalfEdgeCurve(e)&&(this.m_topoGraph.querySegmentXY(e,c),n.setSegmentToIndex(n.getVertexIndex(p),c.get().clone())),this.m_topoGraph.setClusterUserIndex(s,l,1);do{this.progress_();const s=this.m_topoGraph.getHalfEdgeTo(_),o=this.chooseVertexFromCluster_(s,i);if(p=n.addVertex(g,o),u){const t=this.m_topoGraph.getSegmentParentage(e),s=this.m_topoGraph.getHalfEdgeOrigin(e);n.setSegmentParentageAndBreak(p,t,this.m_topoGraph.isBreakNode(s))}if(this.m_topoGraph.setHalfEdgeUserIndex(_,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_),m,1),this.m_topoGraph.setClusterUserIndex(s,l,1),_=this.m_topoGraph.getHalfEdgeNext(_),t=this.m_topoGraph.getHalfEdgeUserIndex(_,m),r=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_),m),a=t|r,2!==a)break;if(h=this.m_topoGraph.getHalfEdgeParentage(_),!this.isGoodParentage(h)){this.m_topoGraph.setHalfEdgeUserIndex(_,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_),m,1);break}this.m_topoGraph.isHalfEdgeCurve(e)&&_!==e&&(this.m_topoGraph.querySegmentXY(e,c),n.setSegmentToIndex(n.getVertexIndex(p),c.get().clone()))}while(_!==e)}else this.m_topoGraph.setHalfEdgeUserIndex(e,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(e),m,1)}e=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(e))}while(e!==t)}for(let s=this.m_topoGraph.getFirstCluster();s!==Nm;s=this.m_topoGraph.getNextCluster(s)){this.progress_();if(1===this.m_topoGraph.getClusterUserIndex(s,l))continue;const t=this.m_topoGraph.getClusterParentage(s);if(this.isGoodParentage(t)){h===Nm&&(h=n.insertPath(a,Nm));const t=this.m_topoGraph.getClusterVertexIterator(s);let e=Nm;if(t!==Nm){e=this.m_topoGraph.getVertexFromVertexIterator(t);const s=this.chooseVertexFromVertexCluster_(e,i);n.addVertex(h,s)}}}this.m_topoGraph.deleteUserIndexForClusters(l),this.m_topoGraph.deleteUserIndexForHalfEdges(m),n.dbgVerifyCurves(),Zu(n,r,3,this.m_bOGCOutput,Nm,this.m_progressTracker);const g=[Nm,Nm,Nm];return g[0]=a,g[1]=o,g[2]=r,g}topoOperationPolylinePolylineOrPolygonEx(t,e){const s=wd();return s.allCrossRoadsImpassable=!1,s.ogcRule=e,s.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(Nm,t,!0,s)}topoOperationMultiPoint(){const t=this.m_topoGraph.getShape(),e=t.createGeometry(s.enumMultiPoint),i=t.insertPath(e,Nm);for(let s=this.m_topoGraph.getFirstCluster();s!==Nm;s=this.m_topoGraph.getNextCluster(s)){const e=this.m_topoGraph.getClusterParentage(s);if(this.isGoodParentage(e)){let e=Nm;for(let i=this.m_topoGraph.getClusterVertexIterator(s);i!==Nm;i=this.m_topoGraph.incrementVertexIterator(i)){const s=this.m_topoGraph.getVertexFromVertexIterator(i);e===Nm&&(e=s);const n=t.getGeometryFromPath(t.getPathFromVertex(s)),r=this.m_topoGraph.getGeometryID(n);if(this.isGoodParentage(r)){e=s;break}}t.addVertex(i,e)}}return e}intersectionEx(e,s){const i=this.m_topoGraph.getShape().getGeometryType(e),n=this.m_topoGraph.getShape().getGeometryType(s),r=bd(i),o=bd(n),a=this.m_topoGraph.getGeometryID(e),h=this.m_topoGraph.getGeometryID(s);t(a>=0),t(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a|h]=!0;let l=Nm;if(this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(l=e),2===r&&2===o)return this.topoOperationPolygonPolygonEx(e,s,l);if(1===r&&o>0||1===o&&r>0){const{first:t,second:e}=this.topoOperationPolylinePolylineOrPolygonEx(l,this.m_bOGCOutput);return[e,t]}if(0===r||0===o){const t=[];return t.push(this.topoOperationMultiPoint()),t}m("")}getCombinedHalfEdgeParentage(t){return this.m_topoGraph.getHalfEdgeParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t))}prevailingDirection(t,e){const s=this.getCombinedHalfEdgeParentage(e),i=this.m_topoGraph.getHalfEdgeOrigin(e),n=this.m_topoGraph.getHalfEdgeTo(e);let r=0,o=0;for(let a=this.m_topoGraph.getClusterVertexIterator(i);a!==Nm;a=this.m_topoGraph.incrementVertexIterator(a)){const i=this.m_topoGraph.getVertexFromVertexIterator(a),h=t.getPathFromVertex(i),m=t.getGeometryFromPath(h),l=this.m_topoGraph.getGeometryID(m),u=t.getFirstVertex(h),c=!!(l&s);c&&u===i&&(this.m_fromEdgeForPolylines=e);const g=t.getNextVertex(i);if(g!==Nm&&this.m_topoGraph.getClusterFromVertex(g)===n){if(r++,c){if(this.m_fromEdgeForPolylines===Nm&&u===g){const t=this.m_topoGraph.getHalfEdgeNext(e);this.isGoodParentage(this.getCombinedHalfEdgeParentage(t))&&(this.m_fromEdgeForPolylines=t)}o++}}else{const s=t.getPrevVertex(i);if(s!==Nm&&this.m_topoGraph.getClusterFromVertex(s)===n&&(r--,c)){if(this.m_fromEdgeForPolylines===Nm&&u===s){const t=this.m_topoGraph.getHalfEdgeNext(e);this.isGoodParentage(this.getCombinedHalfEdgeParentage(t))&&(this.m_fromEdgeForPolylines=t)}o--}}}this.m_topoGraph.queryXY(i,this.m_dummyPt1),this.m_topoGraph.queryXY(n,this.m_dummyPt2);return(0!==o?o:r)*w.distance(this.m_dummyPt1,this.m_dummyPt2)}tryMoveThroughCrossroadBackwards(t,e){const s=this.m_topoGraph.getHalfEdgePrev(t),i=this.m_topoGraph.getHalfEdgeTwin(s);if(!e){if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t)))return Nm;const e=this.m_topoGraph.getHalfEdgeTwin(t);if(i===this.m_topoGraph.getHalfEdgeNext(e))return s}let n=i,r=Nm;for(;n!==t;){const t=this.getCombinedHalfEdgeParentage(n);if(this.isGoodParentage(t)){if(r!==Nm)return Nm;r=this.m_topoGraph.getHalfEdgeTwin(n)}n=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgePrev(n))}return r}tryMoveThroughCrossroadForward(t,e){const s=this.m_topoGraph.getHalfEdgeNext(t),i=this.m_topoGraph.getHalfEdgeTwin(s);if(!e){const e=this.m_topoGraph.getHalfEdgeTwin(t);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e)))return Nm;if(i===this.m_topoGraph.getHalfEdgePrev(e))return s}let n=i,r=Nm;for(;n!==t;){const t=this.getCombinedHalfEdgeParentage(n);if(this.isGoodParentage(t)){if(r!==Nm)return Nm;r=this.m_topoGraph.getHalfEdgeTwin(n)}n=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgeNext(n))}return r}isOnALoop(t,e){let s=t;const i=2*this.m_topoGraph.getShape().getTotalPointCount()+10;for(let n=0;n<i;n++){if(1===this.m_topoGraph.getHalfEdgeUserIndex(s,e))return!1;const i=this.m_topoGraph.getHalfEdgeNext(s);if(i===this.m_topoGraph.getHalfEdgeTwin(s))return!1;if(s=i,s===t)return!0}m("is_on_a_loop_")}restorePolylineParts(e,s,i,n,r,o,a,h,m,l){t(r===Nm&&o>=0&&a>=0||-1===o&&-1===a),t(-1===h&&1!==l.unsplitBehavior||-1!==h&&1===l.unsplitBehavior);const u=l.ogcRule,c=l.allCrossRoadsImpassable,g=1===l.unsplitBehavior,_=0===l.unsplitBehavior,d=this.m_topoGraph.getShape(),p=d.hasSegmentParentage();let f=e,x=this.m_topoGraph.getHalfEdgeTwin(f);const y=new SE;this.m_fromEdgeForPolylines=Nm;let P=this.prevailingDirection(d,f),E=f,C=Nm,S=!1,v=!1,b=!1;if(!g)for(;;){const t=this.m_topoGraph.getHalfEdgePrev(f);if(t===x){b=!0;break}const s=this.m_topoGraph.getHalfEdgeNext(x);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(s))){S=!0;break}if(this.m_topoGraph.getHalfEdgeTwin(t)!==s){if(c){S=!0;break}if(f=this.tryMoveThroughCrossroadBackwards(f,!0),f===Nm){S=!0;break}x=this.m_topoGraph.getHalfEdgeTwin(f)}else f=t,x=s;if(1===this.m_topoGraph.getHalfEdgeUserIndex(f,i)){b=!0;break}if(f===e){C=e,v=!0;break}const n=this.getCombinedHalfEdgeParentage(f);if(!this.isGoodParentage(n))break;E=f,P+=this.prevailingDirection(d,f)}if(C===Nm){for(f=e,x=this.m_topoGraph.getHalfEdgeTwin(f),C=f;;){const t=this.m_topoGraph.getHalfEdgeNext(f),e=this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t));if(e){S=!0;break}if(t===x){b=!0;break}if(-1!==h){const t=this.m_topoGraph.getHalfEdgeOrigin(x);if(1===this.m_topoGraph.getClusterUserIndex(t,h)){S=!0;break}}const s=this.m_topoGraph.getHalfEdgePrev(x);if(this.m_topoGraph.getHalfEdgeTwin(t)!==s){if(e||c){S=!0;break}if(f=this.tryMoveThroughCrossroadForward(f,!0),f===Nm){S=!0;break}x=this.m_topoGraph.getHalfEdgeTwin(f)}else f=t,x=s;if(1===this.m_topoGraph.getHalfEdgeUserIndex(f,i)){b=!0;break}const n=this.getCombinedHalfEdgeParentage(f);if(!this.isGoodParentage(n))break;C=f,P+=this.prevailingDirection(d,f)}const t=this.m_topoGraph.getHalfEdgeOrigin(E);v=this.m_topoGraph.getHalfEdgeTo(C)===t}else if(this.m_fromEdgeForPolylines!==Nm){E=e,C=this.tryMoveThroughCrossroadBackwards(E,!1),t(C!==Nm);const s=this.m_topoGraph.getHalfEdgeTwin(E);this.m_topoGraph.getHalfEdgeNext(s)}let I=v;v||b||m&&(I=this.isOnALoop(e,i),I||(I=this.isOnALoop(x,i)));const w=P>=0;let D=!1;I&&S&&(v?(D=u,w&&(D||g||_)&&E!==e&&(t(!g),E=e,D=!1)):(g||w&&_)&&(E=e));let T=0;for(f=E;x=this.m_topoGraph.getHalfEdgeTwin(f),this.m_topoGraph.setHalfEdgeUserIndex(f,i,1),this.m_topoGraph.setHalfEdgeUserIndex(x,i,1),T++,f!==C;)f=c?this.m_topoGraph.getHalfEdgeNext(f):this.tryMoveThroughCrossroadForward(f,!1);w||(C=q(E,E=C),C=this.m_topoGraph.getHalfEdgeTwin(C),E=this.m_topoGraph.getHalfEdgeTwin(E));let N=d.insertPath(s,Nm);f=E;const A=this.m_topoGraph.getHalfEdgeOrigin(E);let F;F=-1!==o?this.chooseVertexByOrder(A,d,o,a):this.chooseVertexFromCluster_(A,r),this.m_topoGraph.isStrongPathNode(A)&&d.setStrongPathStart(N,!0);let M=d.addVertex(N,F),G=M;-1!==n&&this.m_topoGraph.setClusterUserIndex(A,n,1);let V=0;const Y=D?Math.trunc((T+1)/2):-1;let X=Nm,k=!0,R=Nm;for(;;){if(p){const t=this.m_topoGraph.getSegmentParentage(f),e=this.m_topoGraph.getHalfEdgeOrigin(f);d.setSegmentParentageAndBreak(G,t,k||this.m_topoGraph.isBreakNode(e))}k=!1,this.m_topoGraph.isHalfEdgeCurve(f)&&(this.m_topoGraph.querySegmentXY(f,y),d.setSegmentToIndex(d.getVertexIndex(G),y.get().clone())),X!==Nm&&-1!==a&&d.addToUserIndex(X,a,-1);const t=c?this.m_topoGraph.getHalfEdgeNext(f):this.tryMoveThroughCrossroadForward(f,!1),e=this.m_topoGraph.getHalfEdgeTo(f);let i;if(i=-1!==o?this.chooseVertexByOrder(e,d,o,a):this.chooseVertexFromCluster_(e,r),M=d.addVertex(N,i),R=e,-1!==n&&this.m_topoGraph.setClusterUserIndex(e,n,1),p&&this.m_topoGraph.isBreakNode(e)&&d.setSegmentParentageBreakVertex(M,!0),X=i,V++,D&&V===Y&&(N=d.insertPath(s,Nm),M=d.addVertex(N,i),k=!0,-1!==a&&d.addToUserIndex(i,a,-1),X=Nm),f===C)break;f=t,G=M}R!==Nm&&this.m_topoGraph.isStrongPathNode(R)&&d.setStrongPathEnd(N,!0)}topoOperationPolylineSimplify_(t,e){return this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,Nm,!1,e).first}topoOperationPolylineSimplifyOrPolylineTopoHelper_(e,i,n,r){t(i===Nm||e===Nm);const o=this.m_topoGraph.getShape(),a=t=>t=e===Nm?t===Nm?o.getFirstGeometry():o.getNextGeometry(t):t===Nm?e:Nm,h=o.createGeometry(s.enumPolyline);let m=-1;n&&(m=this.m_topoGraph.createUserIndexForClusters());const l=this.m_topoGraph.createUserIndexForHalfEdges(),u=i===Nm?o.createUserIndex():-1,c=i===Nm?o.createUserIndex():-1;let g=-1;if(1===r.unsplitBehavior){g=this.m_topoGraph.createUserIndexForClusters();for(let t=a(Nm);t!==Nm;t=a(t))for(let e=o.getFirstPath(t);e!==Nm;e=o.getNextPath(e)){{const t=o.getFirstVertex(e),s=this.m_topoGraph.getClusterFromVertex(t);this.m_topoGraph.setClusterUserIndex(s,g,1)}if(!o.isClosedPath(e)){const t=o.getLastVertex(e),s=this.m_topoGraph.getClusterFromVertex(t);this.m_topoGraph.setClusterUserIndex(s,g,1)}}}if(i===Nm){let t=0;for(let e=a(Nm);e!==Nm;e=a(e))for(let s=o.getFirstPath(e);s!==Nm;s=o.getNextPath(s)){if(o.isClosedPath(s)){let e=o.getFirstVertex(s);for(let i=0,n=o.getPathSize(s);i<n;i++,e=o.getNextVertex(e))o.setUserIndex(e,u,t++),o.setUserIndex(e,c,2)}else{const e=o.getFirstVertex(s);o.setUserIndex(e,u,t++),o.setUserIndex(e,c,1);let i=o.getNextVertex(e);for(let n=1,r=o.getPathSize(s)-1;n<r;++n)o.setUserIndex(i,u,t++),o.setUserIndex(i,c,2),i=o.getNextVertex(i);o.setUserIndex(i,u,t++),o.setUserIndex(i,c,1)}}}for(let t=a(Nm);t!==Nm;t=a(t))for(let e=o.getFirstPath(t);e!==Nm;e=o.getNextPath(e)){let t=o.getFirstVertex(e);for(let s=0,n=o.getPathSize(e);s<n;s++,t=o.getNextVertex(t)){const e=this.m_topoGraph.getHalfEdgeFromVertex(t);if(e===Nm)continue;if(1===this.m_topoGraph.getHalfEdgeUserIndex(e,l))continue;const n=this.getCombinedHalfEdgeParentage(e);if(this.isGoodParentage(n)){const t=0===s;this.restorePolylineParts(e,h,l,m,i,u,c,g,t,r)}}}let _=Nm;if(n){_=o.createGeometry(s.enumMultiPoint);let t=Nm;for(let e=this.m_topoGraph.getFirstCluster();e!==Nm;e=this.m_topoGraph.getNextCluster(e)){this.progress_();if(1!==this.m_topoGraph.getClusterUserIndex(e,m)){const s=this.m_topoGraph.getClusterParentage(e);if(this.isGoodParentage(s)){t===Nm&&(t=o.insertPath(_,Nm));const s=this.m_topoGraph.getClusterVertexIterator(e);if(s!==Nm){let n;this.m_topoGraph.getVertexFromVertexIterator(s),n=-1!==u?this.chooseVertexByOrder(e,o,u,c):this.chooseVertexFromCluster_(e,i),o.addVertex(t,n)}}}}}return-1!==c&&o.removeUserIndex(c),-1!==u&&o.removeUserIndex(u),-1!==m&&o.removeUserIndex(m),this.m_topoGraph.deleteUserIndexForHalfEdges(l),j(h,_)}difference(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),i=this.m_topoGraph.getShape().getGeometryType(e),n=P(s),r=P(i);if(n>r)return t;const o=this.m_topoGraph.getGeometryID(t),a=this.m_topoGraph.getGeometryID(e);if(this.m_maskLookup.length=0,this.m_maskLookup.length=1+(o|a),this.m_maskLookup[o]=!0,2===n&&2===r){let s=Nm;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(s=t),this.topoOperationPolygonPolygon_(t,e,s)}if(1===n&&2===r){const e=wd();return e.allCrossRoadsImpassable=!1,e.ogcRule=this.m_bOGCOutput,e.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,Nm,!1,e).first}if(1===n&&1===r){const e=wd();return e.allCrossRoadsImpassable=!0,e.ogcRule=this.m_bOGCOutput,e.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,Nm,!1,e).first}if(0===n)return this.topoOperationMultiPoint_();m("")}symmetricDifference(e,s){const i=this.m_topoGraph.getShape().getGeometryType(e),n=this.m_topoGraph.getShape().getGeometryType(s),r=bd(i),o=bd(n),a=this.m_topoGraph.getGeometryID(e),h=this.m_topoGraph.getGeometryID(s);return t(a>=0),t(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a]=!0,this.m_maskLookup[a]=!0,this.m_maskLookup[h]=!0,2===r&&2===o?this.topoOperationPolygonPolygon_(e,s,Nm):1===r&&1===o?this.topoOperationPolyline_(Nm,this.m_bOGCOutput):0===r&&0===o?this.topoOperationMultiPoint():void m("")}planarSimplifyNoCrackingAndCluster(e,s,i,n){return t(0),!1}unsplitPolylineExact(e){return t(0),new am}planarSimplifyPolylines(e,i,n,r,o){for(let _=e.getFirstGeometry();_!==Nm;_=e.getNextGeometry(_)){const i=e.getGeometryType(_);t(i===s.enumPolyline)}let a=0,h=0,m=null;if(e.hasCurves()&&!e.hasSegmentParentage()){m=new ld;const t=e.getEnvelope2D(this.m_progressTracker);h=hd(i.total());const s=ad(i.total(),t);a=md(s,h),ed(e,s,i.total(),12e3,m,null,this.m_progressTracker)}{const t=fd(i.add(a));e.filterClosePoints(t,!1,!1,!1,Nm)}if(this.m_topoGraph=new Kl,4!==o&&5!==o)if(null===m&&n){const t=new Iu(this.m_progressTracker,!1);t.sweepVertical(e,i.total()),t.hadComplications()?(cd(e,i,this.m_progressTracker,!0,!1),n=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(i.total())}else cd(e,i.add(a),this.m_progressTracker,!0,!1),n=!1;else n=!1;e.removeSelection(),e.collapseAllGeometriesToFirst();const l=e.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(e,l,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return t(n&&null===m),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolylines(e,i,!1,r,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const u=this.m_topoGraph.getGeometryID(l);t(u>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=u+1,this.m_maskLookup[u]=!0;const c=this.topoOperationPolylineSimplify_(e.getFirstGeometry(),r);null!==m&&m.stitchCurves(e,c,h,!0);const g=e.getGeometry(c);return n||g.getImpl().setIsSimple(4,i.total()),g}planarSimplifyMultiPoints(e,i,n,r){for(let l=e.getFirstGeometry();l!==Nm;l=e.getNextGeometry(l)){const i=e.getGeometryType(l);t(i===s.enumMultiPoint)}this.m_topoGraph=new Kl,4!==r&&5!==r?(cd(e,i,this.m_progressTracker,!0,!1),n=!1):n=!1,e.removeSelection(),e.collapseAllGeometriesToFirst();const o=e.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(e,o,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return t(n),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyMultiPoints(e,i,!1,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const a=this.m_topoGraph.getGeometryID(o);t(a>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=a+1,this.m_maskLookup[a]=!0;const h=this.topoOperationMultiPoint(),m=e.getGeometry(h);return n||m.getImpl().setIsSimple(4,i.total()),m}planarSimplifyPolygons(e,i,n,r,o,a){for(let f=e.getFirstGeometry();f!==Nm;f=e.getNextGeometry(f)){const i=e.getGeometryType(f);t(i===s.enumPolygon||i===s.enumPolyline&&n)}let h=0,m=0,l=null;if(e.hasCurves()&&!e.hasSegmentParentage()){l=new ld;const t=e.getEnvelope2D(this.m_progressTracker);m=hd(i.total());const s=ad(i.total(),t);h=md(s,m),ed(e,s,i.total(),12e3,l,null,this.m_progressTracker)}if(a){cd(e,i.add(h),this.m_progressTracker,!0,!1);for(let t=e.getFirstGeometry();t!==Nm;t=e.getNextGeometry(t))e.getGeometryType(t)===s.enumPolygon&&Zu(e,t,-1,!1,Nm,this.m_progressTracker)}if(this.m_topoGraph=new Kl,a||4===o||5===o)r=!1;else if(null===l&&r){const t=new Iu(this.m_progressTracker,!1);t.sweepVertical(e,i.total()),t.hadComplications()?(cd(e,i,this.m_progressTracker,!0,!1),r=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(i.total())}else cd(e,i.add(h),this.m_progressTracker,!0,!1),r=!1;e.removeSelection(),e.collapseAllGeometriesToFirst();const u=e.getFirstGeometry();if(n?this.m_topoGraph.setAndSimplifyEditShapeWinding(e,u,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeAlternate(e,u,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return t(r&&null===l),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolygons(e,i,n,!1,-1,!1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const c=this.m_topoGraph.getGeometryID(u);t(c>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=c+1,this.m_maskLookup[c]=!0,e.setFillRule(u,0);const g=this.m_bOGCOutput&&n,_=g;let d=this.topoOperationPolygonPolygon_(u,Nm,Nm,_);if(g){this.m_topoGraph.removeShape(),this.m_topoGraph=null,e.removeGeometry(u),this.m_topoGraph=new Kl,this.m_topoGraph.setAndSimplifyEditShapeAlternate(e,d,this.m_progressTracker);d=this.topoOperationPolygonPolygon_(d,Nm,Nm,!1)}null!==l&&l.stitchCurves(e,d,m,!0);const p=e.getGeometry(d);return p.setFillRule(0),r?p.getImpl().setIsSimple(3,0):(p.getImpl().setIsSimple(4,i.total()),p.getImpl().updateOGCFlagsProtected()),p}planarSimplify3DImpl_(e,s,i,n,r){return t(0),{}}planarSimplifyImpl_(t,e,i,n,r,o,a,h){if(t.isEmpty())return t.clone();const l=t.getGeometryType(),u=new Vm,c=u.addGeometry(t);if(As(r)&&l===s.enumPolygon&&(i=!1,u.setFillRule(c,0)),h&&(t.hasAttribute(1)&&u.replaceNaNs(1,0),u.removeNaNVertices()),l===s.enumPolygon||l===s.enumPolyline&&i)return this.planarSimplifyPolygons(u,e,i,n,r,!1);if(l===am.type){const t=wd();return t.allCrossRoadsImpassable=!0,t.ogcRule=this.m_bOGCOutput,t.unsplitBehavior=a,this.planarSimplifyPolylines(u,e,n,t,r)}if(l===s.enumMultiPoint)return this.planarSimplifyMultiPoints(u,e,n,r);m("what else?")}}function zd(t,e,s,i){if(t.isEmpty())return t.createInstance();if(e.isEmpty())return i?t.createInstance():new Ge({copy:t});const n=[new w],r=[0],o=2===e.getDimension();1!==e.getDimension()&&2!==e.getDimension()&&m(""),n[0]=t.getXY(),o?B_(e,n,1,s.total(),r):L_(e,n,1,s.total(),r);let a=0===r[0];return i||(a=!a),a?t.createInstance():t}function Ud(t,e,s,i){const n=t.createInstance(),r=D(w,100),o=new Array(100),a=t.getPointCount();let h=!0;const l=2===e.getDimension();1!==e.getDimension()&&2!==e.getDimension()&&m("");for(let m=0;m<a;){const i=t.queryCoordinates(r,r.length,m,-1)-m;l?B_(e,r,i,s.total(),o):L_(e,r,i,s.total(),o);let a=0;for(let e=0;e<i;e++){0===o[e]&&(h&&(h=!1,n.addPoints(t,0,m)),a!==e&&n.addPoints(t,m+a,m+e),a=e+1)}h||a===i||n.addPoints(t,m+a,m+i),m+=i}return h?t:n}function Od(t,e,i,n){const r=t.getGeometryType();if(r===s.enumEnvelope){const e=new Sm({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(r===s.enumPoint&&("|"===n||"^"===n)){const e=new ii({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if(r===s.enumLine){const e=new am({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}if(r===s.enumMultiPoint&&"-"===n&&e.getGeometryType()===s.enumPoint){const e=new Ge({vd:t.getDescription()});return t.isEmpty()||t.getPointByVal(0,e),e}if(r===s.enumMultiPoint&&"&"===n&&e.getGeometryType()===s.enumPoint){const e=new Ge({vd:t.getDescription()});return t.isEmpty()||t.getPointByVal(0,e),e}return t}function Wd(t){const i=t.getGeometryType();if(i===s.enumEnvelope){const e=new Sm({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(i===s.enumPoint){const e=new ii({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if(vd(i)){const e=new am({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}return i!==s.enumMultiPoint&&i!==s.enumPolyline&&i!==s.enumPolygon&&e("Unexpected geometry type"),t}function jd(e,s,i,n){const r=i===Nm?e.getClusterHalfEdge(s):i;let o=r;t(e.getHalfEdgeOrigin(r)===s);do{n(o),o=e.getHalfEdgeNext(e.getHalfEdgeTwin(o))}while(o!==r)}class Zd{constructor(t,e,s,i,n,r){this.m_rParent=t,this.m_rTopoGraph=t.m_topoGraph,this.m_rShape=this.m_rTopoGraph.getShape(),this.m_IDCuttee=this.m_rTopoGraph.getGeometryID(i),this.m_IDCutter=this.m_rTopoGraph.getGeometryID(n),this.m_IDBoth=this.m_IDCuttee|this.m_IDCutter,this.m_bConsiderTouch=e,this.m_sideIndex=s,this.m_cuttee=i,this.m_cutter=n,this.m_rCutHandles=r,this.m_cutteeBreadcrumbsIndex=this.m_rShape.createUserIndexUninitialized(),this.m_clusterParentageIndex=this.m_rShape.createUserIndexUninitialized();for(let o=this.m_rShape.getFirstPath(this.m_cuttee);o!==Nm;o=this.m_rShape.getNextPath(o)){let t=0;const e=this.m_rShape.getPathSize(o);for(let s=this.m_rShape.getFirstVertex(o);t<e;t++,s=this.m_rShape.getNextVertex(s))this.m_rShape.setUserIndex(s,this.m_clusterParentageIndex,this.m_rTopoGraph.getClusterParentage(this.m_rTopoGraph.getClusterFromVertex(s)))}}Do(){this.cutPolylinePolyline_(),this.m_rShape.removeUserIndex(this.m_cutteeBreadcrumbsIndex),this.m_rShape.removeUserIndex(this.m_clusterParentageIndex)}setTbd(t){return 8|t}classifyStandardCut(t,e,s,i){const n=this.m_rShape.getPrevVertex(t),r=this.m_rShape.getNextVertex(t),o=n===Nm?Nm:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(n)),a=r===Nm?Nm:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(r)),h=this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(s)),m=this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(i));let l=1,u=32,c=32;if(jd(this.m_rTopoGraph,e,m,(t=>{t===h&&(l=2),t===o&&(u=l),t===a&&(c=l)})),this.m_bConsiderTouch)32!==u&&this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex)|u),32!==c&&this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|c);else{if(32===u||32===c)return 1;if(u===c&&!(o===h||o===m||a===h||a===m))return 1;this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex)|u),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|c)}return 0}classifyTouchCut(t,e,s,i){const n=this.m_rShape.getPrevVertex(t),r=this.m_rShape.getNextVertex(t),o=n===Nm?Nm:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(n)),a=r===Nm?Nm:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(r)),h=s===Nm?Nm:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(s)),m=i===Nm?Nm:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(i));if(!this.m_bConsiderTouch){let e;return(e=h===o||m===o)?this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))):(e=h===a||m===a)&&this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),e?0:1}if(o===Nm)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(a===Nm)return this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),0;if(o===a)return this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(m!==Nm){if(o===m)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(a===m)return this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),0;let s=1;jd(this.m_rTopoGraph,e,m,(e=>{if(e===o){const t=this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,t),s=2}else if(e===a){const e=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,e),s=2}}))}else{if(o===h)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(a===h)return this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex))),0;let s=2;jd(this.m_rTopoGraph,e,h,(e=>{if(e===o){const t=this.m_rShape.getUserIndex(n,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(n,this.m_cutteeBreadcrumbsIndex,t),s=1}else if(e===a){const e=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,e),s=1}}))}return 0}classifyCutVertex(t,e){let s=0,i=0;for(let n=this.m_rTopoGraph.getClusterVertexIterator(e);n!==Nm;n=this.m_rTopoGraph.incrementVertexIterator(n)){const r=this.m_rTopoGraph.getVertexFromVertexIterator(n);if(this.m_rShape.getGeometryFromVertex(r)===this.m_cutter){i++;const n=this.m_rShape.getPrevVertex(r),o=this.m_rShape.getNextVertex(r);s+=n===Nm||o===Nm?this.classifyTouchCut(t,e,n,o):this.classifyStandardCut(t,e,n,o)}}i&&s===i&&!this.m_bConsiderTouch&&this.m_rShape.setUserIndex(t,this.m_clusterParentageIndex,this.m_IDCuttee)}cutPolylinePolyline_(){this.m_rShape.getGeometryType(this.m_cuttee),this.m_rShape.getGeometryType(this.m_cutter),this.m_rParent.m_maskLookup.length=0,this.m_rParent.m_maskLookup.length=this.m_IDBoth+1,this.m_rParent.m_maskLookup[this.m_IDBoth]=!0;for(let s=this.m_rShape.getFirstPath(this.m_cuttee);s!==Nm;s=this.m_rShape.getNextPath(s)){const t=this.m_rShape.getPathSize(s);let e=this.m_rShape.getFirstVertex(s);for(let s=0;s<t;++s,e=this.m_rShape.getNextVertex(e))this.m_rShape.setUserIndex(e,this.m_cutteeBreadcrumbsIndex,0);e=this.m_rShape.getFirstVertex(s);for(let s=0;s<t;++s,e=this.m_rShape.getNextVertex(e)){const t=this.m_rTopoGraph.getClusterFromVertex(e);this.m_rTopoGraph.getClusterParentage(t)===this.m_IDBoth&&this.classifyCutVertex(e,t)}}const t=(t,e)=>{let s=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex);const i=this.m_rTopoGraph.getHalfEdgeConnector(this.m_rTopoGraph.getClusterFromVertex(t),this.m_rTopoGraph.getClusterFromVertex(e));return(this.m_rTopoGraph.getHalfEdgeParentage(i)&this.m_IDBoth)===this.m_IDBoth&&(s|=4),s};for(let s=this.m_rShape.getFirstPath(this.m_cuttee);s!==Nm;s=this.m_rShape.getNextPath(s)){let e=this.m_rShape.getFirstVertex(s);const i=this.m_rShape.isClosedPath(s),n=this.m_rShape.getPathSize(s)+(i?1:0);let r=1,o=32;for(let s=this.m_rShape.getNextVertex(e);r<n;++r,e=s,s=this.m_rShape.getNextVertex(s)){const i=t(e,s);this.m_rShape.getUserIndex(e,this.m_clusterParentageIndex)===this.m_IDBoth&&(o=i),32!==o&&this.m_rShape.setUserIndex(e,this.m_cutteeBreadcrumbsIndex,o|i)}e=this.m_rShape.getLastVertex(s);let a=32;r=1;for(let s=this.m_rShape.getPrevVertex(e);r<n;++r,e=s,s=this.m_rShape.getPrevVertex(s)){const i=t(s,e);this.m_rShape.getUserIndex(e,this.m_clusterParentageIndex)===this.m_IDBoth&&(a=i),32!==a&&this.m_rShape.setUserIndex(s,this.m_cutteeBreadcrumbsIndex,a|i)}}let e=Nm,i=Nm,n=32;const r=this.m_rShape.hasSegmentParentage(),o=new SE;for(let a=this.m_rShape.getFirstPath(this.m_cuttee);a!==Nm;a=this.m_rShape.getNextPath(a)){const t=this.m_rShape.isClosedPath(a),h=this.m_rShape.getPathSize(a)+(t?1:0);let m=1,l=this.m_rShape.getFirstVertex(a),u=Nm,c=!0;for(let a=this.m_rShape.getNextVertex(l);m<h;++m,a=this.m_rShape.getNextVertex(a)){let t=this.m_rShape.getUserIndex(l,this.m_cutteeBreadcrumbsIndex);8===t?t=3:(t&=-9,4&t?t=4:3&~t||(t=3)),t!==n?(e!==Nm&&(u=this.m_rShape.addVertex(i,l),r&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l))&&this.m_rShape.setSegmentParentageBreakVertex(u,!0),this.m_rCutHandles.push(e),this.m_rShape.setGeometryUserIndex(e,this.m_sideIndex,n)),e=this.m_rShape.createGeometry(s.enumPolyline),i=this.m_rShape.insertPath(e,Nm),n=t,c=!0):this.m_rShape.getUserIndex(l,this.m_clusterParentageIndex)===this.m_IDBoth&&4!==t&&(u=this.m_rShape.addVertex(i,l),r&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l))&&this.m_rShape.setSegmentParentageBreakVertex(u,!0),i=this.m_rShape.insertPath(e,Nm),c=!0),u=this.m_rShape.addVertex(i,l);const h=this.m_rTopoGraph.getClusterFromVertex(l);!c&&r&&this.m_rTopoGraph.isBreakNode(h)&&this.m_rShape.setSegmentParentageBreakVertex(u,!0);const m=this.m_rTopoGraph.getHalfEdgeFromVertex(l);if(r){const t=this.m_rTopoGraph.getSegmentParentage(m);this.m_rShape.setSegmentParentageAndBreak(u,t,c||this.m_rTopoGraph.isBreakNode(h))}this.m_rTopoGraph.isHalfEdgeCurve(m)&&(this.m_rTopoGraph.querySegmentXY(m,o),this.m_rShape.setSegmentToIndex(this.m_rShape.getVertexIndex(u),o.get().clone())),l=a,c=!1}u=this.m_rShape.addVertex(i,l),r&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l))&&this.m_rShape.setSegmentParentageBreakVertex(u,!0),this.m_rCutHandles.push(e),this.m_rShape.setGeometryUserIndex(e,this.m_sideIndex,n),e=Nm,i=Nm,n=32}}}function Qd(t,e,s){return new Hd(s).linesToPolygonsImpl(t,e)}function Kd(t,e,i,n,r){if(n&&(n.m_reason=0,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),t.isEmpty())return 5;const o=t.getGeometryType();if(o===s.enumPoint)return sp(t,n);const a=bs(e,t,!1).total();if(o===s.enumEnvelope){const e=t,s=new ge;return e.queryEnvelope(s),s.isDegenerate(a)?(n&&(n.m_reason=4,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),0):5}if(l(o)){const s=t,o=new am({vd:s.getDescription()});return o.addSegment(s,!0),$d(o,e,i,n,r)}const h=[0],u=t.getImpl().getIsSimple(a,h);let c=i?-1:u;if(Gs(c)||0===c)return c;const g=new gp(t,e,c,r,!1);o===s.enumMultiPoint||o===s.enumPolyline||o===s.enumPolygon?c=g.isSimplePlanarImpl():m("");return t.getImpl().setIsSimple(c,a),n&&n.assign(g.m_nonSimpleResult),c}function Jd(t,e,i,r,a){if(r&&(r.m_reason=0,r.m_vertexIndex1=-1,r.m_vertexIndex2=-1),t.isEmpty())return 5;const h=t.getGeometryType();if(h===s.enumPoint)return sp(t,r);const u=bs(e,t,!1).total();if(h===s.enumEnvelope){const e=t,s=new ge;return e.queryEnvelope(s),s.isDegenerate(u)?(r&&(r.m_reason=4,r.m_vertexIndex1=-1,r.m_vertexIndex2=-1),0):5}if(l(h)){const s=t,n=new am({vd:s.getDescription()});return n.addSegment(s,!0),Jd(n,e,i,r,a)}b(h),o(h)||n("OGC simplify is not implemented for this geometry type");const c=[0],g=t.getImpl().getIsSimple(u,c);let _=i?-1:g;if(5===_||0===_)return _;const d=new gp(t,e,_,a,!0);h===s.enumMultiPoint||h===s.enumPolyline||h===s.enumPolygon?(_=d.isSimplePlanarImpl(),Gs(_)&&(_=5)):m("");return t.getImpl().setIsSimple(_,u),r&&r.assign(d.m_nonSimpleResult),_}function $d(t,e,i,n,r){if(n&&(n.m_reason=0,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),t.isEmpty())return 5;const o=t.getGeometryType();if(o===s.enumPoint)return sp(t,n);const a=bs(e,t,!1).total();if(o===s.enumEnvelope){const e=t,s=ge.constructEmpty();return e.queryEnvelope(s),s.isDegenerate(a)?(n&&(n.m_reason=4,n.m_vertexIndex1=-1,n.m_vertexIndex2=-1),0):5}if(l(o)){const s=t,o=new am({vd:s.getDescription()});return o.addSegment(s,!0),$d(o,e,i,n,r)}const h=[0],u=t.getImpl().getIsSimple(a,h);let c=i?-1:u;if(-1!==c)return c;const g=new gp(t,e,c,r,!1);return o===s.enumMultiPoint?c=g.multipointIsSimpleAsFeature():o===s.enumPolyline?c=g.polylineIsSimpleAsFeature():o===s.enumPolygon?c=g.polygonIsSimpleAsFeature():m(""),t.getImpl().setIsSimple(c,a),n&&n.assign(g.m_nonSimpleResult),c}function tp(t,e,i,n){if(t.isEmpty())return t;const r=t.getGeometryType();if(r===s.enumPoint){const e=new ci;if(sp(t,e),3===e.m_reason){const e=t.clone();return e.replaceNaNs(1,0),e}return 2===e.m_reason?t.createInstance():t}if(r===s.enumEnvelope){const s=bs(e,t,!0).total(),i=t,n=ge.constructEmpty();return i.queryEnvelope(n),n.isDegenerate(s)?i.createInstance():t}if(l(r)){const s=t,r=new am({vd:s.getDescription()});return r.addSegment(s,!0),tp(r,e,i,n)}b(r);const o=bs(e,t,!1).total(),a=[0],h=t.getImpl().getIsSimple(o,a),u=i?-1:h;if(Gs(u)){if(r===s.enumPolygon&&0!==t.getFillRule()){const e=t.clone();return e.setFillRule(0),e}return t}if((r===s.enumMultiPoint||r===s.enumPolyline)&&u>=1)return t;const c=new gp(t,e,u,n,!1);let g;return r===s.enumMultiPoint?g=c.multipointSimplifyAsFeature():r===s.enumPolyline?g=c.polylineSimplifyAsFeature():r===s.enumPolygon?g=c.polygonSimplifyAsFeature():m(""),g}function ep(t,e,i,r){if(t.isEmpty())return t;const a=t.getGeometryType();if(a===s.enumPoint){const e=new ci;if(sp(t,e),3===e.m_reason){const e=t.clone();return e.replaceNaNs(1,0),e}return 2===e.m_reason?t.createInstance():t}if(a===s.enumEnvelope){const s=t,i=new ge;s.queryEnvelope(i);const n=bs(e,t,!0).total();return i.isDegenerate(n)?s.createInstance():t}if(l(a)){const s=t,n=new am({vd:s.getDescription()});return n.addSegment(s,!0),ep(n,e,i,r)}b(a),o(a)||n("OGC simplify is not implemented for this geometry type");const h=bs(e,t,!1).total(),m=[0],u=t.getImpl().getIsSimple(h,m),c=i?-1:u;if(5===c){if(a===s.enumPolygon&&0!==t.getFillRule()){const e=t.clone();return e.setFillRule(0),e}return t}return Td(t,bs(e,t,!0),!1,c,r,0,!0)}function sp(t,e){const s=t.getX(),i=t.getY();if(!Number.isFinite(s)||!Number.isFinite(i))return e&&(e.m_reason=2,e.m_vertexIndex1=-1,e.m_vertexIndex2=-1),0;if(t.hasAttribute(1)){const s=t.getZ();if(!Number.isFinite(s))return e&&(e.m_reason=Number.isNaN(s)?3:2,e.m_vertexIndex1=-1,e.m_vertexIndex2=-1),0}return 5}class ip{constructor(){this.m_segment=null,this.m_vertexIndex=-1,this.m_pathIndex=-1,this.m_flags=0}setReversed(t){this.m_flags&=-2,this.m_flags=this.m_flags|(t?1:0)}getReversed(){return!!(1&this.m_flags)}getRightSide(){return this.getReversed()?0:1}}function np(){return{x:-1,y:-1,ipath:-1,ivertex:-1,ipolygon:-1}}function rp(t,e,s,i,n){return{x:t,y:e,ipath:s,ivertex:i,ipolygon:n}}function op(t,e){return t.x===e.x&&t.y===e.y&&t.ipath===e.ipath&&t.ivertex===e.ivertex&&t.ipolygon===e.ipolygon}function ap(t,e){t.x=e.x,t.y=e.y,t.ipath=e.ipath,t.ivertex=e.ivertex,t.ipolygon=e.ipolygon}function hp(){return{x:-1,y:-1,ipath:-1,ivertex:-1,bBoundary:!1,bEndPoint:!1}}function mp(t,e,s,i,n,r){return{x:t,y:e,ipath:s,ivertex:i,bBoundary:n,bEndPoint:r}}function lp(t,e){t.x=e.x,t.y=e.y,t.ipath=e.ipath,t.ivertex=e.ivertex,t.bBoundary=e.bBoundary,t.bEndPoint=e.bEndPoint}class up extends hs{constructor(t){super(),this.m_helper=t}compare(t,e,s){const i=t.getElement(s),n=this.m_helper.m_xy.read(2*e)-this.m_helper.m_xy.read(2*i);return n<0?-1:n>0?1:0}}class cp extends hs{constructor(t){super(),this.m_helper=t}compare(t,e,s){const i=t.getElement(s),n=this.m_helper.m_edges[e],r=this.m_helper.m_edges[i],o=n.getReversed(),a=r.getReversed();let h=n.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0),m=r.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0);if(h===m){const t=o?n.m_segment.getStartY():n.m_segment.getEndY(),e=a?r.m_segment.getStartY():r.m_segment.getEndY(),s=Math.min(t,e);let i=.5*(s-this.m_helper.m_yScanline)+this.m_helper.m_yScanline;i===this.m_helper.m_yScanline&&(i=s),h=n.m_segment.intersectionOfYMonotonicWithAxisX(i,0),m=r.m_segment.intersectionOfYMonotonicWithAxisX(i,0)}return h<m?-1:h>m?1:0}}class gp{constructor(t,e,s,i,n){this.m_multiVertexGeom=null,this.m_edges=[],this.m_freeEdges=[],this.m_lineEdgesRecycle=[],this.m_newEdges=[],this.m_recycledSegIter=null,this.m_crossOverHelperList=new ls,this.m_progressTracker=null,this.m_progressCounter=0,this.m_AET=new ms,this.m_xyToNode1=null,this.m_xyToNode2=null,this.m_pathOrientations=null,this.m_pathParentage=null,this.m_xy=null,this.m_pairs=[],this.m_pairIndices=null,this.m_pathsForOGCTests=[],this.m_curveStitcher=null,this.m_editShape=null,this.m_multiPathStitcher=null,this.m_nonSimpleResult=new ci,this.m_progressCounter=0,this.m_progressTracker=i,this.m_geometry=t,this.m_knownSimpleResult=s,this.m_sr=e;const r=bs(e,t,!1);this.m_toleranceIsSimple=r,this.m_toleranceIsSimpleClustering=Ts(r),this.m_toleranceIsSimpleCracking=Ns(r),this.m_toleranceSimplify=bs(e,t,!0),this.m_description=this.m_geometry.getDescription(),this.m_attributeCount=this.m_description.getAttributeCount(),this.m_bOGCRestrictions=n,this.m_bPlanarSimplify=this.m_bOGCRestrictions,this.m_unknownOrientationPathCount=-1,this.m_yScanline=0,this.m_progressCounter=0}isSimplePlanarImpl(){if(this.m_bPlanarSimplify=!0,!this.checkStructure())return 0;const t=this.m_geometry.getGeometryType();return p(t)&&!this.checkDegenerateSegments(!1)?0:this._CheckClustering()?p(t)?this._CheckCracking()?this.m_geometry.getGeometryType()===s.enumPolyline?this.checkSelfIntersectionsPolylinePlanar()?4:0:this._CheckSelfIntersections()?this._CheckValidRingOrientation():0:0:5:0}isSimplePlanarImpl3D(){return t(0),7}generateSortedPairs(t){let e=null;p(t.getGeometryType())&&(e=t);const s=(this.m_bPlanarSimplify||this.m_bOGCRestrictions)&&null!==e,i=t.getPointCount();this.m_xy=t.getAttributeStreamRef(0),this.m_pairs.length=0,this.m_pairIndices=new Qe(0),s&&(this.m_pathsForOGCTests.length=0);let n=0;for(let a=0;a<i;a++)if(this.m_pairs.push(2*a),this.m_pairs.push(2*a+1),this.m_pairIndices.add(2*a),this.m_pairIndices.add(2*a+1),s){for(;a>=e.getPathEnd(n);)n++;this.m_pathsForOGCTests.push(n)}const r=new ss,o={parent:this,workPt:new w,userSort(t,e,i){i.sort(t,e,((t,e)=>this.parent.compareVerticesForPlanarClustering(t,e,s)))},getValue(t){const e=this.parent.m_pairs[t],s=e>>1;this.parent.m_xy.queryPoint2D(2*s,this.workPt);return this.workPt.y+(1&e?this.parent.m_toleranceIsSimpleClustering:-this.parent.m_toleranceIsSimpleClustering)}};r.sort(this.m_pairIndices,0,2*i,o)}_TestToleranceDistancePlanar(t,e){const s=this.m_xy.read(2*t),i=this.m_xy.read(2*t+1),n=this.m_xy.read(2*e),r=this.m_xy.read(2*e+1);if(!!ru(s,i,n,r,this.m_toleranceIsSimpleClustering*this.m_toleranceIsSimpleClustering)){if(0===this.m_geometry.getDimension())return!1;return s===n&&i===r}return!0}checkStructure(){const t=this.m_geometry.getGeometryType();if(p(t)){const t=this.m_geometry.getImpl(),e=this.m_geometry.getGeometryType()===s.enumPolygon?3:2;for(let s=0,i=t.getPathCount();s<i;s++)if(t.getPathSize(s)<e){if(t.hasNonLinearSegments()&&t.hasNonLinearSegmentsPath(s)&&t.getPathSize(s)>0)continue;return this.m_nonSimpleResult=new ci(1,s,0),!1}}if(o(t)){const t=this.m_geometry.getImpl(),e=t.getAttributeStreamRef(0);for(let s=0,i=t.getPointCount();s<i;s++){if(!e.readPoint2D(2*s).isFinite())return this.m_nonSimpleResult=new ci(2,s,0),!1}if(this.m_geometry.hasAttribute(1)){const e=t.getAttributeStreamRef(1);for(let s=0,i=t.getPointCount();s<i;s++){const t=e.read(s);if(!Number.isFinite(t))return Number.isNaN(t)?this.m_nonSimpleResult=new ci(3,s,0):this.m_nonSimpleResult=new ci(2,s,0),!1}}}return!0}checkDegenerateSegments(t){const e=this.m_geometry.getImpl(),s=e.querySegmentIterator(),i=e.hasAttribute(1),n=i?vs(this.m_sr,e,!1).total():0,r=e.hasNonLinearSegments(),o=this.m_toleranceIsSimple.total();for(;s.nextPath();)for(;s.hasNextSegment();){const e=s.nextSegment();let a=e.calculateLowerLength2D();if(!(a>o)&&!(r&&e.isCurve()&&(a=e.calculateLength2D(),a>o))){if(t&&i){const t=e.getStartAttributeAsDbl(1,0),s=e.getEndAttributeAsDbl(1,0);if(Math.abs(s-t)>n)continue}return this.m_nonSimpleResult=new ci(4,s.getStartPointIndex(),-1),!1}}return!0}checkDegenerateSegments3D(){return t(0),!1}_CheckClustering(){const t=this.m_geometry.getImpl();this.generateSortedPairs(t);const e=t.getPointCount();this.m_AET.clear(),this.m_AET.setComparator(new up(this)),this.m_AET.setCapacity(e);for(let s=0,i=2*e;s<i;s++){this.progress_();const t=this.m_pairIndices.read(s),e=this.m_pairs[t],i=e>>1;if(1&e){const t=this.m_AET.search(i),e=this.m_AET.getPrev(t),s=this.m_AET.getNext(t);if(this.m_AET.deleteNode(t),e!==ms.st_nullNode()&&s!==ms.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(e),this.m_AET.getElement(s)))return this.m_nonSimpleResult=new ci(5,this.m_AET.getElement(e),this.m_AET.getElement(s)),!1}else{const t=this.m_AET.addElement(i),e=this.m_AET.getPrev(t);if(e!==ms.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(e),i))return this.m_nonSimpleResult=new ci(5,i,this.m_AET.getElement(e)),!1;const s=this.m_AET.getNext(t);if(s!==ms.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(s),i))return this.m_nonSimpleResult=new ci(5,i,this.m_AET.getElement(s)),!1}}return!0}_CheckCracking(){const t=this.m_geometry.getImpl(),e=t.getPointCount();return!t.hasNonLinearSegments()&&e<10?this._CheckCrackingBrute():this._CheckCrackingPlanesweep()}_CheckCrackingPlanesweep(){if(this.m_editShape=new Vm,this.m_editShape.addGeometry(this.m_geometry),this.m_editShape.hasCurves()){this.m_curveStitcher=new ld;const t=ge.constructEmpty();this.m_geometry.queryEnvelope(t);const e=ad(this.m_toleranceSimplify.total(),t),s=new ci;if(nd(this.m_editShape,e,this.m_toleranceSimplify.total(),12e3,s,this.m_curveStitcher,null,this.m_progressTracker),0!==s.m_reason)return this.m_editShape=null,this.m_nonSimpleResult.assign(s),!1}const t=new ci;return qu(!1,this.m_editShape,this.m_toleranceIsSimpleCracking,t,this.m_progressTracker)?(null!=this.m_curveStitcher?(t.m_vertexIndex1=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,t.m_vertexIndex1),t.m_vertexIndex2=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,t.m_vertexIndex2),this.m_curveStitcher=null):(t.m_vertexIndex1=this.m_editShape.getVertexIndex(t.m_vertexIndex1),t.m_vertexIndex2=this.m_editShape.getVertexIndex(t.m_vertexIndex2)),this.m_editShape=null,this.m_nonSimpleResult.assign(t),!1):(null==this.m_curveStitcher&&(this.m_editShape=null),!0)}_CheckCrackingBrute(){const t=this.m_geometry.getImpl(),e=t.querySegmentIterator(),s=t.querySegmentIterator();for(;e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(!e.isLastSegmentInPath()||!e.isLastPath()){s.resetTo(e);do{for(;s.hasNextSegment();){const i=uE(!0,t,s.nextSegment(),this.m_toleranceIsSimpleCracking,!0);if(i){const t=2===i?7:6;return this.m_nonSimpleResult=new ci(t,e.getStartPointIndex(),s.getStartPointIndex()),!1}}}while(s.nextPath())}}return!0}_CheckSelfIntersections(){let t=this.m_geometry.getImpl();null!==this.m_curveStitcher&&(this.m_multiPathStitcher=this.m_editShape.getGeometry(this.m_editShape.getFirstGeometry()),t=this.m_multiPathStitcher.getImpl(),this.generateSortedPairs(t)),this.m_edges.length=0,this.m_lineEdgesRecycle.length=0,this.m_recycledSegIter=t.querySegmentIterator(),this.m_recycledSegIter.setCirculator(!0);const e=new Array(0),s=t.getPointCount();let i=Number.NaN,n=0;for(let r=0,o=2*s;r<o;r++){this.progress_();const t=this.m_pairIndices.read(r),s=this.m_pairs[t];if(1&s)continue;const o=s>>1,a=this.m_xy.read(2*o),h=this.m_xy.read(2*o+1);if(e.length&&(a!==i||h!==n)){if(!this.processBunchForSelfIntersectionTest(e))return!1;e.length=0}e.push(o),i=a,n=h}return!!this.processBunchForSelfIntersectionTest(e)}checkSelfIntersectionsPolylinePlanar(){const t=this.m_geometry.getImpl(),e=[];for(let o=0,a=t.getPathCount();o<a;o++)e.push(t.isClosedPathInXYPlane(o));const s=hp();let i,n,r;{const o=this.m_pairIndices.read(0),a=this.m_pairs[o]>>1,h=this.m_xy.readPoint2D(2*a),m=this.m_pathsForOGCTests[a];i=e[m],n=t.getPathStart(m),r=t.getPathEnd(m)-1,s.bEndPoint=a===n||a===r,this.m_bOGCRestrictions?s.bBoundary=!i&&s.bEndPoint:s.bBoundary=s.bEndPoint,s.ipath=m,s.x=h.x,s.y=h.y,s.ivertex=a}for(let o=1,a=this.m_pairIndices.size();o<a;o++){const a=this.m_pairIndices.read(o),h=this.m_pairs[a];if(1&h)continue;const m=h>>1,l=this.m_xy.readPoint2D(2*m),u=this.m_pathsForOGCTests[m];let c;u!==s.ipath&&(i=e[u],n=t.getPathStart(u),r=t.getPathEnd(u)-1);const g=m===n||m===r;c=this.m_bOGCRestrictions?!i&&g:g;const _=mp(l.x,l.y,u,m,c,g);if(_.x===s.x&&_.y===s.y)if(this.m_bOGCRestrictions){if(!(_.bBoundary&&s.bBoundary||_.ipath===s.ipath&&_.bEndPoint&&s.bEndPoint))return this.m_nonSimpleResult=new ci(10,_.ivertex,s.ivertex),!1}else if(!_.bEndPoint||!s.bEndPoint)return this.m_nonSimpleResult=new ci(7,_.ivertex,s.ivertex),!1;lp(s,_)}return!0}checkSelfIntersectionsPolylinePlanar3D(e){return t(0),!1}checkSelfIntersectionsPolygonsOGC(){const t=this.m_geometry.getImpl(),e=[];let s=-1,i=!1;for(let l=0,u=t.getPathCount();l<u;l++)t.isExteriorRingOGC(l)&&(i=!1,s++,l<u-1&&(t.isExteriorRingOGC(l+1)||(i=!0))),e.push(i?s:-1);const n=np();{const t=this.m_pairIndices.read(0),s=this.m_pairs[t]>>1,i=this.m_xy.readPoint2D(2*s),r=this.m_pathsForOGCTests[s];n.ipath=r,n.x=i.x,n.y=i.y,n.ivertex=s,n.ipolygon=e[r]}const r=[];for(let l=1,u=this.m_pairIndices.size();l<u;l++){const t=this.m_pairIndices.read(l),s=this.m_pairs[t];if(1&s)continue;const i=s>>1,o=this.m_xy.readPoint2D(2*i),a=this.m_pathsForOGCTests[i],h=rp(o.x,o.y,a,i,e[a]);if(h.x===n.x&&h.y===n.y){if(h.ipath===n.ipath)return this.m_nonSimpleResult=new ci(11,h.ivertex,n.ivertex),!1;e[h.ipath]>=0&&e[h.ipath]===e[n.ipath]&&(0!==r.length&&op(r.at(-1),n)||r.push({...n}),r.push(h))}ap(n,h)}if(0===r.length)return!0;const o=new ls(!0);e.fill(-1);let a=-1;const h=new w;for(let l=0,u=r.length;l<u;l++){const t=r[l];t.x===h.x&&t.y===h.y||(a=o.createList(0),h.x=t.x,h.y=t.y);let s=e[t.ipath];-1===s&&(s=o.createList(2),e[t.ipath]=s),o.addElement(s,a),o.addElement(a,s)}const m=[];for(let l=o.getFirstList();-1!==l;l=o.getNextList(l)){const t=o.getListData(l);if(1&t||!(2&t))continue;let s=-1;for(m.push(l),m.push(-1);m.length;){const t=m.at(-1);m.pop();const e=m.at(-1);m.pop();const i=o.getListData(e);if(1&i){s=2&i?e:t;break}o.setListData(e,1|i);for(let s=o.getFirst(e);-1!==s;s=o.getNext(s)){const i=o.getData(s);i!==t&&(m.push(i),m.push(e))}}if(-1!==s){const t=e.indexOf(s);return this.m_nonSimpleResult=new ci(12,t,-1),!1}}return!0}_CheckValidRingOrientation(){const t=null!==this.m_multiPathStitcher?this.m_multiPathStitcher.getImpl():this.m_geometry.getImpl();if(t.calculateArea2D()<=0)return this.m_nonSimpleResult=new ci(8,1===t.getPathCount()?1:-1,-1),0;if(1===t.getPathCount())return this.m_bOGCRestrictions&&!this.checkSelfIntersectionsPolygonsOGC()?0:4;this.m_pathOrientations=new Ze(t.getPathCount(),0),this.m_pathParentage=new Qe(t.getPathCount(),-1);let e=-1,s=0;for(let r=0,o=t.getPathCount();r<o;r++){const i=t.calculateRingArea2D(r);if(this.m_pathOrientations.write(r,i<0?0:8),i>0)e=r,s=i;else{if(0===i)return this.m_nonSimpleResult=new ci(8,r,-1),0;if((e<0||s<Math.abs(i))&&(this.m_nonSimpleResult=new ci(9,r,-1),this.m_bOGCRestrictions))return 0;this.m_pathParentage.write(r,e)}}this.m_unknownOrientationPathCount=t.getPathCount(),this.m_newEdges.length=0;const i=t.getPointCount();this.m_yScanline=Number.NaN;const n=[];this.m_xyToNode1=new Qe(i,ms.st_nullNode()),this.m_xyToNode2=new Qe(i,ms.st_nullNode()),this.m_freeEdges.length=0,this.m_AET.clear(),this.m_AET.setComparator(new cp(this));for(let r=0,o=2*i;this.m_unknownOrientationPathCount>0&&r<o;r++){const t=this.m_pairIndices.read(r),e=this.m_pairs[t];if(1&e)continue;const s=e>>1,i=this.m_xy.read(2*s+1);if(i!==this.m_yScanline&&n.length){if(!this.processBunchForRingOrientationTest(n))return 0;n.length=0}n.push(s),this.m_yScanline=i}return this.m_unknownOrientationPathCount>0&&!this.processBunchForRingOrientationTest(n)?0:this.m_bOGCRestrictions?0!==this.m_nonSimpleResult.m_reason?0:this.checkSelfIntersectionsPolygonsOGC()?5:0:0===this.m_nonSimpleResult.m_reason?4:3}processBunchForSelfIntersectionTest(t){if(1===t.length)return!0;for(let o=0,a=t.length;o<a;o++){const e=t[o];this.m_recycledSegIter.resetToVertex(e,-1);const s=this.m_recycledSegIter.previousSegment();this.m_edges.push(this.createEdge(s,e,this.m_recycledSegIter.getPathIndex(),!0)),this.m_recycledSegIter.nextSegment();const i=this.m_recycledSegIter.nextSegment();this.m_edges.push(this.createEdge(i,e,this.m_recycledSegIter.getPathIndex(),!1))}this.m_edges.sort(((t,e)=>this.edgeAngleCompare(t,e)));let e=this.m_crossOverHelperList.getFirstList();-1===e&&(e=this.m_crossOverHelperList.createList(0)),this.m_crossOverHelperList.reserveNodes(this.m_edges.length);for(let o=0,a=this.m_edges.length;o<a;o++)this.m_crossOverHelperList.addElement(e,o);let s=!0,i=-1,n=-1;for(;s;){s=!1;let t=this.m_crossOverHelperList.getFirst(e);if(-1===t)break;let r=this.m_crossOverHelperList.getNext(t);for(;-1!==r;){const o=this.m_crossOverHelperList.getData(t),a=this.m_crossOverHelperList.getData(r);if(i=this.m_edges[o].m_vertexIndex,n=this.m_edges[a].m_vertexIndex,i!==n)t=r,r=this.m_crossOverHelperList.getNext(t);else if(s=!0,this.m_crossOverHelperList.deleteElement(e,t),t=this.m_crossOverHelperList.getPrev(r),r=this.m_crossOverHelperList.deleteElement(e,r),-1===r||-1===t)break}}const r=this.m_crossOverHelperList.getListSize(e);if(this.m_crossOverHelperList.clear(e),r>0)return this.m_nonSimpleResult=new ci(7,i,n),!1;for(let o=0,a=t.length;o<a;o++)this.recycleEdge(this.m_edges[o]);return this.m_edges.length=0,!0}processBunchForRingOrientationTest(t){for(let e=0,s=t.length;e<s;e++){const s=t[e];let i=this.m_xyToNode1.read(s);if(i!==ms.st_nullNode()){const t=this.m_AET.getElement(i);this.m_freeEdges.push(t),this.m_AET.deleteNode(i),this.recycleEdge(this.m_edges[t]),this.m_edges[t]=null,this.m_xyToNode1.write(s,ms.st_nullNode())}if(i=this.m_xyToNode2.read(s),i!==ms.st_nullNode()){const t=this.m_AET.getElement(i);this.m_freeEdges.push(t),this.m_AET.deleteNode(i),this.recycleEdge(this.m_edges[t]),this.m_edges[t]=null,this.m_xyToNode2.write(s,ms.st_nullNode())}}for(let e=0,s=t.length;e<s;e++){const s=t[e];this.m_recycledSegIter.resetToVertex(s,-1);const i=this.m_recycledSegIter.previousSegment();if(i.getStartY()>i.getEndY()){const t=this.m_recycledSegIter.getStartPointIndex(),e=this.createEdge(i,s,this.m_recycledSegIter.getPathIndex(),!0);let n;this.m_freeEdges.length>0?(n=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[n]=e):(n=this.m_edges.length,this.m_edges.push(e));const r=this.m_AET.addElement(n);this.m_xyToNode1.read(t)===ms.st_nullNode()?this.m_xyToNode1.write(t,r):this.m_xyToNode2.write(t,r),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(r)}this.m_recycledSegIter.nextSegment();const n=this.m_recycledSegIter.nextSegment();if(n.getStartY()<n.getEndY()){const t=this.m_recycledSegIter.getEndPointIndex(),e=this.createEdge(n,s,this.m_recycledSegIter.getPathIndex(),!1);let i;this.m_freeEdges.length>0?(i=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[i]=e):(i=this.m_edges.length,this.m_edges.push(e));const r=this.m_AET.addElement(i);this.m_xyToNode1.read(t)===ms.st_nullNode()?this.m_xyToNode1.write(t,r):this.m_xyToNode2.write(t,r),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(r)}}for(let e=0,s=this.m_newEdges.length;e<s&&this.m_unknownOrientationPathCount>0;e++){const t=this.m_newEdges[e],s=this.m_AET.getElement(t),i=this.m_edges[s].m_pathIndex;if(!(3&this.m_pathOrientations.read(i))){let e=-1,s=this.m_AET.getPrev(t),i=t,n=0;{let t=-1,r=null,o=-1,a=0;for(;s!==ms.st_nullNode()&&(t=this.m_AET.getElement(s),r=this.m_edges[t],o=r.m_pathIndex,a=this.m_pathOrientations.read(o),!(3&a));)i=s,s=this.m_AET.getPrev(s);s===ms.st_nullNode()?(n=1,s=i):(e=1==(3&a)?o:this.m_pathParentage.read(o),n=r.getRightSide()?0:1,s=this.m_AET.getNext(s))}do{const t=this.m_AET.getElement(s),r=this.m_edges[t],o=r.m_pathIndex;let a=this.m_pathOrientations.read(o);if(!(3&a)){if(n!==r.getRightSide())return this.m_nonSimpleResult=new ci(8,o,-1),!1;const t=n&&!r.getReversed()?1:2;if(a=-4&a|t,this.m_pathOrientations.write(o,a),2===t&&0===this.m_nonSimpleResult.m_reason){const t=this.m_pathParentage.read(o);if(t!==e&&(this.m_nonSimpleResult=new ci(9,o,t),this.m_bOGCRestrictions))return!1}if(this.m_unknownOrientationPathCount--,!this.m_unknownOrientationPathCount)return!0}e=1==(3&a)?o:this.m_pathParentage.read(o),i=s,s=this.m_AET.getNext(s),n=n?0:1}while(i!==t)}}return this.m_newEdges.length=0,!0}createEdge(t,e,i,n){let r;return t.getGeometryType()===s.enumLine?r=this.createEdgeLine(t):(r=new ip,r.m_segment=t.clone()),r.m_vertexIndex=e,r.m_pathIndex=i,r.m_flags=0,r.setReversed(n),r}createEdgeLine(t){let e;return this.m_lineEdgesRecycle.length>0?(e=this.m_lineEdgesRecycle.at(-1),this.m_lineEdgesRecycle.pop(),t.copyTo(e.m_segment)):(e=new ip,e.m_segment=t.clone()),e}recycleEdge(t){t.m_segment.getGeometryType()===s.enumLine&&this.m_lineEdgesRecycle.push(t)}static isShortSegment(t,e,s,i){let n=t.calculateLowerLength2D();if(n<=s){let r=!0;if(t.isCurve()&&(n=t.calculateLength2D(),r=n<=s),r){if(e){let e=t.getEndAttributeAsDbl(1,0);Number.isNaN(e)&&(e=0);let s=t.getStartAttributeAsDbl(1,0);return Number.isNaN(s)&&(s=0),Math.abs(s-e)<=i}return!0}return!1}return!1}static isShortSegmentPoints(t,e,s,i,n){if(s){return Ms(t.getXYZ(),e.getXYZ(),i,n)}{const s=t.getXY(),n=e.getXY();return w.sqrDistance(s,n)<=i*i}}removeDegenerateSegmentsFromCurvedPath(e,s,i,n){const r=e.hasAttribute(1),o=e.querySegmentIterator();o.resetToPath(s),t(o.nextPath());const a=this.m_toleranceSimplify.total();let h=!1,m=!0;const l=new Ge,u=new Ge,c=new w;for(;o.hasNextSegment();){this.progress_();const t=o.nextSegment();if(gp.isShortSegment(t,r,a,i))if(h){if(t.queryEnd(u),gp.isShortSegmentPoints(l,u,r,a,i))continue;m&&(n.startPathPoint(l),m=!1),t.queryEnd(l),n.lineToPoint(l),h=!1}else c.assign(t.getStartXY()),t.queryStart(l),h=!0;else if(h)if(t.isCurve()){const e=t.clone();if(e.setCoordsForIntersector(c,t.getEndXY(),!1),e.setStart(l),gp.isShortSegment(e,r,a,i))continue;n.addSegment(e,m),m=!1,h=!1}else{if(t.queryEnd(u),gp.isShortSegmentPoints(l,u,r,a,i))continue;m&&(n.startPathPoint(l),m=!1),n.lineToPoint(u),h=!1}else n.addSegment(t,m),m=!1}if(m)return;if(!h)return;e.isClosedPath(s)?e.getPointByVal(e.getPathStart(s),l):e.getPointByVal(e.getPathEnd(s)-1,l);const g=n.querySegmentIterator();g.resetToLastPath(),g.resetToLastSegment();const _=n.getDescription().getAttributeCount()>1;for(t(g.previousPath());g.hasPreviousSegment();){const t=g.previousSegment();if(t.isCurve()){const e=t.clone();if(e.setCoordsForIntersector(t.getStartXY(),l.getXY(),!1),!gp.isShortSegment(e,r,a,i)){_&&e.setEnd(l);const t=g.getEndPointIndex();for(let e=n.getPointCount()-1;e>=t;e--)n.removePoint(e);return void n.addSegment(e,!1)}}else if(t.queryStart(u),!gp.isShortSegmentPoints(u,l,r,a,i)){const t=g.getEndPointIndex();for(let e=n.getPointCount()-1;e>=t;e--)n.removePoint(e);return void n.lineToPoint(l)}}n.removePath(n.getPathCount()-1)}multipointIsSimpleAsFeature(){if(!this.checkStructure())return 0;const t=this.m_geometry.getImpl();this.m_multiVertexGeom=t;const e=t.getPointCount(),s=new Array(e);for(let i=0;i<e;i++)s[i]=i;s.sort(((t,e)=>this.compareVerticesMultiPoint(t,e)));for(let i=1;i<e;i++)if(0===this.compareVerticesMultiPoint(s[i-1],s[i]))return this.m_nonSimpleResult=new ci(5,s[i-1],s[i]),0;return 1}polylineIsSimpleAsFeature(){return this.checkStructure()&&this.checkDegenerateSegments(!0)?1:0}polygonIsSimpleAsFeature(){return this.isSimplePlanarImpl()}multipointSimplifyAsFeature(){let t=this.m_geometry.getImpl();const e=gp.hasNanZs(t);let s,i=this.m_geometry;e&&(s=this.m_geometry.clone(),t=s.getImpl(),s.replaceNaNs(1,Ce.getDefaultValue(1)),i=s),this.m_multiVertexGeom=t;const n=t.getPointCount(),r=new Array(n);for(let u=0;u<n;u++)r[u]=u;r.sort(((t,e)=>this.compareVerticesMultiPoint(t,e)));const o=new Array(n);o.fill(!1);let a=-1;for(let u=0;u<n;u++){const e=r[u];t.getXY(e).isFinite()&&((a<0||0!==this.compareVerticesMultiPoint(a,e))&&(o[e]=!0),a=e)}const h=this.m_geometry.createInstance();let m=0,l=0;for(let u=0;u<n;u++)o[u]?l=u+1:(m<l&&h.addPoints(i,m,l),m=u+1);return m<l&&h.addPoints(i,m,l),h.getImpl().setIsSimple(1,this.m_toleranceSimplify.total()),h}polylineSimplifyAsFeature(){const t=this.m_geometry.getImpl(),e=t.querySegmentIterator(),s=t.querySegmentIterator(),i=this.m_geometry.createInstance(),n=this.m_geometry,r=t.hasAttribute(1),o=r?vs(this.m_sr,t,!0).total():0,a=[],h=[];let m=null;r&&(m=t.getAttributeStreamRef(1));const l=new Ge,u=t.hasNonLinearSegments(),c=this.m_toleranceSimplify.total();for(;e.nextPath();){if(s.nextPath(),t.getPathSize(e.getPathIndex())<2)continue;if(u&&t.hasNonLinearSegmentsPath(e.getPathIndex())){this.removeDegenerateSegmentsFromCurvedPath(t,e.getPathIndex(),o,i);continue}s.resetToLastSegment();let g=0,_=0,d=!0,p=!0;for(;e.hasNextSegment();){this.progress_();const i=e.nextSegment(),n=s.previousSegment();if(e.getStartPointIndex()>s.getStartPointIndex())break;if(d){const s=e.getStartPointIndex();t.getXY(s).isNAN()||(d=!1,a.push(s))}if(p){const e=s.getEndPointIndex();t.getXY(e).isNAN()||(h.push(e),p=!1)}if(!d){const s=a.at(-1),n=e.getEndPointIndex();if(n-s>1){const e=new w;e.setSub(t.getXY(s),t.getXY(n)),g=e.length()}else g=i.calculateLength2D();if(g>c)a.push(n),g=0;else if(r){let t=m.read(s);Number.isNaN(t)&&(t=0);let e=m.read(n);Number.isNaN(e)&&(e=0),Math.abs(e-t)>o&&(a.push(n),g=0)}}if(!p){const e=h.at(-1),i=s.getStartPointIndex();if(i-e>1){const s=new w;s.setSub(t.getXY(e),t.getXY(i)),_=s.length()}else _=n.calculateLength2D();if(_>c)h.push(i),_=0;else if(r){let t=m.read(e);Number.isNaN(t)&&(t=0);let s=m.read(i);Number.isNaN(s)&&(s=0),Math.abs(s-t)>o&&(h.push(i),_=0)}}}if(a.length>0&&h.length>0&&(a.at(-1)<h.at(-1)?a.length>h.length?a.pop():h.pop():(a.at(-1)===h.at(-1)||h.pop(),h.pop())),h.length+a.length>=2){let t=!1;for(let e=0,s=a.length;e<s;e++)n.getPointByVal(a[e],l),t?i.lineToPoint(l):(i.startPathPoint(l),t=!0);for(let e=h.length-1;e>0;e--)n.getPointByVal(h[e],l),t?i.lineToPoint(l):(i.startPathPoint(l),t=!0);n.isClosedPath(e.getPathIndex())?i.closePathWithLine():h.length>0&&(n.getPointByVal(h[0],l),i.lineToPoint(l))}a.length=0,h.length=0}return r&&i.replaceNaNs(1,0),i.getImpl().setIsSimple(1,c),i}polygonSimplifyAsFeature(){return this.simplifyPlanar()}simplifyPlanar(){if(1===this.m_geometry.getFillRule()&&!As(this.m_knownSimpleResult))return Nd(this.m_geometry,this.m_toleranceSimplify,!0,!1,this.m_knownSimpleResult,this.m_progressTracker,0,!0);const t=new Vm;if(t.addGeometry(this.m_geometry),this.m_geometry.hasAttribute(1)&&t.replaceNaNs(1,0),t.removeNaNVertices(),0!==t.getTotalPointCount()){let e=null,i=0,n=0;if(t.hasCurves()){e=new ld;const s=ge.constructEmpty();this.m_geometry.queryEnvelope(s);const r=ad(this.m_toleranceSimplify.total(),s);i=hd(this.m_toleranceSimplify.total()),n=md(r,i),ed(t,r,this.m_toleranceSimplify.total(),12e3,e,null,this.m_progressTracker)}if(!As(this.m_knownSimpleResult)){cd(t,this.m_toleranceSimplify.add(n),this.m_progressTracker,!0,!1)}this.m_geometry.getGeometryType()===s.enumPolygon&&Zu(t,t.getFirstGeometry(),this.m_knownSimpleResult,!1,-1,this.m_progressTracker),null!==e&&e.stitchCurves(t,t.getFirstGeometry(),i,!0)}const e=t.getGeometry(t.getFirstGeometry());return e.getGeometryType()===s.enumPolygon&&(e.getImpl().updateOGCFlagsProtected(),e.setFillRule(0)),e.getImpl().setIsSimple(4,this.m_toleranceSimplify.total()),e}progress_(){}static hasNanZs(t){if(t.hasAttribute(1)){const e=t.getAttributeStreamRef(1);for(let s=0,i=t.getPointCount();s<i;s++){const t=e.read(s);if(Number.isNaN(t))return!0}}return!1}compareVerticesForPlanarClustering(t,e,s){if(t===e)return 0;const i=this.m_pairs[t],n=this.m_pairs[e],r=i>>1,o=n>>1,a=this.m_xy.readPoint2D(2*r);a.y+=1&i?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const h=this.m_xy.readPoint2D(2*o);h.y+=1&n?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const m=a.compare(h);if(0===m&&s){const t=this.m_pathsForOGCTests[r]-this.m_pathsForOGCTests[o];return Q(t)}return m}compareVerticesMultiPoint(t,e){if(t===e)return 0;const s=this.m_multiVertexGeom.getXY(t),i=this.m_multiVertexGeom.getXY(e),n=!s.isFinite(),r=!i.isFinite();if(n||r)return n<r?-1:n>r?1:0;if(s.y<i.y)return-1;if(s.y>i.y)return 1;if(s.x<i.x)return-1;if(s.x>i.x)return 1;for(let o=1;o<this.m_attributeCount;o++){const s=this.m_description.getSemantics(o),i=Ce.getComponentCount(s);for(let n=0;n<i;n++){const i=this.m_multiVertexGeom.getAttributeAsDbl(s,t,n),r=this.m_multiVertexGeom.getAttributeAsDbl(s,e,n),o=Lt(i,r);if(0!==o)return o}}return 0}edgeAngleCompare(t,e){if(t===e)return 0;const s=t.m_segment.getTangent(t.getReversed()?1:0);t.getReversed()&&s.negateThis();const i=e.m_segment.getTangent(e.getReversed()?1:0);e.getReversed()&&i.negateThis();const n=s.getQuarter(),r=i.getQuarter();if(r===n){const t=s.crossProduct(i);return t<0?1:t>0?-1:0}return n<r?-1:1}}class _p{getOperatorType(){return 10103}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}isSimpleAsFeature(t,e,s,i,n){const r=$d(t,e,s,i,n);return Vs(t.getGeometryType(),r)}isSimplePlanarDONOTUSE(t,e,s,i,n){return Gs(Kd(t,e,s,i,n))}executeMany(t,e,s,i){return new dp(t,e,s,i)}execute(t,e,s,i){const n=new ce([t]),r=this.executeMany(n,e,s,i).next();return r||m("null geometry"),r}}class dp extends ue{constructor(t,e,s,i){super(),this.m_progressTracker=i,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=t,this.m_spatialReference=e}next(){const t=this.m_inputGeometryCursor.next();return t?(this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(t)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(t){if(t||e(""),t.getGeometryType()===s.enumGeometryCollection){const e=ui(t,-1),s=(new _p).executeMany(e,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker),i=t.createInstance();for(let t=s.next();null!=t;t=s.next())i.addGeometry(t);return i}return tp(t,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}class pp{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,i){return new fp(t,e,s,i)}execute(t,e,s,i){return xp(t,e,s,i)}}class fp extends ue{constructor(t,s,i,n){super(),this.m_progressTracker=n,this.m_index=-1,t||e(""),this.m_envelope=s,this.m_inputGeometryCursor=t,this.m_spatialRefImpl=i,this.m_tolerance=Cs(i,s,!1).total()}next(){let t;return(t=this.m_inputGeometryCursor.next())?(g(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),dl(t,this.m_envelope,this.m_tolerance,0,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}function xp(t,e,s,i){return pl(t,e,s,Number.NaN,0,i)}function yp(t,e,i){const n=new ge;t.queryEnvelope(n);const r=new ge;e.queryEnvelope(r);const o=new ge(r);if(o.inflate(2*i),!o.isIntersecting(n))return 4;const a=t.getGeometryType(),h=e.getGeometryType();if(a===s.enumEnvelope&&n.containsEnvelope(o))return 1;if(h===s.enumEnvelope){const t=new ge(n);if(t.inflate(2*i),r.containsEnvelope(t))return 2}return 0}class Pp{constructor(t,e,i,n){this.m_intersectorGeom=null,this.m_sr=null,this.m_dimensionMask=-1,this.m_progressTracker=null,this.m_intersectorGeomType=s.enumUnknown,this.m_geomIntersectorEmptyGeom=null,this.m_intersectorGeom=t,this.m_sr=e,this.m_dimensionMask=i,this.m_progressTracker=n,this.m_intersectorGeomType=t.getGeometryType()}intersect(t){const e=this.tryFastImplementation(t);if(null!==e)return e;const s=Ps(this.m_intersectorGeom,t),i=Cs(this.m_sr,s,!0).total(),n=ge.constructEmpty();this.m_intersectorGeom.queryEnvelope(n);const r=ge.constructEmpty();t.queryEnvelope(r),n.inflateCoords(2*i,2*i),n.intersect(r),n.inflateCoords(100*i,100*i);const o=0;let a=dl(this.m_intersectorGeom,n,o,0,this.m_progressTracker),h=dl(t,n,o,0,this.m_progressTracker);return t.getDimension()>this.m_intersectorGeom.getDimension()&&(a=q(h,h=a)),kd(h,a,this.m_sr,this.m_progressTracker)}intersectEx(t){const e=this.tryFastImplementation(t);if(null!==e){const s=[];return s.length=3,s[e.getDimension()]=e,this.prepareVector(t.getDescription(),this.m_dimensionMask,s)}const s=Ps(this.m_intersectorGeom,t),i=Cs(this.m_sr,s,!0).total(),n=ge.constructEmpty();this.m_intersectorGeom.queryEnvelope(n);const r=ge.constructEmpty();t.queryEnvelope(r),n.inflateCoords(2*i,2*i),n.intersect(r),n.inflateCoords(100*i,100*i);const o=0;let a=dl(this.m_intersectorGeom,n,o,0,this.m_progressTracker),h=dl(t,n,o,0,this.m_progressTracker);t.getDimension()>this.m_intersectorGeom.getDimension()&&(a=q(h,h=a));const m=Rd(h,a,this.m_sr,this.m_progressTracker);return this.prepareVector(t.getDescription(),this.m_dimensionMask,m)}init(e,s,i,n=null){t(0)}static intersectPoints(t,e,s){return Xd(t,e,Cs(s,Ps(t,e),!0))}tryFastImplementation(t){const e=t.getGeometryType();if(this.m_intersectorGeomType===s.enumPoint&&e===s.enumPoint){const e=Pp.intersectPoints(t,this.m_intersectorGeom,this.m_sr);if(-1!==this.m_dimensionMask){const t=new ii({vd:e.getDescription()});return e.isEmpty()||t.add(e),t}return e}if(e===s.enumEnvelope&&this.m_intersectorGeomType===s.enumEnvelope&&(-1===this.m_dimensionMask||4===this.m_dimensionMask)){const e=t,s=this.m_intersectorGeom,i=new ke({copy:e});return i.intersect(s),i}const i=Ps(t,this.m_intersectorGeom),n=Cs(this.m_sr,i,!0),r=t.isEmpty(),o=this.m_intersectorGeom.isEmpty();let a=r||o;if(!a){const e=yp(this.m_intersectorGeom,t,n.total());if(4===e)a=!0;else{if(2&e)return this.m_intersectorGeom;if(1&e)return t}}if(a){const i=P(e),n=P(this.m_intersectorGeomType);return i<n?Pp.ReturnEmpty(t,r):i>n||0===i&&e===s.enumMultiPoint&&this.m_intersectorGeomType===s.enumPoint?this.ReturnEmptyIntersector():Pp.ReturnEmpty(t,r)}if(e===s.enumEnvelope&&0===P(this.m_intersectorGeomType)||this.m_intersectorGeomType===s.enumEnvelope&&0===P(e)){const i=e===s.enumEnvelope?t:this.m_intersectorGeom,r=e===s.enumEnvelope?this.m_intersectorGeom:t,o=ge.constructEmpty();return i.queryEnvelope(o),dl(r,o,n.total(),0,this.m_progressTracker)}if(0===P(e)&&P(this.m_intersectorGeomType)>0||P(e)>0&&0===P(this.m_intersectorGeomType)){if(e===s.enumMultiPoint)return Md(t,this.m_intersectorGeom,n);if(e===s.enumPoint)return Yd(t,this.m_intersectorGeom,n);if(this.m_intersectorGeomType===s.enumMultiPoint)return Md(this.m_intersectorGeom,t,n);if(this.m_intersectorGeomType===s.enumPoint)return Yd(this.m_intersectorGeom,t,n);m("")}return null}tryFastIntersectPolylinePolygon(e,s){return t(0),{}}AnalyseClipSegment(e,s,i){return t(0),0}AnalyseClipSegmenPt(e,s,i){return t(0),0}ReturnEmptyIntersector(){return null===this.m_geomIntersectorEmptyGeom&&(this.m_geomIntersectorEmptyGeom=this.m_intersectorGeom.createInstance()),this.m_geomIntersectorEmptyGeom}static ReturnEmpty(t,e){return e?t:t.createInstance()}prepareVector(t,e,s){let i=0;return 1&e?(s[0]||(s[0]=new ii({vd:t})),i++):s.shift(),2&e?(s[i]||(s[i]=new am({vd:t})),i++):s.splice(i,1),4&e?s[i]||(s[i]=new Sm({vd:t})):s.splice(i,1),new ce(s)}}class Ep extends ue{constructor(t,s,i,n,r){super(),this.m_smallCursor=null,this.m_progressTracker=n,this.m_geomIntersector=s.next(),this.m_intersector=new Pp(this.m_geomIntersector,i,r,n),this.m_index=-1,this.m_inputGeoms=t,this.m_dimensionMask=r,-1!==this.m_dimensionMask&&(this.m_dimensionMask<=0||this.m_dimensionMask>7)&&e("bad dimension mask")}next(){if(!this.m_geomIntersector)return null;let t;if(null!==this.m_smallCursor){if(t=this.m_smallCursor.next(),t)return t;this.m_smallCursor=null}for(;t=this.m_inputGeoms.next();){if(g(t),this.m_index=this.m_inputGeoms.getGeometryID(),-1===this.m_dimensionMask){return this.m_intersector.intersect(t)}this.m_smallCursor=this.m_intersector.intersectEx(t);return this.m_smallCursor.next()}return null}getGeometryID(){return t(0),0}tock(){return t(0),!1}getRank(){return t(0),0}}class Cp{getOperatorType(){return 1e4}accelerateGeometry(t,e,i){if(!this.canAccelerateGeometry(t))return!1;bs(e,t,!0);let n=0;return t.getGeometryType()!==s.enumPolygon&&t.getGeometryType()!==s.enumPolyline||!gn(t)||0===i||(n|=t.getImpl().buildQuadTreeAccelerator(i)?1:0),!!n}canAccelerateGeometry(t){return gn(t)}supportsCurves(){return!0}executeMany(t,e,s,i,n=-1){return new Ep(t,e,s,i,n)}execute(t,e,i,n){if(t.getGeometryType()===s.enumPoint&&e.getGeometryType()===s.enumPoint)return Pp.intersectPoints(t,e,i);const r=new ce([t]),o=new ce([e]),a=this.executeMany(r,o,i,n,-1).next();return a||m("null output"),a}}function Sp(t,e,s){return e.m_projector.project(t,s)}function vp(t,e,s,i,n){t.m_projector.transformInPlaceZ(e,null,s,i,null,n);const r=i.slice(0,s).filter((t=>!t.isNAN()));for(let o=0,a=r.length;o<a;++o)i[o].assign(r[o]);return r.length}function bp(t,e,s,i,n){return t.m_projector.transformInPlaceZ(e,null,s,i,null,n)}function Ip(t,i,n,r){if(t&&i&&i.isPannable()||e("fold_into_360_range_geodetic"),t.isEmpty())return t;if(4===n)return wp(t,i,r);let o=t;const a=o.getGeometryType();if(p(a)){o=xx(t,i);const e=new ge;o.queryEnvelope(e);const s=Cs(i,e,!1).total(),r=i.getPannableExtent();let a=Math.floor((e.xmin-r.xmin)/r.width())*r.width()+r.xmin,h=o;for(;a<e.xmax;)a>e.xmin+s&&a<e.xmax-s&&(h=px(h,i,n,!0,a)),a+=r.width();o=h}else{if(a===s.enumEnvelope){const t=new Sm({vd:o.getDescription()});return t.addEnvelope(o,!1),Ip(t,i,n,r)}if(l(a)){const t=new am({vd:o.getDescription()});return t.addSegment(o,!0),Ip(t,i,n,r)}}return wp(o,i,r)}function wp(t,i,n){if(t&&i&&i.isPannable()||e(""),t.isEmpty())return t;let r;const o=t.getGeometryType();if(o===s.enumEnvelope){const e=new Sm({vd:t.getDescription()});e.addEnvelope(t,!1),r=e}else if(l(o)){const e=new am({vd:t.getDescription()});e.addSegment(t,!0),r=e}else r=t;const a=xx(r,i);return a.isEmpty()?a:mx(a,i,0,a!==t,0,n)}function Dp(t,e,s){if(!e.isPannable()||t.isEmpty())return t;const i=e.getPannableExtent().width(),n=.5*i,r=t.queryInterval(0,0);if(r.width()<n||!o(t.getGeometryType())){if(Number.isNaN(s))return t;const e=r.getCenter();if(Math.abs(e-s)<=n)return t;{const n=new Y,r=et((s-e)/i)*i;n.setShiftCoords(r,0);const o=t.clone();return o.applyTransformation(n),o}}const a=t.getGeometryType(),h=t,m=h.getAttributeStreamRef(0),l=t.clone(),u=l.getAttributeStreamRef(0);let c=0,g=0,_=0,d=p(a)?0:-1;const f=A.constructEmpty();let x=!1;for(let o=0,y=h.getPointCount();o<y;o++){const t=m.read(2*o);o===g&&(p(a)?(0===d&&Number.isNaN(s)&&(x=!0),d>0&&Number.isNaN(s)&&(s=f.getCenter(),x=!1),g=h.getPathEnd(d),d++):g=h.getPointCount(),Number.isNaN(s)?_=t:(_=s,c=0));let e=t-_;Math.abs(e)>n&&(e=et(e/i)*i,c-=e,Math.abs(c)<.1*i&&(c=0));const r=t+c;u.write(2*o,r),x&&f.mergeCoordinate(r),_=t}return l.notifyModified(),l}const Tp="missing implementation";function Np(t,e,s,i){const n=e.getCoordinateSystemType();if(0===n){const i=new eC;return e.queryPrecisionDescriptor(i),Ap(t,i,e,s)}let r=t;2!==i&&3!==i||!e.isPannable()||(r=wp(r,e,s));const o=new eC;if(e.queryPrecisionDescriptor(o),r=Ap(r,o,e,s),0===i||r.isEmpty())return r;if(1===n){if(1===i){const t=new ge;r.queryLooseEnvelope(t);const i=e.getPannableExtent(),n=.01*i.width();return i.xmin=t.xmin-n,i.xmax=t.xmax+n,(new pp).execute(r,i,e,s)}return r}if(2===n){const t=e.getPCSHorizon();if(1===i||2===i){const i=(new Cp).execute(r,t,e,s);return i===t?i.clone():i}return r}if(3===n)return r;m(Tp)}function Ap(t,e,s,i){const n=e.getXYGridRange(),r=t.hasAttribute(1),o=t.hasAttribute(2);let a=new A,h=new A;r&&(a=e.getZGridRange()),o&&(h=e.getMGridRange());let m=(new pp).execute(t,n,s,i);if(r){const e=m.queryInterval(1,0);a.contains(e)||(t===m&&(m=m.clone()),Os(m,a,1,0))}if(o){const e=m.queryInterval(2,0);h.contains(e)||(t===m&&(m=m.clone()),Os(m,h,2,0))}return m}class qp{constructor(t){this.m_inputPCSHorizonClipOption=0,this.m_outputPCSHorizonClipOption=0,this.m_bDontGeonormalizePolygon=!1,this.m_bClipOutCurvedPoles=!1,this.m_bNormalizeOutputGeometry=!1,this.m_bDontHackPolesInGeogToGeog=!1,this.m_centralMeridianOfOutputGCS=0,this.m_densificationStepInput=0,t||e(""),this.m_projTransform=t,this.m_bClipOutCurvedPoles=!1;const s=this.m_projTransform.getExtendedParamsImpl();this.m_bNormalizeOutputGeometry=s.normalizeResultGeometry,this.m_bNormalizeOutputGeometry&&(s.legacyHorizonClipping?this.m_bNormalizeOutputGeometry=!1:this.m_projTransform.getOutputSR().isPannable()||(this.m_bNormalizeOutputGeometry=!1)),s.clipWithInputHorizon?(this.m_inputPCSHorizonClipOption=0,!s.legacyHorizonClipping&&this.m_projTransform.getInputSR().isPannable()&&(this.m_inputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_inputPCSHorizonClipOption=1,s.clipWithOutputHorizon?(this.m_outputPCSHorizonClipOption=0,!s.legacyHorizonClipping&&this.m_projTransform.getOutputSR().isPannable()&&(this.m_outputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_outputPCSHorizonClipOption=1,this.m_centralMeridianOfOutputGCS=s.centralMeridianOfOutputGCS,this.m_densificationStepInput=s.densificationStep;const i=this.m_projTransform.getExtendedParamsInternal();this.m_bDontGeonormalizePolygon=i.hasFlag(2147483648),this.m_bDontHackPolesInGeogToGeog=i.hasFlag(1073741824),this.m_bClipOutCurvedPoles=i.hasFlag(536870912)}project(t,e){if(this.m_projTransform.isIdentity()||t.isEmpty())return t;const i=t.getGeometryType();if(i===s.enumPoint)return this.projectPoint(t,e);const n=this.m_projTransform.getInputSR().getCoordinateSystemType(),r=this.m_projTransform.getOutputSR().getCoordinateSystemType();if(this.m_projTransform.getInputSR(),this.m_projTransform.getOutputSR(),0===n&&n===r){const e=Mp(),s=t.clone();return s.applyTransformation(e),s}switch(i){case s.enumPolyline:case s.enumPolygon:return this.projectMultiPath(t,e);case s.enumMultiPoint:return this.projectMultiPoint(t,e);case s.enumEnvelope:return this.projectEnvelope(t,e);case s.enumGeometryCollection:return this.projectGeometryCollection(t,e);default:m("")}}projectPoint(t,e){const s=[t.getXY()];let i,n=null;(i=t.hasAttribute(1))&&(n=[t.getZ()]),this.transformInPlaceZ(s,n,1,s,n,null);const r=t.clone();return r.setXY(s[0]),i&&r.setZ(n[0]),r}projectMultiPoint(e,s){let i=new ii({copy:e});const n=this.m_projTransform.getInputSR(),r=this.m_projTransform.getOutputSR(),o=n.getCoordinateSystemType(),a=r.getCoordinateSystemType();if(3===o&&t(0),i=Ix(i,n,this.m_inputPCSHorizonClipOption,s),i.isEmpty())return i;2===o&&Gx(n,0,i),Wx(this.m_projTransform,i,!1);let h=0;3===a&&t(0);const m=2===a;return m?h=r.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(h=this.m_centralMeridianOfOutputGCS),m&&0!==this.m_outputPCSHorizonClipOption||(i=mx(i,UE(r),h,!1,0,s)),m&&(i=nx(i,r,this.m_outputPCSHorizonClipOption,s),qx(r,i,this.m_bNormalizeOutputGeometry),i.isEmpty()),i}projectMultiPath(t,e){const i=t.getGeometryType();return i===s.enumPolygon?this.projectPolygon(t,e):i===s.enumPolyline?this.projectPolyline(t,e):void m("project_multi_path_")}projectEnvelope(t,e){this.m_projTransform.getInputSR(),this.m_projTransform.getOutputSR();const s=this.m_projTransform.isVertical()&&t.hasAttribute(1);let i=A.constructEmpty();if(s&&(i=t.queryInterval(1,0)),i.width()>0){const s=t.clone();s.setInterval(1,0,i.vmin,i.vmin);const n=this.projectEnvelopeHelper(s,e);s.setInterval(1,0,i.vmax,i.vmax);const r=this.projectEnvelopeHelper(s,e);return n.merge(r),n}return this.projectEnvelopeHelper(t,e)}projectPolygon(e,i){t(e.getGeometryType()===s.enumPolygon),t(!this.m_projTransform.isIdentity()),t(!e.isEmpty());const n=this.m_projTransform.getInputSR(),r=this.m_projTransform.getOutputSR(),o=n.getCoordinateSystemType(),a=r.getCoordinateSystemType(),h=new Sm({copy:e});3===o&&t(0),3===a&&t(0);const m=2===o,l=2===a,u=m?n.getGCS():n,c=l?r.getGCS():r,g=!l&&!this.m_bDontHackPolesInGeogToGeog;let _=!1,d=Ix(h,n,this.m_inputPCSHorizonClipOption,i);if(d.isEmpty())return d;let p=this.m_densificationStepInput;const f=!Number.isNaN(p);let x;f&&(d=(new kl).execute(d,p,0,0,i));let y=l?r.getPCSInfo():null,P=Number.NaN;m&&(P=n.getCentralMeridian());const E=null!==r.getGCSSplitLines();if(this.m_bDontGeonormalizePolygon){const t=d;if(m&&(zx(n,P,t),f)){const t=n.getUnitsPerMillimeter();p*=n.getGCS().getUnitsPerMillimeter()/t}if(Zx(this.m_projTransform,t,g),f){const t=n.getGCS().getUnitsPerMillimeter();p*=r.getGCS().getUnitsPerMillimeter()/t}x=t}else{let t=new am({vd:d.getDescription()});if(t.addAndExplicitlyOpenAllPaths(d,!1),m){if(zx(n,P,t),f){const t=n.getUnitsPerMillimeter();p*=n.getGCS().getUnitsPerMillimeter()/t}if(this.m_bClipOutCurvedPoles){const e=n.getPCSInfo(),s=e.getSouthPoleGeometry()===CC.PE_POLE_LINE_CURVED,r=e.getNorthPoleGeometry()===CC.PE_POLE_LINE_CURVED;if(s||r){const e=ge.constructEmpty();t.queryLooseEnvelope(e),e.inflateCoords(1,1);const n=89.9999*u.getOneDegreeGCSUnit();s&&(e.ymin=-n),r&&(e.ymax=n),t=fl(t,e,u,0,0,i)}}}if(Zx(this.m_projTransform,t,g),f){const t=UE(n).getUnitsPerMillimeter();p*=UE(r).getUnitsPerMillimeter()/t}let e=Number.NaN;l?(y=r.getPCSInfo(),e=r.getCentralMeridian()):Number.isNaN(this.m_centralMeridianOfOutputGCS)||(e=this.m_centralMeridianOfOutputGCS);let s=Fp(n)|Fp(r),o=10*c.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(s=3,o=10*c.getTolerance(0)),x=_x(d,n,t,c,e,i,s,o,this.m_bNormalizeOutputGeometry),s=0}if(E&&(t(!r.isPannable()),x=Qf(x,r,i)),l){if(!_){const t=c.getPannableExtent().width();if(x.queryInterval(0,0).width()>=t-10*c.getTolerance(0)){const t=y.getNorthPoleLocation(),e=y.getSouthPoleLocation(),s=y.getNorthPoleGeometry(),i=y.getSouthPoleGeometry();let n=0;s===CC.PE_POLE_POINT&&t!==CC.PE_POLE_OUTSIDE_BOUNDARY&&(n=1),i===CC.PE_POLE_POINT&&e!==CC.PE_POLE_OUTSIDE_BOUNDARY&&(n|=2),_||=0!==n}}x=nx(x,r,this.m_outputPCSHorizonClipOption,i),f&&(x=(new kl).execute(x,p,0,0,i)),Mx(r,x,this.m_bNormalizeOutputGeometry)}return x.isEmpty()||_&&(x=(new _p).execute(x,r,!1,i)),x}projectPolyline(e,i){t(e.getGeometryType()===s.enumPolyline),t(!this.m_projTransform.isIdentity()),t(!e.isEmpty());const n=this.m_projTransform.getInputSR(),r=this.m_projTransform.getOutputSR(),o=n.getCoordinateSystemType(),a=r.getCoordinateSystemType(),h=new am({copy:e});3===o&&t(0),3===a&&t(0);const m=2===o,l=2===a;m&&n.getGCS();const u=l?r.getGCS():r,c=!l&&!this.m_bDontHackPolesInGeogToGeog;let g=Ix(h,n,this.m_inputPCSHorizonClipOption,i);if(g.isEmpty())return g;let _=Number.NaN;m&&(_=n.getCentralMeridian());const d=null!==r.getGCSSplitLines();let p=this.m_densificationStepInput;const f=!Number.isNaN(p);let x;if(f&&(g=(new kl).execute(g,p,0,0,i)),this.m_bDontGeonormalizePolygon){if(m&&(zx(n,_,g),f)){const t=n.getUnitsPerMillimeter();p*=n.getGCS().getUnitsPerMillimeter()/t}if(Zx(this.m_projTransform,g,c),f){const t=n.getGCS().getUnitsPerMillimeter();p*=r.getGCS().getUnitsPerMillimeter()/t}x=g}else{const t=new am({vd:g.getDescription()});if(t.addAndExplicitlyOpenAllPaths(g,!1),m&&(zx(n,_,t),f)){const t=n.getUnitsPerMillimeter();p*=n.getGCS().getUnitsPerMillimeter()/t}if(Zx(this.m_projTransform,t,c),f){const t=n.getGCS().getUnitsPerMillimeter();p*=r.getGCS().getUnitsPerMillimeter()/t}let e=Number.NaN;l?e=r.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(e=this.m_centralMeridianOfOutputGCS);let s=Fp(n)|Fp(r),o=10*u.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(s=3,o=0),x=dx(g,n,t,u,e,i,s,o,this.m_bNormalizeOutputGeometry),s=0}return d&&(t(!r.isPannable()),x=Qf(x,r,i)),l&&(x=nx(x,r,this.m_outputPCSHorizonClipOption,i),f&&(x=(new kl).execute(x,p,0,0,i)),Mx(r,x,this.m_bNormalizeOutputGeometry)),x.isEmpty(),x}projectGeometryCollection(e,s){return t(0),{}}tryProjectMultiVertexSimple(e,s){return t(0),{}}projectEnvelopeHelper(t,e){const s=(t.height()+t.width())/400;if(0!==s){const i=(new kl).execute(t,s,0,0,e),n=this.projectMultiPath(i,e),r=new ke({vd:t.getDescription()});if(n.isEmpty()){const s=Math.min(t.height(),t.width()),n=bs(this.m_projTransform.getInputSR(),t,!0).total();if(s>100*n){const t=ge.constructEmpty(),e=Cs(this.m_projTransform.getOutputSR(),t,!0).total(),i=this.m_projTransform.getInputSR().getOneMeter()/this.m_projTransform.getOutputSR().getOneMeter();if(s>100*Math.max(n,e*i))return r}const o=new am;o.addAndExplicitlyOpenAllPaths(i,!1);this.projectMultiPath(o,e).queryEnvelope(r);const a=new ii({vd:t.getDescription()});a.reserve(4);const h=new Ge;for(let e=0;e<4;e++)t.queryCornerByVal(e,h),a.add(h);const m=this.projectMultiPoint(a,e),l=new ke;return m.queryEnvelope(l),r.merge(l),r}return n.queryEnvelope(r),r}{const s=t.getCenterXY(),i=new Ge(s),n=this.projectPoint(i,e),r=new ke({vd:t.getDescription()});if(n.isEmpty())r.setEmpty();else{t.copyTo(r);const e=n.getXY();r.setCoords(e.x,e.y,e.x,e.y)}return r}}transformInPlace(e,s,i,n){return t(0),0}transformInPlaceZ(e,s,i,r,o,a){if(this.m_projTransform.isIdentity())return e!==r&&tt(r,e,i),s!==o&&X(o,s,0,0,i),i;const h=this.m_projTransform,m=h.getInputSR(),l=h.getOutputSR(),u=m.getCoordinateSystemType(),c=l.getCoordinateSystemType();if(0===u&&u===c){const s=m.getHorzUnitFactor()/l.getHorzUnitFactor(),n=new Y;return n.setScaleCoords(s,s),n.transformPoints2D(e,i,r),h.isVertical()&&t(0),i}3===u&&n("image: transform_in_place_"),3===c&&n("image: transform_in_place_"),wx(e,i,r,m,this.m_inputPCSHorizonClipOption),o!==s&&X(o,s,0,0,i),2===u&&Ux(m,0,r,i),Kx(this.m_projTransform,r,o,i,!1);let g=0;const _=2===c;if(_?g=l.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(g=this.m_centralMeridianOfOutputGCS),_&&0!==this.m_outputPCSHorizonClipOption||lx(r,i,l.getGCS(),g),_){if(!hx(r,i,l,this.m_outputPCSHorizonClipOption))for(let t=0;t<i;++t)r[t].setNAN();Tx(l,r,i,!1)}let d=i;for(let t=0;t<i;++t)r[t].isNAN()&&(o&&(o[t]=Number.NaN),d--);return d}}function Fp(t){if(2!==t.getCoordinateSystemType())return 0;let e=0;const s=t.getPCSInfo(),i=s.getNorthPoleLocation(),n=s.getSouthPoleLocation(),r=s.getNorthPoleGeometry(),o=s.getSouthPoleGeometry();return r===CC.PE_POLE_POINT&&i!==CC.PE_POLE_OUTSIDE_BOUNDARY&&(e=1),o===CC.PE_POLE_POINT&&n!==CC.PE_POLE_OUTSIDE_BOUNDARY&&(e|=2),e}function Mp(e,s){return t(0),{}}class Gp{getOperatorType(){return 10300}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s){return!e||e.isIdentity()?t:new Vp(t,e,s)}execute(t,e,s){return e.isIdentity()?t:Sp(t,e,s)}transform(t,e,s,i,n=!0){return n?vp(t,e,s,i,null):bp(t,e,s,i,null)}transform3D(e,s,i,n,r=!0){return t(0),0}foldInto360Range(t,e){return wp(t,e,null)}foldInto360RangeGeodetic(t,e,s){return Ip(t,e,s,null)}normalizeGeometryEx(t,e,s,i,n=0){return bf(t,e,s,i,n)}normalizeGeometry(t,e,s){return Dp(t,e,s)}clipToSpatialReference(t,e,s,i=0){return Np(t,e,s,i)}}class Vp extends ue{constructor(t,s,i){super(),this.m_projTrans=s,this.m_progressTracker=i,this.m_index=-1,t||e(""),this.m_inputGeoms=t}next(){const t=this.m_inputGeoms.next();return null!=t?(c(t),g(t),this.m_index=this.m_inputGeoms.getGeometryID(),Sp(t,this.m_projTrans,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return t(0),!1}getRank(){return t(0),0}}function Yp(t,i,n,r,o,a,h=!1){t||e("Geometry.Geodetic_densify.densify");let m=t.getGeometryType();if(g(t),c(t),t.isEmpty()||u(m))return t;const _=new Hp;_.m_sr=i,_.m_gcs=i.getGCS(),_.m_transform=_.m_gcs!==i?i.getSRToGCSTransform():null,_.m_progressTracker=a;const d=qE();let p,f,x;if(_.m_gcs.querySpheroidData(d),_.m_a=d.majorSemiAxis,_.m_eSquared=d.e2,_.m_rpu=_.m_gcs.getUnit().getUnitToBaseFactor(),_.m_gcsTolerance=_.m_gcs.getTolerance(0),_.m_radTolerance=_.m_gcsTolerance*_.m_rpu,_.m_maxLength=r,_.m_maxDeviation=o,_.m_curveType=n,m===s.enumEnvelope){const e=new Sm({vd:t.getDescription()});e.addEnvelope(t,!1),p=e,m=s.enumPolygon}else if(l(m)){const e=new am({vd:t.getDescription()});e.addSegment(t,!0),p=e,m=s.enumPolyline}else p=t;if(4!==_.m_curveType){if(f=_.m_transform&&!_.m_transform.isIdentity()?(new Gp).execute(p,_.m_transform,a):xx(p,_.m_gcs),f.isEmpty())return f;f=Xp(_.m_rpu,f);let t=_.geodeticDensify(f);h||(t=(new Gp).foldInto360RangeGeodetic(t,_.m_gcs,_.m_curveType)),x=_.m_transform&&!_.m_transform.isIdentity()?(new Gp).execute(t,_.m_transform.getInverse(),a):t}else{let t;if(i.isPannable())t=xx(p,i);else{const e=i.getPCSHorizon();t=(new Cp).execute(p,e,i,a),t===e&&(t=e.clone())}if(f=t,f.isEmpty())return f;x=_.shapePreservingDensify(f)}return x}function Xp(t,e){const s=new ge;if(e.queryLooseEnvelope(s),s.width()*t<Math.PI)return e;let i=!1;const n=e.querySegmentIterator(),r=new w,o=new w;for(;n.nextPath();)for(;n.hasNextSegment();){const e=n.nextSegment();if(r.setCoordsPoint2D(e.getStartXY()),o.setCoordsPoint2D(e.getEndXY()),r.scale(t),o.scale(t),Math.abs(r.x-o.x)>Math.PI){if(!Rp(r,o)){i=!0;break}if(Math.abs(r.x-o.x)>2*Math.PI){i=!0;break}}}if(!i)return e;const a=e.createInstance();a.reserve(e.getPointCount());const h=e.getDescription().getAttributeCount()>1,m=new w,l=new w,u=new w(0,0),c=new w(0,0),g=new Ge;for(n.resetToFirstPath();n.nextPath();){let e=Number.NaN,s=0;for(;n.hasNextSegment();){const i=n.nextSegment();r.setCoordsPoint2D(i.getStartXY()),o.setCoordsPoint2D(i.getEndXY()),r.scale(t),o.scale(t),Number.isNaN(e)?(s=tf(r.x,Number.NaN,s),u.setCoordsPoint2D(r)):u.setCoordsPoint2D(c),e=u.x;if(Rp(r,o)){if(o.x-r.x>2*Math.PI)for(;o.x-r.x>2*Math.PI;)o.x-=2*Math.PI;else if(o.x-r.x<2*-Math.PI)for(;o.x-r.x<2*-Math.PI;)o.x+=2*Math.PI;s=tf(o.x,Number.NaN,s),c.setCoordsPoint2D(o)}else m.setCoordsPoint2D(o),af(m),s=tf(m.x,e,s),c.setCoords(s+m.x,m.y);if(Math.abs(c.x-o.x)<.5&&c.setCoordsPoint2D(o),h){i.queryCoord(0,g),l.setCoordsPoint2D(u),l.scale(1/t),g.setXY(l);n.isFirstSegmentInPath()?a.startPathPoint(g):a.lineToPoint(g),n.isLastSegmentInPath()&&!n.isPathClosed()&&(i.queryCoord(1,g),l.setCoordsPoint2D(c),l.scale(1/t),g.setXY(l),a.lineToPoint(g))}else{n.isFirstSegmentInPath()&&a.insertPath2D(-1,null,0,0,!0);const e=a.getPathCount()-1;l.setCoordsPoint2D(u),l.scale(1/t),a.insertPoint2D(e,-1,l),n.isLastSegmentInPath()&&!n.isPathClosed()&&(l.setCoordsPoint2D(c),l.scale(1/t),a.insertPoint2D(e,-1,l))}}}return a}function kp(t,e,s,i,n,r,o,a,h,m,l,u){const c=new w,g=new w,_=i.compare(n)>0;Jp(_,i,n,c,g);const d=Op(t,e,s,c,g,r,o,a,h,m,null,l,u);return _&&Kp(h,m,null,l),d}function Rp(t,e){return!(!_C(t.y,xt)||!_C(e.y,xt))||!(!_C(t.y,-xt)||!_C(e.y,-xt))}function Bp(t,e){return!(!_C(t.y,xt)||_C(e.y,xt))||!(!_C(t.y,-xt)||_C(e.y,-xt))}function Lp(t,e){return!(!_C(e.y,xt)||_C(t.y,xt))||!(!_C(e.y,-xt)||_C(t.y,-xt))}class Hp{constructor(){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_progressTracker=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_gcsTolerance=0,this.m_radTolerance=0,this.m_maxLength=0,this.m_maxDeviation=0,this.m_curveType=0}geodeticDensify(t){const e=t.createInstance(),s=t.querySegmentIterator(),i=[],n=[],r=new SE,o=t.getDescription().getAttributeCount()>1;for(;s.nextPath();){const t=[0];for(;s.hasNextSegment();){const a=s.nextSegment(),h=a.getStartXY(),m=a.getEndXY();h.scale(this.m_rpu),m.scale(this.m_rpu);const l=new w,u=new w,c=h.compare(m)>0;Jp(c,h,m,l,u),i.length=0,n.length=0,this.m_maxLength>0?Op(this.m_a,this.m_eSquared,this.m_curveType,l,u,this.m_maxLength,this.m_maxDeviation,this.m_radTolerance,null,null,o?n:null,i,t):Wp(),c&&Kp(null,null,o?n:null,i),i[0].setCoordsPoint2D(a.getStartXY()),i.at(-1).setCoordsPoint2D(a.getEndXY());const g=1/this.m_rpu;for(let t=1,e=i.length-1;t<e;t++)i[t].scale(g);if(o){const t=$p(c,a,r);Up(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),a,t,n,i,e)}else zp(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),i,e)}}return e}shapePreservingDensify(t){const e=t.createInstance(),s=t.querySegmentIterator(),i=[],n=[],r=new SE,o=t.getDescription().getAttributeCount()>1;for(;s.nextPath();)for(;s.hasNextSegment();){const t=s.nextSegment(),a=t.getStartXY(),h=t.getEndXY(),m=a.compare(h)>0,l=$p(m,t,r);i.length=0,n.length=0,Qp(this.m_a,this.m_eSquared,this.m_rpu,l,this.m_sr,this.m_maxLength,this.m_maxDeviation,o?n:null,i),m&&Kp(null,null,o?n:null,i),o?Up(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),t,l,n,i,e):zp(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),i,e)}return e}}function zp(t,e,s,i){t&&i.insertPath2D(-1,null,0,0,!0);const n=i.getPathCount()-1;i.insertPointsFromPoints(n,-1,s,0,s.length-1,!0),e&&i.insertPoint2D(n,-1,s.at(-1))}function Up(t,e,s,i,n,r,o){o.reserve(o.getPointCount()+r.length-1);const a=new Ge;if(s.queryStart(a),t?o.startPathPoint(a):o.lineToPoint(a),r.length>2){const t=i.calculateLength2D();for(let e=1;e<r.length-1;e++){const s=i.lengthToT(n[e]*t);i.queryCoord(s,a),a.setXY(r[e]),o.lineToPoint(a)}}e&&(s.queryEnd(a),o.lineToPoint(a))}function Op(t,e,s,i,n,r,o,a,h,m,l,u,c){const g={stack:[],error:void 0,hasError:!1};try{const _=me(g,new fC,!1),d=me(g,new fC,!1),p=me(g,new fC,!1);bC.geodeticDistance(t,e,i.x,i.y,n.x,n.y,p,_,d,s);const f=p.val,x=_.val,y=d.val;let P=x,E=y;P<0&&(P+=2*Math.PI),E<0&&(E+=2*Math.PI),h&&(h[0]=P),m&&(m[0]=E);let C=Number.NaN,S=Number.NaN;if(null!==l){const s=IC.q90(t,e),n=IC.q(t,e,i.y);C=(s-n)/f,S=(s+n)/f}const v=Bp(i,n),b=Lp(i,n),I=v||b,D=rf(i,n,a),T=me(g,new Ct(new fC,new fC),!1),N=new w,A=new w,q=new w;c[0]=tf(i.x,Number.NaN,c[0]);let F=c[0];if(f<=r)return u.push(i.clone()),c[0]=tf(n.x,Number.NaN,c[0]),null!=l&&l.push(0),I?(v&&ef(i,n,l,u),b&&sf(i,n,l,u)):D?nf(i,n,x,C,S,l,u):o>0&&(A.setCoords(i.x-F,i.y),N.setCoords(n.x-c[0],n.y),F=jp()),u.push(n.clone()),f;const M=1+Math.ceil(f/r),G=f/(M-1),V=new w;u.push(i.clone()),V.setCoordsPoint2D(i),A.setCoords(i.x-c[0],i.y),null!==l&&l.push(0);for(let r=1;r<M;r++){let h;if(r<M-1){const n=r*G;bC.geodeticCoordinate(t,e,i.x,i.y,n,x,T.at(0),T.at(1),s),N.setCoords(T.at(0).val,T.at(1).val),c[0]=tf(N.x,V.x,c[0]),q.setCoords(c[0]+N.x,N.y),h=r/(M-1)}else c[0]=tf(n.x,Number.NaN,c[0]),N.setCoords(n.x-c[0],n.y),q.setCoordsPoint2D(n),h=1;I?(1===r&&v&&ef(i,q,l,u),r===M-1&&b&&sf(V,n,l,u)):D?of(V,q,a)&&(i.x<n.x?V.x>q.x&&(c[0]+=2*Math.PI,q.setCoords(c[0]+N.x,N.y)):V.x<q.x&&(c[0]-=2*Math.PI,q.setCoords(c[0]+N.x,N.y)),nf(V,q,x,C,S,l,u)):o>0&&jp(),u.push(q.clone()),null!=l&&l.push(h),V.setCoordsPoint2D(q),A.setCoordsPoint2D(N),F=c[0]}return f}catch(_){g.error=_,g.hasError=!0}finally{le(g)}}function Wp(e,s,i,n,r,o,a,h,m,l){t(0)}function jp(e,s,i,n,r,o,a,h,m,l,u,c,g,_,d){return t(0),0}function Zp(t,e,s,i){const n=Lm(t,e,s),r=Lm(t,e,i);return Fe.distance(n,r)}function Qp(t,e,s,i,n,r,o,a,h){const m=i.isCurve(),l=ol(t,e)*Math.PI*179/180;let u=r;r>0&&!(r>l)||(u=l),u=gl(t,e,u);let c=o;!m||c>0||(c=.001);const g=c>0;let _=Number.NaN;g&&(_=gl(t,e,c));const d=n.getPECoordSys(),p=1===n.getCoordinateSystemType(),f=n.getTolerance(0),x=i.getStartXY(),y=i.getEndXY(),P=new w,E=new w;if(p)P.setCoordsPoint2D(x),P.scale(s),E.setCoordsPoint2D(y),E.scale(s);else{const t=[x.x,x.y,y.x,y.y];PC.projToGeog(d,2,t),P.setCoords(t[0],t[1]),P.scale(s),E.setCoords(t[2],t[3]),E.scale(s)}let C=0,S=0;const v=[],b=[],I=[];v.push(y.clone()),b.push(E.clone()),I.push(1),h.push(x.clone()),null!==a&&a.push(S);const D=n.isPannable(),T=x.clone(),N=[.5,.33333333333333337,.6666666666666666,.16666666666666669,.8333333333333333];let q=5;for(m||(g?(N[0]=.5,N[1]=.25,N[2]=.75,q=3):q=1);b.length>0;){const r=v.at(-1).clone();E.assign(b.at(-1));const o=I.at(-1);let l=!1,c=Number.NaN;const x=Zp(t,e,P,E);let y=u>=x&&Math.abs(P.y-E.y)<.9*Math.PI;p&&y&&(y=Math.abs(P.x-E.x)<.9*Math.PI);const F=new w,M=new w;let G=!1;if(m||g||!y||y&&(G=!0),i.calculateSubLength(S,o)<=f&&(G=!0),!G)for(let a=0;a<q;a++){const r=_t(S,o,N[a]),h=new w;i.queryCoord2D(r,h);const m=new w;if(p)m.setCoords(h.x*s,h.y*s);else{const t=[h.x,h.y];PC.projToGeog(d,1,t),m.setCoords(t[0]*s,t[1]*s)}if(0===a&&(c=r,F.setCoordsPoint2D(h),M.setCoordsPoint2D(m),!y)){l=!0;break}if(p&&Math.abs(P.x-m.x)>=Math.PI){l=!0;break}if(u<Zp(t,e,P,m)){l=!0;break}if(g){const r=Zm(t,e,P,E,N[a]),h=r.clone();if(p?(h.x/=s,h.y/=s):(h.x/=s,h.y/=s,bp(n.getGCSToSRTransform(),[h],1,[h],null)),h.isNAN()){const s=Lm(t,e,m),i=Lm(t,e,P),n=Lm(t,e,E),{first:r,second:o}=tl(t,e,s,i,n,2,null);if(o>_){l=!0;break}}else{if(D){const t=n.getPannableExtent().width(),e=_t(i.getStartX(),i.getEndX(),.5);for(;h.x<e-.5*t;)h.x+=t;for(;h.x>=e+.5*t;)h.x-=t}const a=i.getClosestCoordinateOnInterval(h,new A(S,o),-1),m=i.getCoord2D(a);if(!p){const t=[m.x,m.y];PC.projToGeog(d,1,t),m.x=t[0],m.y=t[1]}m.x*=s,m.y*=s;let u=Zp(t,e,m,r);if(u>_){if(u<4*_){const s=Lm(t,e,m),i=Lm(t,e,P),n=Lm(t,e,E),{first:r,second:o}=tl(t,e,s,i,n,2,null);u=o}if(u>_){l=!0;break}}}}}l?(v.push(F.clone()),b.push(M.clone()),I.push(c)):(v.pop(),b.pop(),I.pop(),h.push(r.clone()),C+=x,null!==a&&a.push(C),T.setCoordsPoint2D(r),P.setCoordsPoint2D(E),S=o)}if(null!==a){const t=1/C;for(let e=0;e<a.length;e++)a[e]*=t}}function Kp(t,e,s,i){if(i.reverse(),null!==s&&s.reverse(),t){const s=t[0],i=e[0];t[0]=i,e[0]=s}}function Jp(t,e,s,i,n){t?(i.setCoordsPoint2D(s),n.setCoordsPoint2D(e)):(i.setCoordsPoint2D(e),n.setCoordsPoint2D(s))}function $p(t,e,s){return t?(s.create(e.getGeometryType()),e.copyTo(s.get()),s.get().reverse(),s.get()):e}function tf(t,e,s){if(Number.isNaN(e)){for(;s-t>Math.PI;)s-=2*Math.PI;for(;t-s>Math.PI;)s+=2*Math.PI;return s}return s+t-e>Math.PI?s-=2*Math.PI:e-(s+t)>Math.PI&&(s+=2*Math.PI),s}function ef(t,e,s,i){if(t.y>0){const n=new w;n.setCoords(e.x,xt),_C(t.x,n.x)||_C(e.y,n.y)||(i.push(n),null!==s&&s.push(0))}else{const n=new w;n.setCoords(e.x,-xt),_C(t.x,n.x)||_C(e.y,n.y)||(i.push(n),null!==s&&s.push(0))}}function sf(t,e,s,i){if(e.y>0){const n=new w;n.setCoords(t.x,xt),_C(e.x,n.x)||_C(t.y,n.y)||(i.push(n),null!==s&&s.push(1))}else{const n=new w;n.setCoords(t.x,-xt),_C(e.x,n.x)||_C(t.y,n.y)||(i.push(n),null!==s&&s.push(1))}}function nf(t,e,s,i,n,r,o){if(pC(s)){if(xt-t.y>0){const e=new w;e.setCoords(t.x,xt),o.push(e),null!==r&&r.push(i)}if(xt-e.y>0){const t=new w;t.setCoords(e.x,xt),o.push(t),null!==r&&r.push(i)}}else{if(xt+t.y>0){const e=new w;e.setCoords(t.x,-xt),o.push(e),null!==r&&r.push(n)}if(xt+e.y>0){const t=new w;t.setCoords(e.x,-xt),o.push(t),null!==r&&r.push(n)}}}function rf(t,e,s){return!(!of(t,e,s)||_C(t.y,xt)||_C(t.y,-xt)||_C(e.y,xt)||_C(e.y,-xt))}function of(t,e,s){return Math.abs(Math.abs(t.x-e.x)-Math.PI)<=s}function af(t){if(t.x<-Math.PI)for(;t.x<-Math.PI;)t.x+=2*Math.PI;else if(t.x>Math.PI)for(;t.x>Math.PI;)t.x-=2*Math.PI}function hf(t,e,s,i){const n={stack:[],error:void 0,hasError:!1};try{const r=[s.x],o=[s.y-i],a=[s.x],h=[s.y+i];rl(r,o),rl(a,h);const m=me(n,new fC,!1),l=me(n,new fC,!1);bC.greatEllipticDistance(t,e,s.x,s.y,r[0],o[0],m,null,null),bC.greatEllipticDistance(t,e,s.x,s.y,a[0],h[0],l,null,null);return Math.min(m.val,l.val)}catch(r){n.error=r,n.hasError=!0}finally{le(n)}}function mf(t,e,s,i,n){const r=new ge;s.queryEnvelope(r);const o=bs(null,s,!0).total();if(e.xmin-r.xmin<=o&&r.xmax-e.xmax<=o)return s;const a=e.width();let h=0;for(;e.xmin+h*a<r.xmin;)h++;for(;e.xmin+h*a>r.xmin;)h--;const m=h*a,l=new Y;l.setShiftCoords(-m,0);const u=s;u.applyTransformation(l);const c=new ge;u.queryEnvelope(c);let g=null;if(c.xmax>e.xmax){let s=0;const i=new ge;i.setCoords({env2D:e}),i.ymin-=1,i.ymax+=1;let r=u;for(;i.xmin<c.xmax;){c.xmax>i.xmax&&(r=px(r,t,2,!0,i.xmax));const o=dl(r,i,Cs(null,ys(r,i),!0).total(),Number.NaN,n);null===g?g=o===r?o.clone():o:(l.setShiftCoords(-s*a,0),o.applyTransformation(l),g.add(o,!1)),s++,i.xmin=i.xmax,i.xmax=e.xmax+s*a}}else g=u;return g}class lf{constructor(e,s){this.m_basisX=new Fe,this.m_basisY=new Fe,this.m_normal=new Fe,t(1===e.getCoordinateSystemType()),this.m_gcs=e;const i=qE();e.querySpheroidData(i),this.m_a=i.majorSemiAxis,this.m_e2=i.e2,this.m_rpu=e.getUnit().getUnitToBaseFactor(),this.m_curvCenterRad=s.mul(this.m_rpu);const n=this.m_curvCenterRad.x,r=this.m_curvCenterRad.y,o=Math.cos(n),a=Math.sin(n),h=Math.cos(r),m=Math.sin(r);this.m_cartCenter3D=zm(this.m_a,this.m_e2,o,a,h,m),this.m_normal.setCoordsPoint3D(this.m_cartCenter3D),this.m_d=this.m_cartCenter3D.length(),this.m_normal.divThis(this.m_d),Fe.selectRightHandedBasisFromNormal(this.m_normal,this.m_basisX,this.m_basisY),this.m_northPolePcs=this.projectPoint(w.construct(0,.5*Math.PI/this.m_rpu)),this.m_southPolePcs=this.projectPoint(w.construct(0,.5*-Math.PI/this.m_rpu))}project(t){const s=t.getGeometryType();if(o(s)){c(t);const e=t;return this.projectMultiVertex(e)}e("Gnomonic.project")}unproject(t,i,n){const r=t.getGeometryType();if(o(r)){c(t);let e=t;const o=[];if(r===s.enumPolygon){const t=e.getPathCount();for(let s=0;s<t;s++){const t=e.calculateRingArea2D(s);o.push(t)}}return this.unprojectMultiVertex(i,e),p(r)?(yf(this.m_gcs,0,e),uf(o,this.m_gcs,0,e,n)):e=mx(e,this.m_gcs,0,!0,0,n),e}e("Gnomonic.unproject")}projectPoint(t){const e=t.mul(this.m_rpu),s=Lm(this.m_a,this.m_e2,e),i=this.m_normal.dotProduct(s);if(i<=0)return w.construct(Number.NaN,Number.NaN);const n=this.m_d/i,r=s.mul(n).sub(this.m_cartCenter3D),o=new w;return o.x=this.m_basisX.dotProduct(r),o.y=this.m_basisY.dotProduct(r),o}unprojectPoint(t){const e=this.m_cartCenter3D.add(this.m_basisX.mul(t.x).add(this.m_basisY.mul(t.y)));return Wm(this.m_a,this.m_e2,e).divide(this.m_rpu)}projectMultiVertex(t){const e=t.getImpl();let s=!0;const i=new w,n=new w;for(let r=0,o=e.getPointCount();r<o;r++)e.queryXY(r,i),i.y*this.m_rpu>.5*Math.PI?n.assign(this.m_northPolePcs):i.y*this.m_rpu<.5*-Math.PI?n.assign(this.m_southPolePcs):n.assign(this.projectPoint(i)),e.setXY(r,n),n.isNAN()&&(s=!1);return e.notifyModifiedFlags(2001),s}unprojectMultiVertex(t,e){const s=e.getImpl(),i=t*t,n=!this.m_northPolePcs.isNAN(),r=!this.m_southPolePcs.isNAN();for(let o=0,a=s.getPointCount();o<a;o++){const t=s.getXY(o);let e=new w;n&&w.sqrDistance(t,this.m_northPolePcs)<=i?(e.setCoords(this.m_curvCenterRad.x,.5*Math.PI),e.scale(1/this.m_rpu)):r&&w.sqrDistance(t,this.m_southPolePcs)<=i?(e.setCoords(this.m_curvCenterRad.x,.5*-Math.PI),e.scale(1/this.m_rpu)):e=this.unprojectPoint(t),s.setXY(o,e)}s.notifyModifiedFlags(2001)}}function uf(t,e,i,n,r){const o=n.getGeometryType(),a=e.getPannableExtent();let h=n,m=!1,l=!1;if(o===s.enumPolygon){const s=new ge,n=w.construct(i,0);s.setCoords({env2D:a}),s.centerAt(n),m=cf(t,e,s,h,r);const o=xf(e,s,h,r);o!==h&&(l=!0),h=o}else h=(new Gp).foldInto360RangeGeodetic(h,e,2);o===s.enumPolygon&&(m||l)&&(h=(new _p).execute(h,e,!1,r)),h!==n&&(n.setEmpty(),n.add(h,!1))}function cf(t,e,s,i,n){const r=gf(s,i),o=_f(t,e,s,i,n);return r||o}function gf(t,e){const s=new ge;e.queryEnvelope(s);const i=_C(t.ymax,s.ymax),n=_C(t.ymin,s.ymin),r=i||n;return!!r&&(df(t,e),r)}function _f(t,e,s,i,n){const r=[],o=[],a=.5*s.width();for(let u=0;u<i.getPathCount();u++){const h=i.getXY(i.getPathStart(u)),m=i.getXY(i.getPathEnd(u)-1),l=t[u]<0;if(Math.abs(h.x-m.x)>a){const t=pf(l,e,s,u,i,n);r.push(t),o.push(u)}else if(!l){if(i.calculateRingArea2D(u)<0){const t=ff(e,s,u,i,n);r.push(t),o.push(u)}}}if(0===r.length)return!1;const h=new Sm({vd:i.getDescription()});let m=0,l=o[m];for(let u=0;u<i.getPathCount();u++)u===l?(h.add(r[m],!1),m++,m<o.length&&(l=o[m])):h.addPath(i,u,!0);return i.setEmpty(),i.add(h,!1),!0}function df(t,e){const s=new Sm,i=new ge;for(let n=0;n<e.getPathCount();n++){e.queryPathEnvelope(n,i);let r=_C(t.ymax,i.ymax),o=_C(t.ymin,i.ymin);if(!(r||o)){s.addPath(e,n,!0);continue}s.insertPath2D(-1,null,0,0,!0);const a=e.getPathStart(n),h=e.getPathEnd(n),m=h-a;let l=-1;for(l=a;l<h;l++){const s=e.getXY(l);if(r=_C(t.ymax,s.y),o=_C(t.ymin,s.y),!r&&!o)break}let u=l,c=!1,g=Number.NaN;do{const i=e.getXY(u);r=_C(t.ymax,i.y),o=_C(t.ymin,i.y);const h=a+(u+1-a)%m;if(r||o){let r=w.construct(g,i.y);s.insertPoint2D(n,-1,r);const o=e.getXY(h),a=_C(t.ymax,o.y),m=_C(t.ymin,o.y);a||m||(r=w.construct(o.x,i.y),c?s.setXY(s.getPointCount()-1,r):s.insertPoint2D(n,-1,r)),c=!0}else s.insertPoint2D(n,-1,i),g=i.x,c=!1;u=h}while(u!==l)}e.setEmpty(),e.add(s,!1)}function pf(t,e,s,i,n,r){const o=new Sm,a=new Sm,h=new Y,m=n.getXY(n.getPathStart(i)),l=n.getXY(n.getPathEnd(i)-1),u=s.width(),c=.5*u,g=new ge;n.queryEnvelope(g);const _=Math.ceil(g.width()/u)+1;let d,p;m.x>l.x?(d=-u,p=t?s.ymin:s.ymax):(d=u,p=t?s.ymax:s.ymin),h.setShiftCoords(d,0),o.addPath(n,i,!0),a.add(o,!1);const f=new Ge;for(let w=0;w<_;w++)a.applyTransformation(h),a.getPointByVal(0,f),o.lineToPoint(f),o.addSegmentsFromPath(a,0,0,a.getSegmentCount()-1,!1);const x=o.getXY(0),y=o.getXY(o.getPointCount()-1);x.y=p,y.y=p,o.lineTo(y);const P=new w;for(P.setCoordsPoint2D(y),P.x-=.5*d;Math.abs(P.x-x.x)>c;)o.lineTo(P),P.x-=.5*d;o.lineTo(x);const E=s.getCenter().x,C=new ge;o.queryEnvelope(C);let S=0;const v=C.getCenter().x;v-E>c?S=-Math.ceil((v-E-c)/u):E-v>c&&(S=Math.ceil((E-v-c)/u)),0!==S&&(h.setShiftCoords(S*u,0),o.applyTransformation(h));const b=new Vm,I=b.addGeometry(o);fx(b,I,e,0,2,!0,s.xmin),fx(b,I,e,0,2,!0,s.xmax);const D=b.getGeometry(I),T=ys(D,s);T.inflateCoords(0,1);return dl(D,s,Cs(null,T,!0).total(),Number.NaN,r)}function ff(t,e,s,i,n){const r=e.width(),o=.5*r,a=e.getCenter().x,h=new ge;i.queryPathEnvelope(s,h);let m,l=0,u=h.getCenter().x;if(u-a>o?l=-Math.ceil((u-a-o)/r):a-u>o&&(l=Math.ceil((a-u-o)/r)),0!==l){const t=new Y;t.setShiftCoords(l*r,0),i.getImpl().applyTransformationToPath(t,s),i.queryPathEnvelope(s,h),u=h.getCenter().x}const c=new ge;e.containsExclusiveEnvelope(h)?(m=!1,c.setCoords({env2D:e})):(m=!0,c.setCoords({env2D:e}),c.xmin-=r,c.xmax+=r);let g=i.createInstance();g.addPathPoint2D(null,0,!0);const _=new w;if(_.setCoords(c.xmin,c.ymin),g.insertPoint2D(0,-1,_),_.setCoords(c.xmin,c.ymax),g.insertPoint2D(0,-1,_),_.setCoords(.5*(c.xmin+c.xmax),c.ymax),g.insertPoint2D(0,-1,_),_.setCoords(c.xmax,c.ymax),g.insertPoint2D(0,-1,_),_.setCoords(c.xmax,c.ymin),g.insertPoint2D(0,-1,_),_.setCoords(.5*(c.xmin+c.xmax),c.ymin),g.insertPoint2D(0,-1,_),m){g.addPath(i,s,!0);const o=new Y;u<a?o.setShiftCoords(r,0):o.setShiftCoords(-r,0),i.getImpl().applyTransformationToPath(o,s),g.addPath(i,s,!0);const h=new Vm,m=h.addGeometry(g);fx(h,m,t,0,2,!0,e.xmin),fx(h,m,t,0,2,!0,e.xmax),g=h.getGeometry(m);const l=ys(g,e);l.inflateCoords(0,1);g=dl(g,e,Cs(null,l,!0).total(),Number.NaN,n)}else g.addPath(i,s,!0);return g}function xf(t,e,s,i){const n=new ge;s.queryEnvelope(n);const r=bs(null,s,!0).total();if(e.xmin-n.xmin<=r&&n.xmax-e.xmax<=r)return s;const o=s.createInstance();let a=s.createInstance();const h=new ge,m=s.getPathCount();for(let l=0;l<m;l++)s.queryPathEnvelope(l,h),e.xmin-h.xmin<=r&&h.xmax-e.xmax<=r?o.addPath(s,l,!0):(a.setEmpty(),a.addPath(s,l,!0),a=mf(t,e,a,!0,i),o.add(a,!0));return o}function yf(t,e,s){const i=t.getPannableExtent(),n=w.construct(e,0);i.centerAt(n);const r=i.width(),o=.5*r,a=new w;a.setNAN();let h=Number.NaN;for(let m=0;m<s.getPathCount();m++)for(let t=s.getPathStart(m);t<s.getPathEnd(m);t++){const e=s.getXY(t),n=_C(e.y,i.ymax)||_C(i.ymin,e.y);t===s.getPathStart(m)?(a.setNAN(),h=0):a.isNAN()||n||(h=Pf(e.x,a.x,o,r,h)),e.x+=h,s.setXY(t,e),n||a.setCoordsPoint2D(e)}s.getImpl().notifyModifiedFlags(2001)}function Pf(t,e,s,i,n){return n+t-e>s?n-=i:e-(n+t)>s&&(n+=i),n}function Ef(t,e,s,i,n,r){const o=e.getAttributeStreamRef(0),a=e.getPointCount();let h=!1;const m=new w;for(let P=0;P<a;++P){if(o.queryPoint2D(2*P,m),1&r&&m.y>=s){h=!0;break}if(2&r&&m.y<=-s){h=!0;break}}if(!h)return!1;let l=!1;t&&(l=e.getImpl().isClosedPathInXYPlane(0));const u=new Vm,c=u.addGeometry(e),g=u.getFirstPath(c);let _=-1,d=!0;const p=new w,f=new Ge;let x=Nm;const y=If*n/360;for(let P=u.getFirstVertex(g);P!==Nm;P=u.getNextVertex(P)){u.queryXY(P,m);let t=1&r&&m.y>=s?1:0;if(t|=2&r&&m.y<=-s?2:0,_>0&&_!==t){if(p.x!==m.x){const t=u.getPrevVertex(P);u.queryPoint(t,f);const e=u.insertVertex(g,P,f);p.x=m.x,u.setXY(e,p)}if(l){let t=x!==Nm?u.getNextVertex(x):u.getFirstVertex(g);const e=u.getPrevVertex(P);for(;t!==e;)t=u.removeVertex(t,!1);if(x!==Nm){const t=u.getXY(x),s=u.getXY(e);if(Math.abs(t.x-s.x)>y){u.queryPoint(x,f);const i=u.insertVertex(g,e,f);t.x=_t(t.x,s.x,.5),u.setXY(i,t)}}}x=Nm}if(t&&(m.y=Z(i,m.y),u.setXY(P,m),!d&&_!==t))if(m.x!==p.x){u.queryPoint(P,f);const t=u.insertVertex(g,P,f);u.setXYCoords(t,p.x,m.y),x=t}else x=P;_=t,p.assign(m),d=!1}if(l){if(x!==Nm){let t=u.getNextVertex(x);for(;t!==Nm;)t=u.removeVertex(t,!1)}const t=u.getFirstVertex(g);let e=u.getLastVertex(g);const s=u.getXY(t),i=u.getXY(e);if(!s.equals(i)&&(u.queryPoint(t,f),e=u.insertVertex(g,Nm,f),Math.abs(s.x-i.x)>y)){const t=u.insertVertex(g,e,f);s.x=_t(s.x,i.x,.5),u.setXY(t,s)}}return e.assignCopy(u.getGeometry(c)),!0}function Cf(t,e){let s=new Sm({vd:t});s.addEnvelope(e,!1);const i=e.width()/180;return s=(new kl).execute(s,i,0,0,null),s}function Sf(t,e){const s=t.getPannableExtent();return Number.isNaN(e)||s.centerAtCoords(e,0),s}function vf(t,e,s){const i=qE();e.querySpheroidData(i);const n=e.getGCS()!==e?e.getSRToGCSTransform():null,r=D(w,100),o=new Fe(0,0,0),a=t.getPointCount(),h=e.getGCS().getUnit().getUnitToBaseFactor();for(let c=0,g=a;c<g;){const e=Math.min(100,g-c);t.queryCoordinates(r,e,c,c+e),n&&(new Gp).transform(n,r,e,r,!1);for(let t=0;t<e;t++){if(r[t].isNAN())continue;r[t].scale(h);const e=Lm(i.majorSemiAxis,i.e2,r[t]);o.addThis(e)}c+=e}const m=Wm(i.majorSemiAxis,i.e2,o);m.scale(1/h);const l=t;if(!new lf(e.getGCS(),m).project(l))return 0;s.length=t.getPathCount();const u=l.calculateArea2D()<0;for(let c=0,g=t.getPathCount();c<g;c++){const t=l.calculateRingArea2D(c),e=u?t<0:t>0;s[c]=e}return u?-1:1}function bf(e,i,n,r,a){if(!i.isPannable()||e.isEmpty())return e;const h=e.getGeometryType();h===s.enumGeometryCollection&&t(0);const l=i.getPannableExtent();Number.isNaN(n)&&(n=l.getCenterX());const u=l.width(),c=.5*u,g=a>0,_=e.queryInterval(0,0);if(!g&&_.width()<c||!o(e.getGeometryType())){const t=_.getCenter();if(Math.abs(t-n)<=c)return e;{const s=new Y,i=et((n-t)/u)*u;s.setShiftCoords(i,0);const r=e.clone();return r.applyTransformation(s),r}}if(h===s.enumPolygon){let t=new am({vd:e.getDescription()});t.addAndExplicitlyOpenAllPaths(e,!1),g&&(t=Yp(t,i,2,a,Number.NaN,null,!0));const s=[];if(!r){{let n=e;g&&(n=new Sm,n.add(t,!1));const r=vf(e,i,s);if(r)r<0&&t.reverseAllPaths();else{const t=n.getPathCount();for(let e=0;e<t;e++)s.push(n.calculateRingArea2D(e)>0)}}r=s}return new wf(null,r,t,null,i,n,3,0,null).geoNormalizePolygonGeometry(!0)}if(h===s.enumPolyline){let t=new am({vd:e.getDescription()});t.addAndExplicitlyOpenAllPaths(e,!1),g&&(t=Yp(t,i,2,a,Number.NaN,null,!0));return new wf(null,null,t,null,i,n,3,0,null).geoNormalizePolylineGeometry(!0)}if(h===s.enumMultiPoint){const t=e,s=t.getAttributeStreamRef(0);let i,r=null,o=n,a=0;const h=.1*u;for(let n=0,m=t.getPointCount();n<m;n++){const t=s.read(2*n);let m=t-o;if(Math.abs(m)>c&&(m=et(m/u)*u,a-=m,Math.abs(a)<h&&(a=0)),0!==a){r||(i=e.clone(),r=i.getAttributeStreamRef(0));const s=t+a;r.write(2*n,s)}o=t}return r?(i.notifyModified(),i):e}m("")}const If=210;class wf{constructor(e,s,i,n,r,o,a,h,m){this.m_bAdjustedAtPoles=0,this.m_inputPoly=i,this.m_progressTracker=m,this.m_originalGeometry=e,this.m_originalSR=n,this.m_polygonRingFlags=s,this.m_pannableSR=r,this.m_poleSnappingTolerance=h,this.m_poleFlags=a,this.m_bAdjustedAtPoles=0,this.m_pannableExtent=Sf(this.m_pannableSR,o),this.m_centralLongitude=Number.isNaN(o)?this.m_pannableExtent.getCenterX():o,this.m_width360=this.m_pannableExtent.width(),this.m_degree=this.m_width360/360,this.m_GCSLargeDelta=If*this.m_degree,t(null===this.m_originalGeometry&&null===this.m_originalSR||null!==this.m_originalGeometry&&null!==this.m_originalSR)}geonormalizeRing(e,s,i,n,r,o,a){let h=i;const l=new am({vd:this.m_inputPoly.getDescription()});l.addPath(this.m_inputPoly,e,!0),0!==this.m_poleFlags&&(this.m_bAdjustedAtPoles|=Ef(!0,l,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,this.m_pannableExtent.width(),this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(h=!1));let u=-1;h&&(u=this.m_originalGeometry.getPathStart(e));const c=l.getAttributeStreamRef(0),g=l.getPointCount();let _=0,d=c.read(0),p=0;const f=3*this.m_pannableSR.getTolerance(0);let x=!1;const y=new w,P=new w;let E=!1;const C=l.hasNonLinearSegments(),S=new w;for(let t=1;t<g;++t){c.queryPoint2D(2*t,S);const e=S.x;let s=e+_;const i=s-d;if(S.x=s,Math.abs(i)>this.m_GCSLargeDelta){if(h){const e=u+t-1,s=u+(t+1<g?t:0),r=o.read(2*e),a=(o.read(2*s)-r)*n;Math.abs(i-a)>1*this.m_degree&&(h=!1)}if(!h){_-=Z(this.m_width360,s-d),s=e+_,++p,E=0!==_,S.x=s}}else x||fs(y,P,S,f)&&(x=!0);E&&(C&&m("error in geonormalize_ring_ for curves"),c.write(2*t,s)),d=s,y.setCoordsPoint2D(P),P.setCoordsPoint2D(S)}p&&l.notifyModified();const v=l.getXY(0),b=l.getXY(g-1);if(w.distance(v,b)<f){const t=this.finalizeGeoNormalizeClosedRing(l,x,r);a.add(t,!1)}else{if(s<0)if(null!==this.m_originalGeometry){t(null!==this.m_originalGeometry);s=this.m_originalGeometry.calculateRingArea2D(e)>0?1:0}else s=1;const i=this.finalizeGeoNormalizeOpenedRing(s>0,l);a.add(i,!1)}}geoNormalizePolygonGeometry(e){t(this.m_originalSR&&this.m_originalGeometry||!this.m_originalGeometry&&!this.m_originalSR),t(this.m_pannableSR.isPannable());let s=null,i=Number.NaN;const n=!!this.m_originalSR&&this.m_originalSR.isPannable();n&&(s=this.m_originalGeometry.getAttributeStreamRef(0),i=this.m_width360/this.m_originalSR.getPannableExtent().width()),this.m_bAdjustedAtPoles=0;const r=new Sm({vd:this.m_inputPoly.getDescription()});for(let t=0,_=this.m_inputPoly.getPathCount();t<_;++t){const o=this.m_polygonRingFlags?this.m_polygonRingFlags[t]?1:0:-1;this.geonormalizeRing(t,o,n,i,e,s,r)}const o=this.m_pannableSR.getTolerance(0),a=this.m_pannableExtent.width()/180;Sx(r,this.m_pannableExtent,.1*o,!1);const h=ge.constructEmpty();if(h.setCoords({env2D:this.m_pannableExtent}),e){let t=!0;for(let e=0;e<2;e++){t=!0;const e=ge.constructEmpty();for(let s=0,i=r.getPathCount();s<i;s++)if(r.queryPathEnvelope(s,e),!(h.xmin<=e.xmin&&h.xmax>=e.xmax||e.xmin>=h.xmax||e.xmax<=h.xmin)){t=!1;break}if(t)break;h.move(.5*this.m_width360,0)}t||h.setCoords({env2D:this.m_pannableExtent})}let m=dl(r,h,o,a,this.m_progressTracker),l=r!==m;const u=this.m_originalGeometry?this.m_originalGeometry.calculateArea2D():1,c=m.calculateArea2D();let g=0;if(c>0&&u<0)g=1;else if(c<=0&&u>0)if(0===c){if(this.m_originalSR){let t=Number.NaN;2===this.m_originalSR.getCoordinateSystemType()?t=this.m_originalSR.getPCSHorizon().calculateArea2D():1===this.m_originalSR.getCoordinateSystemType()&&(t=this.m_originalSR.getPannableExtent().getArea()),u>.99*t&&(g=-1)}}else g=-1;if(0!==g){const t=Cf(m.getDescription(),h);t.add(m,!1),l=!0,m=t}return l&&(m=(new _p).execute(m,this.m_pannableSR,!1,this.m_progressTracker)),m}geoNormalizePolylineGeometry(e){t(this.m_pannableSR.isPannable());let s=null;const i=this.m_originalSR&&this.m_originalSR.isPannable();let n=1;i&&(t(this.m_originalGeometry),n=this.m_width360/this.m_originalSR.getPannableExtent().width(),s=this.m_originalGeometry.getAttributeStreamRef(0));const r=this.m_pannableExtent.width(),o=r*st()*4;let a=e,h=Number.NaN;const l=A.constructEmpty();this.m_bAdjustedAtPoles=0;let u=new am({vd:this.m_inputPoly.getDescription()});for(let _=0,d=this.m_inputPoly.getPathCount();_<d;++_){let e=i;const c=new am({vd:this.m_inputPoly.getDescription()});c.addPath(this.m_inputPoly,_,!0);const g=this.m_inputPoly.isClosedPath(_);0!==this.m_poleFlags&&(this.m_bAdjustedAtPoles|=Ef(g,c,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,r,this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(e=!1));let d=-1;const p=c.getPointCount();let f=!1;e&&(d=this.m_originalGeometry.getPathStart(_),f=this.m_originalGeometry.isClosedPath(_));const x=c.getAttributeStreamRef(0);let y=0,P=x.read(0),E=0;const C=new w,S=new w;let v=!1;const b=c.hasNonLinearSegments(),I=new w;for(let t=1;t<p;++t){x.queryPoint2D(2*t,I);const i=I.x;let r=i+y;const o=r-P;if(I.x=r,Math.abs(o)>this.m_GCSLargeDelta){if(e){const i=d+t-1;let r=d;(!f||t+1<p)&&(r+=t);const a=s.read(2*i),h=(s.read(2*r)-a)*n;Math.abs(o-h)>1*this.m_degree&&(e=!1)}if(!e){y-=Z(this.m_width360,r-P),r=i+y,++E,v=0!==y,I.x=r}}v&&(b&&m("error in geonormalize_ring_ for curves"),x.write(2*t,r)),P=r,C.setCoordsPoint2D(S),S.setCoordsPoint2D(I)}if(E&&c.notifyModified(),a){let e=!1;if(!c.isEmpty()){const s=ge.constructEmpty();if(c.queryEnvelope(s),s.width()>=r||s.ymin<=this.m_pannableExtent.ymin||s.ymax>=this.m_pannableExtent.ymax)e=!0;else{if(Number.isNaN(h)){const e=this.m_centralLongitude-.5*r;h=s.xmin,h+=Math.round((e-s.xmin)/r)*r,h>e&&(h-=r),t(h<=e),h<e&&(h+=r),t(h>=e)}let i=Math.round((h-s.xmin)/r)*r;if(s.xmin+i>h+o&&(i-=r),s.xmin+i<h-o&&(i+=r),l.mergeCoordinate(s.xmin+i),l.mergeCoordinate(s.xmax+i),e=l.width()>=r,!e){const t=new Y;t.setShiftCoords(i,0),c.applyTransformation(t)}}}u.add(c,!1),e&&(u=(()=>{const t=new am({vd:u.getDescription()});for(let e=0,s=u.getPathCount();e<s;++e){const s=new am({vd:u.getDescription()});s.addPath(u,e,!0);const i=mx(s,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);t.add(i,!1)}return t})(),a=!1)}else{const t=mx(c,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);u.add(t,!1)}}if(a)return u;const c=this.m_pannableSR.getTolerance(0),g=this.m_pannableExtent.width()/180;Sx(u,this.m_pannableExtent,.1*c,!1);return dl(u,this.m_pannableExtent,c,g,this.m_progressTracker)}finalizeGeoNormalizeOpenedRing(e,s){const i=s.getPointCount(),n=s.getXY(0),r=s.getXY(i-1);{const e=Math.abs(r.x-n.x),s=Math.round(e/this.m_width360)*this.m_width360;t(Math.abs(e-s)<this.m_pannableSR.getTolerance(0))}const o=Q(r.x-n.x),a=ge.constructEmpty();s.queryLooseEnvelope(a);const h=this.m_pannableExtent.getCenterX();let m=0,l=h-this.m_width360,u=h+this.m_width360;if(o>=0){let t=Math.ceil((l-a.xmin)/this.m_width360);for(t*=this.m_width360;l>a.xmin+t;)t+=this.m_width360;for(;l<a.xmax+t;)t-=this.m_width360;for(m=t,a.width()>720&&(u=l+360*Math.ceil(a.width()/360));u<a.xmax;)u+=this.m_width360}else{let t=Math.ceil((u-a.xmax)/this.m_width360);for(t*=this.m_width360;u<a.xmax+t;)t-=this.m_width360;for(;u>a.xmin+t;)t+=this.m_width360;for(m=t,a.width()>720&&(l=u-360*Math.ceil(a.width()/360));l>a.xmin;)l-=this.m_width360}const c=Math.round(Math.abs(r.x-n.x)/this.m_width360)*this.m_width360,g=o*c,_=a.clone();_.move(m,0);const d=new w(0,0),p=new Y;p.setShiftCoords(m,0),s.applyTransformation(p);const f=new am({vd:s.getDescription()});f.add(s,!1),d.assign(s.getXY(i-1));let x=0,y=f.getXY(0).x;for(;o>0?_.xmax<u:_.xmin>l;)_.move(g,0),p.xd=g,s.applyTransformation(p),y+=g,this.m_pannableExtent.xmin<=y&&this.m_pannableExtent.xmax>=y&&(x=f.getPointCount()-1),s.setXY(0,d),d.assign(s.getXY(i-1)),f.addSegmentsFromPath(s,0,0,i-1,!1);const P=new Sm({vd:f.getDescription()});P.add(f,!1);const E=f.getXY(0),C=f.getXY(f.getPointCount()-1),S=o<0?e:!e,v=P.getPointCount()-1;if(S){const t=new w(C.x,this.m_pannableExtent.ymax);P.lineTo(t);const e=new w(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymax);P.lineTo(e);const s=new w(E.x,this.m_pannableExtent.ymax);P.lineTo(s)}else{const t=new w(C.x,this.m_pannableExtent.ymin);P.lineTo(t);const e=new w(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymin);P.lineTo(e);const s=new w(E.x,this.m_pannableExtent.ymin);P.lineTo(s)}if(P.interpolateAttributesPath(0,v,0),P.getImpl().changeRingStartPoint(x),c>this.m_width360){const t=new Sm({copy:P});p.setShiftCoords(this.m_width360,0),t.applyTransformation(p),P.add(t,!1)}return P}finalizeGeoNormalizeClosedRing(t,e,i){const n=new Sm({vd:t.getDescription()});n.add(t,!1);const r=()=>{const t=n.getPointCount()-2;return n.getSegmentType(t)!==s.enumLine};if(n.hasNonLinearSegments()&&r()){const t=new SE,e=n.getPointCount()-2;n.getSegmentBuffer(e,t,!1),n.removePointFromPath(0,e+1),n.closeLastPathWithSegment(t.get())}else n.removePointFromPath(0,n.getPointCount()-1);const o=ge.constructEmpty();n.queryLooseEnvelope(o);let a=Math.ceil((this.m_pannableExtent.xmin-o.xmin)/this.m_width360);for(a*=this.m_width360;this.m_pannableExtent.xmin>o.xmin+a;)a+=this.m_width360;for(;this.m_pannableExtent.xmin<o.xmax+a;)a-=this.m_width360;if(a+=this.m_width360,0!==a){o.move(a,0);const t=new Y;t.setShiftCoords(a,0),n.applyTransformation(t)}if(this.m_pannableExtent.xmin<=o.xmin&&this.m_pannableExtent.xmax>=o.xmax){if(e){const t=n.calculateArea2D(),e=(new _p).execute(n,this.m_pannableSR,!0,this.m_progressTracker);if(e!==n){const s=e.calculateArea2D();Q(t)!==Q(s)&&e.reverseAllPaths(),n.assignMove(e)}}let t;if(t=new Sm(i?{copy:n}:{move:n}),i)for(;o.xmin<this.m_pannableExtent.xmax;){o.move(this.m_width360,0);const e=new Y;e.setShiftCoords(this.m_width360,0),n.applyTransformation(e),t.add(n,!1)}return t}let h=new Sm({vd:t.getDescription()});h.add(n,!1);const m=e||o.width()>this.m_width360-10*this.m_pannableSR.getTolerance(0);for(;o.xmin<this.m_pannableExtent.xmax;){o.move(this.m_width360,0);const t=new Y;t.setShiftCoords(this.m_width360,0),n.applyTransformation(t),h.add(n,!1)}if(m){const t=h.calculateArea2D();h.setFillRule(1),h=(new _p).execute(h,this.m_pannableSR,!0,this.m_progressTracker);const e=h.calculateArea2D();Q(t)!==Q(e)&&h.reverseAllPaths()}return h}geonormalize_ring_(e,s,i,n,r,o,a){t(0)}}class Df{supportsCurves(){return!0}accelerateGeometry(t,e,s){return Tf(t,e,s)}canAccelerateGeometry(t){return Nf(t)}}function Tf(t,e,s){if(!Nf(t))return!1;ws(e,t,!1);let i=0;const n=t.getGeometryType();return p(n)&&gn(t)&&0!==s&&(i|=t.getImpl().buildQuadTreeAccelerator(s)?1:0),p(n)&&_n(t)&&0!==s&&(i|=t.getImpl().buildQuadTreeForPathsAccelerator(s)?1:0),i>0}function Nf(t){return gn(t)||_n(t)}class Af extends Df{getOperatorType(){return 8}execute(t,e,s,i){return Nc(t,e,s,1,i)}}function qf(t,i,n,r){if(t.isEmpty()||i.isEmpty())return t;const o=t.getDimension(),a=i.getDimension();if(o>a)return t;const h=t.getGeometryType(),m=i.getGeometryType(),u=new ge,c=new ge,g=new ge;t.queryEnvelope(u),i.queryEnvelope(c),g.setCoords({env2D:u}),g.mergeEnvelope2D(c);const _=Cs(n,g,!0),d=Ts(_),p=new ge;if(p.setCoords({env2D:u}),p.inflateCoords(d,d),!p.isIntersecting(c))return t;if(1===o&&2===a){const e=Hf(t,i,m,n,r);if(e)return e}if(h===s.enumPoint){let n;switch(l(m)?(n=new am({vd:i.getDescription()}),n.addSegment(i,!0)):n=i,m){case s.enumPolygon:return Gf(t,n,_);case s.enumPolyline:return Vf(t,n,_);case s.enumMultiPoint:return Yf(t,n,_);case s.enumEnvelope:return Xf(t,n,_);case s.enumPoint:return kf(t,n,_);default:e("invalid shape type")}}else if(h===s.enumMultiPoint)switch(m){case s.enumPolygon:return Rf(t,i,_);case s.enumEnvelope:return Bf(t,i,_);case s.enumPoint:return Lf(t,i,_)}const f=new ge(u);f.inflate(100*_.total());return Gd(t,dl(i,f,0,0,r),n,r)}class Ff{getOperatorType(){return 10002}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,i){return new Mf(t,e,s,i)}execute(t,e,s,i){return this.executeMany(new ce([t]),new ce([e]),s,i).next()}}class Mf extends ue{constructor(t,e,s,i){super(),this.m_progressTracker=i,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=s;const n=e.next();this.m_geomSubtractor=n||new Sm}next(){const t=this.m_inputGeoms.next();return t?(g(t),E(t),this.m_index=this.m_inputGeoms.getGeometryID(),qf(t,this.m_geomSubtractor,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return t(0),!1}getRank(){return t(0),0}}function Gf(t,e,s,i){return 0===X_(e,t,s.total())?t:t.createInstance()}function Vf(t,e,s,i){const n=t.getXY(),r=e.querySegmentIterator(),o=Ts(s),a=o*o;for(;r.nextPath();)for(;r.hasNextSegment();){const e=r.nextSegment(),i=new ge;if(e.queryEnvelope(i),i.inflateCoords(o,o),!i.contains(n))continue;if(e.isIntersectingPoint(n,s.total()))return t.createInstance();let h=e.getStartXY();if(w.sqrDistance(n,h)<=a)return t.createInstance();if(h=e.getEndXY(),w.sqrDistance(n,h)<=a)return t.createInstance()}return t}function Yf(t,e,s,i){const n=e.getImpl().getAttributeStreamRef(0),r=e.getPointCount(),o=t.getXY(),a=Ts(s),h=a*a,m=new w;for(let l=0;l<r;l++){n.queryPoint2D(2*l,m);if(w.sqrDistance(m,o)<=h)return t.createInstance()}return t}function Xf(t,e,s,i){const n=new ge;e.queryEnvelope(n),n.inflate(s.total());const r=t.getXY();return n.contains(r)?t.createInstance():t}function kf(t,e,s,i){const n=Ts(s),r=n*n,o=t.getXY(),a=e.getXY();return w.sqrDistance(o,a)<=r?t.createInstance():t}function Rf(t,e,s,i){const n=new ge;e.queryEnvelope(n),n.inflate(s.total());const r=t.getPointCount();let o=!1;const a=H(r,!1),h=new w;for(let l=0;l<r;l++){if(t.queryXY(l,h),!n.contains(h))continue;0!==k_(e,h,s.total())&&(o=!0,a[l]=!0)}if(!o)return t;const m=t.createInstance();for(let l=0;l<r;l++)a[l]||m.addPoints(t,l,l+1);return m}function Bf(t,e,s,i){const n=new ge;e.queryEnvelope(n),n.inflate(s.total());const r=t.getPointCount();let o=!1;const a=H(r,!1),h=new w;for(let l=0;l<r;l++)t.queryXY(l,h),n.contains(h)&&(o=!0,a[l]=!0);if(!o)return t;const m=t.createInstance();for(let l=0;l<r;l++)a[l]||m.addPoints(t,l,l+1);return m}function Lf(t,e,s,i){const n=t.getImpl().getAttributeStreamRef(0),r=t.getPointCount(),o=e.getXY();let a=!1;const h=H(r,!1),m=Ts(s),l=m*m,u=new w;for(let g=0;g<r;g++){n.queryPoint2D(2*g,u);w.sqrDistance(u,o)<=l&&(a=!0,h[g]=!0)}if(!a)return t;const c=t.createInstance();for(let g=0;g<r;g++)h[g]||c.addPoints(t,g,g+1);return c}function Hf(t,e,i,n,r){const o=new ke;t.queryEnvelope(o);const a=new ge;e.queryEnvelope(a),o.merge(a);const h=.1*o.width(),m=.1*o.height();o.inflateCoords(h,m);const l=new Sm;l.addEnvelope(o,!1);const u=l.getImpl();if(i===s.enumPolygon){const t=e.getImpl();u.add(t,!0)}else u.addEnvelope(e,!0);return new Pp(l,n,-1,r).tryFastImplementation(t)}class zf{getOperatorType(){return 10001}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,i=0){return new jf(t,e,s,i)}execute(t,e,s,i){const n=new ce([t,e]),r=new jf(n,s,i,0).next();return r||m("null output"),r}}function Uf(){return{geom:null,vertexCount:-1,bUnioned:!1,location:new w}}function Of(t,e){return w.compareZorder(t.location,e.location)?-1:t.location.equals(e.location)?0:1}class Wf{constructor(){this.binVertexCount=0,this.geometries=[]}addPair(t){this.binVertexCount+=t.vertexCount,this.geometries.push(t)}sort(){this.geometries.sort(((t,e)=>Of(t,e)))}geomCount(){return this.geometries.length}geomPairs(){return this.geometries}clear(){this.binVertexCount=0,this.geometries.length=0}getBinVertexCount(){return this.binVertexCount}}class jf extends ue{constructor(t,e,s,i,n=!1){super(),this.m_index=-1,this.m_currentDim=-1,this.m_bDone=!1,this.m_unionBins=[],this.m_readyGeoms=K(4),this.m_dimGeomCounts=H(4,0),this.m_addedGeoms=0,this.m_maxDimension=-1,this.m_bHadGeometry=H(4,!1),this.m_complexUnionGeoms=K(4),this.m_totalNonEmptyGeomCounters=H(4,0),this.m_progressTracker=s,this.m_bUnionAllDimensions=!!(4&i),this.m_bPreserveAllPathEnds=!!(8&i),this.m_inputGeoms=t,this.m_spatialReference=e,this.m_options=i,this.m_bIs3D=n}next(){if(this.m_bDone&&this.m_currentDim===this.m_maxDimension)return null;for(;!this.step_(););if(-1===this.m_maxDimension)return null;if(this.m_bUnionAllDimensions){if(-1===this.m_currentDim)for(let e=0;e<=this.m_maxDimension;e++)if(this.m_bHadGeometry[e]){this.m_complexUnionGeoms[e]=this.getResultGeometry(e);for(let s=e+1;s<=this.m_maxDimension;s++)this.m_complexUnionGeoms[s]=this.getResultGeometry(s),this.m_bHadGeometry[s]&&!this.m_complexUnionGeoms[s].isEmpty()&&(this.m_bIs3D?t(0):this.m_complexUnionGeoms[e]=(new Ff).execute(this.m_complexUnionGeoms[e],this.m_complexUnionGeoms[s],this.m_spatialReference,this.m_progressTracker))}for(;this.m_currentDim++,(this.m_currentDim>this.m_maxDimension||this.m_currentDim<0)&&m(""),!this.m_bHadGeometry[this.m_currentDim];);if(this.m_index++,0===this.m_currentDim&&this.m_complexUnionGeoms[this.m_currentDim].getGeometryType()===s.enumPoint){const t=new ii({vd:this.m_complexUnionGeoms[this.m_currentDim].getDescription()});return this.m_complexUnionGeoms[this.m_currentDim].isEmpty()||t.add(this.m_complexUnionGeoms[this.m_currentDim]),t}return this.m_complexUnionGeoms[this.m_currentDim]}return this.m_index=0,this.m_currentDim=this.m_maxDimension,this.getResultGeometry(this.m_maxDimension)}getGeometryID(){return this.m_index}getRank(){return t(0),-1}tock(){return this.step_()}getResultGeometry(t){return this.m_readyGeoms[t]}finishDim(e,i,n){let r=i;if(!n)return 16&this.m_options?(r=Bd([r],1,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D),r):r;if(1&this.m_options)return r;if(1===e){if(!(8&this.m_options)&&(!!(16&this.m_options)||this.m_totalNonEmptyGeomCounters[e]>1)){r=Bd([r],1,this.m_spatialReference,this.m_progressTracker,16|this.m_options,this.m_bIs3D);const e=[0],s=r.getImpl().getIsSimple(0,e);t(this.m_bIs3D||Gs(s))}else 1===this.m_totalNonEmptyGeomCounters[e]&&(this.m_bIs3D?t(0):r=(new _p).execute(r,this.m_spatialReference,!1,this.m_progressTracker))}else this.m_bIs3D?t(0):r=(new _p).execute(r,this.m_spatialReference,!1,this.m_progressTracker);if(0===e&&r.getGeometryType()===s.enumPoint){const t=new ii({vd:r.getDescription()});r.isEmpty()||t.add(r),r=t}return r}static getLevel(t){const e=4,s=_(t);let i=s>0?(Math.log(s)-Math.log(32))/Math.log(e):0;return i<0&&(i=0),Math.floor(i)}step_(){if(this.m_bDone)return!0;let e;if(this.m_inputGeoms?(e=this.m_inputGeoms.next(),null===e?(this.m_bDone=!0,this.m_inputGeoms=null):(this.checkAndThrow(e),e.isEmpty()||this.m_totalNonEmptyGeomCounters[e.getDimension()]++)):e=null,null!==e){const t=e.getDimension();this.m_bHadGeometry[t]=!0,(t>=this.m_maxDimension||this.m_bUnionAllDimensions)&&(this.addGeom(t,!1,e),t>this.m_maxDimension&&!this.m_bUnionAllDimensions&&this.removeAllBinsWithLowerDimension(t))}if(this.m_addedGeoms>0)for(let s=0;s<=this.m_maxDimension;s++){for(;this.m_dimGeomCounts[s]>1;){const t=this.collectGeometriesToUnion(s);if(null===t)break;{let e;e=1&this.m_options?Bd(t,t.length,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D):Ld(t,t.length,this.m_spatialReference,this.m_progressTracker,8|this.m_options,this.m_bIs3D),this.addGeom(s,!0,e)}}if(this.m_bDone&&(t(this.m_dimGeomCounts[s]<=1),0!==this.m_dimGeomCounts[s])){const t=this.m_unionBins[s].entries().next().value,e=t[1].geomPairs()[0].geom,i=t[1].geomPairs()[0].bUnioned;this.m_unionBins[s].clear(),this.m_readyGeoms[s]=this.finishDim(s,e,i)}}return this.m_bDone}addGeom(t,e,s){const i=Uf();i.geom=s;const n=_(s);i.vertexCount=n;const r=ge.constructEmpty();s.queryEnvelope(r),i.location=n>0?r.getCenter():new w(0,0);const o=jf.getLevel(s);if(t+1>this.m_unionBins.length)for(;this.m_unionBins.length<Math.max(2,t+1);)this.m_unionBins.push(new Map);let a=null;const h=this.m_unionBins[t].get(o);h&&(a=h),null===a&&(a=new Wf,this.m_unionBins[t].set(o,a)),i.bUnioned=e,a.addPair(i),this.m_dimGeomCounts[t]++,this.m_addedGeoms++,this.m_maxDimension=Math.max(this.m_maxDimension,t)}removeAllBinsWithLowerDimension(e){t(0)}collectGeometriesToUnion(t){if(1&this.m_options&&!this.m_bDone)return null;let e=null;const s=[];for(const i of this.m_unionBins[t].keys())s.push(i);J(s);for(let i=0;i<s.length;i++){if(-1===s[i])continue;const n=this.m_unionBins[t].get(s[i]);{const r=5e3,o=4,a=n.getBinVertexCount()>r&&n.geomCount()>=o;if(this.m_bDone||a){for(let n=0;n<i;n++){if(-1===s[n])continue;const i=this.m_unionBins[t].get(s[n]);i.sort(),this.m_dimGeomCounts[t]-=i.geomCount(),this.m_addedGeoms-=i.geomCount();for(const t of i.geomPairs())e||(e=new Array),e.push(t.geom);i.clear(),this.m_unionBins[t].delete(s[n]),s[n]=-1}n.sort(),this.m_dimGeomCounts[t]-=n.geomCount(),this.m_addedGeoms-=n.geomCount();for(const t of n.geomPairs())e||(e=new Array),e.push(t.geom);if(n.clear(),this.m_unionBins[t].delete(s[i]),s[i]=-1,!this.m_bDone)break}}}return e}checkAndThrow(t){this.m_bIs3D&&(t.getDimension()>1&&d(),t.hasAttribute(1)||e("Geometry must have Zs")),g(t)}}class Zf extends Df{getOperatorType(){return 3}execute(t,e,s,i=null){return Nc(t,e,s,4,i)}}function Qf(t,e,s){const i=e.getGCSSplitLines();if(null===i)return t;const n=e.getGCS(),r=n.getPannableExtent().width(),o=ge.constructEmpty();t.queryLooseEnvelope(o);const a=A.constructEmpty();o.queryIntervalX(a);const h=i.querySegmentIterator();let m=null;const l=new Y;for(;h.nextPath();)for(;h.hasNextSegment();){const t=h.nextSegment(),e=t.queryInterval(0,0),s=A.constructEmpty();s.setCoordsFromEnvelope(e);let i=0;for(;s.vmax>a.vmin;)s.move(-r),i--;for(;s.vmin<=a.vmax;){if(s.isIntersecting(a)){null===m&&(m=new am);const e=new CE({start:t.getStartXY(),end:t.getEndXY()});0!==i&&(l.setShiftCoords(i*r,0),e.applyTransformation(l)),m.addSegment(e,!0)}s.move(r),++i}}if(null!==m){return Fu(t,m,Ts(bs(n,m,!0)),s)}return t}function Kf(t,e,s){let i=t.getName();return $E(i)||(s||e>0?(i=t.toString(yC.PE_STR_NAME_CANON|yC.PE_STR_AUTH_NONE),i=ex(i)):i=t.toString(yC.PE_STR_AUTH_TOP)),i}function Jf(e,s,i,n){return t(0),""}function $f(t,s=-1){if((s>1||s<-1)&&e("verbosity"),-1===s)return t.toString();{const e=0===s?yC.PE_STR_AUTH_TOP:yC.PE_STR_AUTH_ALL;return t.toString(e)}}function tx(t,s){(s>1||s<-1)&&e("verbosity");let i=yC.PE_STR_FMT_WKT2;return-1!==s&&(i|=0===s?yC.PE_STR_AUTH_TOP:yC.PE_STR_AUTH_ALL),t.toString(i)}function ex(t){return t.toLocaleUpperCase("en-US")}function sx(t,i,n){const r=t.getPCSHorizon();if(r.getGeometryType()!==s.enumPolygon)if(r.getGeometryType()!==s.enumEnvelope)e("");else{const t=r;for(let e=0;e<n;e++)t.contains(i[e])||i[e].setNAN()}else{const e=t.getDefaultPrecisionSR().getTolerance(0),s=r;for(let t=0;t<n;t++)1!==k_(s,i[t],e)&&i[t].setNAN()}}function ix(t,e,s,i){for(let n=0;n<e;n++){if(t[n].y<s.ymin||t[n].y>s.ymax){t[n].setNAN();continue}const e=t[n].x;t[n].x=cx(e,s,i)}}function nx(t,e,i,n){if(t.isEmpty()||1===i)return t;const r=t.getGeometryType();if(r===s.enumPoint){const s=t,n=s.getXY();return 0===hx([n],1,e,i)||n.isNAN()?s.setEmpty():s.setXY(n),t}if(r===s.enumMultiPoint){const s=t,n=t.createInstance(),r=s.getPointCount();n.reserve(r);const o=s.getAttributeStreamRef(0),a=s.getDescription().getAttributeCount()>1,h=new Ge,m=Float64Array.from(o.getArray());if(hx(m,r,e,i)>0)for(let t=0,e=2*r;t<e;t+=2)Number.isNaN(m[t])||(a?(s.getPointByVal(t>>1,h),h.setXYCoords(m[t],m[t+1]),n.add(h)):n.addXY(m[t],m[t+1]));return n}let o=t;const a=e.getOneDegreeGCSUnit(),h=90*a,l=180*a,u=360*a,c=e.getCentralMeridian(),g=.5*a,_=ge.constructEmpty();o.queryEnvelope(_);const d=e.getGCSHorizon(),f=e.getGCSHorisonIsInclusive(),x=d.getGeometryType()===s.enumEnvelope,y=ge.constructEmpty();d.queryEnvelope(y);const P=e.getGCS();if(2!==i&&4!==i||(y.xmin=c-l,y.xmax=y.xmin+u),4===i){if(!(_.width()>u-a)){const t=ge.constructEmpty();t.setCoords({xmin:_.xmin-a,ymin:y.ymin,xmax:_.xmax+a,ymax:y.ymax}),o=(new pp).execute(o,t,P,n);let e=Math.floor((c-_.getCenterX())/u);for(_.move(e*u,0);_.xmin>y.xmax;)e-=1,_.move(-u,0);for(;_.xmin<y.xmin;)e+=1,_.move(u,0);if(0!==e){const t=new Y;t.setShiftCoords(e*u,0),o.applyTransformation(t)}return o}i=2}if(2===i&&(y.xmin=c-l,y.xmax=y.xmin+u),_.ymin<-h||_.ymax>h){const t=ge.constructEmpty();if(t.setCoords({xmin:_.xmin-a,ymin:-h,xmax:_.xmax+a,ymax:h}),o=(new pp).execute(o,t,P,n),o.isEmpty())return o;o.queryEnvelope(_)}if(f&&(y.ymax<_.ymin||y.ymin>_.ymax))return o.createInstance();_.width()>u&&(o=Ex(o,c-l,u,P,!0,0,!0,n),o.queryEnvelope(_));let E=Px(_.xmin,_.xmax,y.xmin,y.xmax,u);if(0!==E&&_.move(E,0),_.xmax>y.xmax||_.xmin<y.xmin){if(_.xmax>y.xmax)for(;_.xmin>=y.xmax;)_.move(-u,0),E-=u;for(;_.xmin<y.xmax-u;)_.move(u,0),E+=u}const C=ws(P,d,!1);if(0!==E){const t=new Y;t.setShiftCoords(E,0),o.applyTransformation(t),E=0}if(f){if(x&&y.containsEnvelope(_))return o;const t=new Array(2);for(let e=0;e<2;e++){let s;if(x?s=p(r)?dl(o,y,C,g,n):dl(o,y,C,0,n):(s=(new Cp).execute(o,d,P,n),s===d&&(s=s.clone())),y.xmin<=_.xmin&&y.xmax>=_.xmax)return s;if(y.xmin>=_.xmin&&y.xmax<=_.xmax)return s;if(t[e]=s,0===e){_.move(-u,0);const t=new Y;t.setShiftCoords(-u,0),o.applyTransformation(t)}}return p(r)?t[0].add(t[1],!1):m("intersect_with_GCS_horizon: unexpected geometry type"),t[0]}{if(y.ymax<_.ymin||y.ymin>_.ymax)return o;let t=0;for(;!o.isEmpty()&&_.xmax>y.xmin;){if(0!==t){const e=new Y;e.setShiftCoords(t,0),o.applyTransformation(e)}if(!(new Zf).execute(o,d,P,n)){o=(new Ff).execute(o,d,P,n),d===o&&(o=o.clone())}if(0!==t){const e=new Y;e.setShiftCoords(-t,0),o.applyTransformation(e)}t-=u,_.move(-u,0)}return o}}function rx(t,e,s,i,n,r){const o={stack:[],error:void 0,hasError:!1};try{if(2===r){return il(t,e,s,i,n)}if(Math.abs(s.x-i.x)>=Math.PI||!gy(s.x,i.x,n))return Number.NaN;s.x>i.x&&(i=q(s,s=i));const a=me(o,new fC,!1),h=me(o,new fC,!1),m=me(o,new fC,!1),l=s.clone();bC.geodeticDistance(t,e,s.x,s.y,i.x,i.y,h,a,null,r);const u=h.val;let c=0,g=1;for(;u*(g-c)>1e-12*t;){const o=.5*(c+g);if(bC.geodeticCoordinate(t,e,s.x,s.y,u*o,a.val,h,m,r),l.x=h.val,l.y=m.val,l.x===n)return l.y;if(gy(s.x,l.x,n))g=o;else{if(!gy(i.x,l.x,n))return Number.NaN;c=o}}return l.y}catch(a){o.error=a,o.hasError=!0}finally{le(o)}}function ox(t,e){let s;if(Array.isArray(t)){const i=t;s=new Float64Array(2*e);for(let t=0,n=0;t<e;t++,n+=2)s[n]=i[t].x,s[n+1]=i[t].y}else s=t;return s}function ax(t,e,s,i){for(let n=0,r=0;n<i;n++,r+=2)e[s+n].x=t[r],e[s+n].y=t[r+1]}function hx(t,e,i,n){if(0===e||1===n)return e;const r=ox(t,e);if(2===n){const s=i.getPannableExtentInGCS();let n=e;for(let t=0,i=2*e;t<i;t+=2)(r[t+1]>s.ymax||r[t+1]<s.ymin)&&(r[t]=Number.NaN,n--);return n?(Cx(r,e,s.xmin,s.width(),!0),t!==r&&ax(r,t,0,e),n):0}const o=i.getOneDegreeGCSUnit(),a=90*o,h=180*o,m=360*o;let l=e;for(let s=0,p=2*e;s<p;s+=2)(r[s+1]>a||r[s+1]<-a)&&(r[s]=Number.NaN,l--);if(!l)return 0;const u=ge.constructEmpty();u.setFromPoints(r,e);const c=i.getGCSHorizon(),g=i.getGCSHorisonIsInclusive(),_=c.getGeometryType()===s.enumEnvelope,d=ge.constructEmpty();if(c.queryEnvelope(d),g&&(d.ymax<u.ymin||d.ymin>u.ymax))return 0;if(g){if(Cx(r,e,d.getCenterX()-h,m,!0),l=e,_)for(let t=0,s=2*e;t<s;t+=2)d.containsCoords(r[t],r[t+1])||(r[t]=Number.NaN,l--);else{const t=ws(i.getGCS(),c,!1),s=new w;for(let i=0,n=2*e;i<n;i+=2){s.setCoords(r[i],r[i+1]);0!==k_(c,s,t)||(r[i]=Number.NaN,l--)}}}else{Cx(r,e,-h,m,!0),l=e;const t=ws(i.getGCS(),c,!1),s=new w;for(let i=0,n=2*e;i<n;i+=2){s.setCoords(r[i],r[i+1]),s.isNAN()&&l--;const e=yx(s.x,d.xmin,d.xmax,m);s.x+=e;0!==k_(c,s,t)&&(r[i]=Number.NaN,l--)}}return l>0&&Array.isArray(t)&&ax(r,t,0,e),l}function mx(t,s,i,n,r,o){if(s.isPannable()||e("fold_into_360_degree_range"),t.isEmpty())return t;let a,h;if(2===s.getCoordinateSystemType()){const t=s.getPannableExtent();h=t.xmin,a=t.width()}else{const t=s.getOneDegreeGCSUnit();a=360*t,h=i-180*t}return Ex(t,h,a,s,n,r,!0,o)}function lx(t,e,s,i){let n,r;if(2===s.getCoordinateSystemType()){const t=s.getPannableExtent();n=t.xmin,r=t.width()}else{const t=s.getOneDegreeGCSUnit();r=360*t,n=i-180*t}Cx(t,e,n,r)}function ux(t,e){const s=e.width();let i=$(t-e.vmin,s);i<0&&(i+=s);return e.snapClip(i+e.vmin)}function cx(t,e,s){return t>e.xmax&&t-e.xmax<s?e.xmax:t<e.xmin&&e.xmin-t<s?e.xmin:t}function gx(t,e,s){if(t[0]<e.vmin||t[0]>e.vmax||s&&t[0]===e.vmax){const s=e.width();return t[0]+=Math.ceil((e.vmin-t[0])/s)*s,t[0]=e.snapClip(t[0]),!0}return!1}function _x(t,e,s,i,n,r,o,a,h){return new wf(t,null,s,e,i,n,o,a,r).geoNormalizePolygonGeometry(h)}function dx(t,e,s,i,n,r,o,a,h){return new wf(t,null,s,e,i,n,o,a,r).geoNormalizePolylineGeometry(h)}function px(t,e,s,i,n){const r=new Vm,o=r.addGeometry(t);return fx(r,o,e,ws(e,t,!1),s,i,n),r.getGeometry(o)}function fx(e,s,i,n,r,o,a){const m={stack:[],error:void 0,hasError:!1};try{t(VE()),i.isPannable()||h("insert_geodetic_points");const l=i.getPannableExtent(),u=i.getGCS(),c=qE();u.querySpheroidData(c);const g=u.getUnit().getUnitToBaseFactor(),_=c.majorSemiAxis,d=c.e2;let p=0;const f=new A;l.queryIntervalX(f);let x=null;const y=new Array(4);2===i.getCoordinateSystemType()?(x=i.getPECoordSys(),o?(y[0]=ux(a,f),y[1]=l.getCenterY(),PC.projToGeog(x,1,y),p=y[0]*g):(y[0]=l.getCenterX(),y[1]=a,PC.projToGeog(x,1,y),p=y[1]*g)):p=a*g,o||0===p||2===r||h("insert_geodetic_points: 1");const P=me(m,new fC,!1),E=new w,C=new w,S=new w,v=new w,b=new w,I=new w;for(let t=e.getFirstPath(s);t!==Nm;t=e.getNextPath(t)){const s=e.getFirstVertex(t);e.queryXY(s,S);let h=!1;const m=e.getNextVertex(s);for(let t=m;t!==Nm;t=e.getNextVertex(t)){if(t===m){if(h)break;h=!0}if(e.queryXY(t,v),o&&(n<a-S.x&&v.x-a>n||n<a-v.x&&S.x-a>n)||!o&&(0!==a||n<-S.y&&v.y>n||n<-v.y&&S.y>n))do{if(Math.abs(S.x-v.x)>=.5*f.width())break;2===i.getCoordinateSystemType()?(y[0]=ux(S.x,f),y[1]=S.y,y[2]=ux(v.x,f),y[3]=v.y,Hx(x,2,y,0),b.x=y[0]*g,b.y=y[1]*g,I.y=y[3]*g):(b.x=S.x*g,b.y=S.y*g,I.y=v.y*g),I.x=(v.x-S.x)*Math.PI*2/f.width()+b.x;let s=0;const n=D(w,2);if(o){if(C.x=p,C.y=rx(_,d,b,I,p,r),Number.isNaN(C.y))break;n[0]=C,s=1}else if(2===r){const t=[0,0];if(s=nl(_,d,b,I,p,t),!s)break;n[0].x=t[0],n[0].y=p,2===s&&(n[1].x=t[1],n[1].y=p)}else{if(C.x=_y(_,d,b,I,r),Number.isNaN(C.x))break;C.y=0,n[0]=C,s=1}let h=-1;for(let m=0;m<s;m++){bC.geodeticDistance(_,d,b.x,b.y,I.x,I.y,P,null,null,r);const s=P.val;bC.geodeticDistance(_,d,b.x,b.y,n[m].x,n[m].y,P,null,null,r);const l=P.val;2===i.getCoordinateSystemType()?(y[0]=n[m].x/g,y[1]=n[m].y/g,PC.geogToProj(x,1,y),o?(E.y=y[1],E.x=a):(E.x=dy(y[0],S.x,v.x,f),E.y=a)):o?(E.x=a,E.y=n[m].y/g):(E.x=dy(n[m].x/g,S.x,v.x,f),E.y=a);const u=s>0?T(l/s,0,1):.5;if(0===u||1===u)continue;if(h>u)continue;const c=e.getPrevVertex(t);e.splitSegment(c,[u],1);const p=e.getNextVertex(c);e.setXYCoords(p,E.x,E.y),h=u}}while(0);S.setCoordsPoint2D(v)}}}catch(l){m.error=l,m.hasError=!0}finally{le(m)}}function xx(e,i){t(i.isPannable());const n=i.getPannableExtent();if(e.getGeometryType()===s.enumPoint){const t=e.getY();return n.ymin<=t&&t<=n.ymax?e:e.createInstance()}const r=ge.constructEmpty();e.queryEnvelope(r);const o=ge.constructEmpty();o.setCoords({env2D:n}),o.xmin=r.xmin,o.xmax=r.xmax,o.inflateCoords(.01*o.height(),0);const a=Is(i,r,!1);let h;return h=o.containsEnvelope(r)?e:dl(e,o,a,0,null),h}function yx(t,e,s,i){return et((.5*(s+e)-t)/i)*i}function Px(t,e,s,i,n){if(t>=s&&e<=i)return 0;return yx(.5*(e+t),s,i,n)}function Ex(t,e,i,n,r,o,a,h){const m=t.getGeometryType(),l=A.constructEmpty();l.setCoords(e,e+i);const u=[0];if(m===s.enumPoint){const e=t;if(u[0]=e.getX(),gx(u,l,a)){const e=r?t:t.clone();return e.setX(u[0]),e}return t}const c=ge.constructEmpty();if(t.queryEnvelope(c),c.isEmpty())return t;if(m===s.enumMultiPoint){const e=r?t:t.clone(),s=e.getImpl(),i=s.getAttributeStreamRef(0),n=2*s.getPointCount();let o=!1;for(let t=0;t<n;t+=2)u[0]=i.read(t),gx(u,l,a)&&(i.write(t,u[0]),o=!0);return o&&s.notifyModifiedFlags(2001),e}const g=A.constructEmpty();if(c.queryIntervalX(g),l.contains(g))return l.vmax,g.vmax,t;const _=ge.constructEmpty();if(_.setCoords({env2D:c}),0===g.width()){let e=g.vmin;e+=Math.ceil((l.vmin-e)/i)*i,e=l.snapClip(e);const s=r?t:t.clone();return s.setAttributeBasic(0,0,e),s}if(m===s.enumEnvelope){const e=r?t:t.clone();return c.intersect(_),e.setEnvelope(c),e}const d=.1*Math.max(c.height(),c.width())*1;_.inflateCoords(0,d);let p=t;const f=n.getTolerance(0),x=new Y;for(;;){const t=Math.floor((g.vmin-e)/i),r=Math.ceil((g.vmax-e)/i);if(!(r-t>3))break;{const a=Math.floor(.5*(r+t));_.xmin=c.xmin-d,_.xmax=e+i*a;const l=dl(p,_,f,o,h);_.xmin=_.xmax,_.xmax=c.xmax+d;const u=dl(p,_,f,o,h);x.setShiftCoords((a-r)*i,0),u.applyTransformation(x),m===s.enumPolygon?p=(new zf).execute(l,u,n,h):(p=l,p.add(u,!1)),p.queryEnvelope(c),c.queryIntervalX(g)}}_.xmin=e,_.xmax=e+i;const y=ge.constructEmpty();y.setCoords({env2D:_}),y.inflateCoords(f,0);const P=Math.floor((c.xmin-_.xmin)/i)*i;let E;P?(_.move(P,0),x.setShiftCoords(-P,0)):x.setIdentity(),E=m===s.enumPolyline?new am({vd:p.getDescription()}):new Sm({vd:p.getDescription()});const C=ge.constructEmpty(),S=ge.constructEmpty();for(;c.xmax>_.xmin;){const t=dl(p,_,f,0,h);t.queryEnvelope(S);let e=!1;e=m===s.enumPolyline?!t.isEmpty()&&(S.width()>f||S.height()>f):!t.isEmpty()&&(m!==s.enumPolygon||S.width()>f),e&&(t.applyTransformation(x),t.queryEnvelope(S),E.queryEnvelope(C),C.inflateCoords(f,f),C.isIntersecting(S)&&m===s.enumPolygon?E=(new zf).execute(E,t,n,h):E.add(t,!1)),_.move(i,0),x.shiftCoords(-i,0)}return E}function Cx(t,e,s,i,n=!0){const r=new A;r.setCoords(s,s+i);const o=[0];if(Array.isArray(t)){const s=t;for(let t=0;t<e;t++)r.containsRightExclusive(s[t].x)||(o[0]=s[t].x,gx(o,r,n),s[t].x=o[0])}else{const s=t;for(let t=0;t<e;t++){const e=t<<1;r.containsRightExclusive(s[e])||(o[0]=s[e],gx(o,r,n),s[e]=o[0])}}}function Sx(e,i,n,r=!0){if(e.isEmpty())return;const a=e.getGeometryType();if(!r||a!==s.enumPolygon)if(o(a)){let s=!1;if(p(a)&&e.hasNonLinearSegments()){const r=e.getImpl(),o=r.getAttributeStreamRef(0),a=r.getSegmentFlagsStreamRef();t(null!==a);for(let t=0,e=r.getPathCount();t<e;t++){let e=!0;const h=r.isClosedPath(t),m=r.getPathEnd(t);if(h&&r.getPathSize(t)>0){e=1===(31&a.read(m-1))}for(let l=r.getPathStart(t);l<m;l++){if(1===(31&a.read(l))){if(e){const t=o.read(2*l),e=cx(t,i,n);e!==t&&(s=!0,o.write(2*l,e))}e=!0}else e=!1}}}else{const t=e.getImpl(),r=t.getAttributeStreamRef(0);for(let e=0,o=t.getPointCount();e<o;e++){const t=r.read(2*e),o=cx(t,i,n);o!==t&&(s=!0,r.write(2*e,o))}}s&&e.getImpl().notifyModifiedFlags(2001)}else if(a===s.enumEnvelope){const t=e,s=ge.constructEmpty();t.queryEnvelope(s),s.xmin=cx(s.xmin,i,n),s.xmax=cx(s.xmax,i,n),t.setEnvelope(s)}else if(a===s.enumPoint){const t=e;t.setX(cx(t.getX(),i,n))}else m("")}function vx(t,e,s){const i=new w;return i.x=cx(t.x,e,s),i.y=t.y,i}function bx(t,e){if(e.isEmpty())return 0;const s=t.getPECoordSys();if(s.getProjection().getCode()===yC.PE_PRJ_AZIMUTHAL_EQUIDISTANT){const i=qE();t.querySpheroidData(i);const n=s.getParameters();if(null===n[yC.PE_PARM_LAM0])return 0;if(null===n[yC.PE_PARM_PHI0])return 0;const r=[n[yC.PE_PARM_LAM0].getValue(),n[yC.PE_PARM_PHI0].getValue()];PC.geogToProj(s,1,r);const o=new w(r[0],r[1]),a=ge.constructEmpty();e.queryEnvelope(a);const h=D(w,4);a.queryCorners(h);let m=0;const l=t.getOneMeter();let u=Math.max(i.majorSemiAxis,i.minorSemiAxis)*Math.PI,c=Math.min(i.majorSemiAxis,i.minorSemiAxis)*Math.PI;c-=u/180,u*=l,c*=l;for(let t=0;t<4;t++){const e=w.distance(h[t],o);if(e>u)m++;else if(e>c)return-1}if(0===m)return 1;if(4===m){const t=ge.constructEmpty();return t.setCoords({center:o,width:u,height:u}),a.isIntersectingNe(t)?-1:0}return-1}return-1}function Ix(e,i,n,r){const o=e.getGeometryType();t(o===s.enumPolygon||o===s.enumPolyline||o===s.enumMultiPoint);const a=i.getCoordinateSystemType();if(2===a){let t=e;if(0===n){const n=bx(i,e);if(0===n)return e.createInstance();if(1===n)return e;const o=i.getPCSHorizon(),a=o.getGeometryType(),h=i.getDefaultPrecisionSR();if(a===s.enumEnvelope){const s=ge.constructEmpty();o.queryEnvelope(s);t=dl(e,s,Is(h,s,!1),5e4*i.getOneMeterPCSUnit(),r)}else(new Af).execute(o,e,h,r)||(t=(new Cp).execute(t,o,h,r),t===o&&(t=t.clone()))}else if(i.isPannable()){const e=ge.constructEmpty();t.queryEnvelope(e);const a=i.getPannableExtent();a.containsEnvelope(e)||(Sx(t,a,i.getTolerance(0)),2!==n&&4!==n||(t=xx(t,i)),4!==n?t=mx(t,i,0,!0,1e5*i.getOneMeterPCSUnit(),r):o===s.enumPolygon&&e.width()>2*a.width()&&(t=Ex(t,-2*a.width(),2*a.width(),i,!0,0,!0,r)))}return t}if(t(1===a),o===s.enumMultiPoint)return Sx(e,i.getPannableExtent(),i.getTolerance(0)),e;{const t=ge.constructEmpty();e.queryEnvelope(t);let n=e;const a=i.getPannableExtent();if(t.ymin<a.ymin||t.ymax>a.ymax){const e=Math.max(1,t.calculateToleranceFromEnvelope()),s=new ge(t.xmin-e,a.ymin,t.xmax+e,a.ymax);if(n=(new pp).execute(n,s,i,r),n.isEmpty())return n}return o===s.enumPolygon&&t.width()>2*a.width()&&(n=Ex(n,-2*a.width(),2*a.width(),i,!0,0,!0,r)),n}}function wx(e,s,i,n,r,o){const a=n.getCoordinateSystemType();if(2===a){if(0===r)i!==e&&tt(i,e,s),sx(n,i,s);else if(i!==e&&tt(i,e,s),n.isPannable()){const t=n.getTolerance(0);ix(i,s,n.getPannableExtent(),t),lx(i,s,n,0)}}else{t(1===a);const r=n.getTolerance(0),o=n.getPannableExtent();for(let t=0;t<s;t++)i[t].assign(vx(e[t],o,r))}}function Dx(t,e){const s=e.getPointCount();if(!s)return;const i=e.getImpl(),n=i.getAttributeStreamRef(0),r=t;PC.geogToProj(r,s,n.getArray()),i.notifyModifiedFlags(2001)}function Tx(t,e,s,i){if(!s)return;const n=t.getPECoordSys();if(1===s){const s=[e[0].x,e[0].y];if(PC.geogToProj(n,1,s),i){const{first:i,second:n}=t.m_peCoordSysVal.getGeogToProjFactors();s[0]=i*(e[0].x-t.getCentralMeridian())+n}return void e[0].setCoords(s[0],s[1])}const r=t.isPannable(),o=r?t.getPannableExtent().width():0,a=179*o/360;let h=0;r&&(h=t.getCentralMeridian());const m=256,l=new Float64Array(2*m);for(let u=0;u<s;){for(let t=u;t<s&&e[t].isNAN();++t)u++;let c=Math.min(m,s-u);if(c>0){for(let t=1,s=u+1;t<c;++t,++s)if(e[s].isNAN()){c=t;break}for(let t=0;t<c;++t){const s=t<<1;l[s]=e[u+t].x,l[s+1]=e[u+t].y}if(PC.geogToProj(n,c,l),i){const{first:s,second:i}=t.m_peCoordSysVal.getGeogToProjFactors();for(let t=0;t<c;++t){l[t<<1]=s*(e[u+t].x-h)+i}}if(r)for(let t=0,s=u;t<c;t++,s++){const i=t<<1,n=l[i],r=Q(n),m=e[s].x-h;r*Q(m)<0&&Math.abs(n)>a&&(l[i]-=r*o)}ax(l,e,u,c),u+=c}}}function Nx(t,e,s,i){const n=t.getSRToGCSTransform();return(new Gp).transform(n,e,s,i,!1)}function Ax(t,e,s,i){const n=new ii({vd:e.getDescription()});let r;n.addPoints(e,0,-1),r=(new Gp).execute(n,t,i);const o=e.getPointCount();if(s.setEmpty(),t.getInputSR().isPannable()){if(o!==r.getPointCount())return!1;const i=new ge;e.queryEnvelope(i);const n=new ge;r.queryEnvelope(n);const a=i.width(),h=n.width();if(0!==a&&0!==h){const e=h/a,s=t.getOutputSR().getPannableExtent().width()/t.getInputSR().getPannableExtent().width();if(Math.abs(e/s-1)>1e-10)return!1}else if(0!==a||0!==h)return!1;s.add(e,!1);for(let t=0;t<o;t++){const e=r.getXY(t);s.setXY(t,e)}return!0}return!1}function qx(e,s,i){t(!i||e.isPannable());const n=s.getPointCount();if(!n)return;const r=s.getImpl(),o=r.getAttributeStreamRef(0),a=e.getPECoordSys();let h=0;const m=o.readRange(0,2*n);let l=()=>{PC.geogToProj(a,n,m)};const u=e.isPannable()&&!i,c=u?e.getPannableExtent().width():0,g=179*c/360;if(e.isPannable()&&(h=e.getCentralMeridian(),i)){const t=e.m_peCoordSysVal.getGeogToProjFactors(),s=t.first,i=t.second;l=()=>{PC.geogToProj(a,n,m);for(let t=0;t<n;t++){const e=t<<1,n=o.read(e),r=s*(n-h)+i;m[e]=r}}}if(l(),u)for(let t=0;t<n;t++){const e=t<<1,s=m[e],i=Q(s),n=o.read(e)-h;i*Q(n)<0&&Math.abs(s)>g&&(m[e]+=-i*c)}o.writeRangeFromArray(0,2*n,m,!0,1),r.notifyModifiedFlags(2001)}function Fx(t,e,i){switch(e.getGeometryType()){case s.enumLine:return void ny(t,e,i);case s.enumBezier:return void ly(t,e,i);case s.enumEllipticArc:return void oy(t,e,i);case s.enumBezier2:return void uy();case s.enumRationalBezier2:return void cy();default:m("")}}function Mx(e,s,i){if(!s.hasNonLinearSegments())return void qx(e,s,i);if(t(!i||e.isPannable()),s.isEmpty())return;const n=0,r=e.getPECoordSys(),o=e.isPannable(),a=o?e.getPannableExtent().width():0,h=179*a/360;let m=0;o&&(m=e.getCentralMeridian());const l=s.createInstance();l.reserveParts(s.getPointCount(),s.getPathCount());const u=s.getImpl(),c=new SE;for(let t=0,g=s.getPathCount();t<g;++t)if(u.hasNonLinearSegmentsPath(t)){let s=!0,n=-1;const r=u.getPathStart(t),o=r+u.getSegmentCountPath(t);u.isClosedPath(t)&&(n=o-1);const a=new w;for(let t=r;t<o;++t){if(u.getSegmentBuffer(t,c,!1),Fx(e,c.get(),i),!s){c.get().getStartXY().equals(a)||c.get().moveTo(a)}if(t!==n)l.addSegment(c.get(),s);else{if(s){const t=new Ge;c.get().queryStart(t),l.startPathPoint(t)}l.closeLastPathWithSegment(c.get())}a.assign(c.get().getEndXY()),s=!1}}else{const e=1024;let i,c=u.getPathSize(t),g=Math.min(c,e);l.insertPath(-1,s,t,!0);const _=u.getAttributeStreamRef(0),d=l.getAttributeStreamRef(0);for(let s=u.getPathStart(t),l=u.getPathEnd(t);s<l;){if(i=_.readRange(s,g),PC.geogToProj(r,g,i),o)for(let t=0;t<g;t++){const e=t<<1,s=i[e],r=Q(s),o=_.read(2*(n+t))-m;r*Q(o)<0&&Math.abs(s)>h&&(i[e]+=-r*a)}d.writeRangeFromArray(s,g,i,!0,1),s+=g,c-=g,g=Math.min(c,e)}}s.assignMove(l)}function Gx(t,e,s){const i=1e3;let n=s.getPointCount();if(!n)return;const r=s.getImpl(),o=r.getAttributeStreamRef(0);let a=Math.min(n,i),h=0;const m=t.getPECoordSys();Number.isNaN(e)&&(e=0);const l=t.isPannable(),u=t.getOneDegreeGCSUnit(),c=360*u,g=179*u;let _;for(;n;){if(_=o.readRange(2*h,2*a),Hx(m,a,_,e),l)for(let t=0;t<a;t++){const s=t<<1,i=_[s]-e,n=Q(i),r=o.read(2*(h+t));n*Q(r)<0&&Math.abs(i)>g&&(_[s]+=-n*c)}o.writeRangeFromArray(2*h,2*a,_,!0,1),h+=a,n-=a,a=Math.min(n,i)}r.notifyModifiedFlags(2001)}function Vx(t,e,i){switch(i.getGeometryType()){case s.enumLine:return void Yx(t,e,i);case s.enumBezier:return void Rx(t,e,i);case s.enumEllipticArc:return void Xx(t,e,i);case s.enumBezier2:return void Bx();case s.enumRationalBezier2:return void Lx();default:m("")}}function Yx(t,e,s){const i=[s.getStartXY(),s.getEndXY()];Ux(t,e,i,2),s.setStartXY(i[0]),s.setEndXY(i[1]),s.normalizeAfterEndpointChange()}function Xx(t,e,s){if(0===s.projectionBehavior())kx(t,e,s);else{const i=s.isClosed()&&s.isMajor(),n=[s.getStartXY(),i?s.getCenter():s.getEndXY()],r=[n[0].clone(),n[1].clone()];ay(t,e,r,2);const o=new Y;o.initializeFromTwoPointsArray(n,r),s.applyTransformation(o);const a=i?0:1;s.setCoordsForIntersector(r[0],r[a],!1)}}function kx(t,e,s){hy(!1,t,e,s,!1)}function Rx(t,e,s){const i=D(w,4);s.queryControlPoints(i),ay(t,e,i,4),s.setControlPoints(i)}function Bx(e,s,i){t(0)}function Lx(e,s,i){t(0)}function Hx(e,s,i,n){const r=PC.projToGeogCenter(e,s,i,n);for(let o=0;o<s;++o){const e=o<<1;t(Number.isFinite(i[e]+i[e+1]))}return r}function zx(t,e,s){if(!s.hasNonLinearSegments())return void Gx(t,e,s);if(s.isEmpty())return;const i=t.getPECoordSys();Number.isNaN(e)&&(e=0);const n=t.isPannable(),r=t.getOneDegreeGCSUnit(),o=360*r,a=179*r,h=s.createInstance();h.reserveParts(s.getPointCount(),s.getPathCount());const m=s.getImpl(),l=new SE;for(let u=0,c=s.getPathCount();u<c;++u)if(m.hasNonLinearSegmentsPath(u)){let s=!0,i=-1;const n=m.getPathStart(u),r=n+m.getSegmentCountPath(u);m.isClosedPath(u)&&(i=r-1);const o=new w;for(let a=n;a<r;++a){if(m.getSegmentBuffer(a,l,!1),Vx(t,e,l.get()),!s){l.get().getStartXY().equals(o)||l.get().moveTo(o)}if(a!==i)h.addSegment(l.get(),s);else{if(s){const t=new Ge;l.get().queryStart(t),h.startPathPoint(t)}h.closeLastPathWithSegment(l.get())}o.assign(l.get().getEndXY()),s=!1}}else{const t=1e3;let r,l=m.getPathSize(u),c=Math.min(l,t);h.insertPath(-1,s,u,!0);const g=m.getAttributeStreamRef(0),_=h.getAttributeStreamRef(0);for(let s=m.getPathStart(u),h=m.getPathEnd(u);s<h;){if(r=g.readRange(2*s,2*c),Hx(i,c,r,e),n)for(let t=0;t<c;t++){const i=t<<1,n=r[i]-e,h=Q(n),m=g.read(2*s);h*Q(m)<0&&Math.abs(n)>a&&(r[i]+=-h*o)}_.writeRangeFromArray(2*s,2*c,r,!0,1),s+=c,l-=c,c=Math.min(l,t)}}s.assignMove(h)}function Ux(t,e,s,i){const n=t.getPECoordSys();Number.isNaN(e)&&(e=0);const r=t.isPannable(),o=t.getOneDegreeGCSUnit(),a=360*o,h=179*o,m=256,l=new Float64Array(2*m);for(let u=0;u<i;){for(let e=u;e<i&&s[e].isNAN();++e)u++;let t=Math.min(m,i-u);if(t>0){for(let e=1,i=u+1;e<t;++e,++i)if(s[i].isNAN()){t=e;break}for(let e=0;e<t;e++){const t=e<<1;l[t]=s[u+e].x,l[t+1]=s[u+e].y}if(Hx(n,t,l,e),r)for(let i=0,n=u;i<t;++i,++n){const t=i<<1,r=s[n].x,o=l[t]-e,m=Q(o);m*Q(r)<0&&Math.abs(o)>h&&(l[t]-=m*a)}for(let e=0;e<t;e++){const t=e<<1;s[u+e].x=l[t],s[u+e].y=l[t+1]}u+=t}}}function Ox(e,s,i,n){t(0)}function Wx(t,e,s){let i=e.getPointCount();if(!i)return!1;const n=e.getImpl(),r=n.getAttributeStreamRef(0);let o=null;const a=t.getInputSR(),h=t.getOutputSR();a.getVCS(),h.getVCS();const m=a.getOneDegreeGCSUnit(),l=h.getOneDegreeGCSUnit(),u=t.isVertical();u&&e.hasAttribute(1)&&(o=n.getAttributeStreamRef(1));const c=t.getDatumTransformation(),g=!!c&&1===c.getType();if(g||null===o||(Ox(o.getArray()),o=null),!c||0===c.count()){const t=a.getGcsUnitFactor()/h.getGcsUnitFactor(),e=(a.getPrimeMeridian()-h.getPrimeMeridian())*l,s=-90*m,o=90*m;let u=0;const c=r.getArray(),g=[0];for(let n=1,r=2*i;n<r;)g[0]=c[n],u|=Ht(g,s,o)?1:0,c[n]=g[0],n+=2;if(0!==e||1!==t){u=1;const s=r.getArray();for(let n=0,r=2*i;n<r;){let i=s[n];i*=t,i+=e,s[n]=i,s[n+1]*=t,n+=2}}return 0!==u&&n.notifyModifiedFlags(2001),!!u}const _=1e3;let d=Math.min(i,_);const p=new Array(d),f=new Array(d);let x=null;null!==o&&(x=new Float64Array(d));let y=0,P=Number.NaN,E=Number.NaN;const C=360*l,S=l/m;s&&(E=90*l,P=89.9*m,f.fill(0));let v=!0,b=0;for(;i;){let t=!1;const e=r.readRange(2*y,2*d);for(let s=0;s<d;s++)p[s]=e[s<<1];if(s)for(let s=0;s<d;s++){const i=1+(s<<1),n=Math.abs(e[i])-P;if(n>0){const r=e[i];e[i]=Z(P,r),f[s]=Z(n,r),t=!0}}const n=e[0];if(g){const t=c;x&&o.queryRange(y,d,x,!0,1),t.transform(!1,e,x,d),x&&o.writeRangeFromArray(y,d,x,!0,1)}else{c.transform(!1,e,d)}v&&(b=e[0]-S*n,v=!1);for(let s=0;s<d;s++){const t=s<<1,i=e[t]-p[s]*S-b;Math.abs(i)>200&&(e[t]+=i>0?-C:C)}if(t){for(let t=0;t<d;t++)if(f[t]){const s=1+(t<<1);e[s]+=S*f[t],e[s]>E?e[s]=E:e[s]<-E&&(e[s]=-E)}f.fill(0)}r.writeRangeFromArray(2*y,2*d,e,!0,1),u&&o&&o.writeRangeFromArray(y,d,x,!0,1),y+=d,i-=d,d=Math.min(i,_)}return n.notifyModifiedFlags(2001),!0}function jx(t,e,i){switch(e.getGeometryType()){case s.enumLine:return Jx(t,e,i);case s.enumBezier:return ey(t,e,i);case s.enumEllipticArc:return $x(t,e,i);case s.enumBezier2:return sy();case s.enumRationalBezier2:return iy();default:m("")}}function Zx(t,e,s){if(!e.hasNonLinearSegments())return Wx(t,e,s);if(e.isEmpty())return!1;const i=e.createInstance();i.reserveParts(e.getPointCount(),e.getPathCount());const n=e.getImpl(),r=new SE;for(let o=0,a=e.getPathCount();o<a;++o){let e=!0,a=-1;const h=n.getPathStart(o),m=h+n.getSegmentCountPath(o);n.isClosedPath(o)&&(a=m-1);const l=new w;for(let o=h;o<m;++o){if(n.getSegmentBuffer(o,r,!1),jx(t,r.get(),s),!e){r.get().getStartXY().equals(l)||r.get().moveTo(l)}if(o!==a)i.addSegment(r.get(),e);else{if(e){const t=new Ge;r.get().queryStart(t),i.startPathPoint(t)}i.closeLastPathWithSegment(r.get())}l.assign(r.get().getEndXY()),e=!1}}return e.assignMove(i),!0}function Qx(t,e,s,i,n,r){if(t.isIdentityGeogToGeog()){const s=90*t.getInputSR().getOneDegreeGCSUnit();let n=0;const r=[0];for(let t=0;t<i;t++)r[0]=e[t].y,n|=Ht(r,-s,s)?1:0,e[t].y=r[0];return n}const o=t.getInputSR(),a=t.getOutputSR(),h=o.getVCS(),m=a.getVCS(),l=o.getOneDegreeGCSUnit(),u=90*l,c=a.getOneDegreeGCSUnit(),g=t.isVertical(),_=t.getDatumTransformation(),d=!!_&&1===_.getType();if(g||(s=null),!_||0===_.count()){let t=0;const n=[0];for(let s=0;s<i;s++)n[0]=e[s].y,t|=Ht(n,-u,u)?1:0,e[s].y=n[0];return t|=kC(o.getGCS(),h,a.getGCS(),m,e,s,i)?1:0,t}d||null===s||Ox();const p=1024;let f=Math.min(i,p);const x=new Array(f),y=H(f,0);let P=0,E=Number.NaN,C=Number.NaN;const S=360*c,v=c/l;n&&(C=90*c,E=89.9*l);let b=!0,I=0,w=i;for(;w;){let t=!1;for(let s=0;s<f;s++)x[s]=e[s+P].x;if(n)for(let s=0;s<f;s++){const i=Math.abs(e[s+P].y)-E;if(i>0){const n=e[s+P].y;e[s+P].y=Z(E,n),y[s]=Z(i,n),t=!0}}const i=e[0].x;if(d){_.transform(!1,e,s,f)}else{_.transform(!1,e,f)}b&&(I=e[0].x-v*i,b=!1);for(let s=0;s<f;s++){const t=e[P+s].x-x[s]*v-I;Math.abs(t)>200&&(t>0?e[P+s].x-=S:e[P+s].x+=S)}if(t){for(let t=0;t<f;t++)y[t]&&(e[P+t].y+=v*y[t],e[P+t].y>C?e[P+t].y=C:e[P+t].y<-C&&(e[P+t].y=-C));y.fill(0,0,f)}P+=f,w-=f,f=Math.min(w,p)}return 1}function Kx(t,e,s,i,n,r){let o=0,a=!0,h=0;for(let m=0;m<i;++m)e[m].isNAN()?a||(o|=Qx(t,e.slice(h,m-h),s?s.slice(h,m-h):null,m-h,n),h=m,a=!0):a&&(h=m,a=!1);return a||(o|=Qx(t,0===h?e:e.slice(h),s?0===h?s:s.slice(h):null,i-h,n)),0!==o}function Jx(t,e,s){const i=[e.getStartXY(),e.getEndXY()],n=[0,0];let r=null;e.hasAttribute(1)&&(r=n,r[0]=e.getAttributeAsDbl(0,1,0),r[1]=e.getAttributeAsDbl(1,1,0));const o=Kx(t,i,r,2,s);return e.setStartXY(i[0]),e.setEndXY(i[1]),r&&(e.setStartAttribute(1,0,r[0]),e.setEndAttribute(1,0,r[1])),e.normalizeAfterEndpointChange(),o}function $x(t,e,s){if(0===e.projectionBehavior())return ty(t,e,s);const i=e.getStartXY().equals(e.getEndXY()),n=D(w,3),r=D(w,3),o=[0,0,0];let a=null;n[0].assign(e.getStartXY()),n[1].assign(i?e.getCenter():e.getEndXY());let h=!1;e.hasAttribute(1)&&(a=o,a[0]=e.getAttributeAsDbl(0,1,0),a[1]=e.getAttributeAsDbl(1,1,0),a[2]=_t(a[0],a[1],.5),i&&(a[1]=a[2])),r[0].setCoordsPoint2D(n[0]),r[1].setCoordsPoint2D(n[1]);const m=new Y;if(i||e.isDegenerateToLine())h=Kx(t,r,a,2,s),m.initializeFromTwoPoints(n[0],n[1],r[0],r[1]);else{const i=new w;e.queryCoord2D(.5,i),n[2].setCoordsPoint2D(i),r[2].setCoordsPoint2D(i),h=Kx(t,r,a,3,s),m.setFromTwoTriangles(n,r)}return m.isIdentity()||(e.applyTransformation(m),e.setStartXY(r[0]),e.setEndXY(i?r[0]:r[1]),e.normalizeAfterEndpointChange()),a&&(e.setStartAttribute(1,0,a[0]),e.setEndAttribute(1,0,i?a[0]:a[1])),h}function ty(t,e,s){const i=[e.getStartXY(),e.getEndXY(),e.getInteriorPoint(),e.getCenter()];let n=4;e.isDegenerateToLine()&&(n=2);const r=[0,0,0,0];let o=null;if(e.hasAttribute(1)){o=r,o[0]=e.getAttributeAsDbl(0,1,0),o[1]=e.getAttributeAsDbl(1,1,0);const t=_t(o[0],o[1],.5);o[2]=t,o[3]=t}const a=e.getStartXY().equals(e.getEndXY())&&!e.isDegenerateToLine(),h=Kx(t,i,o,n,s);return a?e.constructCircleCenterAndPoint(i[3],i[0],!e.isClockwise()):e.isDegenerateToLine()?e.constructLineCircularArc(i[0],i[1]):e.constructCircularArcThreePoint(i[0],i[1],i[2]),o&&(e.setStartAttribute(1,0,o[0]),e.setEndAttribute(1,0,o[1])),h}function ey(t,e,s){const i=D(w,4);e.queryControlPoints(i);const n=[0,0,0,0];let r=null;e.hasAttribute(1)&&(r=n,r[0]=e.getAttributeAsDbl(0,1,0),r[3]=e.getAttributeAsDbl(1,1,0),r[1]=_t(r[0],r[3],.5),r[2]=r[1]);const o=Kx(t,i,r||null,i.length,s);return e.setControlPoints(i),r&&(e.setStartAttribute(1,0,r[0]),e.setEndAttribute(1,0,r[3])),e.normalizeAfterEndpointChange(),o}function sy(e,s,i){return t(0),!1}function iy(e,s,i){return t(0),!1}function ny(t,e,s){const i=[e.getStartXY(),e.getEndXY()];Tx(t,i,2,s),e.setStartXY(i[0]),e.setEndXY(i[1]),e.normalizeAfterEndpointChange()}function ry(t,e,s,i){Tx(t,e,s,i)}function oy(t,e,s){if(0===e.projectionBehavior())my(t,e,s);else{const i=e.isClosed()&&e.isMajor(),n=[e.getStartXY(),i?e.getCenter():e.getEndXY()],r=[n[0].clone(),n[1].clone()];ry(t,r,2,s);const o=new Y;o.initializeFromTwoPointsArray(n,r),e.applyTransformation(o);const a=i?0:1;e.setCoordsForIntersector(r[0],r[a],!1)}}function ay(t,e,s,i){Ux(t,e,s,i);const n=new ge;n.setFromPoints(s,i);const r=t.getOneDegreeGCSUnit(),o=360*r,a=180*r;if(n.width()>a){for(let t=0;t<i;t++)for(;s[t].x<e;)s[t].x+=o;if(n.setFromPoints(s,i),n.xmax>a+e)for(let t=0;t<i;t++)s[t].x-=o}}function hy(t,e,s,i,n){const r=D(w,3);let o=0,a=!1,h=!1;const m=i.isDegenerateToLine();m?(r[0].assign(i.getStartXY()),r[1].assign(i.getEndXY()),r[2].setCoords(0,0),o=2):i.isClosed()&&i.isMajor()?(a=!0,h=!i.isClockwise(),r[0].assign(i.getStartXY()),r[1].assign(i.getCenter()),r[2].setCoords(0,0),o=2):(r[0].assign(i.getStartXY()),r[1].assign(i.getEndXY()),r[2].assign(i.getInteriorPoint()),o=3),t?ry(e,r,o,n):ay(e,s,r,o),m?i.constructLineCircularArc(r[0],r[1]):a?i.constructCircleCenterAndPoint(r[1],r[0],h):i.constructCircularArcThreePoint(r[0],r[1],r[2])}function my(t,e,s){hy(!0,t,0,e,s)}function ly(t,e,s){const i=D(w,4);e.queryControlPoints(i),ry(t,i,4,s),e.setControlPoints(i)}function uy(e,s,i){t(0)}function cy(e,s,i){t(0)}function gy(t,e,s){const i=fm(t),n=Pm(i,fm(e)),r=Pm(i,fm(s));return 0===r||(n>0&&r>0&&r<=n||n<0&&r<0&&r>=n)}function _y(e,s,i,n,r){const o={stack:[],error:void 0,hasError:!1};try{const a=i.clone(),h=n.clone();if(2===r){const t=[0,0];return nl(e,s,a,h,0,t),t[0]}if(a.y>h.y){const t=new w;t.assign(a),a.assign(h),h.assign(t)}const m=me(o,new fC,!1),l=me(o,new fC,!1),u=me(o,new fC,!1),c=new A;if(c.setCoords(a.y,h.y),!c.containsCoordinate(0)||Math.abs(a.x-h.x)>=Math.PI)return Number.NaN;if(a.x===h.x)return a.x;bC.geodeticDistance(e,s,a.x,a.y,h.x,h.y,l,m,null,r);const g=l.val;let _=0,d=1;const p=a.clone();for(;g*(d-_)>1e-12*e;){const i=.5*(_+d);if(bC.geodeticCoordinate(e,s,a.x,a.y,g*i,m.val,l,u,r),p.x=l.val,p.y=u.val,c.setCoords(a.y,p.y),0===p.y)return p.x;if(c.containsCoordinate(0))d=i;else{if(c.setCoords(h.y,p.y),!c.containsCoordinate(0))return t(!1),Number.NaN;_=i}}return p.x}catch(a){o.error=a,o.hasError=!0}finally{le(o)}}function dy(t,e,s,i){const n=new A;n.setCoords(e,s);const r=i.width();let o=Math.floor((t-e)/r)*r+t;const a=n.getCenter();for(;Math.abs(o-a)>Math.abs(o+r-a);)o+=r;return o}class py extends ue{constructor(){super(),this.m_geometryDeque=[],this.m_index=-1}next(){if(this.m_geometryDeque.length>0){this.m_index++;const t=this.m_geometryDeque[0];return this.m_geometryDeque.shift(),t}return null}getGeometryID(){return this.m_index}tick(t){this.m_geometryDeque.push(t)}tock(){return!0}getRank(){return 1}}function fy(t,e){return t===e||null!==t&&null!==e&&(t.m_csType===e.m_csType&&(0===t.m_WKID&&0===e.m_WKID?t.m_hashCode===e.m_hashCode&&t.m_canonicalWkt===e.m_canonicalWkt:t.m_WKID===e.m_WKID))}function xy(t,e){return t===e||null!==t&&null!==e&&(t.m_csType===e.m_csType&&(0===t.m_WKID&&0===e.m_WKID?1===t.m_csType?t.m_peCoordSys.isEqual(e.m_peCoordSys):t.m_peCoordSys===e.m_peCoordSys:t.m_WKID===e.m_WKID))}class yy{constructor(s,i=!0){this.m_PCSHorizon=null,this.m_GCSHorizon=null,this.m_GCSSplitLines=null,this.m_bGCSHorisonIsInclusive=!1,this.m_oneMeterPCS=0,this.m_oneDegreeGCS=0,this.m_gcsUnitFactor=0,this.m_northPole=w.getNAN(),this.m_southPole=w.getNAN(),this.m_polesUpdated=0,this.m_domain=ge.constructEmpty(),this.m_primeMeridian=Number.NaN,this.m_geogToProjFactor=1,this.m_geogToProjOffset=0,this.m_geogToProjFactorsUpdated=0,this.m_oneMillimeter=0,this.m_centralMeridian=0,this.m_pPCSInfoNoDomain=null,this.m_oldWKID=-1973,this.m_vcsWKID=-1,this.m_bIsPannable=!1,this.m_bCached=!1,this.m_pannableExtent=ge.constructEmpty(),this.m_pannableExtentGCS=ge.constructEmpty(),this.m_areaOfUse=null,this.m_canonicalWkt="",this.m_peCoordSys=s,this.m_WKID=xC.getCode(s),this.m_WKID<=0?(this.m_WKID=0,this.m_canonicalWkt=Kf(s,0,!0),this.m_hashCode=zt(this.m_canonicalWkt)):this.m_hashCode=R(this.m_WKID);const n=this.m_peCoordSys.getType();this.m_csType=n===yC.PE_TYPE_PROJCS?2:1,t(n===yC.PE_TYPE_PROJCS||n===yC.PE_TYPE_GEOGCS),n===yC.PE_TYPE_PROJCS&&(s.loadConstants()||e("PeProjcs.loadConstants failed"));const r=n===yC.PE_TYPE_GEOGCS?this.m_peCoordSys:this.m_peCoordSys.getGeogcs();n!==yC.PE_TYPE_GEOGCS&&xC.getCode(r),this.m_unit=wm(s),this.m_primeMeridian=r.getPrimem().getLongitude();{const t=r.getUnit().getUnitFactor();this.m_gcsUnitFactor=t;let e=Math.PI/(180*t);Math.abs(e-1)<1e-10&&(e=1),this.m_oneDegreeGCS=e}if(n===yC.PE_TYPE_PROJCS){const t=this.m_peCoordSys,e=t.getUnit().getUnitFactor();this.m_oneMeterPCS=1/e,this.m_oneMillimeter=.001/e,this.m_pPCSInfoNoDomain=CC.generate(t,CC.PE_PCSINFO_OPTION_NONE),this.m_pPCSInfoNoDomain||m("cannot create pcs info"),this.m_bIsPannable=this.m_pPCSInfoNoDomain.isPannableRectangle(),this.m_centralMeridian=this.m_pPCSInfoNoDomain.getCentralMeridian()}else{this.m_bIsPannable=!0,this.m_polesUpdated=1,this.m_oneMeterPCS=0;const t=1/r.getUnit().getUnitFactor(),e=r.getDatum().getSpheroid().getAxis();this.m_oneMillimeter=.001/e*t,this.m_centralMeridian=0}this.m_bIsPannable&&(this.updateGCSHorizon(),this.updatePCSHorizon(),this.updatePoles(),this.updateDomain(),this.updatePannableExtent(),this.updatePannableExtentGCS())}[Symbol.dispose](){}getHashCode(){return this.m_hashCode}getPCSHorizonPannable(){return this.m_PCSHorizon}getGCSHorizonPannable(){return this.m_GCSHorizon}getPCSInfo(){return t(this.m_pPCSInfoNoDomain),this.m_pPCSInfoNoDomain}getCentralMeridian(){return this.m_centralMeridian}updateGCSHorizon(){if(this.m_peCoordSys.getType()!==yC.PE_TYPE_PROJCS)return;let e=!0;const s=this.m_peCoordSys,i=s.getGeogcs(),n=s.horizonGcsGenerate();if(!n)return;t(n.length>0);const r=n[0].getNump(),o=n[0].getKind();let a,h;e=n[0].getInclusive()>0;const m=this.getOneDegreeGCSUnit(),l=90*m,u=360*m,c=370*m,g=180*m*yC.PE_HORIZON_DELTA/Math.PI,_=ge.constructEmpty();let d=null;if(r>1)for(let t=1;t<r;t++)if(n[t].getKind()===yC.PE_HORIZON_LINE){d||(d=new am);const e=n[t].getCoord();d.startPathCoords(e[0][0],e[0][1]),d.lineToCoords(e[1][0],e[1][1])}if(o===yC.PE_HORIZON_RECT){const t=n[0].getCoord();if(_.setFromPoints([new w(t[0][0],t[0][1]),new w(t[1][0],t[1][1])],2),Math.abs(_.ymax-l)<1e-7*g&&(_.ymax=l),Math.abs(_.ymin+l)<1e-7*g&&(_.ymin=-l),_.width()>c){const t=-400*m,e=t+5*u;_.setCoords({xmin:t,ymin:_.ymin,xmax:e,ymax:_.ymax})}const s=new ke({env2D:_});this.m_GCSHorizon||(this.m_GCSHorizon=s,this.m_bGCSHorisonIsInclusive=e)}else{let s=this.getPCSInfo().isGcsHorizonMultiOverlap();const o=RE(i,null,null,1),c=[],g=new A;for(let t=0;t<r;t++){if(n[t].getKind()!==yC.PE_HORIZON_POLY)continue;a=n[t].getSize();const e=n[t].getCoord(),s=ge.constructEmpty();s.setFromPoints(Ut(e),a),c.push(new A(s.xmin,s.xmax)),s.width(),g.merge(c.at(-1))}let _=!1;const p=new A;g.width()>u&&c.length>1?(p.vmin=this.getCentralMeridian()-u,p.vmax=p.vmin+2*u,_=!0,s=!0):(p.vmin=g.vmin,p.vmax=p.vmin+u);const f=t=>{let e=0;for(;c[t].vmin+e<p.vmin;)e+=u;for(;c[t].vmax+e-u>p.vmin;)e-=u;return e};let x=new Sm;if(s){const t=new py,e=(new zf).executeMany(t,o,null);for(let s=0;s<r;s++){if(n[s].getKind()!==yC.PE_HORIZON_POLY)continue;a=n[s].getSize();const i=n[s].getCoord();h=n[s].getInclusive()>0;const r=new Sm;if(r.addPathPoint2D(Ut(i),a-1,!0),_){const e=f(s),i=c[s].clone();i.move(e);let n=e;const o=new Y;do{o.setShiftCoords(n,0);const e=r.clone();e.applyTransformation(o),t.tick(e),t.tock(),n+=u,i.move(u)}while(i.vmin<p.vmax)}else t.tick(r),e.tock()}x=e.next()}else{x=new Sm;for(let s=0;s<r;s++){if(n[s].getKind()!==yC.PE_HORIZON_POLY)continue;a=n[s].getSize();const i=n[s].getCoord();if(h=n[s].getInclusive()>0,t(h===e),_){const t=new Sm;t.addPathPoint2D(Ut(i),a-1,!0);const e=f(s),n=c[s].clone();n.move(e);let r=e;const o=new Y;do{if(0!==r){o.setShiftCoords(r,0);const e=new Sm({copy:t});e.applyTransformation(o),x.addPath(e,0,!0)}else x.addPath(t,0,!0);r+=u,n.move(u)}while(n.vmin<p.vmax)}else x.addPathPoint2D(Ut(i),a-1,!0)}}_&&(x=(new pp).execute(x,new ge(p.vmin,-l-m,p.vmax,l+m),o,null)),e?(new Cp).accelerateGeometry(x,o,1):(new Ff).accelerateGeometry(x,o,1),(new Zf).accelerateGeometry(x,o,1),null===this.m_GCSHorizon&&(this.m_GCSHorizon=x,this.m_bGCSHorisonIsInclusive=e,this.m_GCSSplitLines=d)}}updateAreaOfUse(){return null}updatePCSHorizon(){if(this.m_peCoordSys.getType()!==yC.PE_TYPE_PROJCS)return;const e=this.m_peCoordSys.horizonPcsGenerate();if(!e)return;let s;this.getPCSInfo();const i=e[0].getKind();e[0].getInclusive();const n=ge.constructEmpty(),r=e[0].getNump();let o=!1;if(i===yC.PE_HORIZON_RECT){const t=e[0].getCoord();n.setFromPoints(Ut(t),2),s=new ke({env2D:n})}else{let i=-1;for(let t=0;t<r;t++)e[t].getKind()===yC.PE_HORIZON_POLY&&(i=t);t(i>=0);const n=e[i].getSize()-1,a=e[i].getCoord(),h=new Sm;s=h,h.addPathPoint2D(Ut(a),n,!0),o=!0}if(this.getPCSInfo().isDensificationNeeded()){t(i!==yC.PE_HORIZON_RECT);const e=1e5*this.getOneMeterPCSUnit();s=(new kl).execute(s,e,0,0,null)}if(o){{const t=new ke;s.queryEnvelope(t),s.calculateArea2D(),s.calculateLength2D(),s.getExteriorRingCount()}(new Cp).accelerateGeometry(s,null,1)}null===this.m_PCSHorizon&&(this.m_PCSHorizon=s)}updatePannableExtent(){const t=this.m_peCoordSys.getType();if(t===yC.PE_TYPE_PROJCS){const t=this.m_peCoordSys,e=this.getPCSInfo().getCentralMeridian(),s=t.getGeogcs();s||m("");const i=[e+1/s.getUnit().getUnitFactor()*Math.PI,0];PC.geogToProj(t,1,i);const n=i[0],r=t.getParameters()[yC.PE_PARM_X0].getValue(),o=this.getPCSHorizon(),a=ge.constructEmpty();o.queryEnvelope(a);const h=Math.abs(n-r),l=h+r,u=-1*h+r,c=a.ymax,g=a.ymin;this.m_pannableExtent.setCoords({xmin:u,ymin:g,xmax:l,ymax:c})}else if(t===yC.PE_TYPE_GEOGCS){const t=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtent.setCoords({xmin:-t,ymin:-t/2,xmax:t,ymax:t/2})}else m("")}updatePannableExtentGCS(){const t=this.m_peCoordSys.getType();if(t===yC.PE_TYPE_PROJCS){const t=this.m_peCoordSys,e=this.m_centralMeridian,s=t.getGeogcs();s||m("");const i=1/s.getUnit().getUnitFactor()*Math.PI,n=this.getGCSHorizon(),r=ge.constructEmpty();n.queryEnvelope(r),this.m_pannableExtentGCS.setCoords({xmin:e-i,ymin:r.ymin,xmax:e+i,ymax:r.ymax})}else if(t===yC.PE_TYPE_GEOGCS){const t=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtentGCS.setCoords({xmin:-t,ymin:-t/2,xmax:t,ymax:t/2})}else m("")}updateDomain(){if(1===this.m_csType){const t=400*this.getOneDegreeGCSUnit();this.m_domain=ge.construct(-t,-t,t,t)}else{t(2===this.m_csType);const e=CC.generate(this.m_peCoordSys,CC.PE_PCSINFO_OPTION_DOMAIN);e||m("generate pcs info failed");const s=new ge(e.getDomainMinx(),e.getDomainMiny(),e.getDomainMaxx(),e.getDomainMaxy());this.m_domain.isEmpty()&&this.m_domain.setCoords({env2D:s})}}updatePoles(){if(this.m_peCoordSys.getType()===yC.PE_TYPE_PROJCS){const t=90*this.getOneDegreeGCSUnit(),e=[[0,t],[0,-t]];PC.geogToProj(this.m_peCoordSys,2,e);const s=this.getPCSInfo().getNorthPoleLocation()!==CC.PE_POLE_OUTSIDE_BOUNDARY,i=this.getPCSInfo().getSouthPoleLocation()!==CC.PE_POLE_OUTSIDE_BOUNDARY;this.m_polesUpdated||(s&&this.m_northPole.setCoords(e[0][0],e[0][1]),i&&this.m_southPole.setCoords(e[1][0],e[1][1]),this.m_polesUpdated=1)}else this.m_polesUpdated=1}updateGeogToProjFactors(){if(this.m_peCoordSys.getType()===yC.PE_TYPE_PROJCS){const e=this.getOneDegreeGCSUnit(),s=this.m_pPCSInfoNoDomain.getCentralMeridian(),i=[0,0,0,0];i[0]=s,i[1]=0,i[2]=s+e,i[3]=0;const n=PC.geogToProj(this.m_peCoordSys,2,i);t(2===n);const r=(i[2]-i[0])/e,o=i[0];0===this.m_geogToProjFactorsUpdated&&(this.m_geogToProjFactor=r,this.m_geogToProjOffset=o,this.m_geogToProjFactorsUpdated=1)}else this.m_geogToProjFactorsUpdated=1}getOneMeterPCSUnit(){return this.m_oneMeterPCS}getOneDegreeGCSUnit(){return this.m_oneDegreeGCS}getGcsUnitFactor(){return this.m_gcsUnitFactor}getUnitsPerMillimeter(){return this.m_oneMillimeter}getGCSSplitLines(){return this.m_bIsPannable?null:(this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSSplitLines)}getGCSHorizon(){return this.m_bIsPannable?this.getGCSHorizonPannable():(null!==this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSHorizon)}getGCSHorisonIsInclusive(){return this.m_bIsPannable||this.getGCSHorizon(),this.m_bGCSHorisonIsInclusive}getPCSHorizon(){return this.m_bIsPannable?this.getPCSHorizonPannable():(null!==this.m_PCSHorizon||this.updatePCSHorizon(),this.m_PCSHorizon)}getPole(t){return this.m_bIsPannable||0!==this.m_polesUpdated||this.updatePoles(),t?this.m_southPole:this.m_northPole}getGeogToProjFactors(){return 0===this.m_geogToProjFactorsUpdated&&this.updateGeogToProjFactors(),j(this.m_geogToProjFactor,this.m_geogToProjOffset)}getDomainXY(){if(this.m_bIsPannable)return this.m_domain.clone();let t=!1;return t=this.m_domain.isEmpty(),t&&this.updateDomain(),this.m_domain.clone()}getPrimeMeridian(){return this.m_primeMeridian}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;if(t<0){if(t=0,this.m_WKID>0){const e=[0],s=[0];FC(this.m_peCoordSys.getType(),this.m_WKID,e,s)||m("query_code_change"),t=e[0]}this.m_oldWKID=t}return t}isCustomWkid(){return!1}isPannable(){return this.m_bIsPannable}getPannableExtent(){return this.m_pannableExtent.clone()}getPannableExtentGCS(){return this.m_pannableExtentGCS.clone()}getAreaOfUse(){return null!==this.m_areaOfUse?this.m_areaOfUse:this.updateAreaOfUse()}getVcsCode(){return 0}saveMemory(){}getCSType(){return this.m_csType}getUnit(){return this.m_unit}setCached(){this.m_bCached=!0}getCached(){return this.m_bCached}static equal(t,e){return!1}static equal_for_projection(t,e){return!1}}function Py(t,e,s,i){return Ey(!0,t,e,s,i)}function Ey(t,e,s,i,n,r){return new Iy(2,e,s,i,n,r)}function Cy(){return{centralMeridianOfOutputGCS:Number.NaN,densificationStep:Number.NaN,clipWithInputHorizon:!0,clipWithOutputHorizon:!0,legacyHorizonClipping:!1,normalizeResultGeometry:!1,equals(t){return F(this.centralMeridianOfOutputGCS,t.centralMeridianOfOutputGCS)&&F(this.densificationStep,t.densificationStep)&&this.clipWithInputHorizon===t.clipWithInputHorizon&&this.clipWithOutputHorizon===t.clipWithOutputHorizon&&this.legacyHorizonClipping===t.legacyHorizonClipping&&this.normalizeResultGeometry===t.normalizeResultGeometry}}}function Sy(){return{flagsMask:0,setFlag(t,e){e?this.flagsMask|=t:this.flagsMask&=~t},hasFlag(t){return!!(this.flagsMask&t)}}}function vy(){return{m_extendedParams:Cy(),m_extendedParamsInternal:Sy()}}function by(){return vy()}class Iy{constructor(s,i,n,r,o,a){let h,m;this.m_datumTran=null,this.m_bIdentity=!0,this.m_bIdentityGeogToGeog=!0,this.m_bVertical=!1,this.m_bNormalize=!1,i&&n||e("!inputSR || !outputSR"),r&&0===r.getType()&&(r.m_bReadOnly=!0),this.m_bNormalize=!1,1!==s&&(h=i.getVCS(),m=n.getVCS(),this.m_bVertical=null!=h&&null!=m),this.m_inputSR=i,this.m_outputSR=n,this.m_bIdentity=!1,this.m_bIdentityGeogToGeog=!1,t(!this.m_params),o&&(this.m_params=vy(),this.m_params.m_extendedParams=o),a&&(this.m_params||(this.m_params=vy()),this.m_params.m_extendedParamsInternal=a);let l=!1;const u=null!=r,c=i.getCoordinateSystemType(),g=n.getCoordinateSystemType();if(n.isPannable()&&0!==c&&o){const t=o.centralMeridianOfOutputGCS;if(!Number.isNaN(t)&&n.isPannable()){const e=n.getPannableExtent(),s=e.getCenterX();if(s!==t){const i=Math.ceil(e.width());t+i!==s+i&&(l=!0)}}}const _=o&&o.normalizeResultGeometry;if(i.equals(n))return this.m_bIdentity=!l,this.m_bIdentityGeogToGeog=!0,void this.updateProjector();const d=!u&&i.equalForProjection(n,this.m_bVertical);this.m_bIdentity=d&&!l,this.m_bIdentity?this.m_bIdentityGeogToGeog=!0:0!==c&&0!==g&&(_&&this.m_outputSR.isPannable()&&(this.m_bNormalize=_),this.m_datumTran=r||null,this.m_bIdentityGeogToGeog=(!this.m_datumTran||0===this.m_datumTran.count())&&this.m_inputSR.getGCS().equalForProjection(this.m_outputSR.getGCS(),this.m_bVertical)),this.updateProjector()}getInputSR(){return this.m_inputSR}getOutputSR(){return this.m_outputSR}getDatumTransformation(){return this.m_datumTran}getInverse(){const t=new Iy(1,this.m_outputSR,this.m_inputSR,this.m_datumTran?.createInverse());return t.m_bIdentity=this.m_bIdentity,t.m_bVertical=this.m_bVertical,t.m_bIdentityGeogToGeog=this.m_bIdentityGeogToGeog,t.updateProjector(),t}isIdentity(){return this.m_bIdentity}getExtendedParams(){return this.m_params?this.m_params.m_extendedParams:by().m_extendedParams}equals(e){return t(0),!1}isVertical(){return this.m_bVertical}isMatchingTransformation(e,s){return t(0),!1}getGeographicTransformations(){return this.m_datumTran}getExtendedParamsImpl(){return this.m_params?this.m_params.m_extendedParams:by().m_extendedParams}getExtendedParamsInternal(){return this.m_params?this.m_params.m_extendedParamsInternal:by().m_extendedParamsInternal}isIdentityGeogToGeog(){return this.m_bIdentityGeogToGeog}normalizeOutput(){return this.m_bNormalize}updateProjector(){this.m_projector=new qp(this)}}const wy=new Map,Dy=new Map,Ty=new Map;function Ny(t){let e=t.getCode();if(e>0){const t=Xy(e);return t||Yy(xC.coordsys(e))}const s=t.getName();if(Dy.has(s)){const e=Dy.get(s);if(e&&e.deref()){const s=e.deref();if(s.m_peCoordSys.isEqual(t))return s}}return e=xC.getCode(t),Yy(e>0?xC.coordsys(e):t)}function Ay(t){t<=0&&C(t);{const e=Xy(t);if(e)return e}const e=DC(xC.coordsys(t));e.get()||C(t);const s=Yy(e.release());return s.getLatestID()!==t&&wy.set(t,new WeakRef(s)),s}function qy(t){const e=DC(xC.fromString(yC.PE_TYPE_COORDSYS,t));return e.get()||S(t),Ny(e.release())}function Fy(t){Dy.delete(t.m_peCoordSys.getName()),Ty.delete(Kf(t.m_peCoordSys,0,!1))}let My;function Gy(){return My||(My=xC.unit(9001)),My}function Vy(t){return!1}function Yy(t){const e=DC(t),s=t.getCode();if(s>0){const t=Xy(s);if(t)return t}const i=t.getName();let n=Dy.get(i);if(n){const e=n.deref();if(e&&e.m_peCoordSys.isEqual(t))return e}const r=new yy(e.release());if(s>0)return r.setCached(),wy.set(s,new WeakRef(r)),Dy.set(i,new WeakRef(r)),r;const o=Kf(t,0,!1);if(n=Ty.get(o),n){const t=n.deref();if(t)return t}return r.setCached(),Ty.set(o,new WeakRef(r)),r}function Xy(t){const e=wy.get(t);if(e)return e.deref()}class ky extends hi{constructor(t){return void 0===t?(super(),this.m_wkid=9001,void(this.m_peUnit=null)):"number"==typeof t?(super(),this.m_factor=t,void(this.m_wkid=0)):(super(t),void(t||(this.m_factor=1,this.m_wkid=9001,this.m_peUnit=Gy())))}getUnitType(){return 0}convertFromMeters(t){return t/this.getUnitToBaseFactor()}convertToMeters(t){return t*this.getUnitToBaseFactor()}}function Ry(e,s=!0){return t(0),{}}function By(t){return Vy()}function Ly(t,e,s,i,n,r){const o=.5*(i.sub(e).length()+i.sub(s).length());t.m_center.assign(i),t.m_startAngle=Math.atan2(e.y-t.m_center.y,e.x-t.m_center.x);Hy(t,Math.atan2(s.y-t.m_center.y,s.x-t.m_center.x),n,r);const a=t.constructEllipticArcEndPointsCenter(e,s,o,1,0,Math.abs(t.m_sweepAngle)>Math.PI,t.m_sweepAngle>0,i);return t.setProjectionBehavior(0),a}function Hy(t,e,s,i){let n=t.m_startAngle,r=t.m_sweepAngle;const o=1e-12;for(;n>ft();)n-=2*ft();for(;n<=-ft();)n+=2*ft();if(!Number.isNaN(e)){for(;e>ft();)e-=2*ft();for(;e<=-ft();)e+=2*ft();!s&&e>n&&(e-=2*ft()),s&&e<n&&(e+=2*ft()),r=e-n,Math.abs(r)<o&&!i&&(r=s?2*ft():-2*ft()),Math.abs(r)>2*ft()-o&&i&&(r=0)}Math.abs(r)>2*ft()-o&&(r=r>=0?2*ft():-2*ft(),t.setEndXY(t.getStartXY())),Math.abs(r)<o&&(r=0,t.setEndXY(t.getStartXY())),i=Math.abs(r)<=ft(),r&&(s=r>0),t.m_startAngle=tP(n),t.m_sweepAngle=r,IP(t,!i),vP(t,s)}function zy(t,e,s){t.isEmpty()&&r(""),c(t);const i=t.getImpl(),n=[];return Wy(i.getPointCount(),n),jy(Oy(i),n,i.getPointCount(),e)}function Uy(t,e,s,i){const n=[];return Wy(e,n),jy(t,n,e,s)}function Oy(t){return{at:e=>t.getXY(e)}}function Wy(t,e){e.length=t;for(let s=0;s<e.length;++s)e[s]=s;t>3&&js(t,e)}function jy(t,e,s,i,n){let r=0;const o=[0,0,0];let a=0;const h=3;let m=0;for(let l=0;l<h;++l){let n=!1;for(;m<s;){const s=t.at(e[m]);let u=1;if(3===r?u=w.inCircleRobust(t.at(i[0]),t.at(i[1]),t.at(i[2]),s):2===r?u=w.inCircleRobust3Point(t.at(i[0]),t.at(i[1]),s):1===r&&s.equals(t.at(i[0]))&&(u=0),u<=0){if(u<0&&l+1<h){e[a]=q(e[m],e[m]=e[a]);for(let t=0;t<r;t++)if(i[t]===e[m]){o[t]=m;break}a++}m++;continue}n=!0;let c=0;for(let t=0;t<r;t++)o[t]>m&&(i[c]=i[t],o[c]=o[t],c++);r=c,i[r]=e[m],o[r]=m,r++,r<3?m=a:(1===w.orientationRobust(t.at(i[0]),t.at(i[1]),t.at(i[2]))&&(i[2]=q(i[0],i[0]=i[2]),o[2]=q(o[0],o[0]=o[2])),m++)}if(!n)break;if(l+1<h){a=0;let s=!1;for(let t=0;t<r;t++)for(let e=t+1;e<r;e++)o[t]>o[e]&&(o[e]=q(o[t],o[t]=o[e]),i[e]=q(i[t],i[t]=i[e]),s=!0);for(let t=0;t<r;t++)e[o[t]]=q(e[t],e[t]=e[o[t]]),o[t]=t;s&&3===r&&1===w.orientationRobust(t.at(i[0]),t.at(i[1]),t.at(i[2]))&&(i[2]=q(i[0],i[0]=i[2]),o[2]=q(o[0],o[0]=o[2]))}m=r}return r}function Zy(){return{e2:0,completeE:0}}class Qy{constructor(t,e){this.m_arc=t,this.m_sqrChordLength=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?w.sqrDistance(this.m_arc.getCoord2D(e),this.m_arc.getCoord2D(1-e))-this.m_sqrChordLength:0}getError(e){return t(0),0}}function Ky(t,e,s){if(fP(t)){Qi(new CE({start:t.getStartXY(),end:t.getEndXY()}),e,s)}else if(0===e.value())s.set(t.getStartXY());else if(1===e.value())s.set(t.getEndXY());else{const i=new ot;oP(t,e,i);const n=new ot,r=new ot;ot.st_cosAndSin(i,n,r);const o=pi.constructCoordsE(new ot(t.m_semiMajorAxis).mulThisE(n),new ot(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio).mulThisE(r)),a=new ot(t.m_rotation);ot.st_cosAndSin(a,n,r),o.rotateDirect(n,r),o.addThisE(pi.constructPoint2D(t.m_center)),s.setE(o)}}function Jy(t,e){return t.convertToCanonic(e)}function $y(t,e){const s=new A(t.getStartAngle(),t.getEndAngle());s.normalize();const i=St(),n=$(e,i);if(n<s.vmin){let t=n+i;for(;t<s.vmin;)t+=i;return s.containsCoordinate(t)?t:s.vmin-n<t-s.vmax?n:t}if(n>s.vmax){let t=n-i;for(;t>s.vmax;)t-=i;return s.containsCoordinate(t)||s.vmin-t<n-s.vmax?t:n}return n}function tP(t){let e=t,s=!1;return e<=-ft()?(e+=St(),s=!0):e>ft()&&(e-=St(),s=!0),e<=-ft()?(e=$(e,St()),e<=-ft()&&(e+=St()),s=!0):e>ft()&&(e=$(e,St()),e>ft()&&(e-=St()),s=!0),s&&(e>ft()||e<=-ft())&&(e=ft()),e}function eP(t,e,s){const i=s,n=i.getSemiAxes();let r=new w(n.x*Math.cos(t[0]),n.y*Math.sin(t[0]));return r=i.convertFromCanonic(r),w.sqrDistance(r,i.getStartXY())}function sP(t,e,s){const i=s,n=i.getSemiAxes(),r=t[0]+i.getStartAngle();let o=new w(n.x*Math.cos(r),n.y*Math.sin(r));return o=i.convertFromCanonic(o),w.sqrDistance(o,i.getEndXY())}function iP(t){if(t.m_center.isNAN())return t.m_startAngle=0,void(t.m_sweepAngle=0);const e=t.getStartXY(),s=t.getEndXY(),i=e.equals(s),n=wP(t),r=bP(t),o=t.projectionBehavior();if(i){const s=t.convertToCanonic(e),i=new w(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);s.x/=i.x,s.y/=i.y,t.m_startAngle=tP(Math.atan2(s.y,s.x)),t.m_sweepAngle=n?r?St():-St():0}else{const i=t.convertToCanonic(e),a=new w(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);i.x/=a.x,i.y/=a.y;const h=t.convertToCanonic(s);h.x/=a.x,h.y/=a.y,t.m_startAngle=Math.atan2(i.y,i.x),t.m_sweepAngle=w.calculateAngle(i,h),r?t.m_sweepAngle<0&&(t.m_sweepAngle+=St()):t.m_sweepAngle>0&&(t.m_sweepAngle-=St()),t.m_startAngle=tP(t.m_startAngle);let m=eP([t.m_startAngle],1,t);if(m=Math.sqrt(m),m>.25*Yi(t)){const e=t.m_startAngle-1e-4,s=t.m_startAngle+1e-4,i=[0];Cn(eP,t,1,[t.m_startAngle],[e],[s],1e-14,i),t.m_startAngle=tP(i[0])}if(m=sP([t.m_sweepAngle],1,t),m=Math.sqrt(m),m>.25*Yi(t)){const e=t.m_sweepAngle-1e-4,s=t.m_sweepAngle+1e-4,i=[0];Cn(sP,t,1,[t.m_sweepAngle],[e],[s],1e-14,i),t.m_sweepAngle=i[0]}const l=Math.abs(t.m_sweepAngle)>ft();if(IP(t,l),n!==l&&!n&&Math.abs(t.m_sweepAngle)>1.5*ft())return void pP(t,e,s,o);if(0===t.m_sweepAngle||r!==t.m_sweepAngle>0)return void pP(t,e,s,o)}}function nP(t,e){return($y(t,e)-t.getStartAngle())/t.getSweepAngle()}function rP(t,e){return t.m_startAngle+e*t.m_sweepAngle}function oP(t,e,s){s.assign(new ot(t.m_startAngle).addE(e.mulE(new ot(t.m_sweepAngle))))}function aP(t,e){const s=new ot(t.m_cosr).sqrThis(),i=new ot(t.m_sinr).sqrThis(),n=new ot(t.m_minorMajorRatio),r=new ot(1/t.m_minorMajorRatio),o=n.mulE(s).addThisE(r.mulE(i)),a=n.subE(r).mulThis(2*t.m_cosr*t.m_sinr),h=n.mulE(i).addThisE(r.mulE(s));e[0]=o,e[1]=a,e[2]=h,e[3]=new ot(-t.m_semiMajorAxis).mulThis(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio)}function hP(t,e){const s=new fi;s.a11.setE(t[0]),s.a12=ot.st_mulByPower2(t[1],.5),s.a21.setE(s.a12),s.a22.setE(t[2]);const i=[w.getNAN(),w.getNAN()],n=[new ot,new ot];s.eigenSymmetric(n,i);const r=t[3].clone();r.negateThis(),r.invThis(),n[0].mulThisE(r),n[1].mulThisE(r),n[0].sqrtThis().invThis(),n[1].sqrtThis().invThis(),e.x=n[0].toDouble(),e.y=n[1].toDouble();return Math.atan2(i[0].y,i[0].x)}function mP(t,e,s){if(fP(t))return(s-e)*w.distance(t.getStartXY(),t.getEndXY());if(1===t.m_minorMajorRatio)return Math.abs(t.getSweepAngle()*(e-s))*t.m_semiMajorAxis;const i=xP(t,e);return xP(t,s)-i}function lP(t){return t.m_cachedValues}function uP(t){if(t.m_cachedValues)return t.m_cachedValues;const e=Zy();return e.e2=_P(t),e.completeE=Ot(e.e2),t.m_cachedValues=e,e}function cP(t,e,s,i){if(!e.isEqual(t.m_XStart,t.m_YStart)||!s.isEqual(t.m_XEnd,t.m_YEnd)){if(fP(t))return t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,XP(t),void t.afterCompletedModification();if(i&&Math.abs(t.getSweepAngle())<=1.01*Et()){const i=D(w,3),n=qP(t,i);if(na(i)){i[0].assign(e),i[2].assign(s),oa(i);if(0===t.projectionBehavior()){let e=0,s=2;w.sqrDistance(i[1],i[0])<w.sqrDistance(i[1],i[2])&&(s=q(e,e=s));const n=i[s].sub(i[e]),r=n.length();n.divThis(r);const o=i[1].sub(i[e]),a=o.length(),h=o.dotProduct(n)/a,m=o.crossProduct(n)/a,l=new w;lt(i[e],i[s],.5,l);const u=.5*r/m*T(1-h,0,1),c=i[1].side(i[e],i[s]),g=n.clone();c?g.leftPerpendicularThis():g.rightPerpendicularThis();const _=l.sub(g.mul(u));t.constructCircularArcThreePoint(i[0],i[2],_)}else FP(i,n*n,null,!1,t);return}}0===t.projectionBehavior()?jP(t,e,s):ZP(t,e,s)}}function gP(t,e,s){const i=0===t.projectionBehavior();if(s<=2)return void pP(t,e[0],e[s-1],i?0:1);if(i){t.constructCircularArcThreePoint(e[0],e[s-1],e[Math.trunc(s/2)]);const i=new w;return t.queryCoord2D(.5,i),void t.m_interior.setCoordsPoint2D(i)}const n=t.getSemiMajorAxis(),r=t.getMinorMajorRatio(),o=t.getAxisXRotation(),a=t.getCenter(),h=new Array(4);h[0]=t.isMajor(),h[1]=!h[0],h[2]=h[0],h[3]=!h[0];const m=new Array(4);m[0]=t.isClockwise(),m[1]=m[0],m[2]=!m[0],m[3]=!m[0];const l=Math.trunc(s<5?1:(s+4)/5),u=D(Cm,4),c=new Array(4);let g=0;for(let _=0;_<4;_++){u[_].constructEllipticArcEndPointsCenter(e[0],e[s-1],n,r,o,h[_],m[_],a),c[_]=0;let t=0;for(let i=l;i<s-1;i+=l){const s=u[_].getClosestCoordinate(e[i],!1);c[_]+=w.sqrDistance(u[_].getCoord2D(s),e[i]),t++}c[_]/=t,c[_]<c[g]&&(g=_)}t.assignCopy(u[g])}function _P(t){return 1-M(t.m_minorMajorRatio)}function dP(t,e,s,i,n,r,o,a,h){return t.m_bits=0,t.m_rotation=r,bi(t,e),wi(t,s),t.m_cosr=Math.cos(r),t.m_sinr=Math.sin(r),IP(t,o),vP(t,a),void 0!==h?t.m_center.assign(h):t.m_center.setNAN(),t.setProjectionBehavior(1),t.m_semiMajorAxis=i,t.m_minorMajorRatio=n,AP(t,void 0===h)}function pP(t,e,s,i){t.m_bits=0,t.m_rotation=0,bi(t,e),wi(t,s),t.m_interior.assign(e.add(s).mul(.5)),t.m_startAngle=0,t.m_sweepAngle=0,t.m_cosr=1,t.m_sinr=0,IP(t,!1),vP(t,!1),t.m_center.setNAN(),t.m_semiMajorAxis=1,t.m_minorMajorRatio=0,t.setProjectionBehavior(i),t.afterCompletedModification()}function fP(t){return t.m_center.isNAN()}function xP(t,e){if(0===e)return 0;const s=uP(t),i=rP(t,e),n=Et(),r=PP(t),o=vt(i+n,s.e2,s.completeE),a=t.m_semiMajorAxis*(o-r);return Math.abs(a)}function yP(t,e){if(fP(t)){const s=w.distance(t.getStartXY(),t.getEndXY());return 0===s?0:e/s}if(1===t.m_minorMajorRatio){const s=Math.abs(t.getSweepAngle()*t.m_semiMajorAxis);return 0===s?0:e/s}if(0===e)return 0;const s=t.getSweepAngle();if(0===s)return.5;const i=uP(t),n=Et(),r=PP(t);s<0&&(e=-e);const o=e/t.m_semiMajorAxis+r;let a=bt(o,i.e2,i.completeE);a-=n,a-=t.getStartAngle();return a/s}function PP(t){const e=uP(t);return vt(t.getStartAngle()+Et(),e.e2,e.completeE)}function EP(e,s,i){if(s instanceof ai)return void t(0);if(t(!TP(e)),s.isIdentity())return;SP(e);const n=w.getNAN();n.x=e.m_XStart,n.y=e.m_YStart,s.transformInPlace(n);const r=w.getNAN();if(r.x=e.m_XEnd,r.y=e.m_YEnd,s.transformInPlace(r),fP(e))return e.m_XStart=n.x,e.m_YStart=n.y,e.m_XEnd=r.x,void(e.m_YEnd=r.y);const o=e.m_center.clone();if(s.transformInPlace(o),i||s.isUniformNoRotation()){let t=bP(e);s.isReflective()&&(t=!t);if(0===e.projectionBehavior()){if(!n.equals(r)){const t=e.m_interior.clone();return s.transformInPlace(t),void e.constructCircularArcThreePoint(n,r,t)}return void Ly(e,n,r,o,t,!1)}const i=new w(e.m_cosr,e.m_sinr);s.transformWithoutTranslateInPlace(i);const a=Math.atan2(i.y,i.x),h=e.getSemiAxes();s.transformWithoutTranslateInPlace(h);const m=e.m_center.clone();return s.transformInPlace(m),void e.constructEllipticArcEndPointsCenter(n,r,h.x,h.y/h.x,a,e.isMajor(),t,m)}{{const t=new Array(4);aP(e,t);const i=new fi;i.a11.setE(t[0]),i.a12.setE(t[1]),i.a12.mulThisByPower2(.5),i.a21.setE(i.a12),i.a22.setE(t[2]);if(!i.det().isZero()){const a=new fi;if(a.a11.set(s.xx),a.a12.set(s.xy),a.a21.set(s.yx),a.a22.set(s.yy),a.invertThis()){const h=a.clone();h.transposeThis();const m=i.clone();m.mulThis(a),m.mulLeftThis(h);if(!m.det().isZero()){const i=D(ot,4);i[0].setE(m.a11),i[1].setE(m.a12),i[1].mulThisByPower2(2),i[2].setE(m.a22),i[3].setE(t[3]);const a=w.getNAN(),h=hP(i,a);let l=bP(e);return s.isReflective()&&(l=!l),void e.constructEllipticArcEndPointsCenter(n,r,a.x,a.y/a.x,h,e.isMajor(),l,o)}}}}const t=[w.getNAN(),w.getNAN(),w.getNAN()];t[0].setCoords(e.getSemiMajorAxis(),0),t[0].rotateDirect(e.m_cosr,e.m_sinr),t[1].setCoords(e.getSemiMajorAxis(),e.getSemiMinorAxis()),t[1].rotateDirect(e.m_cosr,e.m_sinr),t[2].setCoords(0,e.getSemiMinorAxis()),t[2].rotateDirect(e.m_cosr,e.m_sinr);let i=e.isClockwise();i&&(t[2]=q(t[0],t[0]=t[2]));const a=.5;s.transformWithoutTranslateArray(t,3,t),s.isReflective()&&(i=!i);const h=new w(0,0),m=e.createInstance();FP(t,a,h,!1,m),e.constructEllipticArcEndPointsCenter(n,r,m.getSemiMajorAxis(),m.getMinorMajorRatio(),m.getAxisXRotation(),e.isMajor(),!i,o)}}function CP(t,e){t.m_cachedValues=e}function SP(t){t.m_cachedValues=null}function vP(t,e){const s=e?1:0;t.m_bits=-2&t.m_bits|s}function bP(t){return!!(1&t.m_bits)}function IP(t,e){const s=e?1:0;t.m_bits=-3&t.m_bits|s<<1}function wP(t){return!!(2&t.m_bits)}function DP(t){if(t.m_center.isNAN())return!1;const e=8,s=new pi;s.setWithEps(t.getStartXY(),e),s.subThisE((new pi).setWithEps(t.m_center,e));const i=new ot;i.setWithEps(t.m_rotation,e);const n=new ot,r=new ot;ot.st_cosAndSin(i,n,r),s.rotateReverse(n,r);const o=new pi;o.setWithEps(t.getEndXY()),o.subThisE(pi.constructPoint2D(t.m_center)),o.rotateReverse(n,r);const a=new ot;a.setWithEps(t.m_semiMajorAxis,e);const h=a.clone(),m=new ot;m.setWithEps(t.m_minorMajorRatio),h.mulThisE(m),s.x.divThisE(a),s.y.divThisE(h),o.x.divThisE(a),o.y.divThisE(h);const l=s.x.sqr().addThisE(s.y.sqr()).subThisE(It),u=o.x.sqr().addThisE(o.y.sqr()).subThisE(It);return!l.isZero()||!u.isZero()}function TP(t){return!!(8&t.m_bits)}function NP(t){t.m_bits&=-9}function AP(t,e){NP(t);const s=t.getStartXY(),i=t.getEndXY();let n=!1;const r=wP(t),o=bP(t),a=t.projectionBehavior(),h=s.equals(i);let m=0===t.m_minorMajorRatio||0===t.m_semiMajorAxis;if(Number.isNaN(t.m_minorMajorRatio)&&(0===t.m_semiMajorAxis?t.m_minorMajorRatio=1:x("NAN minor major ratio and non-zero major axis")),m||=e?h:t.m_center.isNAN(),m)return pP(t,s,i,a),!0;t.m_semiMajorAxis=Math.abs(t.m_semiMajorAxis),t.m_minorMajorRatio=Math.abs(t.m_minorMajorRatio),t.m_minorMajorRatio>1&&(t.m_semiMajorAxis*=t.m_minorMajorRatio,t.m_minorMajorRatio=1/t.m_minorMajorRatio);const l=new w(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);if(h){const e=t.convertToCanonic(s);e.x/=l.x,e.y/=l.y;const i=Math.sqrt(M(e.x)+M(e.y));if(n=1!==i,t.m_semiMajorAxis*=i,l.mulThis(i),t.m_startAngle=tP(Math.atan2(e.y,e.x)),!r)return t.m_interior.assign(s),t.m_sweepAngle=0,t.afterCompletedModification(),n;t.m_sweepAngle=o?St():-St()}else{let e=t.m_center.isNAN()||DP(t);if(!e){const n=t.convertToCanonic(s);n.x/=l.x,n.y/=l.y;const r=new w(1,0);t.m_startAngle=w.calculateAngle(r,n);const o=t.convertToCanonic(i);o.x/=l.x,o.y/=l.y,t.m_sweepAngle=w.calculateAngle(n,o),e=!GP(t)}if(e){n=!0;const e=s.sub(i).mulThis(.5);e.rotateReverse(t.m_cosr,t.m_sinr);let a=M(e.x/l.x)+M(e.y/l.y);a>1&&(a=Math.sqrt(a),t.m_semiMajorAxis*=a,l.mulThis(a));const h=new w(0,0);{const t=l.x*l.x,s=l.y*l.y,i=t*e.y*e.y+s*e.x*e.x,n=t*s-i;if(n>0){const t=Math.sqrt(n/i);h.setCoords(l.x*e.y/l.y,-l.y*e.x/l.x),h.mulThis(t),r===o&&h.negateThis()}}{const e=new w(h.x,h.y);e.rotateDirect(t.m_cosr,t.m_sinr),e.addThis(s.add(i).mulThis(.5)),t.m_center.assign(e)}}if(iP(t),!GP(t))return pP(t,s,i,a),!0}return XP(t),t.afterCompletedModification(),n}function qP(e,s){t(Math.abs(e.getSweepAngle())<15*Math.PI/16);const i=e.getSemiMajorAxis(),n=e.getSemiMinorAxis();let r;if(0===i)return s[0].setCoordsPoint2D(e.getStartXY()),s[1].setCoordsPoint2D(e.getStartXY()),s[2].setCoordsPoint2D(e.getStartXY()),r=1,r;if(0===n)return s[0].setCoordsPoint2D(e.getStartXY()),s[2].setCoordsPoint2D(e.getEndXY()),s[1]=w.lerp(s[0],s[2],.5),r=1,r;const o=e.getSweepAngle(),a=e.getStartAngle(),h=a+o,m=new w(-i*Math.sin(a),n*Math.cos(a)),l=new w(-i*Math.sin(h),n*Math.cos(h));m.normalize(),l.normalize(),m.rotateDirect(e.m_cosr,e.m_sinr),l.rotateDirect(e.m_cosr,e.m_sinr),s[0].setCoordsPoint2D(e.getStartXY()),s[2].setCoordsPoint2D(e.getEndXY()),s[1].setSub(s[2],s[0]);const u=m.crossProduct(l);s[1].assign(m.mul(s[1].crossProduct(l)/u)),s[1].addThis(s[0]);return r=Math.cos(.5*o),r}function FP(e,s,i,n,r){const o=e[0].sub(e[1]),a=e[2].sub(e[1]),h=o.crossProduct(a),m=o.dotProduct(a),l=s;t(l<=1),t(l>0);const u=.5/(1-l),c=o.sqrLength(),g=m,_=a.sqrLength(),d=M(h),p=o.sub(a).sqrLength();if(0===d)return pP(r,e[0],e[2],1),!1;if(m<=-Math.sqrt(c)*Math.sqrt(_))return pP(r,e[0],e[2],1),!1;const f=[0,0],x=new A;x.setInfinite();const y=Pn(2*d,-(p/l+4*g),2*(1-l)/l,x,!1,f);if(0===y)return pP(r,e[0],e[2],1),!1;1===y&&(f[1]=f[0]);const P=Math.sqrt(u/f[0]),E=Math.sqrt(u/f[1]),C=.5/l;let S=C-_*f[0],v=C-c*f[0];Math.abs(S)>Math.abs(v)?v=g*f[0]-C+1:S=g*f[0]-C+1;const b=o.mul(S).add(a.mul(v)),I=b.norm(1)<1e-15*P?0:Math.atan2(b.y,b.x)+Math.PI,w=o.add(a),D=i?i.clone():e[1].add(w.mul(u)),T=e[0].sub(D),N=e[2].sub(D),q=T.crossProduct(N)<0,F=!1;new Cm;return r.constructEllipticArcEndPointsCenter(e[0],e[2],P,E/P,I,F,!q,D)}function MP(t,e,s,i,n){return FP(t,e,s,i,n)}function GP(t){let e=!1;{const s=new w(t.m_semiMajorAxis*Math.cos(t.m_startAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle));s.rotateDirect(t.m_cosr,t.m_sinr),s.addThis(t.m_center);e=w.distance(t.getStartXY(),s)>Yi(t)}let s=!1;if(!e){const e=new w(t.m_semiMajorAxis*Math.cos(t.m_startAngle+t.m_sweepAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle+t.m_sweepAngle));e.rotateDirect(t.m_cosr,t.m_sinr),e.addThis(t.m_center);s=w.distance(t.getEndXY(),e)>Yi(t)}return!e&&!s}function VP(t,s,i,n){0===i&&e("construct_enclosing_circle");const r=[0,0,0],o=Uy(s,i,r);if(1===o)t.constructCircleRadius(0,s[r[0]],n);else if(2===o){const e=w.lerp(s[r[0]],s[r[1]],.5),i=w.distance(s[r[0]],e),o=w.distance(s[r[1]],e);t.constructCircleRadius(Math.max(i,o),e,n)}else if(3===o){const e=w.calculateCircleCenterFromThreePoints(s[r[0]],s[r[1]],s[r[2]]),i=w.distance(s[r[0]],e),o=w.distance(s[r[1]],e),a=w.distance(s[r[2]],e);t.constructCircleRadius(Math.max(i,o,a),e,n)}else m("unexpected")}function YP(t){if(fP(t))return 0;if(t.isDegenerate(0))return 0;const e=t.m_semiMajorAxis,s=t.getSemiMinorAxis(),i=e*e+s*s,n=t.getStartAngle(),r=t.getEndAngle(),o=t.m_center.y-t.m_YStart,a=t.m_cosr,h=t.m_sinr;let m=1,l=0;t.m_rotation&&(m=(a-h)*(a+h),l=2*a*h);const u=((-.5*(r-n)+.25*m*(2*Math.cos(r+n)*Math.sin(r-n)))*s+-2*Math.sin(.5*(r+n))*Math.sin(.5*(r-n))*a*o)*e/i;let c=0;if(t.m_rotation){c=.125*(-2*Math.sin(r+n)*Math.sin(r-n))*l-s*o/i*(2*Math.cos(.5*(r+n))*Math.sin(.5*(r-n)))*h}return i*(u+c)+-.5*(t.m_XEnd-t.m_XStart)*(t.m_YEnd-t.m_YStart)}function XP(t){t.queryCoord2D(.5,t.m_interior)}function kP(t,e,s,i,n){if(n){if(0!==gE(e,s))return 2}else if(yi(e,s))return 1;return 0!==BP(t,e,s,null,null,null,i,void 0!==n&&n,!0,!1)?4:0}function RP(t,e,s,i,n){if(n){if(0!==gE(e,s))return 2}else if(yi(e,s))return 1;return 0!==LP(t,e,s,null,null,null,i,void 0!==n&&n,!0,!1)?4:0}function BP(e,s,i,n,r,o,a,h,m,l){if(fP(s)){return tn(new CE({start:s.getStartXY(),end:s.getEndXY()}),i,n,r,o,a,h,l)}null!==r&&(r.length=0),null!==o&&(o.length=0),null!==n&&(n.length=0);const u=Xi(s,i);if(ki(s,i,a=Math.max(u,a)))return 0;const c=i.getStartXY();c.subThis(s.m_center);const g=i.getEndXY();g.subThis(s.m_center),c.rotateReverse(s.m_cosr,s.m_sinr),g.rotateReverse(s.m_cosr,s.m_sinr);const _=g.clone();_.subThis(c);const d=s.m_semiMajorAxis,p=1/d,f=s.getSemiMinorAxis(),x=1/f,y=_.clone();y.leftPerpendicularThis();const P=Math.atan2(f*y.y,d*y.x),E=new Array(16),C=new Array(16);let S=0;const v=[P,P+Math.PI];for(let t=0;t<2;++t){const e=nP(s,v[t]);if(e>=0&&e<=1){E[S]=e;const t=s.getCoord2D(E[S]);C[S]=i.getClosestCoordinate(t,!1),w.distance(t,i.getCoord2D(C[S]))<=a&&S++}}const b=c.x*p,I=c.y*x,D=_.x*p,T=_.y*x;let N=Pn(D*D+T*T,2*(b*D+I*T),b*b+I*I-1,A.unit(),!1,C);t(N>=0);for(let t=0;t<N;t++){const e=_.mul(C[t]).add(c);e.x*=p,e.y*=x;const n=nP(s,Math.atan2(e.y,e.x));if(n>=0&&n<=1){E[S]=n;const t=s.getCoord2D(n);C[S]=i.getClosestCoordinate(t,!1),w.distance(t,i.getCoord2D(C[S]))<=a&&S++}}t(S<E.length+4);const q=new Array(16);N=s.intersectPoint(i.getStartXY(),q,a);for(let t=0;t<N;t++,S++)E[S]=q[t],C[S]=0;N=s.intersectPoint(i.getEndXY(),q,a);for(let t=0;t<N;t++,S++)E[S]=q[t],C[S]=1;N=i.intersectPoint(s.getStartXY(),q,a);for(let t=0;t<N;t++,S++)E[S]=0,C[S]=q[t];N=i.intersectPoint(s.getEndXY(),q,a);for(let t=0;t<N;t++,S++)E[S]=1,C[S]=q[t];return 0===S?0:xE(e,s,i,E,C,S,n,r,o,a,h,m,l)}function LP(e,s,i,n,r,o,a,h,m,l){if(fP(s)){const t=new CE({start:s.getStartXY(),end:s.getEndXY()});return BP(e,i,t,n,o,r,a,h,m,!l)}if(fP(i)){const t=new CE({start:i.getStartXY(),end:i.getEndXY()});return BP(e,s,t,n,r,o,a,h,m,l)}const u=Xi(s,i);a=Math.max(a,u);let c=!1;{const e=s.getSemiAxes(),n=s.getCenter(),l=i.getSemiAxes(),u=i.getCenter(),g=w.distance(u,n),_=e.x+l.x;if(g>_+a)return 0;if(e.y>l.x){if(g+l.x+a<e.y)return 0}else if(l.y>e.x&&g+e.x+a<l.y)return 0;if(m&&!h){const n=1===s.m_minorMajorRatio&&s.isClosed()&&s.isMajor(),a=1===i.m_minorMajorRatio&&i.isClosed()&&i.isMajor();if(n&&a&&(c=!0,g<=_)){if(Math.max(e.x,l.x)<=Math.min(e.x,l.x)+g)return t(!r&&!o),1}}}if(!c&&ki(s,i,a))return 0;const g=[],_=[],d=!1,p=!1,f=vl(s,0,0,d,p,g,_,null),x=[],y=[],P=vl(i,0,0,d,p,x,y,null);if(1===f&&1===P){const t=new Xa({points:g,weights:_}),e=new Xa({points:x,weights:y}),u=[],c=[],d=xa(!1,t,e,n,null===r?null:u,null===o?null:c,a,h,m,l);if(d>0&&null!==r||null!==o){r&&(r.length=0),o&&(o.length=0);for(let n=0;n<d;++n){if(r)if(ht(u[n],0,1))r.push(u[n]);else{const e=t.tToLength(u[n]),i=s.lengthToT(e);r.push(i)}if(o)if(ht(c[n],0,1))o.push(c[n]);else{const t=e.tToLength(c[n]),s=i.lengthToT(t);o.push(s)}}}return d}let E=[];const C=[];let S=0;const v=m&&!h;for(let t=0;t<f;t++){const e=new Xa({points:g.slice(2*t,2*t+3),weights:_.slice(2*t,2*t+3)});let n=0;for(let r=0;r<P;r++){C.length<=r&&C.push(new Xa({points:x.slice(2*r,2*r+3),weights:y.slice(2*r,2*r+3)}));const o=[],h=[],m=v?null:o,l=v?null:h,u=xa(!1,e,C[r],null,m,l,a,!1,v,!1);if(u>0&&v)return 1;for(let a=0;a<u;++a){if(0===o[a]&&0===t)o[a]=0;else if(1===o[a]&&t===f-1)o[a]=1;else{const t=e.tToLength(o[a])+S,i=s.lengthToT(t);o[a]=i}if(0===h[a]&&0===r)h[a]=0;else if(1===h[a]&&r===P-1)h[a]=1;else{const t=C[r].tToLength(h[a])+n,e=i.lengthToT(t);h[a]=e}E.push(j(o[a],h[a]))}n+=C[r].calculateLength2D()}S+=e.calculateLength2D()}if(0===E.length)return 0;if(h&&(E=E.filter((t=>!ht(t.first,0,1)||!ht(t.second,0,1)||!s.getCoord2D(t.first).equals(i.getCoord2D(t.second))))),m)return E.length;const b=[],I=[];for(const t of E)b.push(t.first),I.push(t.second);return xE(e,s,i,b,I,b.length,n,r,o,a,h,m,l)}function HP(t,e,s){if(s.setCoords(t.getCoord2D(e.vmin)),s.mergeNe(t.getCoord2D(e.vmax)),fP(t))return;const i=t.getSemiAxes(),n=[0,0,0,0];{const e=Math.atan2(-i.y*t.m_sinr,i.x*t.m_cosr),s=e+Math.PI,r=Math.atan2(i.y*t.m_cosr,i.x*t.m_sinr),o=r+Math.PI;n[0]=nP(t,e),n[1]=nP(t,s),n[2]=nP(t,r),n[3]=nP(t,o)}const r=new w;for(let o=0;o<4;o++){const i=n[o];e.containsExclusiveCoordinate(i)&&(t.queryCoord2D(i,r),s.mergeNe(r))}}function zP(e,s,i,n,r){if(0===e.m_semiMajorAxis)return i.vmin;let o=w.getNAN();e.queryCoord2D(i.vmin,o);let a=w.getNAN();if(e.queryCoord2D(i.vmax,a),fP(e)){return new CE({start:o,end:a}).getClosestCoordinate(s,n)}const h=Jy(e,s);if(o=Jy(e,o),a=Jy(e,a),1===e.m_minorMajorRatio){if(h.isEqual(0,0))return i.vmin;const t=nP(e,Math.atan2(h.y,h.x));if(n||i.containsCoordinate(t))return t;return w.distance(h,o)<=w.distance(h,a)?i.vmin:i.vmax}const m=e.getSemiMajorAxis(),l=e.getSemiMinorAxis(),u=(m-l)*(m+l),c=M(u),g=h.x,_=h.y,d=M(l*_),p=l*u*_*2,f=[new ot(d),new ot(p),new ot(c-M(m*g)-d),new ot(-p),new ot(-c)],x=D(ot,4),y=qn(f,4,new A(-1,1),!1,x,4);let P=i.vmin,E=w.sqrDistance(h,o);{const t=w.sqrDistance(h,a);t<E&&(P=i.vmax,E=t)}t(!n);let C=new Array(8);for(let t=0;t<y;++t){const s=x[t].value(),i=Math.sqrt(1-s*s),n=Math.atan2(s,i),r=Math.atan2(s,-i);C[2*t]=nP(e,n),C[2*t+1]=nP(e,r)}C=C.slice(0,2*y),J(C);for(let t=0,S=2*y;t<S;++t)if(C[t]>i.vmin&&C[t]<i.vmax){const i=w.sqrDistance(s,e.getCoord2D(C[t]));E>i&&(E=i,P=C[t])}return P}function UP(e,s,i){return t(0),!1}function OP(e,s,i){t(!fP(e));const n=new Y;n.setRotateAngle(-e.getAxisXRotation());const r=new w;n.queryTransform(s,r);const o=Math.atan2(-r.x*e.getMinorMajorRatio(),r.y),a=o+ft();let h=nP(e,o),m=nP(e,a);m<h&&(m=q(h,h=m));let l=0;return h>=0&&h<=1&&(i[l++]=h),m>=0&&m<=1&&(i[l++]=m),l}function WP(e,s,i){t(0)}function jP(t,e,s,i){const n=t.getStartXY(),r=t.getEndXY(),o=n.equals(r),a=e.equals(s);if(!o&&!a){const i=new Y;i.setShiftCoords(-t.m_XStart,-t.m_YStart);const o=w.distance(e,s),a=w.distance(n,r),h=o/a;i.scale(h,h);const m=r.sub(n);m.divThis(a);const l=s.sub(e);l.divThis(o);const u=m.crossProduct(l),c=l.dotProduct(m);return i.rotate(c,u),i.shiftCoords(e.x,e.y),EP(t,i,!0),t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,void(t.m_YEnd=s.y)}const h=new w;if(t.queryCoord2D(.5,h),a){if(o){const i=t.m_center.add(e.sub(n));t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),1,0,!0,!t.isClockwise(),i),t.setProjectionBehavior(0)}else if(t.isMajor()){const i=h.sub(e).getUnitVector().mul(2*t.getSemiMajorAxis()).add(e);t.constructCircularArcThreePoint(e,s,i)}else t.constructCircularArcThreePoint(e,s,e);return}const m=e.add(s).mul(.5),l=s.sub(e);l.rightPerpendicularThis();const u=m.add(l),c=w.getClosestCoordinate(m,u,t.getCenter(),!0),g=new w;lt(m,u,c,g);const _=w.distance(e,g);t.constructEllipticArcEndPointsCenter(e,s,_,1,0,!0,!t.isClockwise(),g),t.setProjectionBehavior(0)}function ZP(e,s,i,n){const r=e.getStartXY(),o=e.getEndXY(),a=r.equals(o),h=s.equals(i);if(!a&&!h){const t=new Y;return t.initializeFromTwoPoints(r,o,s,i),EP(e,t,!0),e.m_XStart=s.x,e.m_YStart=s.y,e.m_XEnd=i.x,e.m_YEnd=i.y,e.endPointModified(),void e.normalizeAfterEndpointChange()}if(!e.isMajor())return void pP(e,s,i,1);if(a&&h){const t=e.m_center.add(s.sub(r));return void e.constructEllipticArcEndPointsCenter(s,i,e.getSemiMajorAxis(),e.getMinorMajorRatio(),e.getAxisXRotation(),!0,!e.isClockwise(),t)}if(!a){const t=.5*(St()-Math.abs(e.getSweepAngle())),n=(e.getSweepAngle()+t*Q(e.getSweepAngle()))/e.getSweepAngle(),r=new w;e.queryCoord2D(n,r),e.constructEllipticArcEndPointsCenter(r,r,e.getSemiMajorAxis(),e.getMinorMajorRatio(),e.getAxisXRotation(),!0,!e.isClockwise(),e.getCenter());const o=e.getCenter().add(s.sub(r));return void e.constructEllipticArcEndPointsCenter(s,i,e.getSemiMajorAxis(),e.getMinorMajorRatio(),e.getAxisXRotation(),!0,!e.isClockwise(),o)}const m=w.sqrDistance(s,i);let l=.25,u=.75;if(m<w.sqrDistance(e.getCoord2D(.25),e.getCoord2D(.75))){const s=[0],i=xn(new Qy(e,m),A.construct(0,.25),1,s);i>0&&(t(1===i),l=s[0],u=1-s[0])}const c=e.getCoord2D(l),g=e.getCoord2D(u);t(!c.equals(g)),e.constructEllipticArcEndPointsCenter(c,g,e.getSemiMajorAxis(),e.getMinorMajorRatio(),e.getAxisXRotation(),!0,!e.isClockwise(),e.m_center),ZP(e,s,i)}function QP(t){if(t.isEmpty())return new Sm({vd:t.getDescription()});const e=t.getImpl(),s=e.getPointCount();if(s<=2){if(1===s||e.getXY(0).equals(e.getXY(1))){const t=new Ge({vd:e.getDescription()});return e.getPointByVal(0,t),t}{const t=new Ge,s=new am({vd:e.getDescription()});return e.getPointByVal(0,t),s.startPathPoint(t),e.getPointByVal(1,t),s.lineToPoint(t),s}}const i=e.getAttributeStreamRef(0),n=new eE({stream:i,n:s});let r=0,o=1;const a=i.readPoint2D(r<<1),h=new w;for(;o<s&&i.queryPoint2D(o<<1,h).equals(a);)o++;if(n.m_treeHull.addElement(r),o<s){n.m_treeHull.addBiggestElement(o);const t=new w;for(let s=o+1;s<e.getPointCount();s++){i.queryPoint2D(s<<1,t);const e=n.treeHull(t);-1!==e&&n.m_treeHull.setElement(e,s)}}const m=e.getDescription(),l=m.getAttributeCount()>1,u=n.m_treeHull.size();let c=null;if(u>=2){c=u>=3?new Sm({vd:m}):new am({vd:m});const t=c.getImpl();t.reserve(n.m_treeHull.size()),t.addPathPoint2D(null,0,!0);const s=new w;for(let r=n.m_treeHull.getFirst();-1!==r;r=n.m_treeHull.getNext(r))if(l){const s=new Ge;e.getPointByVal(n.m_treeHull.getElement(r),s),t.insertPoint(0,-1,s)}else i.queryPoint2D(n.m_treeHull.getElement(r)<<1,s),t.insertPoint2D(0,-1,s)}else if(l){const t=new Ge({vd:m});e.getPointByVal(n.m_treeHull.getElement(n.m_treeHull.getFirst()),t),c=t}else{const t=i.readPoint2D(n.m_treeHull.getElement(n.m_treeHull.getFirst())<<1);c=new Ge(t)}return c}function KP(e,s,i){if(s<=262144)return nE(e,s,i);t(0);const n=new eE({points:e,n:s}),r=0;let o=1;const a=e[r].clone();for(;o<s&&e[o].equals(a);)o++;if(n.m_treeHull.addElement(r),o<s){n.m_treeHull.addBiggestElement(o);for(let t=o+1;t<s;t++){const s=e[t],i=n.treeHull(s);-1!==i&&n.m_treeHull.setElement(i,t)}}let h=0;for(let t=n.m_treeHull.getFirst();-1!==t;t=n.m_treeHull.getNext(t))i[h++]=n.m_treeHull.getElement(t);return h}function JP(t,e,s){const i=t.getImpl(),n=i.getPathStart(e),r=i.getPathEnd(e),o=!i.isClosedPath(e)&&i.isClosedPathInXYPlane(e),a=i.getAttributeStreamRef(0),h=2*n;let m=2*r;if(o&&(m-=2),m-h<6)return!0;const l=a.readPoint2D(h),u=a.readPoint2D(h+2),c=a.readPoint2D(h+4);if(!rE(w.orientationRobust(u,c,l)))return!1;const g=u.clone(),_=new w;for(let d=h+6;d<m;d+=2){_.assign(u),u.assign(c),a.queryPoint2D(d,c);if(!rE(w.orientationRobust(u,c,l)))return!1;if(!rE(w.orientationRobust(g,c,l)))return!1;if(!rE(w.orientationRobust(u,c,_)))return!1}return!0}function $P(t,e,i,n,r){if(i.setNAN(),n.setCoords(1,0),r.setCoords(0,0),t.isEmpty())return;if(t.getGeometryType()===s.enumPoint)return void i.assign(t.getXY());const o=t,a=o.getPointCount();if(2===a){const t=o.getXY(0),e=o.getXY(1);i.assign(t.add(e).mul(.5));const s=e.sub(t);n=hE(s),r.setCoords(.5*s.length(),0)}else{let t=Number.MAX_VALUE;const s=[0,1,0,0],h=new Wt(4,2);for(h.set(0,0,0),h.set(0,1,1),h.set(1,0,1),h.set(1,1,2);s[0]<a;++s[0],mE(h,0,a)){s[1]===s[0]&&(++s[1],mE(h,1,a));for(let t=1;;++t){for(;;){const e=lE(o.getXY(h.get(0,0)),o.getXY(h.get(0,1)),o.getXY(h.get(t,0)),o.getXY(h.get(t,1)),2^t);if(e>0)break;if(++s[t],mE(h,t,a),0===e)break}if(3===t)break;s[t+1]<s[t]&&(s[t+1]=s[t],h.set(t+1,0,h.get(t,0)),h.set(t+1,1,h.get(t,1)))}const m=o.getXY(h.get(0,0)).add(o.getXY(h.get(2,0))).mul(.5),l=hE(o.getXY(h.get(0,1)).sub(o.getXY(h.get(0,0)))),u=new w;let c,g;if(u.x=Math.max(0,l.dotProduct(o.getXY(h.get(1,0)).sub(o.getXY(h.get(3,0))))),u.y=Math.max(0,l.crossProduct(o.getXY(h.get(0,0)).sub(o.getXY(h.get(2,0))))),e?(c=u.x*u.y,g=c<t):(c=u.y,g=c<t),g){t=c;const e=o.getXY(h.get(1,0)),s=o.getXY(h.get(3,0)),a=e.add(s).mul(.5).sub(m);i.assign(m.add(l.mul(l.dotProduct(a)))),n.assign(l),r.assign(u)}}r.mulThis(.5),r.x<r.y&&(r.y=q(r.x,r.x=r.y),n.leftPerpendicularThis())}n.y<0?n.negateThis():0===n.y&&(n.x=1)}class tE{constructor(e){this.m_handleP=-1,this.m_handleQ=-1,this.m_currentSupport=-1,this.m_area=0,this.m_bDone=!0,t(0),this.m_convexHull=e,this.m_function=this.done_}next(){return t(0),!1}get_vertex_handle_p(){return t(0),0}get_vertex_handle_q(){return t(0),0}get_current_support(){return t(0),0}getNext(e){return t(0),0}getPrev(e){return t(0),0}intialize_(){return t(0),!1}increment_(){return t(0),!1}increment_q_(){return t(0),!1}increment_p_(){return t(0),!1}parallel_edge_with_q_support_(){return t(0),!1}parallel_edge_with_p_support_(){return t(0),!1}done_(){return t(0),!1}}class eE{nullGetXY(t){return m("m_getXY is null"),{}}nullDeleteNode(t){m("m_deleteNode is null")}constructor(e){return this.m_treeHull=new ms,this.m_shape=null,this.m_stream=null,this.m_points=null,this.m_geometryHandle=-1,this.m_pathHandle=-1,this.m_getXY=this.nullGetXY,this.m_deleteNode=this.nullDeleteNode,e?e.stream?(this.m_treeHull.setCapacity(Math.min(20,e.n)),this.m_stream=e.stream,this.m_getXY=this.getXYStream,this.m_deleteNode=this.deleteNodeStream,this.m_points=null,this.m_geometryHandle=Nm,void(this.m_pathHandle=Nm)):e.points?(this.m_treeHull.setCapacity(Math.min(20,e.n)),this.m_points=e.points,this.m_getXY=this.getXYPoints,this.m_deleteNode=this.deleteNodePoints,this.m_stream=null,this.m_geometryHandle=Nm,void(this.m_pathHandle=Nm)):void t(0):(this.m_treeHull.setCapacity(20),this.m_shape=new Vm,this.m_geometryHandle=this.m_shape.createGeometry(s.enumMultiPoint),this.m_pathHandle=this.m_shape.insertPath(this.m_geometryHandle,Nm),this.m_getXY=this.getXYShape,this.m_deleteNode=this.deleteNodeShape,this.m_stream=null,void(this.m_points=null))}getXYShape(t){return this.m_shape.getXY(t)}getXYStream(t){return this.m_stream.readPoint2D(t<<1)}getXYPoints(e){return t(0),new w}deleteNodeShape(t){const e=this.m_treeHull.getElement(t);this.m_treeHull.deleteNode(t),this.m_shape.removeVertex(e,!1)}deleteNodeStream(t){this.m_treeHull.deleteNode(t)}deleteNodePoints(e){t(0)}addGeometry(t){if(t.isEmpty())return;const i=t.getGeometryType();if(i===s.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else o(i)?this.addMultiVertexGeometry(t):l(i)?this.addSegment(t):i===s.enumEnvelope?this.addEnvelope(t):i===s.enumPoint?this.addPoint(t):e("Convex_hull: geometry not supported")}getBoundingGeometry(){const t=new Ge,e=this.m_treeHull.getFirst(),s=new Sm({vd:this.m_shape.getVertexDescription()});if(0===this.m_treeHull.size())return s;s.reserve(this.m_treeHull.size()),this.m_shape.queryPoint(this.m_treeHull.getElement(e),t),s.startPathPoint(t);for(let i=this.m_treeHull.getNext(e);-1!==i;i=this.m_treeHull.getNext(i))this.m_shape.queryPoint(this.m_treeHull.getElement(i),t),s.lineToPoint(t);return s}getAntipodalPairsIterator(){return t(0),new tE(this)}getXY(e){return t(0),new w}getXYWithIndex(e){return t(0),new w}getFirst(){return t(0),0}getLast(){return t(0),0}getNext(e){return t(0),0}getPrev(e){return t(0),0}getVertexIndex(e){return t(0),0}getPointCount(){return t(0),0}static constructOrientedMinimumBoundingBox(e,s,i,n,r){t(0)}addMultiVertexGeometry(t){const e=new Ge,s=t.getImpl(),i=new w;for(let n=0;n<t.getPointCount();n++){s.queryXY(n,i);const r=this.addPoint2D(i);if(-1!==r){t.getPointByVal(n,e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(r,s)}}}addEnvelope(t){const e=new Ge;for(let s=0;s<4;s++){const i=new w;t.queryCorner(s,i);const n=this.addPoint2D(i);if(-1!==n){t.queryCornerByVal(s,e);const i=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(n,i)}}}addSegment(t){const e=new Ge,s=t.getStartXY(),i=this.addPoint2D(s);if(-1!==i){t.queryStart(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(i,s)}const n=t.getEndXY(),r=this.addPoint2D(n);if(-1!==r){t.queryEnd(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(r,s)}}addPoint(t){const e=t.getXY(),s=this.addPoint2D(e);if(-1!==s){const e=this.m_shape.addPoint(this.m_pathHandle,t);this.m_treeHull.setElement(s,e)}}addPoint2D(t){let e=-1;if(0===this.m_treeHull.size())return e=this.m_treeHull.addElement(-4),e;if(1===this.m_treeHull.size()){const s=this.m_treeHull.getElement(this.m_treeHull.getFirst()),i=this.m_shape.getXY(s);return t.equals(i)||(e=this.m_treeHull.addBiggestElement(-5)),e}return e=this.treeHull(t),e}treeHull(t){let e=-1;do{const s=this.m_treeHull.getFirst(),i=this.m_treeHull.getLast(),n=this.m_treeHull.getElement(s),r=this.m_treeHull.getElement(i),o=this.m_getXY(n),a=this.m_getXY(r),h=w.orientationRobust(a,t,o);if(rE(h)){e=this.m_treeHull.addBiggestElement(-1);const n=this.treeHullWalkBackward(t,i,s);n!==s&&this.treeHullWalkForward(t,s,this.m_treeHull.getPrev(n));break}if(oE(h)){let n=this.m_treeHull.getRoot(),r=this.m_treeHull.getFirst(),a=this.m_treeHull.getLast(),h=-1,m=-1,l=-1;for(;r!==this.m_treeHull.getPrev(a);){m=this.m_treeHull.getElement(n);const e=this.m_getXY(m);oE(w.orientationRobust(e,t,o))?(a=n,n=this.m_treeHull.getLeft(n)):(r=n,n=this.m_treeHull.getRight(n))}n=a,h=r,m=this.m_treeHull.getElement(n),l=this.m_treeHull.getElement(h);const u=this.m_getXY(m),c=this.m_getXY(l);if(h!==s){if(!rE(w.orientationRobust(c,t,u)))break}e=this.m_treeHull.addElementAtPosition(h,n,-2,!0,!1),this.treeHullWalkForward(t,n,i),this.treeHullWalkBackward(t,h,s);break}{const n=aE(t,a,o);if(-1===n){const n=this.m_treeHull.getPrev(i);this.m_treeHull.deleteNode(i),e=this.m_treeHull.addBiggestElement(-3),this.treeHullWalkBackward(t,n,s)}else if(1===n){const n=this.m_treeHull.getNext(s);this.m_treeHull.deleteNode(s),e=this.m_treeHull.addElementAtPosition(-1,n,-3,!0,!1),this.treeHullWalkForward(t,n,i)}break}}while(0);return e}treeHullWalkForward(t,e,s){if(e===s)return s;let i=e,n=this.m_treeHull.getElement(i),r=this.m_treeHull.getNext(i);const o=this.m_getXY(n);for(;i!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(r),s=this.m_getXY(e);if(rE(w.orientationRobust(s,t,o)))break;const a=i;i=r,n=e,o.assign(s),r=this.m_treeHull.getNext(i),this.m_deleteNode(a)}return i}treeHullWalkBackward(t,e,s){if(e===s)return s;let i=e,n=this.m_treeHull.getElement(i),r=this.m_treeHull.getPrev(i);const o=this.m_getXY(n);for(;i!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(r),s=this.m_getXY(e);if(rE(w.orientationRobust(o,t,s)))break;const a=i;i=r,n=e,o.assign(s),r=this.m_treeHull.getPrev(i),this.m_deleteNode(a)}return i}}function sE(t,e,s){const i=e.sub(t),n=s.sub(e);if(0===i.x)return n.x>0?-1:0;if(0===i.y)return n.y>0?1:n.y<0?-1:0;const r=i.crossProduct(n),o=4*Number.EPSILON*(Math.abs(n.x*i.y)+Math.abs(n.y*i.x));return r>o?1:r<-o?-1:w.orientationRobust(t,e,s)}function iE(t,e,s){const i=e.sub(t),n=s.sub(e);if(0===i.x)return n.x<0?-1:0;if(0===i.y)return n.y>0?-1:n.y<0?1:0;const r=i.crossProduct(n),o=4*Number.EPSILON*(Math.abs(n.x*i.y)+Math.abs(n.y*i.x));return r>o?1:r<-o?-1:w.orientationRobust(t,e,s)}function nE(t,e,s){const i=new Qe(0);for(let a=0;a<e;a++)i.add(a);const n={userSort(e,s,i){i.sort(e,s,((e,s)=>t[e].compareX(t[s])))},getValue:e=>t[e].x};ss.sortEx(i,0,e,n);let r=0;t:for(let a=0;a<e;++a){const e=i.read(a);for(;r>=2;){const n=s[r-2],o=s[r-1];if(t[o].equals(t[e])){i.write(a,-1);continue t}if(!(sE(t[n],t[o],t[e])>=0)){o===i.read(a-1)&&i.write(a-1,-1);break}r--}s[r++]=e,2===r&&t[e].equals(t[s[0]])&&(i.write(1,-1),r--)}const o=r+1;t:for(let a=e-2;a>=0;--a){const e=i.read(a);if(!(e<0)){for(;r>=o;){const i=s[r-2],n=s[r-1];if(t[n].equals(t[e]))continue t;if(!(iE(t[i],t[n],t[e])>=0))break;r--}if(0!==a){const i=s[r-1];s[r++]=e,t[e].equals(t[i])&&r--}}}return r>1&&t[s[0]].equals(t[s[r-1]])&&r--,r}function rE(t){return t<0}function oE(t){return t>0}function aE(t,e,s){let i=-1;if(e.y===s.y)i=0;else if(e.x===s.x)i=1;else{i=Math.abs(e.x-s.x)>=Math.abs(e.y-s.y)?0:1}let n=-1;return n=e[i]<s[i]?t[i]<e[i]?-1:s[i]<t[i]?1:0:e[i]<t[i]?-1:t[i]<s[i]?1:0,n}function hE(t){return(t=t.clone()).divThis(Math.max(Math.abs(t.x),Math.abs(t.y))),t.normalize(),t}function mE(t,e,s){t.inc(e,0)===s&&t.set(e,0,0),t.inc(e,1)===s&&t.set(e,1,0)}function lE(t,s,i,n,r){switch(r){case 0:break;case 1:s.rightPerpendicularThis(),t.rightPerpendicularThis();break;case 2:s.negateThis(),t.negateThis();break;case 3:s.leftPerpendicularThis(),t.leftPerpendicularThis();break;default:e("")}return w.orientationRobustEx(t,s,i,n)}function uE(t,e,s,i,n){return cE(t,!1,e,s,i,n)}function cE(t,e,i,n,r,o){const a=i.getGeometryType(),h=n.getGeometryType(),l=Math.max(r,Xi(i,n));if(a===s.enumLine&&h===s.enumLine)return $i(i,n,l,o);let u=i,c=n,g=i.getStartXY(),_=i.getEndXY();if(g.compare(_)>0&&(u=i.clone().reverse()),g=n.getStartXY(),_=n.getEndXY(),g.compare(_)>0&&(c=n.clone().reverse()),e){if(i.equals(n))return 2;if(vi(i,n,l))return 4}switch(a){case s.enumLine:switch(h){case s.enumEllipticArc:return kP(t,c,u,l,o);case s.enumBezier:return vh(t,c,u,l,o);case s.enumRationalBezier2:return ua(t,c,u,l,o);case s.enumBezier2:return Wr();default:m("")}break;case s.enumEllipticArc:switch(h){case s.enumLine:return kP(t,u,c,l,o);case s.enumEllipticArc:return RP(t,u,c,l,o);case s.enumBezier:return bh(t,c,u,l,o);case s.enumRationalBezier2:return ca();case s.enumBezier2:return jr();default:m("")}break;case s.enumBezier:switch(h){case s.enumLine:return vh(t,u,c,l,o);case s.enumEllipticArc:return bh(t,u,c,l,o);case s.enumBezier:return Ih(t,u,c,l,o);case s.enumRationalBezier2:return wh(t,u,c,l,o);case s.enumBezier2:return Dh();default:m("")}break;case s.enumRationalBezier2:switch(h){case s.enumLine:return ua(t,u,c,l,o);case s.enumEllipticArc:return ca();case s.enumBezier:return wh(t,c,u,l,o);case s.enumRationalBezier2:return _a(t,u,c,l,o);case s.enumBezier2:return da();default:m("")}break;case s.enumBezier2:switch(h){case s.enumLine:return Wr();case s.enumEllipticArc:return jr();case s.enumBezier:return Dh();case s.enumRationalBezier2:return da();case s.enumBezier2:return Zr();default:m("")}break;default:m("")}}function gE(t,e,i=!0){if(!i&&!_E(t,e))return 0;const n=t.isLine()&&e.isLine();if(t.getStartXY().equals(e.getStartXY())&&t.getEndXY().equals(e.getEndXY())){const i=1;if(n)return i;const r=t.getGeometryType();if(r!==e.getGeometryType())return 0;if(r===s.enumBezier){const s=t,n=e;return s.getControlPoint1().equals(n.getControlPoint1())&&s.getControlPoint2().equals(n.getControlPoint2())?i:0}if(r===s.enumEllipticArc)return UP()?i:0;if(r===s.enumRationalBezier2){const s=t,n=e;if(s.getControlPoint1().equals(n.getControlPoint1())&&s.getStandardFormWeight()===n.getStandardFormWeight())return i}else if(r===s.enumBezier2){const s=e;if(t.getControlPoint1().equals(s.getControlPoint1()))return i}return 0}if(t.getStartXY().equals(e.getEndXY())&&t.getEndXY().equals(e.getStartXY())){const i=-1;if(n)return i;const r=t.getGeometryType();if(r!==e.getGeometryType())return 0;if(r===s.enumBezier){const s=t,n=e;return s.getControlPoint1().equals(n.getControlPoint2())&&s.getControlPoint2().equals(n.getControlPoint1())?i:0}if(r===s.enumEllipticArc)return UP()?i:-1;if(r===s.enumRationalBezier2){const s=t,n=e;if(s.getControlPoint1().equals(n.getControlPoint1())&&s.getStandardFormWeight()===n.getStandardFormWeight())return i}else if(r===s.enumBezier2){const s=e;if(t.getControlPoint1().equals(s.getControlPoint1()))return i}return 0}return 0}function _E(t,e){const i=t.getGeometryType();return i===e.getGeometryType()&&(i!==s.enumEllipticArc||t.projectionBehavior()===e.projectionBehavior())}function dE(t,i,n,r,o,a,h){!o&&a&&e("");const l=i.getGeometryType(),u=n.getGeometryType(),c=Math.max(h,Xi(i,n));if(r&&(r.length=0),o&&(o.length=0),a&&(a.length=0),l===s.enumLine&&u===s.enumLine)return tn(i,n,r,o,a,c,!1,!1);let g=i,_=n,d=i.getStartXY(),p=i.getEndXY(),f=!1,x=!1;d.compare(p)>0&&(g=i.clone(!0).reverse(),f=!0),d=n.getStartXY(),p=n.getEndXY(),d.compare(p)>0&&(_=n.clone(!0).reverse(),x=!0);let y=0;switch(l){case s.enumLine:switch(u){case s.enumEllipticArc:y=BP(t,_,g,r,a,o,c,!1,!1,!0);break;case s.enumBezier:y=Th(t,_,g,r,a,o,c,!1,!1,!0);break;case s.enumRationalBezier2:y=pa(t,_,g,r,a,o,c,!1,!1,!0);break;case s.enumBezier2:y=Qr(t,_,g,r,a,o,c,!1,!1,!0);break;default:m("")}break;case s.enumEllipticArc:switch(u){case s.enumLine:y=BP(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumEllipticArc:y=LP(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumBezier:y=Nh(t,_,g,r,a,o,c,!1,!1,!0);break;case s.enumRationalBezier2:y=fa();break;case s.enumBezier2:y=Kr(t,_,g,r,a,o,c,!1,!1,!0);break;default:m("")}break;case s.enumRationalBezier2:switch(u){case s.enumLine:y=pa(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumEllipticArc:y=fa();break;case s.enumBezier:y=qh(t,_,g,r,a,o,c,!1,!1,!0);break;case s.enumRationalBezier2:y=xa(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumBezier2:y=ya(t,g,_,r,o,a,c,!1,!1,!1);break;default:m("")}break;case s.enumBezier2:switch(u){case s.enumLine:y=Qr(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumEllipticArc:y=Kr(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumBezier:y=Fh(t,_,g,r,a,o,c,!1,!1,!0);break;case s.enumRationalBezier2:y=ya(t,_,g,r,a,o,c,!1,!1,!0);break;case s.enumBezier2:y=Jr(t,g,_,r,o,a,c,!1,!1,!1);break;default:m("")}break;case s.enumBezier:switch(u){case s.enumLine:y=Th(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumEllipticArc:y=Nh(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumBezier:y=Ah(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumRationalBezier2:y=qh(t,g,_,r,o,a,c,!1,!1,!1);break;case s.enumBezier2:y=Fh(t,g,_,r,o,a,c,!1,!1,!1);break;default:m("")}break;default:m("")}if(f){if(o){for(let t=0;t<y;t++)o[t]=1-o[t];o.reverse()}r&&r.reverse(),a&&a.reverse()}if(x&&a)for(let e=0;e<y;e++)a[e]=1-a[e];return y}function pE(t,e,s){if(e===s)return 0;e>s&&(s=q(e,e=s));return t.cut(e,s,!0).calculateUpperLength2D()}function fE(t,e,s,i,n){const r=[],o=[],a=[];for(let m=0,l=n;m<l;m++)r.push(t.calculateSubLengthFromStart(s[m])),o.push(e.calculateSubLengthFromStart(i[m])),ht(s[m],0,1)&&ht(i[m],0,1)&&t.getCoord2D(s[m]).equals(e.getCoord2D(i[m]))&&a.push(m);if(0===a.length||a.length===n)return;a.sort(((t,e)=>s[t]<s[e]?-1:s[t]>s[e]?1:i[t]<i[e]?-1:i[t]>i[e]?1:0));let h=-1;for(const m of a){if(h>=0&&s[m]===s[h]&&s[m]===s[h]){h=m;continue}h=m;const a=[];a.length=n;for(let t=0;t<a.length;++t)a[t]=t;a.sort(((t,e)=>{const s=r[m],i=o[m],n=r[t]-s,a=o[t]-i,h=n*n+a*a,l=r[e]-s,u=o[e]-i,c=l*l+u*u;return h<c?-1:h>c?1:0}));for(let r=0;r<n;r++){const n=a[r];if(n===m||s[n]===s[m]&&i[n]===i[m]||ht(s[n],0,1)&&ht(i[n],0,1))continue;const o=(s,i,n,r)=>{const o=new pi,a=new ot;a.setWithEps(1);const h=new ot;h.set(i,a.eps()),t.queryCoord2DE(h,o);const m=new pi;t.queryCoord2DE(new ot(s),m);let l=!1;return o.eq(m)&&(h.set(r,a.eps()),e.queryCoord2DE(h,o),e.queryCoord2DE(new ot(n),m),l=o.eq(m)),!l},h=w.getNAN();t.queryCoord2D(s[n],h);const l=w.getNAN();e.queryCoord2D(i[n],l);if(0===w.distance(h,l)&&o(s[m],s[n],i[m],i[n]))break;const u=new A(i[n],i[m]);u.normalizeNoNAN();const c=new A(s[n],s[m]);c.normalizeNoNAN();let g=-1,_=Number.POSITIVE_INFINITY,d=Number.POSITIVE_INFINITY,p=s[n];h.assign(t.getCoord2D(p));for(let r=0;r<5;r++){const r=e.getClosestCoordinateOnInterval(h,u,-1);l.assign(e.getCoord2D(r));const a=w.distance(h,l);if(p=t.getClosestCoordinateOnInterval(l,c,-1),p===s[m]&&r===i[m]){g=1;break}h.assign(t.getCoord2D(p));const f=w.distance(l,h);if(!(f<d&&a<_)){g=0;break}if(0===f&&0===a){o(s[m],s[n],i[m],i[n])?(s[n]=p,i[n]=r,g=0):g=1;break}d=f,_=a}if(-1===g&&(g=ht(s[n],0,1)||ht(i[n],0,1)?0:1),1!==g)break;s[n]=s[m],i[n]=i[m]}}}function xE(t,e,s,i,n,r,o,a,h,m,l,u,c){if(!r)return 0;const g=(t,e)=>{for(let s=0;s<r;++s){let i=e[s];if(ht(i,0,1)){i=te(i);continue}const n=t.getCoord2D(i);i<.5?n.equals(t.getStartXY())&&pE(t,0,i)<=Yi(t)&&(e[s]=0):n.equals(t.getEndXY())&&pE(t,i,1)<=Yi(t)&&(e[s]=1)}};g(e,i),g(s,n),fE(e,s,i,n,r);const _=[];for(let f=0,x=r;f<x;f++)_.push(f);const d=(t,e)=>c?ee(n[t],i[t],n[e],i[e]):ee(i[t],n[t],i[e],n[e]);if(_.length>1){_.sort(d);const t=Math.max(Yi(e),Yi(s));let r=0;for(let o=1,a=_.length;o<a;o++){const a=i[_[r]],h=i[_[o]],m=n[_[r]],l=n[_[o]];if(a!==h||m!==l)if(!(pE(e,a,h)<=t&&pE(s,m,l)<=t)||ht(a,0,1)&&ht(m,0,1)||ht(h,0,1)&&ht(l,0,1))r++,_[r]=_[o];else{const t=w.distance(e.getCoord2D(a),s.getCoord2D(m)),i=w.distance(e.getCoord2D(h),s.getCoord2D(l));if(t<=i)continue;if(i<t){_[r]=_[o];continue}}}if(_.length=r+1,1===_.length&&0!==_[0]&&(i[0]=i[_[0]],n[0]=n[_[0]],_[0]=0),_.length>2){const t=A.constructEmpty(),r=A.constructEmpty();t.setCoords(i[_[0]],i[_.at(-1)]),r.setCoords(n[_[0]],n[_.at(-1)]);let o=!0;for(let e=1,s=_.length-1;e<s;e++)if(!t.containsCoordinate(i[_[e]])||!r.containsCoordinate(n[_[e]])){o=!1;break}if(o){const i=[.5,.2,.7,.1,.3,.4,.6,.8,.9];for(let n=0;n<i.length;n++){let a=_t(t.vmin,t.vmax,i[n]);const h=e.getCoord2D(a);if(!s.isCloserThanDistance(h,r,m)){o=!1;break}a=_t(r.vmin,r.vmax,i[n]);const l=s.getCoord2D(a);if(!e.isCloserThanDistance(l,t,m)){o=!1;break}}}o&&(_[1]=_.at(-1),_.length=2)}}if(1===_.length&&t){const t=0,r=0;Si(e,s,i[0],n[0],m,1,[t],[r])&&(_.push(1),i[1]=t,n[1]=r,_.sort(d))}if(l&&1===_.length){let t=!0;for(let r=0,o=_.length;r<o;r++){if(ht(i[_[r]],0,1)&&ht(n[_[r]],0,1)){if(0===w.distance(e.getCoord2D(i[_[r]]),s.getCoord2D(n[_[r]])))continue}t=!1;break}if(t)return 0}let p=0;for(let f=0,x=_.length;f<x;f++){if(a&&a.push(i[_[f]]),h&&h.push(n[_[f]]),o){const t=w.getNAN();e.queryCoord2D(i[_[f]],t),o.push(t)}p++}return p}function yE(t,e,s,i,n,r,o,a,h){if(ht(s,0,1)&&ht(i,0,1)){if(0===w.distance(t.getCoord2D(s),e.getCoord2D(i))){const m=1e-12,l=new pi,u=Number.EPSILON;if(t.queryDerivative(new ot(s,u),l),l.isTrueZero()){const e=1===s?-m:m;t.queryDerivative(new ot(s,u).add(e),l)}1===s&&l.negateThis();const c=new pi;if(e.queryDerivative(new ot(i,u),c),c.isTrueZero()){const t=1===s?-m:m;e.queryDerivative(new ot(i,u).add(t),c)}1===i&&c.negateThis(),l.isZero()||l.normalize(),c.isZero()||c.normalize();const g=l.dotProduct(c),_=l.crossProduct(c);_.scaleError(3);const d=()=>{if(h)return.001;{const s=t.calculateUpperLength2D(),i=e.calculateUpperLength2D();return Math.min(.01*n/Math.min(s,i),1e-10)}};if(g.ge(wt)&&(_.isZero()||Math.abs(_.value())<d())){return Ci(t,e,s,i,n,r,o,a)}}}return 0}function PE(e,s,i,n,r){let o=-1,a=-1,h=-1,m=-1;{const t=[0,s],r=[s,0],l=[0,n],u=[n,0];for(let s=0;s<2&&-1===o;++s)for(let n=0;n<2;++n)if(e[t[s]].equals(i[l[n]])){o=t[s],a=r[s],h=l[n],m=u[n];break}}if(-1===o){const t=new ni;t.setFromPoints(e,s+1);const o=new ni;return o.setFromPoints(i,n+1),o.inflate(r),t.isIntersectingW(o)?-1:0}{const l=new Array(s+1),u=KP(e,s+1,l);t(u>1);let c=0,g=0;for(let t=0;t<u;++t)o===l[t]&&(g=t,c++),a===l[t]&&c++;if(2!==c)return-1;const _=new Array(n+1),d=KP(i,n+1,_);t(d>1),c=0;let p=0;for(let t=0;t<d;++t)h===_[t]&&(p=t,c++),m===_[t]&&c++;if(2!==c)return-1;const f=e[l[(g+u-1)%u]],x=e[l[(g+1)%u]],y=i[_[(p+d-1)%d]],P=i[_[(p+1)%d]],E=e[o],C=[f,x,y,P],S=[0,1,2,3];S.sort(((t,e)=>w.compareVectorsOrigin(E,C[t],C[e])));let v=S[0];for(let t=1;t<4;t++){if(S[t]!==(v+1)%4)return-1;v=S[t]}{const t=f.sub(E),e=P.sub(E),s=e.dotProduct(t);if(s>0){const i=e.crossProduct(t),n=Math.abs(Math.atan2(i,s)),o=n*t.length(),a=n*e.length();if(o<=r||a<=r)return-1}}{const t=x.sub(E),e=y.sub(E),s=e.dotProduct(t);if(s>0){const i=e.crossProduct(t),n=Math.abs(Math.atan2(i,s)),o=n*t.length(),a=n*e.length();if(o<=r||a<=r)return-1}}return 1}}var EE=Ce;class CE extends zi{constructor(t){super(t||{XStart:0,YStart:0,XEnd:0,YEnd:0})}assignMove(t){return this!==t&&(this.m_description=t.m_description,t.m_description=null,this.m_attributes=t.m_attributes,t.m_attributes=null,this.m_XStart=t.m_XStart,t.m_XStart=Number.NaN,this.m_YStart=t.m_YStart,this.m_XEnd=t.m_XEnd,t.m_XEnd=Number.NaN,this.m_YEnd=t.m_YEnd),this}assignCopy(t){return this!==t&&t.copyTo(this),this}calculateLowerLength3D(){return t(0),0}calculateUpperLength3D(){return t(0),0}changeEndPoints3D(e,s){t(0)}getClosestCoordinate3D(e,s,i){return t(0),0}getBoundary(){return lm(this)}transformAttribute(e,s,i,n,r){t(0)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?Wi(this,t):ji(this,t);const i=EE.getInterpolation(e),n=this.getStartAttributeAsDbl(e,s),r=this.getEndAttributeAsDbl(e,s);return dt(i,n,r,t,EE.getDefaultValue(e))}constructFromCoords(t,e,s,i){this.dropAllAttributes(),this.setStartXYCoords(t,e),this.setEndXYCoords(s,i)}construct(t,e){this.dropAllAttributes(),this.setStartXY(t),this.setEndXY(e)}construct3D(e,s){t(0)}constructFromPoints(e,s){t(0)}getGeometryType(){return CE.type}queryEnvelope(e){if(e instanceof ke){e.setEmpty(),e.assignVertexDescription(this.m_description);const t=ge.constructEmpty();this.queryEnvelope(t),e.setEnvelope(t);for(let s=1,i=this.m_description.getAttributeCount();s<i;s++){const t=this.m_description.getSemantics(s);for(let i=0,n=EE.getComponentCount(t);s<n;s++){const s=this.queryInterval(t,i);e.setIntervalEnvelope(t,i,s)}}}else e instanceof ge?e.setCoords({xmin:this.m_XStart,ymin:this.m_YStart,xmax:this.m_XEnd,ymax:this.m_YEnd}):e instanceof _e?(e.setEmpty(),e.mergeCoords(this.m_XStart,this.m_YStart,Fi(this,0,1,0)),e.mergeCoords(this.m_XEnd,this.m_YEnd,Fi(this,1,1,0))):t(0)}applyTransformation(e){t(e instanceof Y);const s=new w;s.x=this.m_XStart,s.y=this.m_YStart,e.transformInPlace(s),this.m_XStart=s.x,this.m_YStart=s.y,s.x=this.m_XEnd,s.y=this.m_YEnd,e.transformInPlace(s),this.m_XEnd=s.x,this.m_YEnd=s.y}createInstance(){return t(0),this}calculateLength2D(){return Math.sqrt(mn(this))}calculateLength3D(e){return t(0),0}changeEndPoints2D(t,e){this.setStartXY(t),this.setEndXY(e),this.normalizeAfterEndpointChange()}queryCoord2D(t,e){return Ui(this,t,e)}queryCoord3D(e,s){t(0)}getCoordZ(e){return t(0),0}queryCoord2DE(t,e){Qi(this,t,e)}getCoordX(e){return t(0),0}getCoordY(e){return t(0),0}cut(t,e,s){const i=new SE;return this.queryCut(t,e,i,s),i.releaseSegment()}queryCut(t,e,s,i){const n=s.createLine();i&&n.assignVertexDescription(this.m_description);const r=w.getNAN();if(Ui(this,t,r),n.setStartXYCoords(r.x,r.y),Ui(this,e,r),n.setEndXYCoords(r.x,r.y),!i)for(let o=1,a=this.m_description.getAttributeCount();o<a;o++){const s=this.m_description.getSemantics(o),i=EE.getComponentCount(s);for(let r=0;r<i;r++){const i=this.getAttributeAsDbl(t,s,r);n.setStartAttribute(s,r,i);const o=this.getAttributeAsDbl(e,s,r);n.setEndAttribute(s,r,o)}}}queryDerivative(t,e){Zi(this,t,e)}getClosestCoordinate(t,e){return w.getClosestCoordinate(this.getStartXY(),this.getEndXY(),t,e)}getClosestCoordinateOnInterval(t,e,s=-1){const i=new w;this.queryCoord2D(e.vmin,i);const n=new w;this.queryCoord2D(e.vmax,n);const r=w.getClosestCoordinate(i,n,t,!1);return Li.recalculateParentT(e.vmin,e.vmax,r)}intersectionOfYMonotonicWithAxisX(t,e){const s=this.m_YEnd-this.m_YStart;if(!s)return t===this.m_YEnd?e:Number.NaN;const i=(t-this.m_YStart)/s;let n=Wi(this,i);return 1===i&&(n=this.m_XEnd),n}isCurve(){return!1}isMonotoneQuickAndDirty(){return!0}isDegenerate(t){const e=this.m_XStart-this.m_XEnd,s=this.m_YStart-this.m_YEnd;return Math.sqrt(e*e+s*s)<=t}isDegenerate3D(e,s){return t(0),!1}queryLooseEnvelope(t){this.queryEnvelope(t)}clone(t){const e=new CE;return this.copyTo(e),e}tToLength(t){return t*this.calculateLength2D()}lengthToT(t){const e=this.calculateLength2D();return 0!==e?t/e:0}calculateWeightedAreaCentroid2D(e){return t(0),new w(0,0)}calculateWeightedCentroid2D(){return this.getCoord2D(.5).mul(this.calculateLength2D())}queryAttributeAsDbl(e,s,i,n){t(0)}getTangent(t){const e=w.getNAN();return e.setSub(this.getEndXY(),this.getStartXY()),e}getDerivative(e){return t(0),new w(0,0)}getCurvature(t){return 0}isIntersectingPoint(t,e,s){return rn(this,t,e,s)>=0}isIntersectingPoint3D(e,s,i,n,r=1){return t(0),!1}getYMonotonicParts(e,s){return t(0),0}getMonotonicParts(t,e){return 0}getMonotonicPartParams(e,s){return t(0),0}intersectionWithAxis2D(t,e,s,i){if(t){const t=this.m_YEnd-this.m_YStart;if(!t)return e===this.m_YEnd?-1:0;const n=(e-this.m_YStart)/t;return n<0||n>1?0:(s&&(s[0]=Wi(this,n)),i&&(i[0]=n),1)}{const t=this.m_XEnd-this.m_XStart;if(!t)return e===this.m_XEnd?-1:0;const n=(e-this.m_XStart)/t;return n<0||n>1?0:(s&&(s[0]=ji(this,n)),i&&(i[0]=n),1)}}calculateUpperLength2D(){return this.calculateLength2D()}calculateLowerLength2D(){return this.calculateLength2D()}normalizeAfterEndpointChange(){return!1}queryLooseEnvelopeOnInterval(e,s){if(s instanceof ge){let t=T(e.vmin,0,1);const i=new w;return this.queryCoord2D(t,i),s.setCoords({pt:i}),t=T(e.vmax,0,1),this.queryCoord2D(t,i),void s.mergeNe(i)}t(0)}orientBottomUp(){Ji(this)}isLine(){return!0}isDegenerateToLineHelper(e){return t(0),!1}copyIgnoreAttributes(e){t(0)}calculateArea2DHelper(){return t(0),0}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)}queryEnvelopeW(t,e){e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax))}setSegmentFromCoords(e,s){t(0)}writeInBufferStream(e,s){return t(0),0}readFromBufferStream(e,s){t(0)}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(e,s){return t(0),0}ensureXYMonotone(){return!1}setCoordsForIntersector(t,e,s){Ki(this,t,e)}static isIntersectingLineLine(e,s,i,n){return t(0),0}static isIntersectingLineLine_(e,s,i,n){return t(0),0}copyToImpl(t){}reverseImpl(){}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}getHashCodeImpl(){return t(0),0}swapImpl(e){t(0)}afterCompletedModification(){}endPointModified(){}clearEndPointModified(){}intersect(t,e,s,i,n){return dE(!1,this,t,e,s,i,n)}intersectPoint(t,e,s){e.length<1&&i("");const n=rn(this,t,s,!1);return n>=0?(e&&(e[0]=n),1):0}isIntersecting(t,e,s){return 0!==uE(!1,this,t,e,s)}intersect_(e,s,i,n){return t(0),0}}CE.type=s.enumLine;class SE{constructor(e){this.m_seg=null,this.m_curves=null,this.m_lineBuffer=new CE,this.m_mask=0,this.m_active=0,void 0!==e&&(e.copy?e.copy.copyTo(this,!1):e.move?this.assignMove(e.move):e.segment?this.copyFrom(e.segment,!!e.bIgnoreAttributes):t(0))}assignCopy(t){return t instanceof SE?this!==t&&t.copyTo(this,!1):this.copyFrom(t,!1),this}assignMove(t){if(t instanceof SE){if(this===t)return this;this.reset(),1&t.m_mask&&(this.m_lineBuffer=t.m_lineBuffer,t.m_lineBuffer=null,this.m_mask=1),this.m_curves=t.m_curves,this.m_mask=t.m_mask,this.m_active=t.m_active,t.reset(),this.m_seg=this.activeSegment(),t.m_seg=null}else{if(this.m_seg===t)return this;this.create(t.getGeometryType()),this.m_seg.swap(t)}return this}activeSegment(){switch(this.m_active){case 0:return null;case 1:return this.line();case 2:return this.arc();case 4:return this.bezier3();case 8:return this.bezier2();case 16:return this.rbezier2();default:m("")}}get(){return this.m_seg}reset(){1&this.m_mask&&(this.m_lineBuffer=null),this.m_mask>1&&(this.m_curves=null),this.m_mask=0,this.m_active=0}empty(){return null===this.m_seg}copyTo(t,e){this!==t&&(this.empty()?t.m_seg=null:t.copyFrom(this.m_seg,e))}copyToWithZ(e,s){t(0)}createImpl(t){switch(t){case s.enumLine:1&this.m_mask||(this.m_lineBuffer=new CE,this.m_mask|=1,this.m_active=1);break;case s.enumEllipticArc:2&this.m_mask||(this.m_curves=new Cm,this.m_mask=1&this.m_mask|2,this.m_active=2);break;case s.enumBezier:4&this.m_mask||(this.m_curves=new lo,this.m_mask=1&this.m_mask|4,this.m_active=4);break;case s.enumBezier2:8&this.m_mask||(this.m_curves=new Ln,this.m_mask=1&this.m_mask|8,this.m_active=8);break;case s.enumRationalBezier2:16&this.m_mask||(this.m_curves=new Xa,this.m_mask=1&this.m_mask|16,this.m_active=16);break;default:e("")}}create(t){t===s.enumLine?this.createLine():t===s.enumEllipticArc?this.createEllipticArc():t===s.enumBezier?this.createCubicBezier():t===s.enumRationalBezier2?this.createQuadraticRationalBezier():t===s.enumBezier2?this.createQuadraticBezier():e("Segment_buffer.create")}copyFrom(t,e){this.m_seg!==t&&(this.create(t.getGeometryType()),e?t.copyIgnoreAttributes(this.m_seg):t.copyTo(this.m_seg))}copyFromWithZ(e,s){t(0)}line(){return this.m_lineBuffer}arc(){return this.m_curves}bezier3(){return this.m_curves}bezier2(){return this.m_curves}rbezier2(){return this.m_curves}createLine(){return this.createImpl(s.enumLine),this.m_seg=this.line(),this.line()}createEllipticArc(){return this.createImpl(s.enumEllipticArc),this.m_seg=this.arc(),this.arc()}createCubicBezier(){return this.createImpl(s.enumBezier),this.m_seg=this.bezier3(),this.bezier3()}createQuadraticRationalBezier(){return this.createImpl(s.enumRationalBezier2),this.m_seg=this.rbezier2(),this.rbezier2()}createQuadraticBezier(){return this.createImpl(s.enumBezier2),this.m_seg=this.bezier2(),this.bezier2()}releaseSegment(){if(this.m_seg=null,0===this.m_active&&m("releaseSegment"),1&this.m_active){const t=this.line();return this.m_mask-=1,this.m_active=0,this.m_lineBuffer=null,t}let t;return 2&this.m_active?t=this.arc():4&this.m_active?t=this.bezier3():8&this.m_active?t=this.bezier2():16&this.m_active?t=this.rbezier2():m("releaseSegment"),this.m_mask-=this.m_active,this.m_active=0,this.m_curves=null,t}equals(e){return e instanceof SE?this===e||(this.empty()?e.empty():!e.empty()&&this.get().equals(e.get())):(t(0),!1)}}const vE=["0","1","2","3","4","5","6","7","8","9","b","c","d","e","f","g","h","j","k","m","n","p","q","r","s","t","u","v","w","x","y","z"];function bE(t,e,s){const i=H(e,"R");let n=0,r=0;for(let o=0;o<e;o++){let s=t[n]>>r&31;if(r+=5,r>31){const e=37-r;s&=(1<<e)-1,r-=32,n++,s|=(t[n]&(1<<r)-1)<<e}const a=vE[s];i[e-1-o]=a}return s>e?i.push(..."0".repeat(s-e)):s<e&&(i.length=s),i.join("")}function IE(e,s,i,n,r){t(n>>5<r.length);let o=s,a=i;for(let t=n;t>=0;t-=2){const s=31&t,i=.5*(a+o);e>=i?(r[t>>5]|=1<<s,o=i):a=i}}let wE=new Set;const DE=2147483645n,TE=9007199254740990n,NE="operation is not supported for unknown coordinate systems";var AE;function qE(){return{majorSemiAxis:0,e2:0,minorSemiAxis:0,flattening:0,isSphere(){return 0===this.e2}}}function FE(t,e,s){t.majorSemiAxis=e,t.minorSemiAxis=e*(1-s),t.e2=s*(2-s),t.flattening=s}function ME(t){if(xC)return;qC(t);const e=wE;wE=null,e.forEach((t=>{const e=t.deref();e&&e.attachToPe()}))}function GE(t){AC(t)}function VE(){return!!xC}function YE(){return!!xC||!!TC}function XE(e,s,i){return t(YE()),mC(e,0,null,!1)}function kE(e,s){t(YE());const i=new tC;let n;return VE()?(n=qy(e),i.setHorzProj_(n),i.m_vertcs=null,i.m_userWKID=n.getLatestID()):(n=NC(e),i.m_unit=n.isPCS?new ky(n.metersOrRadiansPerUnit):new vm(n.metersOrRadiansPerUnit)),oC(i.m_precisionDescriptor,n,null,1),i.m_bDefaultDescriptor=!0,i.m_userWKT=e,i.calculateHashCode(),i.initDbgName(),i}function RE(t,e,s,i,n=!0){let r=null;return e&&(r=Ry(e,n)),BE(t,r,s,i,n)}function BE(t,s,i,n,r){t||e("!PE_coord_sys");const o=new tC;let a;return a=r?Ny(t):new yy(t,!1),oC(o.m_precisionDescriptor,a,s,n),o.m_bDefaultDescriptor=!0,o.setHorzProj_(a),o.m_vertcs=s,o.m_userWKID=a.getLatestID(),o.calculateHashCode(),o.initDbgName(),o}function LE(t,s,i=!1){3===t.getCoordinateSystemType()&&e("image spatial reference cannot be altered");const n=new tC,r=t;return n.m_peCoordSysVal=r.m_peCoordSysVal,n.m_vertcs=r.m_vertcs,n.m_unit=r.m_unit,n.m_precisionDescriptor.assign(s),n.m_localZToXYFactor=r.m_localZToXYFactor,(Number.isNaN(n.m_precisionDescriptor.m_falseX)||Number.isNaN(n.m_precisionDescriptor.m_falseY))&&(n.m_precisionDescriptor.m_falseX=r.m_precisionDescriptor.m_falseX,n.m_precisionDescriptor.m_falseY=r.m_precisionDescriptor.m_falseY),n.m_precisionDescriptor.snapPrecision(),n.m_precisionDescriptor.fixTolerance(),n.m_userWKID=r.m_userWKID,n.m_precisionDescriptor.equals(r.m_precisionDescriptor)?n.m_bDefaultDescriptor=r.m_bDefaultDescriptor:n.m_bDefaultDescriptor=!1,i&&(n.m_bDefaultDescriptor=!0),n.calculateHashCode(),n.initDbgName(),n}function HE(t,s,i){void 0===s&&(s=1),(s<=0||!Number.isFinite(s))&&e(""),t||1===s||e("null Unit has to have z_to_xy_factor equal to 1");const n=new tC;n.m_unit=t;const r=t||new ky(9001);return void 0===i?(hC(n.m_precisionDescriptor,r,null,1),n.m_bDefaultDescriptor=!0):(n.m_precisionDescriptor.assign(i),n.m_precisionDescriptor.fixTolerance(),n.m_bDefaultDescriptor=!1),Number.isNaN(n.m_precisionDescriptor.m_falseX)&&e("NAN false X/Y are not allowed here"),n.m_localZToXYFactor=s,n.calculateHashCode(),n.initDbgName(),n}function zE(t,e){return t.snapGeometry(e)}function UE(e){const s=e.getCoordinateSystemType();return 1===s?e:(3===s&&t(0),e.getGCS())}let OE;function WE(){return OE||(OE=(()=>{const t=Math.trunc(Math.random()*k()),e=Date.now();return`|abba_000|${t.toString(16)}|${e.toString(16)}|`})()),OE}!function(t){t[t.utmDefault=0]="utmDefault",t[t.utmNorthSouth=1]="utmNorthSouth"}(AE||(AE={}));let jE,ZE,QE,KE=0;function JE(t=""){let e=`${WE()}${KE++}`;return""!==t&&(e+=`|${t}`),e}function $E(t){return t.startsWith(WE())}class tC{destroy(){Fy(this.m_peCoordSysVal),1===this.getCoordinateSystemType()||2===this.getCoordinateSystemType()?this.getPECoordSys().destroy():m("SpatialReference.destroy")}constructor(){this.m_vertcs=null,this.m_peCoordSysVal=null,this.m_userWKID=0,this.m_userWKT=null,this.m_geogSpatialReference=null,this.m_srToGcs=null,this.m_gcsToSr=null,this.m_defaultPrecisionSR=null,this.m_localZToXYFactor=-1,this.m_precisionDescriptor=new eC,this.m_hashCode=0,this.m_bDefaultDescriptor=!1,rC(this.m_precisionDescriptor),wE&&wE.add(new WeakRef(this))}attachToPe(){(this.m_userWKID>0?XE(this.m_userWKID):kE(this.m_userWKT)).copyTo(this,!1)}copyTo(t,e=!0){(e||t.m_bDefaultDescriptor)&&(t.m_bDefaultDescriptor=this.m_bDefaultDescriptor,t.m_precisionDescriptor.assign(this.m_precisionDescriptor)),t.m_defaultPrecisionSR=null,t.m_gcsToSr=this.m_gcsToSr,t.m_geogSpatialReference=this.m_geogSpatialReference,t.m_hashCode=this.m_hashCode,t.m_localZToXYFactor=this.m_localZToXYFactor,t.m_peCoordSysVal=this.m_peCoordSysVal,t.m_srToGcs=this.m_srToGcs,t.m_userWKID=this.m_userWKID,t.m_userWKT=this.m_userWKT,t.m_vertcs=this.m_vertcs,t.m_unit=this.m_unit}getHashCode(){return this.m_hashCode}getHashCodeHorizontal(){let t=0;return t=this.m_peCoordSysVal?this.m_peCoordSysVal.getHashCode():this.m_unit?this.m_unit.getHashCode():305419891,t}updateTransform(t){if(1===this.getCoordinateSystemType())return Py(this,this,null);let e=t?this.m_srToGcs:this.m_gcsToSr;if(e)return e;const s=this.getGCS(),i=this;e=t?Py(i,s,null):Py(s,i,null);const n=e,r=t?this.m_srToGcs:this.m_gcsToSr;return r||(t?this.m_srToGcs=n:this.m_gcsToSr=n,e)}getHashCodeVertical(){return this.m_vertcs?this.m_vertcs.getHashCode():0}calculateHashCode(){let t=this.getHashCodeHorizontal();const e=this.getHashCodeVertical(),s=this.m_precisionDescriptor.getHashCode();t=O(t,e),this.m_hashCode=O(t,s)}initDbgName(){}setHorzProj_(t){this.m_peCoordSysVal=t,this.m_unit=this.m_peCoordSysVal.getUnit()}getTolerance(t=0){return this.m_precisionDescriptor.getTolerance(t)}getResolution(t=0){return this.m_precisionDescriptor.getResolution(t)}getPECoordSys(){return this.m_peCoordSysVal?this.m_peCoordSysVal.m_peCoordSys:null}getPCSInfo(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSInfo()}getCentralMeridian(){if(this.throwIfNotGCSOrPCS(),1===this.getCoordinateSystemType())return 0;return this.getPCSInfo().getCentralMeridian()}getCoordinateSystemType(){const t=this.getPECoordSys();if(t){switch(t.getType()){case yC.PE_TYPE_GEOGCS:return 1;case yC.PE_TYPE_PROJCS:return 2;default:return 0}}else{if((this.m_userWKID>0||this.m_userWKT)&&this.m_unit instanceof ky)return 2;if(this.m_unit instanceof vm)return 1}return 0}getID(){return this.m_userWKID}getLatestID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getLatestID():this.m_userWKID}getOldID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getOldID():this.m_userWKID}getVerticalID(){return n("vcs not implemented"),0}getLatestVerticalID(){return this.m_vertcs?this.m_vertcs.getLatestID():0}getOldVerticalID(){return n("vcs not implemented"),0}getPEVerticalCoordSys(){return null}getPole(e){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getPole(e)}getText(){const t=this.getPECoordSys();return t?$f(t):this.m_userWKT??""}getTextExtended(t){const e=this.getPECoordSys();return e?this.getPEVerticalCoordSys()?Jf(null,e,this.getPEVerticalCoordSys()):$f(e,t):this.m_userWKT??""}getText2(t=-1){const e=this.getPECoordSys();return e?tx(e,t):this.m_userWKT??""}getUnit(){return this.m_unit}getUnitsPerMillimeter(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getUnitsPerMillimeter():this.m_unit instanceof ky?.001/this.m_unit.getUnitToBaseFactor():this.m_unit instanceof vm?.001/(NC(this.m_userWKT??this.m_userWKID).semiMajor*this.m_unit.getUnitToBaseFactor()):(h("sr object not in valid state"),0)}getAuthorityName(){return""}getVerticalUnit(){return n("vcs not implemented"),{}}getVCS(){return this.m_vertcs}hasVCS(){return!1}getGCSHorisonIsInclusive(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorisonIsInclusive()}getGCSHorizon(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorizon()}getGCS(){const e=this.getCoordinateSystemType();if(0===e)h(NE);else{if(1===e)return this;3===e&&h("image cs not supported")}if(this.m_geogSpatialReference)return this.m_geogSpatialReference;let s;if(this===sC()||this===iC())s=nC();else{t(this.m_peCoordSysVal);const e=this.m_peCoordSysVal.m_peCoordSys.getGeogcs();e||m(""),s=RE(e,this.m_vertcs,null,this.m_precisionDescriptor.getPrecision(),this.m_peCoordSysVal.getCached())}return this.m_geogSpatialReference?s=this.m_geogSpatialReference:this.m_geogSpatialReference=s,s}getGCSSplitLines(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSSplitLines()}toGCS(s,i){if(0===s.length)return 0;s.length>i.length&&e("coordsSrc.size() > coordsDst.size()");const n=this.getCoordinateSystemType();if(0===n&&h(NE),1===n)return tt(i,s,s.length),s.length;t(this.m_peCoordSysVal);const r=this.getSRToGCSTransform();return(new Gp).transform(r,s,s.length,i)}toMilitaryGrid(e,s,i,n,r){return t(0),[]}fromMilitaryGrid(t,e){return[]}toUnitedStatesNationalGrid(t,e,s,i){return[]}fromUnitedStatesNationalGrid(t){return[]}toUniversalTransverseMercator(t,e,s){return[]}fromUniversalTransverseMercator(t,e){return[]}toWorldGeographicReference(t,e,s){return[]}fromWorldGeographicReference(t){return[]}toGlobalArea(t){return[]}fromGlobalArea(t,e){return[]}toDegreeMinuteSecond(t,e){return[]}fromDegreeMinuteSecond(t){return[]}toDegreeDecimalMinute(t,e){return[]}fromDegreeDecimalMinute(t){return[]}toDecimalDegree(t,e){return[]}fromDecimalDegree(t){return[]}fromGeohashToGCSEnvelope(t){return{}}toGeohash(t,e=8){const s=t.clone();s.scale(9102===this.getGCS().getUnit().getID()?1:this.getGCS().getUnit().getUnitToBaseFactor()/Math.PI*180),s.x<-180?(s.x=$(s.x,360),s.x<-180&&(s.x+=360)):s.x>180&&(s.x=$(s.x,360),s.x>180&&(s.x-=360)),s.y>90&&(s.y=90),s.y<-90&&(s.y=-90);const i=5*e,n=new Uint32Array(4);IE(s.x,-180,180,i-1,n),IE(s.y,-90,90,i-2,n);return bE(n,e,e)}calculateContainingGeohash(t){return"1;"}calculateCoveringGeohashes(t,e){return[]}calculateGeohashNeighbours(t){return[]}calculateGeohashNeighbour(t,e,s){return""}isPannable(){const e=this.getCoordinateSystemType();return 0!==e&&3!==e&&(t(this.m_peCoordSysVal),this.m_peCoordSysVal.isPannable())}getPannableExtent(){return this.isPannable()||e("!is_pannable"),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtent()}getPannableExtentInGCS(){return this.isPannable()||e("!is_pannable"),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtentGCS()}throwIfNotGCSOrPCS(){const t=this.getCoordinateSystemType();1!==t&&2!==t&&e("Not a GCS or PCS")}getDomainXY(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getDomainXY()}getFullWorldExtent(){return this.throwIfNotGCSOrPCS(),this.isPannable()?this.getPannableExtent():this.getDomainXY()}queryPrecisionDescriptor(e){if(e.assign(this.m_precisionDescriptor),Number.isNaN(e.m_falseX))if(VE()||h("projection engine is not loaded"),t(null!==this.m_peCoordSysVal),2!==this.m_precisionDescriptor.m_precision){const t=this.m_peCoordSysVal.getDomainXY();e.m_falseX=t.xmin,e.m_falseY=t.ymin}else e.m_falseX=-Number.MAX_VALUE,e.m_falseY=-Number.MAX_VALUE}queryPrecisionDescriptorWithoutFalseXY(t){t.assign(this.m_precisionDescriptor),t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}queryDefaultPrecisionDescriptorWithoutFalseXY(t){if(this.m_bDefaultDescriptor)t.assign(this.m_precisionDescriptor);else{const e=this.getCoordinateSystemType();0===e?hC(t,this.m_unit,this.m_vertcs,this.m_precisionDescriptor.getPrecision()):3===e?n("image cs"):oC(t,this.m_peCoordSysVal,this.m_vertcs,this.m_precisionDescriptor.getPrecision())}t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}horizontalEqual(t){return fy(this.m_peCoordSysVal,t.m_peCoordSysVal)}verticalEqual(t){return null!==this.m_vertcs==(null!==t.m_vertcs)&&(!this.m_vertcs||this.m_vertcs.equals(t.m_vertcs))}equals(e){const s=e;if(this===s)return!0;if(!this.horizontalEqual(s)||!this.verticalEqual(s))return!1;if(!s.m_peCoordSysVal){if(t(!this.m_peCoordSysVal),null!==this.m_unit!=(null!==s.m_unit))return!1;if(this.m_unit&&!this.m_unit.equals(s.m_unit))return!1;if(this.m_localZToXYFactor!==s.m_localZToXYFactor)return!1}if(!this.m_bDefaultDescriptor||!s.m_bDefaultDescriptor){if(this.m_peCoordSysVal){if(!this.m_precisionDescriptor.equalsWithoutFalseXY(s.m_precisionDescriptor))return!1;t(s.m_peCoordSysVal);let e=this.m_precisionDescriptor.m_falseX,i=this.m_precisionDescriptor.m_falseY;if(Number.isNaN(e)){const t=this.m_peCoordSysVal.getDomainXY();e=t.xmin,i=t.ymin}let n=s.m_precisionDescriptor.m_falseX,r=s.m_precisionDescriptor.m_falseY;if(Number.isNaN(n)){const t=s.m_peCoordSysVal.getDomainXY();n=t.xmin,r=t.ymin}return e===n&&i===r}return this.m_precisionDescriptor.equals(s.m_precisionDescriptor)}return!0}equalForProjection(t,e){if(this===t)return!0;const s=this.getCoordinateSystemType(),i=t.getCoordinateSystemType();if(0===s||0===i)return 0===s&&0===i?(!e||this.getZToXYFactor()===t.getZToXYFactor())&&(!this.getUnit()||!t.getUnit()||this.getUnit().equals(t.getUnit())):3!==s&&3!==i&&(null===this.getUnit()||null===t.getUnit()||(!e||this.getZToXYFactor()===t.getZToXYFactor())&&this.getUnit().equals(t.getUnit()));if(s!==i)return!1;if(3===s)return this.equals(t);if(xy(this.m_peCoordSysVal,t.m_peCoordSysVal)){if(!e)return!0;if(null!==this.m_vertcs==(null!==t.m_vertcs))return!this.m_vertcs||this.m_vertcs.equalForProjection(t.m_vertcs)}return!1}equalHorizontal(t){return this.horizontalEqual(t)}equalVertical(t){return!1}equalVerticalVCS(t){return!1}convergenceAngle(t){return 0}getPeCoordsysCopy(){if(this.m_peCoordSysVal){const t=this.m_peCoordSysVal.m_peCoordSys;return t||m("cannot clone coord sys"),t}return null}getPeVertcsCopy(){return 0}throwIfLocal(){0===this.getCoordinateSystemType()&&e(NE)}getPrimeMeridian(){return this.throwIfLocal(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getPrimeMeridian()}getSRToGCSTransform(){return this.updateTransform(!0)}getGCSToSRTransform(){return this.updateTransform(!1)}getOneMeter(){return 1e3*this.getUnitsPerMillimeter()}getOneMeterPCSUnit(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneMeterPCSUnit()}getDefaultPrecisionSR(){if(this.m_bDefaultDescriptor)return this;if(null===this.m_defaultPrecisionSR){const t=new eC;this.queryDefaultPrecisionDescriptorWithoutFalseXY(t),this.m_defaultPrecisionSR=LE(this,t,!0)}return this.m_defaultPrecisionSR}getPCSHorizon(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSHorizon()}getHorzUnitFactor(){return this.m_unit?this.m_unit.getUnitToBaseFactor():1}querySpheroidData(e){this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal);const s=this.getGCS().getPECoordSys().getDatum().getSpheroid(),i=s.getFlattening();FE(e,s.getAxis(),i)}getAreaOfUse(){0===this.getCoordinateSystemType()&&h(""),t(this.m_peCoordSysVal);const e=this.m_peCoordSysVal.getAreaOfUse();return null===e?new gi:new gi({geom:e.clone(),sr:XE(4326)})}getZToXYFactor(){return 1}isCustomWkid(){return!1}getOneDegreeGCSUnit(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneDegreeGCSUnit()}getGcsUnitFactor(){return this.throwIfNotGCSOrPCS(),t(this.m_peCoordSysVal),this.m_peCoordSysVal.getGcsUnitFactor()}snapGeometry(t){if(t.isEmpty())return!1;if(2===this.m_precisionDescriptor.getPrecision())return!1;const e=t.getGeometryType();if(o(e))return this.snapMultiVertex_(t);if(e===s.enumPoint)return this.snapPoint_(t);if(e===s.enumEnvelope)return this.snapEnvelope_(t);if(l(e))return this.snapSegment_(t);if(e===s.enumGeometryCollection){const e=t;let s=!1;for(let t=0,i=e.getGeometryCount();t<i;++t)s=this.snapGeometry(e.getGeometry(t))||s;return s}m("what else?")}snapMultiVertex_(e){if(t(!e.isEmpty()),t(2!==this.m_precisionDescriptor.getPrecision()),p(e.getGeometryType())){const t=e;if(t.hasNonLinearSegments())return this.snapGeometryWithCurves_(t)}const s=e.getImpl(),i=s.getDescription();let n=!1;for(let t=0,r=i.getAttributeCount();t<r;t++){const e=i.getSemantics(t),r=s.getAttributeStreamRef(e);n=this.snapAttributes(e,r,0,s.getPointCount())||n}return n&&s.notifyModifiedFlags(2001),n}snapPoint_(t){return!1}snapEnvelope_(t){return!1}snapSegment_(e){t(!e.isEmpty()),t(2!==this.m_precisionDescriptor.getPrecision());const s=new eC;this.queryPrecisionDescriptor(s);const i=e.getStartXY(),n=new w;n.x=lC(i.x,s.getFalseX(),s.getGridUnitsXY()),n.y=lC(i.y,s.getFalseY(),s.getGridUnitsXY());let r=!n.equals(i);const o=e.getEndXY(),a=new w;a.x=lC(o.x,s.getFalseX(),s.getGridUnitsXY()),a.y=lC(o.y,s.getFalseY(),s.getGridUnitsXY()),r||=!a.equals(o),r&&e.changeEndPoints2D(n,a);const h=(t,s,i)=>{let n=!1;{const r=e.getStartAttributeAsDbl(t,0),o=lC(r,s,i),a=!F(o,r);n||=a,a&&e.setStartAttribute(t,0,o)}{const r=e.getEndAttributeAsDbl(t,0),o=lC(r,s,i),a=!F(o,r);n||=a,a&&e.setEndAttribute(t,0,o)}return n};let m=r?1:0;return e.hasAttribute(1)&&(m|=h(1,s.getFalseZ(),s.getGridUnitsZ())?1:0),e.hasAttribute(2)&&(m|=h(2,s.getFalseM(),s.getGridUnitsM())?1:0),!!m}snapGeometryWithCurves_(e){t(!e.isEmpty()),t(2!==this.m_precisionDescriptor.getPrecision());const s=e.createInstance(),i=new SE;let n=0;for(let t=0,r=e.getPathCount();t<r;++t){const r=e.getSegmentCountPath(t);if(0===r){if(s.addPath(e,t,!0),1===s.getPathSize(t)){const t=new Ge;s.getPointByVal(s.getPointCount()-1,t),n|=this.snapGeometry(t)?1:0,s.setPointByVal(s.getPointCount()-1,t)}continue}const o=e.isClosedPath(t);for(let a=0,h=o?r-1:r;a<h;++a)e.getSegmentFromPath(t,a,i,!1),n|=this.snapGeometry(i.get())?1:0,s.addSegment(i.get(),0===a);o&&(e.getSegmentFromPath(t,r-1,i,!1),n|=this.snapGeometry(i.get())?1:0,1===r?s.addPathFromClosedSegment(i.get(),!1):s.closeLastPathWithSegment(i.get()))}return n&&s.copyTo(e),!!n}snapAttributes(t,e,s,i){let n=!1;const r=new eC;if(this.queryPrecisionDescriptor(r),0===t){const t=e;for(let e=s;e<i;e++){const s=t.read(2*e),i=tC.s_SnapValue(s,r.getFalseX(),r.getGridUnitsXY()),o=t.read(2*e+1),a=tC.s_SnapValue(o,r.getFalseY(),r.getGridUnitsXY());n=n||i!==s||a!==o,n&&(t.write(2*e,i),t.write(2*e+1,a))}}else if(1===t){const t=e;for(let e=s;e<i;e++){const s=t.read(e),i=tC.s_SnapValue(s,r.getFalseZ(),r.getGridUnitsZ());n=n||!F(i,s),n&&t.write(e,i)}}else if(2===t){const t=e;for(let e=s;e<i;e++){const s=t.read(e),i=tC.s_SnapValue(s,r.getFalseM(),r.getGridUnitsM());n=n||!F(i,s),n&&t.write(e,i)}}return n}static s_SnapValue(t,e,s){return et((t-e)*s)/s+e}}class eC{constructor(){const t=TE,e=1e-4,s=.001,i=e*Number(t)*.5;this.m_precision=1,this.m_falseX=-i,this.m_falseY=-i,this.m_unitsXY=Number(t)/(2*i),this.m_falseM=-1e5,this.m_unitsM=1/e,this.m_falseZ=-1e5,this.m_unitsZ=1/e,this.m_toleranceXY=s,this.m_toleranceM=s,this.m_toleranceZ=s}getHashCode(){let t=7777,e=7777;return e=O(e,this.m_falseM),e=O(e,this.m_unitsM),t=O(t,this.m_unitsXY),e=O(e,this.m_toleranceXY),t=O(t,this.m_falseZ),e=O(e,this.m_toleranceZ),t=O(t,this.m_unitsZ),e=O(e,this.m_toleranceM),t=O(t,this.m_precision),O(t,e)}clone(){const t=new eC;return t.m_falseX=this.m_falseX,t.m_falseY=this.m_falseY,t.m_unitsXY=this.m_unitsXY,t.m_falseZ=this.m_falseZ,t.m_unitsZ=this.m_unitsZ,t.m_falseM=this.m_falseM,t.m_unitsM=this.m_unitsM,t.m_toleranceXY=this.m_toleranceXY,t.m_toleranceZ=this.m_toleranceZ,t.m_toleranceM=this.m_toleranceM,t.m_precision=this.m_precision,t}assign(t){return this.m_falseX=t.m_falseX,this.m_falseY=t.m_falseY,this.m_unitsXY=t.m_unitsXY,this.m_falseZ=t.m_falseZ,this.m_unitsZ=t.m_unitsZ,this.m_falseM=t.m_falseM,this.m_unitsM=t.m_unitsM,this.m_toleranceXY=t.m_toleranceXY,this.m_toleranceZ=t.m_toleranceZ,this.m_toleranceM=t.m_toleranceM,this.m_precision=t.m_precision,this}initialize2D(t,e){}getTolerance(t){switch(t){case 0:return this.m_toleranceXY;case 1:return this.m_toleranceZ;case 2:return this.m_toleranceM;default:return 0}}getResolution(t){if(2===this.m_precision)return 0;switch(t){case 0:return 1/this.m_unitsXY;case 1:return 1/this.m_unitsZ;case 2:return 1/this.m_unitsM;default:return 0}}getFalseX(){return this.m_falseX}getFalseY(){return this.m_falseY}getFalseZ(){return this.m_falseZ}getFalseM(){return this.m_falseM}getGridUnitsXY(){return this.m_unitsXY}getGridUnitsZ(){return this.m_unitsZ}getGridUnitsM(){return this.m_unitsM}getPrecision(){return this.m_precision}static getLimit32(){return 2147483645}static getLimit64(){return 9007199254740990n}static getLimitFloat(){return 0}getXYGridRange(){const t=new ge;switch(this.m_precision){case 0:{const e=eC.getLimit32()/this.getGridUnitsXY();t.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+e,ymax:this.getFalseY()+e})}break;case 1:{const e=Number(eC.getLimit64())/this.getGridUnitsXY();t.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+e,ymax:this.getFalseY()+e})}break;case 2:t.setCoords({xmin:-Number.MAX_VALUE,ymin:-Number.MAX_VALUE,xmax:Number.MAX_VALUE,ymax:Number.MAX_VALUE});break;default:t.setEmpty(),m("")}return t}getZGridRange(){const t=new A;switch(this.m_precision){case 0:{const e=eC.getLimit32()/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+e)}break;case 1:{const e=Number(eC.getLimit64())/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+e)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),m("")}return t}getMGridRange(){const t=new A;switch(this.m_precision){case 0:{const e=eC.getLimit32()/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+e)}break;case 1:{const e=Number(eC.getLimit64())/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+e)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),m("")}return t}setTolerance(t,s){switch(s<0&&e("tol < 0"),Number.isFinite(s)||e("tol is not finite"),t){case 0:this.m_toleranceXY=s;break;case 1:this.m_toleranceZ=s;break;case 2:this.m_toleranceM=s;break;default:e("cannot set tolerance for this attribute")}}setGridParams(t,s,i){Number.isFinite(t)&&Number.isFinite(s)&&Number.isFinite(i)||e("grid params are not finite"),i<1&&e("grid units cannot be smaller than 1.0"),this.m_falseX=t,this.m_falseY=s,this.m_unitsXY=i}setZParams(t,s){Number.isFinite(t)&&Number.isFinite(s)||e("grid params are not finite"),s<1&&e("grid units cannot be smaller than 1.0"),this.m_falseZ=t,this.m_unitsZ=s}setMParams(t,s){Number.isFinite(t)&&Number.isFinite(s)||e("grid params are not finite"),s<1&&e("grid units cannot be smaller than 1.0"),this.m_falseM=t,this.m_unitsM=s}setPrecision(t){}equals(t){return this===t||F(this.m_falseX,t.m_falseX)&&F(this.m_falseY,t.m_falseY)&&this.equalsWithoutFalseXY(t)}snapPrecision(){if(2===this.m_precision)return;const t=(t,e,s,i)=>{if(!Number.isFinite(e)||!Number.isFinite(s))return s;if(s<1)return 1;if(!i)return s;const n=Number(t)/s;return Math.trunc((e+n-e)*s)>t&&(s=t/(e+n-e)),Math.max(1,s)},e=Number(0===this.m_precision?DE:TE);this.m_unitsXY=t(e,this.m_falseX,this.m_unitsXY,!0),this.m_unitsXY=t(e,this.m_falseY,this.m_unitsXY,!0),this.m_unitsZ=t(e,this.m_falseZ,this.m_unitsZ,!1),this.m_unitsM=t(e,this.m_falseM,this.m_unitsM,!1)}verifyPrecision(){if(2===this.m_precision)return!0;const t=(t,e,s,i)=>{if(s<1)return!1;if(!Number.isFinite(e)||!Number.isFinite(s))return!1;if(!i)return!0;const n=Number(t)/s;return!(BigInt((e+n-e)*s)>t)},e=0===this.m_precision?DE:TE;return!!t(e,this.m_falseX,this.m_unitsXY,!0)&&(!!t(e,this.m_falseY,this.m_unitsXY,!0)&&(!!t(e,this.m_falseZ,this.m_unitsZ,!1)&&!!t(e,this.m_falseM,this.m_unitsM,!1)))}fixTolerance(){2!==this.m_precision&&(this.m_toleranceXY=Math.max(2/this.m_unitsXY,this.m_toleranceXY),this.m_toleranceZ=Math.max(2/this.m_unitsZ,this.m_toleranceZ),this.m_toleranceM=Math.max(2/this.m_unitsM,this.m_toleranceM),(Number.isNaN(this.m_falseX)||Number.isNaN(this.m_falseY))&&(this.m_falseX=this.m_falseY=Number.NaN))}equalsWithoutFalseXY(t){return this===t||this.m_unitsXY===t.m_unitsXY&&this.m_falseZ===t.m_falseZ&&this.m_unitsZ===t.m_unitsZ&&this.m_falseM===t.m_falseM&&this.m_unitsM===t.m_unitsM&&this.m_toleranceXY===t.m_toleranceXY&&this.m_toleranceZ===t.m_toleranceZ&&this.m_toleranceM===t.m_toleranceM&&this.m_precision===t.m_precision}setBestXyDomainFromEnvelope(t,e){}setBestZDomainFromZRange(t,e,s){}setBestMDomainFromMRange(t,e,s){}}function sC(){return jE||(jE=mC(3857,0,null,!0)),jE}function iC(){return ZE||(ZE=mC(102100,0,null,!0)),ZE}function nC(){return QE||(QE=mC(4326,0,null,!0)),QE}function rC(t){t.m_falseX=0,t.m_falseY=0,t.m_unitsXY=1,t.m_falseZ=0,t.m_unitsZ=1,t.m_falseM=0,t.m_unitsM=1,t.m_toleranceXY=100*st(),t.m_toleranceZ=100*st(),t.m_toleranceM=100*st(),t.m_precision=2}function oC(t,s,i,n){const r=s instanceof yy;rC(t),t.m_precision=n,t.m_falseX=Number.NaN,t.m_falseY=Number.NaN;const o=1e-4,a=.001,h=r?s.m_csType:s.isPCS?2:1;if(1===h){const e=(0===n?1/18e5:1e-9)*(r?s.getOneDegreeGCSUnit():Math.PI/s.metersOrRadiansPerUnit/180);t.m_unitsXY=1/e}else if(2===h){const e=(0===n?a:o)*(r?s.getOneMeterPCSUnit():1/s.metersOrRadiansPerUnit);t.m_unitsXY=1/e}else e("unrecognized cs type");t.m_falseM=-1e5,t.m_unitsM=1/(0===n?a:o),t.m_unitsM=Math.max(1,t.m_unitsM),t.m_unitsXY=Math.max(1,t.m_unitsXY);let m=0,l=0;0!==n&&1!==n||(m=2/t.m_unitsXY,l=2/t.m_unitsM),t.m_toleranceXY=Math.max(m,r?s.getUnitsPerMillimeter():2===h?.001/s.metersOrRadiansPerUnit:.001/(s.semiMajor*s.metersOrRadiansPerUnit)),t.m_toleranceM=Math.max(a,l),aC(t,i)}function aC(t,e){const s=1e-4,i=.001;if(t.m_falseZ=-1e5,e){const n=(0===t.m_precision?i:s)*e.getOneMeter();t.m_unitsZ=1/n}else t.m_unitsZ=1/(0===t.m_precision?i:s);t.m_unitsZ=Math.max(1,t.m_unitsZ);let n=0;0!==t.m_precision&&1!==t.m_precision||(n=2/t.m_unitsZ),t.m_toleranceZ=Math.max(e?e.getOneMeter()*i:i,n)}function hC(t,e,s,i){rC(t),t.m_precision=i;const n=0===i?DE:TE,r=1e-4,o=.001;let a=1,h=1,m=.001;e&&(h=e.getUnitToBaseFactor()),e&&1===e.getUnitType()?(a=400*Math.PI/180,m=8.983152841195215e-9*Math.PI/180/h):(a=(0===i?o:r)*Number(n)*.5,m=o/h),a/=h,t.m_falseX=-a,t.m_falseY=-a,t.m_unitsXY=Number(n)/(2*a),t.m_falseM=-1e5,t.m_unitsM=1/(0===i?o:r),t.m_unitsM=Math.max(1,t.m_unitsM),t.snapPrecision();let l=0,u=0;0!==t.m_precision&&1!==t.m_precision||(u=2/t.m_unitsM,l=2/t.m_unitsXY),t.m_toleranceXY=Math.max(l,m),t.m_toleranceM=Math.max(o,u),aC(t,s)}function mC(t,e,s,i){if(!i&&0===e&&!s){if(3857===t)return sC();if(102100===t)return iC();if(4326===t)return nC()}const n=new tC;let r,o=null;return VE()?(r=Ay(t),e<=0&&By()&&(e=t),e>0?o=null:e=0,n.setHorzProj_(r),n.m_vertcs=o):(r=NC(t),n.m_unit=r.isPCS?new ky(r.metersOrRadiansPerUnit):new vm(r.metersOrRadiansPerUnit)),oC(n.m_precisionDescriptor,r,o,1),n.m_bDefaultDescriptor=!0,n.m_userWKID=t,n.calculateHashCode(),n.initDbgName(),n}function lC(t,e,s){return et((t-e)*s)/s+e}let uC=null;const cC=3552713678800501e-30;function gC(t,e,s){return t===e||Math.abs(t-e)<=s*(1+(Math.abs(t)+Math.abs(e))/2)}function _C(t,e){return gC(t,e,cC)}function dC(t,e){return 0===t||Math.abs(t)<=e}function pC(t){return dC(t,cC)}let fC,xC,yC,PC,EC,CC,SC,vC,bC,IC,wC;function DC(t){return{_this:t,get(){return this._this},reset(t){this._this=t},release(){const t=this._this;return this._this=null,t}}}let TC=null;function NC(e){t(TC);const s=TC(e);return s.semiMajor=s.isPCS?Number.NaN:GC(e),s}function AC(e){TC=e,t(TC)}function qC(e){const s=e;xC=s.PeFactory,t(xC),wC=s.PeGCSExtent,t(wC),bC=s.PeLineType,t(bC),IC=s.PeMath,t(IC),fC=s.PeDouble,t(fC),yC=s.PeDefs,t(yC),PC=s.PeCSTransformations,t(PC),EC=s.PeGTTransformations,t(EC),CC=s.PePCSInfo,t(CC),SC=s.PeGTlistExtended,t(SC),xC.initialize(),vC=s.PeGTlistExtendedEntry,t(vC),yC.PE_TYPE_ANGUNIT=512,yC.PE_STR_AUTH_ALL=2,CC.PE_POLE_LINE_STRAIGHT=2,CC.PE_POLE_LINE_CURVED=3,yC.PE_PARM_LAM0=2,yC.PE_PARM_PHI0=6,yC.PE_PRJ_AZIMUTHAL_EQUIDISTANT=43032,yC.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA=43033,yC.PE_PRJ_ALBERS=43007,yC.PE_PRJ_CYLINDRICAL_EQAREA=43034,yC.PE_TYPE_VERTCS=8,yC.PE_LINETYPE_GEODESIC=0,yC.PE_LINETYPE_LOXODROME=1,yC.PE_LINETYPE_GREAT_ELLIPTIC=2,yC.PE_LINETYPE_NORMAL_SECTION=3,TC=null}function FC(t,e,s,i){return e<=0?(s[0]=0,i[0]=0,!1):(s[0]=e,i[0]=e,!0)}const MC=/(?:ELLIPSOID|SPHEROID)\["(?:\w|[-()])+",(\d+\.\d+)/;function GC(t){if(xC&&h("pe has been loaded. no-pe methods should not be used at this point."),"string"==typeof t){const s=t.match(MC);s&&2===s.length||e("bad gcs wkt");const i=Number.parseFloat(s[1]);return Number.isFinite(i)||e("bad gcs wkt"),i}return uC||VC(),uC.has(t)||h("gcs wkid not found"),uC.get(t)}function VC(){uC=new Map;for(const t in _i){const e=Number.parseFloat(t),s=_i[t];if(Array.isArray(s))for(const t of s)uC.set(t,e);else uC.set(s,e)}di()}function YC(t,e,s,i,n){if(t.equals(e))return!1;if(i){let s=1,r=0,o=1,a=1,h=0,m=1;Number.isNaN(t.m_heightMetersPerUnit)||(s=t.m_heightMetersPerUnit,r=t.m_heightZ0,o=t.m_heightSign,a=e.m_heightMetersPerUnit,h=e.m_heightZ0,m=e.m_heightSign);const l=o*m*s/a;for(let t=0;t<n;t++)i[t]=(i[t]-r)*l+h}let r=1,o=0;if(Number.isNaN(t.m_XYToRadians)||(r=t.m_XYToRadians/e.m_XYToRadians,o=t.m_PrimeMeridianDegrees-e.m_PrimeMeridianDegrees,0!==o&&(o=pm(o),o/=e.m_XYToRadians)),Array.isArray(s)){const t=s;for(let e=0;e<n;e++)t[e][0]=t[e][0]*r+o,t[e][1]=t[e][1]*r}else{const t=s;for(let e=0;e<n;e++){const s=e<<1;t[s]=t[s]*r+o,t[s+1]=t[s+1]*r}}return!0}function XC(){return{m_heightMetersPerUnit:0,m_heightSign:0,m_heightZ0:0,m_XYToRadians:0,m_PrimeMeridianDegrees:0,assign(t){this.m_heightMetersPerUnit=t.m_heightMetersPerUnit,this.m_heightSign=t.m_heightSign,this.m_heightZ0=t.m_heightZ0,this.m_XYToRadians=t.m_XYToRadians,this.m_PrimeMeridianDegrees=t.m_PrimeMeridianDegrees},equals(t){return F(this.m_heightSign,t.m_heightSign)&&F(this.m_heightMetersPerUnit,t.m_heightMetersPerUnit)&&F(this.m_heightZ0,t.m_heightZ0)&&F(this.m_XYToRadians,t.m_XYToRadians)&&F(this.m_PrimeMeridianDegrees,t.m_PrimeMeridianDegrees)},initFromGcsAndVcsPe(e,s){this.m_heightSign=1,this.m_heightMetersPerUnit=Number.NaN,this.m_heightZ0=0,this.m_XYToRadians=Number.NaN,this.m_PrimeMeridianDegrees=Number.NaN,s&&t(0),e&&(this.m_XYToRadians=e.getUnit().getUnitFactor(),this.m_PrimeMeridianDegrees=e.getPrimem().getLongitude())},initFromGcsAndVcs(t,e){const s=t?t.getPECoordSys():null,i=e?e.getPEVerticalCoordSys():null;this.initFromGcsAndVcsPe(s,i)},processUnitParams(t){Number.isNaN(this.m_heightMetersPerUnit)&&(this.m_heightMetersPerUnit=t.m_heightMetersPerUnit,this.m_heightSign=t.m_heightSign,this.m_heightZ0=t.m_heightZ0),Number.isNaN(this.m_XYToRadians)&&(this.m_XYToRadians=t.m_XYToRadians,this.m_PrimeMeridianDegrees=t.m_PrimeMeridianDegrees)}}}function kC(t,e,s,i,n,r,o){let a=null;if(e){a=e.getPEVerticalCoordSys()}let h=null;if(t){h=t.getPECoordSys()}let m=null;if(i){m=i.getPEVerticalCoordSys()}let l=null;if(s){l=s.getPECoordSys()}if(!(h||a||l||m))return!1;const u=XC();u.initFromGcsAndVcsPe(h,a);const c=XC();return c.initFromGcsAndVcsPe(l,m),YC(u,c,n,r,o)}W(0),W(1);export{_C as $,nd as A,zu as B,ld as C,z_ as D,ke as E,zf as F,Py as G,IC as H,Ts as I,Yp as J,Gp as K,CE as L,ii as M,xx as N,kl as O,Ge as P,Xp as Q,Nd as R,SE as S,Hd as T,HE as U,bm as V,py as W,ys as X,dl as Y,mf as Z,fx as _,Sm as a,Cm as a$,fC as a0,bC as a1,qE as a2,lf as a3,qs as a4,Fs as a5,hf as a6,Bp as a7,Lp as a8,kp as a9,Dd as aA,Jd as aB,ep as aC,ps as aD,bl as aE,JP as aF,$P as aG,eE as aH,ui as aI,QP as aJ,Df as aK,Nc as aL,nn as aM,Qe as aN,ss as aO,VE as aP,Zu as aQ,zE as aR,dd as aS,cd as aT,md as aU,sd as aV,Qd as aW,Ce as aX,li as aY,Uy as aZ,zy as a_,Rp as aa,eC as ab,Ix as ac,Lm as ad,cl as ae,pm as af,Km as ag,tl as ah,Wm as ai,Nx as aj,yC as ak,bp as al,ul as am,Fe as an,Qm as ao,Tx as ap,Ux as aq,Rm as ar,Ex as as,B_ as at,PC as au,lm as av,ux as aw,Ax as ax,Js as ay,Qs as az,am as b,Pl as b0,Am as b1,Kl as b2,Jl as b3,Rl as b4,El as b5,Pn as b6,xn as b7,ch as b8,Zs as b9,Ha as ba,Ku as bb,tc as bc,Tf as bd,Nf as be,Vd as bf,cr as bg,JE as bh,xC as bi,Dx as bj,hl as bk,XE as c,kE as d,pp as e,Af as f,Ps as g,Cs as h,GE as i,Vm as j,ad as k,ed as l,Id as m,Nm as n,Ff as o,Zf as p,k_ as q,js as r,hd as s,ge as t,ME as u,Cp as v,Is as w,_p as x,Gs as y,bs as z};
