/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{ForwardLinearDepth as e}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{Offset as r}from"../views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js";import{isColorOrColorEmission as o}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as i}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as a}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{InstancedDoublePrecision as l}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js";import{NormalAttribute as s,NormalType as t}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{PositionAttribute as n}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js";import{SymbolColor as d}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js";import{TextureCoordinateAttribute as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as m}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VertexNormal as g}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js";import{VerticalOffset as v}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js";import{DefaultMaterialAuxiliaryPasses as u}from"../views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js";import{ComputeNormalTexture as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js";import{EvaluateAmbientOcclusion as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as w,addAmbientBoostFactor as p,addLightingGlobalFactor as f}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{Normals as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js";import{PhysicallyBasedRendering as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js";import{PhysicallyBasedRenderingParameters as C,PBRMode as j}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapPass as P,ReadShadowMapDraw as T}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as O}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{colorTextureUV as N,normalTextureUV as S,emissiveTextureUV as A,occlusionTextureUV as V,metallicRoughnessTextureUV as $}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TextureTransformUV.glsl.js";import{VisualVariables as D}from"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js";import{alphaCutoff as M}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js";import{DiscardOrAdjustAlphaPass as E}from"../views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js";import{MixExternalColor as U}from"../views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js";import{addProjViewLocalOrigin as I,addCameraPosition as B}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as F}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as _}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as R}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as z,If as G}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as W}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as k}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{VertexAttribute as H}from"../views/3d/webgl-engine/lib/VertexAttribute.js";import{outputColorHighlightOID as q}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";function J(J){const K=new W,{vertex:Q,fragment:X,varyings:Y}=K,{output:Z,normalType:ee,offsetBackfaces:re,instancedColor:oe,spherical:ie,receiveShadows:ae,snowCover:le,pbrMode:se,textureAlphaPremultiplied:te,instancedDoublePrecision:ne,hasVertexColors:de,hasVertexTangents:ce,hasColorTexture:me,hasNormalTexture:ge,hasNormalTextureTransform:ve,hasColorTextureTransform:ue}=J;if(I(Q,J),K.include(n),Y.add("vpos","vec3"),K.include(D,J),K.include(l,J),K.include(v,J),K.include(N,J),!o(Z))return K.include(u,J),K;K.include(S,J),K.include(A,J),K.include(V,J),K.include($,J),B(Q,J),K.include(s,J),K.include(a,J);const be=ee===t.Attribute||ee===t.Compressed;return be&&re&&K.include(r),K.include(b,J),K.include(g,J),oe&&K.attributes.add(H.INSTANCECOLOR,"vec4"),Y.add("vPositionLocal","vec3"),K.include(c,J),K.include(e,J),K.include(d,J),K.include(m,J),Q.uniforms.add(new _("externalColor",(e=>e.externalColor))),Y.add("vcolorExt","vec4"),J.terrainDepthTest&&Y.add("depth","float"),Q.main.add(z`
    forwardNormalizedVertexColor();
    vcolorExt = externalColor;
    ${G(oe,"vcolorExt *= instanceColor * 0.003921568627451;")}
    vcolorExt *= vvColor();
    vcolorExt *= getSymbolColor();
    forwardColorMixMode();

    if (vcolorExt.a < ${z.float(M)}) {
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
    } else {
      vpos = getVertexInLocalOriginSpace();
      vPositionLocal = vpos - view[3].xyz;
      vpos = subtractOrigin(vpos);
      ${G(be,"vNormalWorld = dpNormal(vvLocalNormal(normalModel()));")}
      vpos = addVerticalOffset(vpos, localOrigin);
      ${G(ce,"vTangent = dpTransformVertexTangent(tangent);")}
      gl_Position = transformPosition(proj, view, vpos);
      ${G(be&&re,"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);")}
    }

    ${G(J.terrainDepthTest,"depth = (view * vec4(vpos, 1.0)).z;")}
    forwardLinearDepth();
    forwardTextureCoordinates();
    forwardColorUV();
    forwardNormalUV();
    forwardEmissiveUV();
    forwardOcclusionUV();
    forwardMetallicRoughnessUV();
  `),K.include(w,J),K.include(h,J),K.include(E,J),K.include(ne?P:T,J),K.include(O,J),K.include(i,J),K.include(q,J),B(X,J),X.uniforms.add(Q.uniforms.get("localOrigin"),new F("ambient",(e=>e.ambient)),new F("diffuse",(e=>e.diffuse)),new R("opacity",(e=>e.opacity)),new R("layerOpacity",(e=>e.layerOpacity))),me&&X.uniforms.add(new k("tex",(e=>e.texture))),K.include(C,J),K.include(L,J),X.include(U),K.include(y,J),p(X),f(X),x(X),X.main.add(z`
      discardBySlice(vpos);
      ${G(J.terrainDepthTest,"terrainDepthTest(depth);")}
      ${me?z`
              vec4 texColor = texture(tex, ${ue?"colorUV":"vuv0"});
              ${G(te,"texColor.rgb /= texColor.a;")}
              discardOrAdjustAlpha(texColor);`:z`vec4 texColor = vec4(1.0);`}
      shadingParams.viewDirection = normalize(vpos - cameraPosition);
      ${ee===t.ScreenDerivative?z`vec3 normal = screenDerivativeNormal(vPositionLocal);`:z`shadingParams.normalView = vNormalWorld;
                 vec3 normal = shadingNormal(shadingParams);`}
      applyPBRFactors();
      float ssao = evaluateAmbientOcclusionInverse() * getBakedOcclusion();

      vec3 posWorld = vpos + localOrigin;

      float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
      float shadow = ${ae?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))":G(ie,"lightingGlobalFactor * (1.0 - additionalAmbientScale)","0.0")};

      vec3 matColor = max(ambient, diffuse);
      vec3 albedo = mixExternalColor(${G(de,"vColor.rgb *")} matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
      float opacity_ = layerOpacity * mixExternalOpacity(${G(de,"vColor.a * ")} opacity, texColor.a, vcolorExt.a, int(colorMixMode));
      ${ge?`mat3 tangentSpace = computeTangentSpace(${ce?"normal":"normal, vpos, vuv0"});\n             vec3 shadingNormal = computeTextureNormal(tangentSpace, ${ve?"normalUV":"vuv0"});`:"vec3 shadingNormal = normal;"}
      vec3 normalGround = ${ie?"normalize(posWorld);":"vec3(0.0, 0.0, 1.0);"}

      ${G(le,z`
            float snow = smoothstep(0.5, 0.55, dot(normal, normalGround));
            albedo = mix(albedo, vec3(1), snow);
            shadingNormal = mix(shadingNormal, normal, snow);
            ssao = mix(ssao, 1.0, snow);`)}

      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

      ${se===j.Normal||se===j.Schematic?z`
              float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
              ${G(le,z`mrr = mix(mrr, vec3(0.0, 1.0, 0.04), snow);`)}
              vec4 emission = ${le?"mix(getEmissions(), vec4(0.0), snow)":"getEmissions()"};
              vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);`:z`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
      vec4 finalColor = vec4(shadedColor, opacity_);
      outputColorHighlightOID(finalColor, vpos);
  `),K}const K=Object.freeze(Object.defineProperty({__proto__:null,build:J},Symbol.toStringTag,{value:"Module"}));export{K as D,J as b};
