/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{create as e}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{Gamma as r}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Gamma.glsl.js";import{Float2PassUniform as a}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float3PassUniform as o}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as t}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{NoParameters as n,glsl as s}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as i}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as m}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{ScreenSpacePassAtmosphere as l}from"../views/3d/webgl-engine/shaders/ScreenSpacePassAtmosphere.glsl.js";import{SphereIntersect as d}from"../views/3d/webgl-engine/shaders/SphereIntersect.glsl.js";import{ToneMapping as g}from"../views/3d/webgl-engine/shaders/ToneMapping.glsl.js";class c extends n{constructor(){super(...arguments),this.color=e(),this.strength=4e-6,this.atmosphereC=1,this.amount=0}}function p(){const e=new i;e.include(l,{needUVs:!0,needEyeDirection:!0});const n=e.fragment;return n.uniforms.add(new t("atmosphereC",(e=>e.atmosphereC)),new o("cameraPosition",((e,r)=>r.camera.eye)),new a("nearFar",((e,r)=>r.camera.nearFar)),new m("depthTexture",((e,r)=>r.mainDepth)),new t("fogStrength",(e=>e.strength)),new t("fogAmount",(e=>e.amount)),new o("fogColor",(e=>e.color))),e.include(r),n.include(d),n.include(g),n.code.add(s`float getFogAmount(float dist, vec3 rayDir) {
if(dist == -1.0){
dist = 0.055 * sphereIntersect(cameraPosition, rayDir, atmosphereC).y;
}
return fogAmount * (1.0 - exp(-dist * fogStrength));
}`),n.main.add(s`vec3 rayDir = normalize(worldRay);
float terrainDepth = -1.0;
float depthSample = texture(depthTexture, uv).r;
float zNorm = 2.0 * depthSample - 1.0;
float linDepth = 2.0 * nearFar[0] * nearFar[1] / (nearFar[1] + nearFar[0] - zNorm * (nearFar[1] - nearFar[0]));
if(depthSample < 1.0 && depthSample > 0.0){
vec3 cameraSpaceRay = normalize(eyeDir);
cameraSpaceRay /= cameraSpaceRay.z;
cameraSpaceRay *= linDepth;
terrainDepth = max(0.0, length(cameraSpaceRay));
}
float fogAmount = getFogAmount(terrainDepth, rayDir);
vec4 fog = vec4(fogColor, 1.0) * fogAmount;
fragColor = delinearizeGamma(vec4(tonemapACES(fog.rgb), fog.a));`),e}const f=Object.freeze(Object.defineProperty({__proto__:null,FogPassParameters:c,build:p},Symbol.toStringTag,{value:"Module"}));export{c as F,f as a,p as b};
