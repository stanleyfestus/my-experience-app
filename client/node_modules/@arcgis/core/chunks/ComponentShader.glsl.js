/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{earth as e,mars as o,moon as r}from"../geometry/support/Ellipsoid.js";import{OverlayContent as a}from"../views/3d/terrain/OverlayContent.js";import{IntegratedMeshMode as i}from"../views/3d/webgl-engine/collections/Component/Material/ComponentTechniqueConfiguration.js";import{ComponentData as l,ComponentDataType as t}from"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js";import{VertexDiscardByOpacity as n}from"../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js";import{ForwardLinearDepth as d}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{ShaderOutput as s,isColorOrColorEmission as g}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SlicePass as m}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{TextureCoordinateAttribute as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as v}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VertexNormal as h}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js";import{VertexPosition as u}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js";import{OutputDepth as w}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as p}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{computeFragmentNormals as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeFragmentNormals.glsl.js";import{ComputeMaterialColor as C}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js";import{ComputeNormalTexture as f}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js";import{EvaluateSceneLighting as y,addLightingGlobalFactor as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{PBRMode as j,PhysicallyBasedRenderingParameters as S}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadBaseColorTexture as O}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js";import{ReadShadowMapPass as N}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as M}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{OverlayIM as T,getIMColorTexture as $}from"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js";import{alphaCutoff as A}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js";import{DiscardOrAdjustAlphaDraw as W}from"../views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js";import{EllipsoidMode as D}from"../views/3d/webgl-engine/core/shaderLibrary/util/EllipsoidMode.js";import{If as P,glsl as B}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as R}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as z}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{outputColorHighlightOID as E}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";function H(H){const I=new R;I.include(u,H),I.include(h,H),I.include(v,H),I.include(c,H),I.include(d,H),I.include(l,H),I.include(W,H),I.include(m,H),I.include(O,H),I.include(n,H);const{vertex:F,fragment:V}=I,{output:_,pbrMode:G,hasNormalTexture:k,snowCover:q,receiveShadows:U,spherical:J,ellipsoidMode:K}=H,Q=G===j.Normal||G===j.Schematic;Q&&(I.include(S,H),k&&I.include(f,H));const X=_===s.Shadow||_===s.ShadowHighlight||_===s.ShadowExcludeHighlight,Y=X&&H.componentData===t.Varying;F.code.add(`#define discardShadows(castShadows) { ${P(Y,"if(!castShadows) { gl_Position = vec4(vec3(1e38), 1.0); return; }")} }`);const Z=H.integratedMeshMode===i.ColorOverlay||H.integratedMeshMode===i.ColorOverlayWithWater;if(Z){I.include(y,H),I.include(T,H);const a=K===D.Earth,i=K===D.Earth,l=a?e.radius:i?o.radius:r.radius;F.code.add(`\n      ${P(J,`const float invRadius = ${B.float(1/l)};`)}\n      vec2 projectOverlay(vec3 pos) { return pos.xy ${P(J,"/ (1.0 + invRadius * pos.z);")}; }`)}const ee=Z&&g(_)&&G===j.WaterOnIntegratedMesh;if(ee&&(I.varyings.add("tbnTangent","vec3"),I.varyings.add("tbnBiTangent","vec3"),I.varyings.add("groundNormal","vec3")),F.main.add(B`
    bool castShadows;
    vec4 externalColor = forwardExternalColor(castShadows);
    discardShadows(castShadows);

    vertexDiscardByOpacity(externalColor.a);

    ${_===s.ObjectAndLayerIdColor?B`externalColor.a = 1.0;`:""}

    if (externalColor.a < ${B.float(A)}) {
      // Discard this vertex
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    }

    forwardPosition(readElevationOffset());
    forwardNormal();
    forwardTextureCoordinates();
    forwardVertexColor();
    forwardLinearDepth();
    forwardObjectAndLayerIdColor();
    ${ee?J?B`
              groundNormal = normalize(positionWorld());
              tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
              tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:B`
              groundNormal = vec3(0.0, 0.0, 1.0);
              tbnTangent = vec3(1.0, 0.0, 0.0);
              tbnBiTangent = vec3(0.0, 1.0, 0.0);`:""}
    ${Z?B`setOverlayVTC(projectOverlay(position));`:""}
  `),g(_))return I.include(M,H),I.include(C,H),I.include(b,H),I.include(y,H),I.include(E,H),U&&I.include(N,H),V.code.add(B`
      float evaluateShadow() {
        return ${U?"readShadowMap(vPositionWorldCameraRelative, linearDepth)":"0.0"};
      }`),Z&&V.uniforms.add(new z("ovColorTex",((e,o)=>$(e,o)))),V.main.add(B`
      discardBySlice(vPositionWorldCameraRelative);
      terrainDepthTest(vPosition_view.z);

      vec4 textureColor = readBaseColorTexture();
      discardOrAdjustAlpha(textureColor);

      vec4 externalColor;
      int externalColorMixMode;
      readExternalColor(externalColor, externalColorMixMode);

      vec4 materialColor = computeMaterialColor(textureColor, externalColor, externalColorMixMode);
      ${Z?B`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);`:""}
    `),Q?(L(V),J&&x(V),V.main.add(B`
        applyPBRFactors();
        ${P(G===j.Normal,B`if (externalColorMixMode == 3) {
              mrr = vec3(0.0, 0.6, 0.2);
            }`)}
        float additionalIrradiance = 0.02 * mainLightIntensity[2];
        ${P(k,"mat3 tangentSpace = computeTangentSpace(fragmentShadingNormal, vPositionWorldCameraRelative, vuv0);")}
        vec3 shadingNormal = ${k?"computeTextureNormal(tangentSpace, vuv0)":"fragmentShadingNormal"};
        vec3 normalGround = ${J?B`normalize(positionWorld())`:B`vec3(0.0, 0.0, 1.0)`};

        vec3 viewDir = normalize(vPositionWorldCameraRelative);
        float ssao = 1.0 - occlusion * evaluateAmbientOcclusionInverse();
        ${P(q,B`float snow = smoothstep(0.5, 0.55, dot(fragmentFaceNormal, normalize(positionWorld())));
                 materialColor.rgb = mix(materialColor.rgb, vec3(1.1), snow);
                 ssao = mix(ssao, 0.5 * ssao, snow);
                 shadingNormal = mix(shadingNormal, fragmentFaceNormal, snow);`)}
        ${P(Z,"materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;")}

        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
        vec4 emission = getEmissions();
        ${P(J,"float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());")}
        ${J?B`float shadow = max(lightingGlobalFactor * (1.0 - additionalAmbientScale), evaluateShadow());`:"float shadow = evaluateShadow();"}
        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, shadow, ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);
        `)):(J&&x(V),ee&&V.uniforms.add(new z("ovNormalTex",((e,o)=>o.overlay?.getTexture(a.WaterNormal)))),V.main.add(B`
        ${P(J,"float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());")}
        float shadow = ${U?J?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), evaluateShadow())":"evaluateShadow()":J?"lightingGlobalFactor * (1.0 - additionalAmbientScale)":"0.0"};

        ${P(q,B`float snow = smoothstep(0.5, 0.55, dot(fragmentFaceNormal, normalize(positionWorld())));
               materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`)}

        // At global scale we create some additional ambient light based on the main light to simulate global illumination
        float ssao = evaluateAmbientOcclusion();
        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());

        ${Z?B` materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:""}

        vec4 shadedColor = vec4(evaluateSceneLighting(fragmentShadingNormal, materialColor.rgb, shadow, ssao, additionalLight), materialColor.a);
        ${P(ee,B`vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
                 float waterNormalLength = length(overlayWaterMask);
                 if (waterNormalLength > 0.95) {
                   mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
                   vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());
                   vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                   // un-gamma the ground color to mix in linear space
                   shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
                 }`)}
      `)),V.main.add(B`outputColorHighlightOID(shadedColor, vPositionWorldCameraRelative);`),I;const oe=_===s.Normal,re=_===s.ObjectAndLayerIdColor,ae=_===s.Highlight,ie=X||_===s.ViewshedShadow;return ie&&I.include(w,H),oe&&I.include(b,H),I.include(p,H),V.main.add(B`
    discardBySlice(vPositionWorldCameraRelative);

    vec4 textureColor = readBaseColorTexture();
    discardOrAdjustAlpha(textureColor);

    ${P(ie,"outputDepth(linearDepth);")}
    ${P(oe,B`fragColor = vec4(vec3(0.5) + 0.5 * fragmentFaceNormalView, 1.0);`)}
    ${P(re,Z?"fragColor = getOverlayColorTexel(vtcOverlay);":"outputObjectAndLayerIdColor();")}
    ${P(ae,B`${P(Z,B`
           vec2 overlayHighlightTexel = getAllOverlayHighlightValuesEncoded();
           outputAllHighlights(overlayHighlightTexel);`,B`calculateOcclusionAndOutputHighlight();`)}`)}`),I}const I=Object.freeze(Object.defineProperty({__proto__:null,build:H},Symbol.toStringTag,{value:"Module"}));export{I as C,H as b};
