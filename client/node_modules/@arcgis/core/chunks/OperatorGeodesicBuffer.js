/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{S as e,G as t}from"./SimpleGeometryCursor.js";import{e as s,d as n,t as i,a as r,f as o,G as m,h as a,c as h,b as c,i as u,j as l}from"./Geometry.js";import{F as _,t as f,a as d,O as g,G as p,H as P,b as x,I as b,h as y,P as w,J as C,K as S,N as v,Q as D,z as I,R as G,U as M,V as T,W as N,o as k,x as A,X as q,Y as E,Z as R,j as z,_ as X,$ as B,a0 as Y,a1 as F,a2 as O,a3 as W,a4 as j,a5 as J,a6 as U,a7 as H,a8 as L,a9 as V,aa as Q,ab as K}from"./QuadraticBezier.js";import{b as Z,c as $}from"./tslib.es6.js";import{c as ee,d as te,T as se,P as ne,S as ie,g as re,e as oe}from"./Transformation2D.js";import{c as me}from"./GeometryCleaner-k94LXQsr.js";function ae(e,t,s,n,a,h){n<Number.MAX_VALUE&&n>-Number.MAX_VALUE||i("Geodesic_bufferer.buffer - bad distance"),r(e);const c=me(e),u=c.getGeometryType();if(o(u)){const e=c.getPointCount(),i=8e6;if(Math.abs(n)>i&&(e>50||u!==m.enumMultiPoint&&4===s&&e>2)){let e=c;const r=n>0?1:-1,o=7e6;let m=n,u=1;do{u++,m=(Math.abs(m)-o)*r}while(Math.abs(m)>i);m=n;for(let n=0;n<u-1;n++)e=ce(e,t,s,o*r,a,u,h),m=(Math.abs(m)-o)*r;return e=ce(e,t,s,m,a,u,h),e}}return ce(c,t,s,n,a,1,h)}class he{constructor(e){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=e}bufferPolygon(e){const t=new d,s=new Ce(this,e,t);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferPolyline(e){const t=new Ce(this,e,null);return this.processGnomonicBufferPiecesCursor(!0,t)}bufferMultiPoint(e){const t=new Se(this,e);return this.processGnomonicBufferPiecesCursor(!1,t)}bufferPoint(e){const t=e.getXY();t.scale(this.m_rpu);let s=new d;if(this.bufferPoint2D(t,!1,s)){const e=I(null,s,!0);s=G(s,e,!0,!0,-1,this.m_progressTracker,0,!1)}return s=(new S).foldInto360RangeGeodetic(s,this.m_gcs,2),s}processGnomonicBufferPiecesCursor(e,t){const s=t;let n=s.getGnomonic();const i=M(T()),r=new K;i.queryPrecisionDescriptor(r),r.setTolerance(0,.001),M(T(),void 0,r);let o=new N,m=(new _).executeMany(o,i,this.m_progressTracker,2);const a=ee(6,!1),h=te(f,6);this.initializeGrid(a,h);const c=[null,null,null,null,null,null],u=[null,null,null,null,null,null],l=[null,null,null,null,null,null];let d,g,p;for(;null!==(d=s.next());){if(g=s.getGnomonic(),g!==n){if(null!==n){let t=m.next();if(o=null,m=null,null!=t){const s=I(i,t,!0),r=b(s);t=n.unproject(t,r,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,a,h,c,u,l)}}null!==g&&(o=new N,m=(new _).executeMany(o,i,this.m_progressTracker,2)),n=g}if(s.isRunningInGnomonic()){if(g.project(d),s.needsSimplify()){const e=I(null,d,!0);d=G(d,e,!0,!0,-1,this.m_progressTracker,0,!1)}o.tick(ye(d)),m.tock()}else this.putInGridCursors(e,d,i,!0,a,h,c,u,l)}let P=!1;for(let _=0;_<6;_++)if(null!=l[_]){P=!0;break}if(P){let t=!1;const r=[null,null,null,null,null,null];if(e){const n=s.m_densified;if(s.m_densified=null,null!==n){const s=new se;s.scale(1/this.m_rpu,1/this.m_rpu),n.applyTransformation(s),this.m_distance>0?this.putInGridCursors(e,n,i,!1,a,h,c,u,l):(this.processInGrid(e,n,!1,a,h,c,r),t=!0)}}const f=new N,d=(new _).executeMany(f,this.m_gcs,this.m_progressTracker,2);if(null!==m){let t=m.next();o=null,m=null;const s=I(i,t,!0),r=b(s);t=n.unproject(t,r,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,a,h,c,u,l)}for(let e=0;e<6;e++)if(null!=l[e]){let s=l[e].next();l[e]=null,u[e]=null,t&&null!==r[e]&&(s=(new k).execute(r[e],s,i,this.m_progressTracker));const n=I(i,s,!0),o=b(n);s=c[e].unproject(s,o,this.m_progressTracker),s=(new A).execute(s,this.m_gcs,!0,this.m_progressTracker),f.tick(ye(s)),d.tock()}p=d.next()}else{let t,r=!1;if(e){let e=s.m_densified;if(s.m_densified=null,null!==e){const s=new se;s.scale(1/this.m_rpu,1/this.m_rpu),e.applyTransformation(s),g.project(e);const n=I(null,e,!0);e=G(e,n,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(o.tick(ye(e)),m.tock()):(t=e,r=!0)}}let a=m.next();o=null,m=null,r&&(a=(new k).execute(t,a,i,this.m_progressTracker));const h=I(i,a,!0),c=b(h);p=n.unproject(a,c,this.m_progressTracker),p=(new A).execute(p,this.m_gcs,!0,this.m_progressTracker)}return p=(new S).foldInto360RangeGeodetic(p,this.m_gcs,2),p}putInGridCursors(e,t,s,n,i,r,o,m,a){const h=[null,null,null,null,null,null];this.processInGrid(e,t,n,i,r,o,h);for(let c=0;c<6;c++)null!==h[c]&&(null===m[c]&&(m[c]=new N,a[c]=(new _).executeMany(m[c],s,this.m_progressTracker,2)),m[c].tick(ye(h[c])),a[c].tock())}processInGrid(e,t,s,n,i,r,o){const m=.01,a=this.insertGeodeticPointsAlongGrid(t,i,m);for(let h=0;h<6;h++){if(n[h])continue;const e=i[h].clone();e.inflateCoords(m,m);const c=q(t,e),u=y(null,c,!1).total();let l=E(a,e,u,Number.NaN,this.m_progressTracker);if(null!==l&&!l.isEmpty()){if(l===a&&(l=l.clone()),null===r[h]){const e=new ne;h<3?e.setCoords(0,1):e.setCoords(0,-1);const t=new ne;t.setAdd(i[h].getCenter(),e),r[h]=be(this.m_gcs,t)}r[h].project(l);const e=I(null,l,!0);l=G(l,e,s,!0,-1,this.m_progressTracker,0,!1),o[h]=l}}}insertGeodeticPointsAlongGrid(e,t,s){const n=f.construct(t[3].xmin,t[3].ymin,t[2].xmax,t[2].ymax),i=R(this.m_gcs,n,e,!0,this.m_progressTracker),r=new z,o=r.addGeometry(i);return X(r,o,this.m_gcs,0,2,!0,t[0].xmax+s),X(r,o,this.m_gcs,0,2,!0,t[1].xmax+s),X(r,o,this.m_gcs,0,2,!1,t[1].ymin+s),0!==s&&(X(r,o,this.m_gcs,0,2,!0,t[0].xmax-s),X(r,o,this.m_gcs,0,2,!0,t[1].xmax-s),X(r,o,this.m_gcs,0,2,!1,t[1].ymin-s)),r.getGeometry(o)}initializeGrid(e,t){for(let s=0;s<6;s++)e[s]=!1;t[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),t[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),t[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),t[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),t[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),t[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t,s,n,i,r){const o=e[0],m=e.at(-1),a=o.y<m.y?o.y:m.y,h=o.y>m.y?o.y:m.y,c=P.q(this.m_a,this.m_eSquared,a),u=P.q(this.m_a,this.m_eSquared,h);if(this.m_q90-(c+t+this.m_absDistance)>.001&&this.m_q90+(u-t-this.m_absDistance)>.001)return!1;const l=s-oe,_=n+oe,f=l-Math.PI,d=l+Math.PI,g=_+Math.PI,p=[Number.NaN],x=[Number.NaN],b=[Number.NaN],y=[Number.NaN];let w=!1;if(_e(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,l,f,m,_,p,x),_e(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,m,g,_,o,f,b,y),(_<p[0]&&p[0]<g||_<x[0]&&x[0]<g)&&(w=!0),w||(f<b[0]&&b[0]<l||f<y[0]&&y[0]<l)&&(w=!0),!w&&i)return!1;const C=[];for(let P=e.length-1;P>=0;P--)C.push(e[P]);r.setEmpty(),r.addPathPoint2D(null,0,!0);let S=0;S=ue(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,e,l,_,i,S,r),S=le(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,m,_,g,this.m_cornerStep,i,S,r,p[0],x[0]),S=ue(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,C,g,d,i,S,r),S=le(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,f,l,this.m_cornerStep,i,S,r,b[0],y[0]);let v=!1;return i||(v=this.checkAndPrepForPole(r)),w||v}bufferPoint2D(e,t,s){s.setEmpty(),s.addPathPoint2D(null,0,!0);const n=0;le(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,e,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,t,n,s);let i=!1;return t||(i=this.checkAndPrepForPole(s)),i}checkAndPrepForPole(e){const t=this.checkAndPrepForPoleTouch(e),s=this.checkAndPrepForPoleWrap(e);return t||s}checkAndPrepForPoleTouch(e){const t=new f;return e.queryEnvelope(t),!(!B(t.ymax,this.m_gcs90)&&!B(t.ymin,-this.m_gcs90))&&(this.prepPoleTouch(e),!0)}checkAndPrepForPoleWrap(e){const t=e.getXY(0),s=e.getXY(e.getPointCount()-1);return Math.abs(t.x-s.x)>this.m_gcs180?(this.prepSinglePoleWrap(e),!0):this.checkAndPrepForDoublePoleWrap(e)}checkAndPrepForDoublePoleWrap(e){return e.calculateArea2D()<0&&(this.prepDoublePoleWrap(e),!0)}prepPoleTouch(e){const t=new d;t.insertPath2D(-1,null,0,0,!0);const s=e.getPathStart(0),n=e.getPathEnd(0),i=n-s;let r=-1;for(r=s;r<n;r++){const t=e.getXY(r),s=B(t.y,this.m_gcs90),n=B(t.y,-this.m_gcs90);if(!s&&!n)break}let o=r,m=!1,a=Number.NaN;do{const n=e.getXY(o),r=B(n.y,this.m_gcs90),h=B(n.y,-this.m_gcs90),c=s+(o+1-s)%i;if(r||h){let s=ne.construct(a,n.y);t.insertPoint2D(0,-1,s);const i=e.getXY(c),r=B(i.y,this.m_gcs90),o=B(i.y,-this.m_gcs90);r||o||(s=ne.construct(i.x,n.y),m?t.setXY(t.getPointCount()-1,s):t.insertPoint2D(0,-1,s)),m=!0}else t.insertPoint2D(0,-1,n),a=n.x,m=!1;o=c}while(o!==r);e.setEmpty(),e.add(t,!1)}prepSinglePoleWrap(e){const t=new d,s=new d,n=new se,i=e.getXY(e.getPathStart(0)),r=e.getXY(e.getPathEnd(0)-1),o=this.m_gcs360,m=this.m_gcs180,a=new f;a.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const h=new f;e.queryEnvelope(h);const c=Math.ceil(h.width()/o);let u,l;i.x>r.x?(u=-o,l=this.m_gcs90):(u=o,l=-this.m_gcs90),n.setShiftCoords(u,0),t.addPath(e,0,!0),s.add(t,!1);const _=new w;for(let f=0;f<c;f++)s.applyTransformation(n),s.getPointByVal(0,_),t.lineToPoint(_),t.addSegmentsFromPath(s,0,0,s.getSegmentCount()-1,!1);const g=t.getXY(0),p=t.getXY(t.getPointCount()-1);g.y=l,p.y=l,t.lineTo(p);const P=new ne;for(P.setCoordsPoint2D(p),P.x-=.5*u;Math.abs(P.x-g.x)>m;)t.lineTo(P),P.x-=.5*u;t.lineTo(g);const x=a.getCenterX(),b=new f;t.queryEnvelope(b);let C=0;const S=b.getCenter().x;S-x>m?C=-Math.ceil((S-x-m)/o):x-S>m&&(C=Math.ceil((x-S-m)/o)),0!==C&&(n.setShiftCoords(C*o,0),t.applyTransformation(n));const v=new z,D=v.addGeometry(t);X(v,D,this.m_gcs,0,2,!0,a.xmin),X(v,D,this.m_gcs,0,2,!0,a.xmax);const I=v.getGeometry(D),G=q(I,a);G.inflateCoords(0,1);const M=y(null,G,!0).total(),T=E(I,a,M,Number.NaN,this.m_progressTracker);e.setEmpty(),e.add(T,!1)}prepDoublePoleWrap(e){const t=this.m_gcs360,s=this.m_gcs180,n=new f;n.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const i=n.getCenter().x,r=new f;e.queryPathEnvelope(0,r);let o,m=0,a=r.getCenter().x;if(a-i>s?m=-Math.ceil((a-i-s)/t):i-a>s&&(m=Math.ceil((i-a-s)/t)),0!==m){const s=new se;s.setShiftCoords(m*t,0),e.getImpl().applyTransformationToPath(s,0),e.queryPathEnvelope(0,r),a=r.getCenter().x}const h=new f;n.containsExclusiveEnvelope(r)?(o=!1,h.setCoords({env2D:n})):(o=!0,h.setCoords({env2D:n}),h.xmin-=t,h.xmax+=t);let c=e.createInstance();c.addPathPoint2D(null,0,!0);const u=new ne;if(u.setCoords(h.xmin,h.ymin),c.insertPoint2D(0,-1,u),u.setCoords(h.xmin,h.ymax),c.insertPoint2D(0,-1,u),u.setCoords(.5*(h.xmin+h.xmax),h.ymax),c.insertPoint2D(0,-1,u),u.setCoords(h.xmax,h.ymax),c.insertPoint2D(0,-1,u),u.setCoords(h.xmax,h.ymin),c.insertPoint2D(0,-1,u),u.setCoords(.5*(h.xmin+h.xmax),h.ymin),c.insertPoint2D(0,-1,u),o){c.addPath(e,0,!0);const s=new se;a<i?s.setShiftCoords(t,0):s.setShiftCoords(-t,0),e.getImpl().applyTransformationToPath(s,0),c.addPath(e,0,!0);const r=new z,o=r.addGeometry(c);X(r,o,this.m_gcs,0,2,!0,n.xmin),X(r,o,this.m_gcs,0,2,!0,n.xmax),c=r.getGeometry(o);const m=q(c,n);m.inflateCoords(0,1);const h=y(null,m,!0).total();c=E(c,n,h,Number.NaN,this.m_progressTracker)}else c.addPath(e,0,!0);e.setEmpty(),e.add(c,!1)}setMinCornerStep(){const e={stack:[],error:void 0,hasError:!1};try{let s=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);s=Math.min(s,.125*this.m_a*Math.PI);const n=new ne;n.setCoords(0,10*this.m_rpu);const i=0;let r=45*this.m_rpu;const o=Z(e,new ie(new Y,new Y),!1),m=Z(e,new ie(new Y,new Y),!1),a=Z(e,new ie(new Y,new Y),!1),h=Z(e,new ie(new Y,new Y),!1),c=new ne,u=new ne,l=new ne,_=new ne;for(F.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,s,i,o.at(0),o.at(1)),c.setCoords(o.at(0).val,o.at(1).val),F.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,s,r,m.at(0),m.at(1)),u.setCoords(m.at(0).val,m.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const t=.5*(i+r);F.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,s,t,a.at(0),a.at(1)),l.setCoords(a.at(0).val,a.at(1).val);const o=Z(e,new Y,!1),f=Z(e,new Y,!1);F.geodeticDistance(this.m_a,this.m_eSquared,c.x,c.y,u.x,u.y,o,f,null,2),F.geodeticCoordinate(this.m_a,this.m_eSquared,c.x,c.y,.5*o.val,f.val,h.at(0),h.at(1),2),_.setCoords(h.at(0).val,h.at(1).val);const d=Z(e,new Y,!1);F.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,_.x,_.y,d,null,null,2);if(d.val<=this.m_convergenceOffset)break;r*=.9,F.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,s,r,m.at(0),m.at(1)),u.setCoords(m.at(0).val,m.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{$(e)}}const f=r-i,d=2*Math.PI/Math.ceil(2*Math.PI/f);this.m_cornerStep=d}catch(s){e.error=s,e.hasError=!0}finally{$(e)}}setMinSegmentStep(){const e={stack:[],error:void 0,hasError:!1};try{let n=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);n=Math.min(n,.125*this.m_a*Math.PI);const i=new ne,r=new ne;i.setCoords(0,10*this.m_rpu),r.setCoords(10*this.m_rpu,10*this.m_rpu);const o=Z(e,new Y,!1),m=Z(e,new Y,!1),a=Z(e,new Y,!1);F.geodeticDistance(this.m_a,this.m_eSquared,i.x,i.y,r.x,r.y,a,o,m,this.m_curveType);const h=Z(e,new ie(new Y,new Y),!1),c=Z(e,new ie(new Y,new Y),!1),u=new ne,l=Z(e,new Y,!1),_=Z(e,new ie(new Y,new Y),!1),f=Z(e,new ie(new Y,new Y),!1),d=Z(e,new ie(new Y,new Y),!1),g=Z(e,new ie(new Y,new Y),!1),p=new ne,P=new ne,x=new ne,b=new ne,y=0;let w=1;const C=o.val,S=m.val,v=C-.5*Math.PI,D=S+.5*Math.PI,I=a.val;for(F.geodesicCoordinate(this.m_a,this.m_eSquared,i.x,i.y,n,v,_.at(0),_.at(1)),p.setCoords(_.at(0).val,_.at(1).val),F.geodesicCoordinate(this.m_a,this.m_eSquared,r.x,r.y,n,D,f.at(0),f.at(1)),P.setCoords(f.at(0).val,f.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const s=.5*(y+w);F.geodeticCoordinate(this.m_a,this.m_eSquared,i.x,i.y,s*I,C,h.at(0),h.at(1),this.m_curveType),u.setCoords(h.at(0).val,h.at(1).val),F.geodeticDistance(this.m_a,this.m_eSquared,i.x,i.y,u.x,u.y,null,null,l,this.m_curveType);const o=l.val+.5*Math.PI;F.geodesicCoordinate(this.m_a,this.m_eSquared,u.x,u.y,n,o,d.at(0),d.at(1)),x.setCoords(d.at(0).val,d.at(1).val);const m=Z(e,new Y,!1),a=Z(e,new Y,!1);F.geodeticDistance(this.m_a,this.m_eSquared,p.x,p.y,P.x,P.y,m,a,null,2),F.geodeticCoordinate(this.m_a,this.m_eSquared,p.x,p.y,.5*m.val,a.val,g.at(0),g.at(1),2),b.setCoords(g.at(0).val,g.at(1).val);const _=Z(e,new Y,!1);F.geodeticDistance(this.m_a,this.m_eSquared,x.x,x.y,b.x,b.y,_,null,null,2);if(_.val<=this.m_convergenceOffset)break;{const e={stack:[],error:void 0,hasError:!1};try{w*=.9,F.geodeticCoordinate(this.m_a,this.m_eSquared,i.x,i.y,w*I,C,c.at(0),c.at(1),this.m_curveType),r.setCoords(c.at(0).val,c.at(1).val);const t=Z(e,new Y,!1);F.geodeticDistance(this.m_a,this.m_eSquared,i.x,i.y,r.x,r.y,null,null,t,this.m_curveType);const s=t.val+.5*Math.PI;F.geodesicCoordinate(this.m_a,this.m_eSquared,r.x,r.y,n,s,f.at(0),f.at(1)),P.setCoords(f.at(0).val,f.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{$(e)}}}catch(s){e.error=s,e.hasError=!0}finally{$(e)}}let G=w*I;G>1e5&&(G=1e5),this.m_segmentStep=G}catch(n){e.error=n,e.hasError=!0}finally{$(e)}}setConvergenceOffset(){let e;e=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/e<500&&(e=this.m_absDistance/500),e<.01&&(e=.01),this.m_convergenceOffset=e}}function ce(e,t,s,n,i,r,o){if(e.isEmpty())return new d({vd:e.getDescription()});let _=e;if(a(_)){const e=10*t.getTolerance(0);_=(new g).execute(_,0,e,0,o,12e3)}const I=new he(o);I.m_sr=t,I.m_gcs=t.getGCS(),I.m_transform=p(t,I.m_gcs,null);const G=O();I.m_gcs.querySpheroidData(G);const M=new f;_.queryEnvelope(M),I.m_a=G.majorSemiAxis,I.m_eSquared=G.e2,I.m_rpu=I.m_gcs.getUnit().getUnitToBaseFactor(),I.m_gcs90=.5*Math.PI/I.m_rpu,I.m_gcs180=Math.PI/I.m_rpu,I.m_gcs360=2*Math.PI/I.m_rpu,I.m_gcs60=I.m_gcs360/6,I.m_q90=P.q90(I.m_a,I.m_eSquared),I.m_ellipticToGeodesicMaxRatio=.5*I.m_a*Math.PI/I.m_q90;const T=I.m_gcs.getTolerance(0);I.m_radTolerance=T*I.m_rpu,4===s?(I.m_curveType=2,I.m_bShapePreserving=!0):(I.m_curveType=s,I.m_bShapePreserving=!1),I.m_distance=n,I.m_absDistance=Math.abs(n),Number.isNaN(i)||i<=0?I.setConvergenceOffset():I.m_convergenceOffset=Math.max(i,.001),I.m_convergenceOffset/=r;let N,k=_.getGeometryType();if(h(k)){const e=new x({vd:_.getDescription()});e.addSegment(_,!0),N=e,k=m.enumPolyline}else if(k===m.enumEnvelope){const e=_,t=new f;e.queryEnvelope(t);const s=b(y(I.m_sr,M,!0));if(t.minDimension()<=s)if(0===t.maxDimension()){const t=new w({vd:_.getDescription()});e.getCenter(t),N=t,k=m.enumPoint}else{const t=new x({vd:_.getDescription()});t.addEnvelope(e,!1),N=t,k=m.enumPolyline}else{const t=new d({vd:_.getDescription()});t.addEnvelope(e,!1),N=t,k=m.enumPolygon}}else N=_;if(I.setMinCornerStep(),c(k)||I.setMinSegmentStep(),I.m_absDistance<=.5*I.m_convergenceOffset)return k!==m.enumPolygon?new d({vd:N.getDescription()}):I.m_bShapePreserving?N:C(N,I.m_sr,I.m_curveType,I.m_segmentStep,-1,o);if(I.m_distance<0&&k!==m.enumPolygon)return new d({vd:N.getDescription()});if(I.m_bShapePreserving&&u(k)){const e=C(N,t,4,Number.NaN,I.m_convergenceOffset,o);N=(new S).execute(e,I.m_transform,o)}else N=(new S).execute(N,I.m_transform,o);if(N=v(N,I.m_gcs),N.isEmpty())return new d({vd:N.getDescription()});!I.m_bShapePreserving&&u(k)&&(N=D(I.m_rpu,N)),N=de(N,I.m_gcs);let A=new d;switch(k){case m.enumPolygon:A=I.bufferPolygon(N);break;case m.enumPolyline:A=I.bufferPolyline(N);break;case m.enumMultiPoint:A=I.bufferMultiPoint(N);break;case m.enumPoint:A=I.bufferPoint(N);break;default:l("")}const q=(new S).execute(A,I.m_transform.getInverse(),o);return q.mergeVertexDescription(N.getDescription()),q}function ue(e,t,s,n,i,r,o,m,a,h,c){const u={stack:[],error:void 0,hasError:!1};try{const l=new ne;l.setNAN(),a||c.getPointCount()>0&&(l.setCoordsPoint2D(c.getXY(c.getPointCount()-1)),l.scale(s));const _=Z(u,new Y,!1),f=Z(u,new ie(new Y,new Y),!1),d=new ne,g=new ne,p=r.at(-1),P=1/s;for(let s=0;s<r.length;s++){const u=r[s];let x;0===s?x=o:s===r.length-1?x=m:(F.geodeticDistance(e,t,p.x,p.y,u.x,u.y,null,null,_,i),x=_.val-.5*Math.PI),F.geodesicCoordinate(e,t,u.x,u.y,n,x,f.at(0),f.at(1)),a?g.setCoords(f.at(0).val,f.at(1).val):(d.setCoords(f.at(0).val,f.at(1).val),h=fe(u.x,d.x,l.x,h),g.setCoords(h+d.x,d.y),l.setCoordsPoint2D(g)),g.scale(P),c.insertPoint2D(0,-1,g)}return h}catch(l){u.error=l,u.hasError=!0}finally{$(u)}}function le(e,t,s,n,i,r,o,m,a,h,c,u=Number.NaN,l=Number.NaN){const _={stack:[],error:void 0,hasError:!1};try{if(o-r<m)return h;const f=Z(_,new ie(new Y,new Y),!1),d=new ne,g=new ne,p=new ne;g.setNAN(),a||c.getPointCount()>0&&(g.setCoordsPoint2D(c.getXY(c.getPointCount()-1)),g.scale(s));let P=Math.ceil(r/m),x=P++*m;x===r&&(x=P++*m);let b=r;const y=1/s;for(;x<o+m&&(b<u&&u<x?(x=u,P--):b<l&&l<x&&(x=l,P--),!(x>=o));)F.geodesicCoordinate(e,t,i.x,i.y,n,x,f.at(0),f.at(1)),a?p.setCoords(f.at(0).val,f.at(1).val):(d.setCoords(f.at(0).val,f.at(1).val),h=fe(i.x,d.x,g.x,h),p.setCoords(h+d.x,d.y),g.setCoordsPoint2D(p)),p.scale(y),c.insertPoint2D(0,-1,p),b=x,x=P++*m;return h}catch(f){_.error=f,_.hasError=!0}finally{$(_)}}function _e(e,t,s,n,i,r,o,m,a,h,c){const u={stack:[],error:void 0,hasError:!1};try{const s=new ne,l=new ne,_=Z(u,new ie(new Y,new Y),!1);F.geodesicCoordinate(e,t,i.x,i.y,n,r,_.at(0),_.at(1)),s.setCoords(_.at(0).val,_.at(1).val),F.geodesicCoordinate(e,t,i.x,i.y,n,o,_.at(0),_.at(1)),l.setCoords(_.at(0).val,_.at(1).val);const f=Z(u,new Y,!1);for(F.geodeticDistance(e,t,m.x,m.y,s.x,s.y,null,f,null,0),h[0]=f.val,F.geodeticDistance(e,t,m.x,m.y,l.x,l.y,null,f,null,0),c[0]=f.val;h[0]<=c[0];)h[0]+=re;for(;h[0]>c[0];)h[0]-=re;for(;h[0]>=a;)h[0]-=re,c[0]-=re;for(;h[0]<a;)h[0]+=re,c[0]+=re}catch(l){u.error=l,u.hasError=!0}finally{$(u)}}function fe(e,t,s,n){if(Number.isNaN(s)){for(;n+t-e>Math.PI;)n-=re;for(;e-(n+t)>Math.PI;)n+=re;return n}return n+t-s>Math.PI?n-=re:s-(n+t)>Math.PI&&(n+=re),n}function de(e,t){const s=e.getGeometryType();let n;if(n=u(s)?e.getPathCount():s===m.enumMultiPoint?e.getPointCount():1,1===n)return e;const i=[],r=[];for(let m=0;m<n;m++){i.push(m);const n=new ne;if(u(s)){const t=new f;e.queryPathEnvelope(m,t),n.assign(t.getCenter())}else n.assign(e.getXY(m));const o=t.toGeohash(n);r.push(o)}i.sort(((e,t)=>r[e]<r[t]?-1:r[e]>r[t]?1:0));const o=e.createInstance();for(let m=0;m<n;m++){const t=i[m];u(s)?o.addPath(e,t,!0):o.addPoints(e,t,t+1)}return o}function ge(e,t,s,n,i,r){const o={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const m=s[0],a=s.at(-1),h=Z(o,new Y,!1),c=Z(o,new Y,!1),u=Z(o,new Y,!1);F.greatEllipticDistance(e,t,i.x,i.y,m.x,m.y,h,null,null),F.greatEllipticDistance(e,t,i.x,i.y,a.x,a.y,c,null,null),F.greatEllipticDistance(e,t,m.x,m.y,a.x,a.y,u,null,null);let l=Math.min(h.val,c.val)+u.val,_=l+n;if(_<r)return!0;const f=Z(o,new Y,!1);l=Math.max(h.val,c.val);for(let n=1;n<s.length-1;n++){const r=s[n];F.greatEllipticDistance(e,t,i.x,i.y,r.x,r.y,f,null,null),f.val>l&&(l=f.val)}return _=l+n,_<r}catch(m){o.error=m,o.hasError=!0}finally{$(o)}}function pe(e,t,s,n,i,r,o,m){let a;if(n.length%2==0){const e=n.length>>1,t=n[e],s=n[e-1];a=ne.lerp(t,s,.5)}else{a=n[n.length-1>>1].clone()}const h=a.clone(),c=U(e,t,h,75/180*Math.PI);return!!ge(e,t,n,i,h,c)&&(null!==r&&(r.setCoordsPoint2D(a),r.scale(1/s)),null!==o&&o.setCoordsPoint2D(h),null!==m&&(m[0]=c),!0)}function Pe(e,t,s,n,i,r){const o={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const m=Z(o,new Y,!1);F.greatEllipticDistance(e,t,i.x,i.y,s.x,s.y,m,null,null);return m.val+n<r}catch(m){o.error=m,o.hasError=!0}finally{$(o)}}function xe(e,t,s,n,i,r,o,m){const a=U(e,t,n,75/180*Math.PI);return!!Pe(e,t,n,i,n,a)&&(null!==r&&(r.setCoordsPoint2D(n),r.scale(1/s)),null!==o&&o.setCoordsPoint2D(n),null!==m&&(m[0]=a),!0)}function be(e,t){return new W(e,t)}function ye(e){return j(e,0)||J(e,0),e}class we{constructor(e){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new ne,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=e}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class Ce extends we{constructor(e,t,s){super(e.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new d,this.m_densifiedPoints=[],this.m_bufferer=e,this.m_multiPath=t,this.m_densified=s,this.m_bNeedsSimplify=!0;const n=new f;this.m_multiPath.queryEnvelope(n);const i=n.getCenter(),r=i.clone();r.scale(this.m_bufferer.m_rpu),this.m_gnomonic=be(this.m_bufferer.m_gcs,i),this.m_gnomonicCenterRad=r.clone(),this.m_minGnomonicRadius=U(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,r,75/180*Math.PI)}next(){let e;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e;if(null===this.m_segIter){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;null!==this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;null!=this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}let t=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;const s=16;let n=0;const i=new ne,r=new ne;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<s;){const e=this.m_segIter.nextSegment();if(i.setCoordsPoint2D(e.getStartXY()),r.setCoordsPoint2D(e.getEndXY()),i.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),H(i,r))i.x=r.x;else if(L(i,r))r.x=i.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),n=this.m_multiPath.getPathStart(s),o=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<n&&(e=this.m_multiPath.isClosedPath(s)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(s)?n:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),L(t,i)&&(i.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),H(r,e)&&(r.x=e.x)}}this.m_densifiedPoints.length=0;const s=V(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,r,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(0===n)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else{if(pe(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}if(0===s||Q(i,r)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(i,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(s,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),null===t&&(t=new d,t.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(t),n++}if(this.m_currentDensifiedDelta=[0],n>0){const e=this.m_segIter.getStartPointIndex(),s=this.m_segIter.getPathIndex();for(;n>0;){if(this.m_segIter.previousSegment(),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),i.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(H(i,r))i.x=r.x;else if(L(i,r))r.x=i.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),n=this.m_multiPath.getPathStart(s),o=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<n&&(e=this.m_multiPath.isClosedPath(s)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(s)?n:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),L(t,i)&&(i.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),H(r,e)&&(r.x=e.x)}}this.m_densifiedPoints.length=0,V(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,r,i,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(t),n--}return i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=le(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,i,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_segIter.resetToVertex(e,s),this.m_segIter.nextSegment(),t}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e}isSegmentBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&ge(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new ne,s=new ne,n=[0];return pe(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=be(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,e,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,t)}addJoinAndBufferLeftSide(e){const t=this.m_densifiedPoints[0];let s=Number.NaN,n=this.m_startAzimuth[0]-oe;const i=this.m_endAzimuth[0]+oe;let r=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(s=this.m_lastAzimuth+oe,n=s+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(s=this.m_lastAzimuth+oe,n=s+Math.PI-(re-(this.m_startAzimuth[0]-this.m_lastAzimuth))),r=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI)&&!(this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let i=!1;if(Math.abs(n-s)<=.5*this.m_bufferer.m_cornerStep&&(r||(i=!0)),i){if(e.removePointFromPath(0,e.getPointCount()-1),!this.m_bRunningInGnomonic){const t=new ne;t.setCoordsPoint2D(e.getXY(e.getPointCount()-1)),t.scale(this.m_bufferer.m_rpu),t.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=re:t.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=re)}n=.5*(n+s)}else if(r){const s=new ne;s.setCoordsPoint2D(t),s.scale(1/this.m_bufferer.m_rpu),e.insertPoint2D(0,-1,s)}else le(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],s,n,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,ue(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,n,i,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_lastAzimuth=this.m_endAzimuth[0]}}class Se extends we{constructor(e,t){super(e.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=e,this.m_multiPoint=t,this.m_bNeedsSimplify=!1;const s=new f;this.m_multiPoint.queryEnvelope(s);const n=s.getCenter(),i=n.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=be(this.m_bufferer.m_gcs,n),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=U(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const e=this.m_multiPoint.getXY(this.m_pointIndex);e.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(e),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(e));const t=new d,s=this.m_bufferer.bufferPoint2D(e,this.m_bRunningInGnomonic,t);return this.m_bNeedsSimplify=s,t}isPointBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&Pe(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new ne,s=new ne,n=[0];return xe(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=be(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}}class ve{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n,i,r,o,m){if(o){const o=new De(e,t,s,n,i,!1,r,m);return(new _).executeMany(o,t,m)}return new De(e,t,s,n,i,!1,r,m)}execute(t,n,i,r,o,m,a){const h=new e([t]),c=[r],u=this.executeMany(h,n,i,c,o,!1,m,a).next();return u||s("geodesic buffer null output"),u}}class De extends t{constructor(e,t,s,r,o,m,a,h){super(),this.m_currentUnionEnvelope2D=new f,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=h,m&&n(""),t||i("");0===t.getCoordinateSystemType()&&i(""),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_curveType=s,this.m_distances=r,this.m_convergenceOffset=o,this.m_bOutlineOnly=m,this.m_bUnion=a}next(){let e;for(;e=this.m_inputGeoms.next();)return r(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(e,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(e,t){return ae(e,this.m_spatialReference,this.m_curveType,t,this.m_convergenceOffset,this.m_progressTracker)}}export{ve as OperatorGeodesicBuffer};
