/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{set as e,copy as o}from"../core/libs/gl-matrix-2/math/vec2.js";import{create as r}from"../core/libs/gl-matrix-2/factories/vec2f64.js";import{ZEROS as i,fromValues as t}from"../core/libs/gl-matrix-2/factories/vec4f64.js";import{earth as a}from"../geometry/support/Ellipsoid.js";import{ShaderOutput as l}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as s}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{ObjectAndLayerIdColor as n}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js";import{AlignPixel as c}from"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js";import{HUD as d}from"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js";import{HUDOcclusionPass as u}from"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js";import{HUDVisibility as p}from"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js";import{OutputHighlight as f}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{VisualVariables as g}from"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js";import{alphaCutoff as m}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js";import{ColorConversion as v}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{RgbaFloatEncoding as b}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{ScreenSizePerspective as h,addScreenSizePerspective as w,addScreenSizePerspectiveAlignment as x}from"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js";import{addPixelRatio as C}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float2PassUniform as P}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float4DrawUniform as z}from"../views/3d/webgl-engine/core/shaderModules/Float4DrawUniform.js";import{Float4PassUniform as S}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as j}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as y,If as A}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as O}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as F}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{OITPass as $}from"../views/3d/webgl-engine/lib/OITPass.js";import{VertexAttribute as D}from"../views/3d/webgl-engine/lib/VertexAttribute.js";const L={occludedFadeFactor:.6};function T(o){const r=new O,T=o.signedDistanceFieldEnabled;if(r.include(d,o),r.include(s,o),o.occlusionPass)return r.include(u,o),r;const{vertex:M,fragment:H}=r;r.include(h),r.include(g,o),r.include(n,o),r.include(p),H.include(b),H.include(v),r.varyings.add("vcolor","vec4"),r.varyings.add("vtc","vec2"),r.varyings.add("vsize","vec2"),r.varyings.add("voccluded","float"),M.uniforms.add(new S("viewport",((e,o)=>o.camera.fullViewport)),new P("screenOffset",((o,r)=>e(R,2*o.screenOffset[0]*r.camera.pixelRatio,2*o.screenOffset[1]*r.camera.pixelRatio))),new P("anchorPosition",(e=>E(e))),new S("materialColor",(e=>e.color)),new j("materialRotation",(e=>e.rotation))),C(M),T&&(M.uniforms.add(new S("outlineColor",(e=>e.outlineColor))),H.uniforms.add(new S("outlineColor",(e=>B(e)?e.outlineColor:i)),new j("outlineSize",(e=>B(e)?e.outlineSize:0)))),o.horizonCullingEnabled&&M.uniforms.add(new z("pointDistanceSphere",((e,o)=>{const r=o.camera.eye,i=e.origin;return t(i[0]-r[0],i[1]-r[1],i[2]-r[2],a.radius)}))),o.pixelSnappingEnabled&&M.include(c),o.hasScreenSizePerspective&&(w(M),x(M)),o.debugDrawLabelBorder&&r.varyings.add("debugBorderCoords","vec4"),r.attributes.add(D.UV0,"vec2"),r.attributes.add(D.COLOR,"vec4"),r.attributes.add(D.SIZE,"vec2"),r.attributes.add(D.ROTATION,"float"),r.attributes.add(D.FEATUREATTRIBUTE,"vec4"),M.code.add(o.horizonCullingEnabled?y`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return  b > 0.0 && b < a && b * b  > a * c;
}`:y`bool behindHorizon(vec3 posModel) { return false; }`),M.main.add(y`
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      if (behindHorizon(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      vec2 inputSize;
      ${A(o.hasScreenSizePerspective,y`
          inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
          vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,y`
          inputSize = size;
          vec2 screenOffsetScaled = screenOffset;`)}
      ${A(o.vvSize,y`inputSize *= vvScale(featureAttribute).xx;`)}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);
      bool visible = testHUDVisibility(posProj);
      voccluded = visible ? 0.0 : 1.0;
    `);const U=y`
      vec2 uv01 = floor(uv0);
      vec2 uv = uv0 - uv01;
      quadOffset.xy = (uv01 - anchorPosition) * 2.0 * combinedSize;

      ${A(o.hasRotation,y`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,V=o.pixelSnappingEnabled?T?y`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:y`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:y`posProj += quadOffset;`;M.main.add(y`
    ${A(o.occlusionTestEnabled,y`
      if (!visible) {
        vtc = vec2(0.0);
        ${A(o.debugDrawLabelBorder,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
        return;
      }`)}
    ${U}
    ${o.vvColor?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${A(o.output===l.ObjectAndLayerIdColor,y`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${y.float(m)};
    ${A(T,`alphaDiscard = alphaDiscard && outlineColor.a < ${y.float(m)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${V}
      gl_Position = posProj;
    }

    vtc = uv;

    ${A(o.debugDrawLabelBorder,y`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),H.uniforms.add(new F("tex",(e=>e.texture))),o.occludedFragmentFade&&(H.uniforms.add(new F("depthMap",((e,o)=>o.mainDepth))),H.uniforms.add(new j("fadeFactor",(()=>L.occludedFadeFactor))));const _=o.debugDrawLabelBorder?y`(isBorder > 0.0 ? 0.0 : ${y.float(m)})`:y.float(m),I=o.output===l.Highlight,q=y`
    ${A(o.debugDrawLabelBorder,y`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    ${A(o.sampleSignedDistanceFieldTexelCenter,y`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;`,y`vec2 samplePos = vtc;`)}

    ${T?y`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${_} ||
          fillPixelColor.a + outlinePixelColor.a < ${y.float(m)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${A(!I,y`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${_}) {
          discard;
        }

        ${A(!I,y`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:y`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${_}) {
            discard;
          }
          ${A(!I,y`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${A(o.occludedFragmentFade&&!I,y`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= fadeFactor;
        }
        `)}

    ${A(!I&&o.debugDrawLabelBorder,y`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(o.output){case l.Color:o.oitPass===$.ColorAlpha&&(r.outputs.add("fragColor","vec4",0),r.outputs.add("fragAlpha","float",1)),H.main.add(y`
        ${q}
        ${A(o.oitPass===$.FrontFace,y`fragColor.rgb /= fragColor.a;`)}
        ${A(o.oitPass===$.ColorAlpha,y`fragAlpha = fragColor.a;`)}`);break;case l.ObjectAndLayerIdColor:H.main.add(y`
        ${q}
        outputObjectAndLayerIdColor();`);break;case l.Highlight:r.include(f,o),H.main.add(y`
        ${q}
        outputHighlight(voccluded == 1.0);`)}return r}function B(e){return e.outlineColor[3]>0&&e.outlineSize>0}function E(e,r=R){return e.textureIsSignedDistanceField?M(e.anchorPosition,e.distanceFieldBoundingBox,r):o(r,e.anchorPosition),r}function M(o,r,i){null!=r?e(i,o[0]*(r[2]-r[0])+r[0],o[1]*(r[3]-r[1])+r[1]):e(i,0,0)}const R=r(),H=Object.freeze(Object.defineProperty({__proto__:null,build:T,calculateAnchorPosForRendering:E,shaderSettings:L},Symbol.toStringTag,{value:"Module"}));export{H,T as b,E as c,L as s};
