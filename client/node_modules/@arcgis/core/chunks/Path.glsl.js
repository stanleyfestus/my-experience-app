/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{ForwardLinearDepth as e,addNearFar as i}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{isColorOrColorEmission as a,ShaderOutput as o}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as r}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as n}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ObjectAndLayerIdColor as l}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js";import{PathVertexPosition as s}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js";import{OutputDepth as d}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as t}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{EvaluateAmbientOcclusion as c}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as g,addAmbientBoostFactor as m,addLightingGlobalFactor as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as v}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{Normals as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js";import{NormalUtils as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{PhysicallyBasedRenderingParameters as b,PBRMode as w}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapDraw as f}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{ColorConversion as j}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{addProjViewLocalOrigin as L,addViewNormal as P,addCameraPosition as S}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as O}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as C}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as D,If as A}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as I}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{outputColorHighlightOID as F}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";function B(B){const _=new I,{vertex:M,fragment:V}=_;L(M,B),_.varyings.add("vpos","vec3"),_.include(s,B);const{output:z,spherical:T,pbrMode:x,receiveShadows:H}=B,N=a(z);switch((N||z===o.ObjectAndLayerIdColor)&&(_.include(n,B),_.include(f,B),_.include(e,B),_.include(l,B),_.varyings.add("vnormal","vec3"),_.varyings.add("vcolor","vec4"),B.terrainDepthTest&&_.varyings.add("depth","float"),M.main.add(D`
      vpos = calculateVPos();
      vnormal = normalize(localNormal());

      ${B.terrainDepthTest?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = transformPosition(proj, view, vpos);

      ${N?"forwardLinearDepth();":""}
      forwardObjectAndLayerIdColor();

      vcolor = getColor();`)),_.include(y,B),z){case o.ColorEmission:case o.Color:_.include(b,B),_.include(g,B),_.include(c,B),_.include(f,B),_.include(p,B),_.include(r,B),_.include(F,B),S(V,B),m(V),h(V),V.uniforms.add(M.uniforms.get("localOrigin"),new O("ambient",(e=>e.ambient)),new O("diffuse",(e=>e.diffuse)),new O("specular",(e=>e.specular)),new C("opacity",(e=>e.opacity))),V.include(j),v(V),V.main.add(D`
        discardBySlice(vpos);
        ${B.terrainDepthTest?D`terrainDepthTest(depth);`:""}

        shadingParams.viewDirection = normalize(vpos - cameraPosition);
        shadingParams.normalView = vnormal;
        vec3 normal = shadingNormal(shadingParams);
        float ssao = evaluateAmbientOcclusionInverse();

        vec3 posWorld = vpos + localOrigin;
        vec3 normalGround = ${T?"normalize(posWorld);":"vec3(0.0, 0.0, 1.0);"}

        float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
        vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
        float shadow = ${H?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth));":T?"lightingGlobalFactor * (1.0 - additionalAmbientScale);":"0.0;"}
        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
        float combinedOpacity = vcolor.a * opacity;
        albedo += 0.25 * specular; // don't completely ignore specular for now

        ${A(x===w.Schematic,"float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];\n           vec4 emission = getEmissions();")}

        vec3 shadedColor = ${x===w.Schematic?"evaluateSceneLightingPBR(normal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);":"evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);"}
        vec4 finalColor = vec4(shadedColor, combinedOpacity);
        outputColorHighlightOID(finalColor, vpos);`);break;case o.Depth:_.include(n,B),M.main.add(D`vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);`),_.include(r,B),V.main.add(D`discardBySlice(vpos);`);break;case o.Shadow:case o.ShadowHighlight:case o.ShadowExcludeHighlight:case o.ViewshedShadow:_.include(n,B),i(_),_.varyings.add("depth","float"),M.main.add(D`vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);`),_.include(r,B),_.include(d,B),V.main.add(D`discardBySlice(vpos);
outputDepth(depth);`);break;case o.ObjectAndLayerIdColor:_.include(r,B),V.main.add(D`discardBySlice(vpos);
outputObjectAndLayerIdColor();`);break;case o.Normal:_.include(n,B),_.include(u,B),P(M),_.varyings.add("vnormal","vec3"),M.main.add(D`vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);`),_.include(r,B),V.main.add(D`discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);`);break;case o.Highlight:_.include(n,B),_.include(u,B),_.varyings.add("vnormal","vec3"),M.main.add(D`vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);`),_.include(r,B),_.include(t,B),V.main.add(D`discardBySlice(vpos);
calculateOcclusionAndOutputHighlight();`)}return _}const _=Object.freeze(Object.defineProperty({__proto__:null,build:B},Symbol.toStringTag,{value:"Module"}));export{_ as P,B as b};
