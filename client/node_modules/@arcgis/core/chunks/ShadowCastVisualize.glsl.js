/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{clone as e,fromValues as a}from"../core/libs/gl-matrix-2/factories/vec4f64.js";import{ScreenSpacePass as s}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{CameraSpace as r}from"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js";import{Float4PassUniform as o}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as t}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{NoParameters as i,glsl as l}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as n}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as d}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{S as c}from"./ShadowCastAccumulate.glsl.js";import{ShadowCastVisualization as m}from"../views/3d/webgl-engine/shaders/ShadowCastVisualizeTechniqueConfiguration.js";class h extends i{constructor(a){super(),this._data=a,this.sampleScale=0,this.opacityFromElevation=1,this.color=e(u),this.bandSize=.1,this.threshold=.5}get shadowCastMap(){return this._data.shadowCastTexture}}const u=a(.01,0,.25,1);function p(e){const a=new n,i=a.fragment;a.include(r),a.include(s);const{visualization:h,bandsEnabled:u}=e;i.constants.add("inverseSampleValue","float",c),i.uniforms.add(new d("shadowCastMap",(e=>e.shadowCastMap)),new t("sampleScale",(e=>e.sampleScale)),new t("opacityFromElevation",(e=>e.opacityFromElevation)),new o("uColor",(e=>e.color)));const p=h===m.Gradient,f=h===m.Threshold;return p&&u?i.uniforms.add(new t("bandSize",(e=>e.bandSize))):f&&i.uniforms.add(new t("threshold",(e=>e.threshold))),i.main.add(l`
    float record = texture(shadowCastMap, uv).r;
    float pixelSamples = record * inverseSampleValue;

    fragColor = vec4(0.0);
    if (pixelSamples < 1.0) {
      return;
    }

    float strength = pixelSamples * sampleScale;
    ${f?l`if (strength <= threshold) return;`:""}
    ${p&&u?l`strength = ceil(strength / bandSize) * bandSize;`:""}
    fragColor = vec4(uColor.xyz, uColor.a * opacityFromElevation ${p?"* strength":""});
  `),a}const f=Object.freeze(Object.defineProperty({__proto__:null,ShadowCastVisualizePassParameters:h,build:p},Symbol.toStringTag,{value:"Module"}));export{h as S,f as a,p as b};
