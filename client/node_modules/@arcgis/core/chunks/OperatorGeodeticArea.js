/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{t as e,a as t,G as i,e as s,g as n}from"./Geometry.js";import{a,O as _,G as r,x as h,t as o,h as m,e as l,bg as p,K as u,ak as c,bh as g,d,au as E,a2 as f,N as P,ax as S,bi as A,bj as x,a0 as y,a1 as R,ad as M,bk as C,an as T,ai as w,L as q,ar as N}from"./QuadraticBezier.js";import{f as b,P as I,K as v,e as $,k as z,T as G,E as k,j as D,c as O,r as L,s as F,t as J,v as Y,w as U}from"./Transformation2D.js";import{O as X}from"./OperatorShapePreservingLength.js";import{b as j,c as B}from"./tslib.es6.js";import{a as H}from"./GeodeticDistanceCalculator-CJvEB3vc.js";class Q{constructor(e,t,i,s,n=100){this.m_startPt=e.clone(),this.m_endPt=t.clone(),this.m_cE2=s,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=i.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=2===i.getCoordinateSystemType(),this.PEProjcs=i.getPECoordSys(),this.m_points=new Array(2*n)}setSegmentEndPoints(e,t){this.m_startPt.assign(e),this.m_endPt.assign(t)}makeFunctor(){return e=>{const t=[0,0];t[0]=this.m_startPt.x*(1-e)+this.m_endPt.x*e,t[1]=this.m_startPt.y*(1-e)+this.m_endPt.y*e,this.isPcs&&E.projToGeogCenter(this.PEProjcs,1,t,0);const i=Math.sin(t[1]*this.m_cRpu);if(0===this.m_cE2)return i;return-Math.log((1-this.m_cE*i)/(1+this.m_cE*i))*this.m_c1By2e+i/(1-this.m_cE2*i*i)}}makeArrayFunctor(){return n(0),{}}}function V(e,t,i){const s=new o;e.queryEnvelope(s);const n=m(t,s,!0).total(),a=t.getPannableExtent();a.xmin=s.xmin-10*n,a.xmax=s.xmax+10*n;const _=(new l).execute(e,a,t,i).getImpl().querySegmentIterator();_.stripAttributes();const r=f();t.querySpheroidData(r);const h=r.e2,u=0===h?2:1,c=new I(0,0),g=new I(0,0),d=new v(0),E=new Q(c,g,t,h,100);for(;_.nextPath();)for(;_.hasNextSegment();){const e=_.nextSegment();c.assign(e.getStartXY()),g.assign(e.getEndXY()),E.setSegmentEndPoints(c,g);const t=p(6,0,1,1e-12,1e-15,E.makeFunctor());d.pe((g.x-c.x)*t)}const P=r.majorSemiAxis;return u*P*P*(1-h)*Math.PI*d.getResult()/t.getPannableExtent().width()}function Z(e,t,i,s,n){const a=se(e,t,n);let _=K(e,a.first,i,s,n),r=1,h=0,o=0;do{if(r++,a.first*=.5,a.first<50*t.getTolerance(0))return _;a.second*=2,o=K(e,a.first,i,s,n),h=Math.abs(o-_),_=o}while(Math.abs(_)>1&&h>1e-8*Math.abs(_)&&(a.second<65e3&&r<8||r<4));return o}function K(e,t,i,s,n){const a=(new _).execute(e,t,0,0,n);let r;r=s?(new u).execute(a,s,n):a;const h=1===i.getUnit().getUnitToBaseFactor()?Math.PI/180:1,m=new o;r.queryEnvelope(m);const l=new o,p=new o,c=new o;l.setCoords({xmin:m.xmin,ymin:75*h,xmax:m.xmax,ymax:90*h}),p.setCoords({xmin:m.xmin,ymin:-60*h,xmax:m.xmax,ymax:75*h}),c.setCoords({xmin:m.xmin,ymin:-90*h,xmax:m.xmax,ymax:-60*h}),l.inflateCoords(.01*l.width(),0),p.inflateCoords(.01*p.width(),0),c.inflateCoords(.01*c.width(),0);let g=0;return g+=W(r,l,i,n),g+=W(r,p,i,n),g+=W(r,c,i,n),g}function W(e,t,i,s){const n=(new l).execute(e,t,i,s);if(null!==n&&!n.isEmpty()){const e=new o;n.queryEnvelope(e);const{first:t,second:a}=ie(i,e,!1),_=r(i,t,null),h=(new u).execute(n,_,s).calculateArea2D();return a&&t.destroy(),h}return 0}const ee=[null,null,null,null,null,null,null];function te(e,t,i){const a=e.getUnit().getUnitToBaseFactor(),_=t.getCenter();_.scale(180*a/Math.PI);const r=new I;r.x=0,r.y=0;let h=0;if(0===h){_.y>45?(r.y=$,h=0):_.y<-45?(r.y=-$,h=1):_.x>=45&&_.x<135?(r.x=$,h=2):_.x>=135||_.x<-135?(r.x=$,h=3):_.x<-45&&_.x>=-135?(r.x=-$,h=4):(r.x=0,h=5);const e=a*Math.sqrt(z(t.xmin-t.xmax)+z(t.ymin-t.ymax)),i=r.clone(),s=t.getCenter();s.scale(a),h<2&&(i.x=s.x);if(I.distance(i,s)+.5*e>$)return null}const o=ee[h];if(null!==o&&o.getGCS().equalHorizontal(e))return o;const m=e.getText(),l=r.x,p=r.y,u=0,E=0;let f=0,P=-1;6!==h?P=c.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:(n(i),f=0,P=c.PE_PRJ_CYLINDRICAL_EQAREA);const S=g("EqualAreaPCS");let A;P===c.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?A=`PROJCS["${S}",${m},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${u}],PARAMETER["False_Northing",${E}],PARAMETER["Central_Meridian",${l}],PARAMETER["Latitude_of_Origin",${p}],UNIT["Meter",1.0]]`:P===c.PE_PRJ_CYLINDRICAL_EQAREA?A=`PROJCS["${S}",${m},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${u}],PARAMETER["False_Northing",${E}],PARAMETER["Central_Meridian",${l}],PARAMETER["Standard_Parallel_1",${f}],PARAMETER["Latitude_of_Origin",${p}],UNIT["Meter",1.0]]`:s("getEqualAreaPcsFixed");const x=d(A);return ee[h]&&ee[h].destroy(),ee[h]=x,x}function ie(e,t,i){const n=te(e,t,i);if(null!==n)return b(n,!1);const a=e.getText(),_=e.getUnit().getUnitToBaseFactor(),r=(t.xmin+t.width()/2)*_,h=(t.ymin+t.height()/2)*_,o=0,m=0;let l=0,p=0,u=-1;t.ymin*_>=75*Math.PI/180||t.ymax*_<=-60*Math.PI/180?u=c.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:t.ymin>0||t.ymax<0?(l=(t.ymin+1/3*t.height())*_,p=(t.ymin+2/3*t.height())*_,u=c.PE_PRJ_ALBERS):(l=(t.ymin+2/3*t.height())*_,u=c.PE_PRJ_CYLINDRICAL_EQAREA);const E=g("EqualAreaPCS");let f;return u===c.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?f=`PROJCS["${E}",${a},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${o}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${r}],PARAMETER["Latitude_of_Origin",${h}],UNIT["Meter",1.0]]`:u===c.PE_PRJ_ALBERS?f=`PROJCS["${E}",${a},PROJECTION["Albers"],PARAMETER["False_Easting",${o}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${r}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Standard_Parallel_2",${p}],PARAMETER["Latitude_of_Origin",${h}],UNIT["Meter",1.0]]`:u===c.PE_PRJ_CYLINDRICAL_EQAREA?f=`PROJCS["${E}",${a},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${o}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${r}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Latitude_of_Origin",${h}],UNIT["Meter",1.0]]`:s("getEqualAreaPCSInstance"),b(d(f),!0)}function se(e,t,i){const s=e.calculateLength2D(),n=(new X).execute(e,t,i)/25e3,a=s/e.getSegmentCount()*2;let _=Math.min(a,s/n);0===_&&(_=1);return b(_,s/_)}class ne{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(e,t,i){return!1}canAccelerateGeometry(e){return!1}execute(s,n,o){if(0===n.getCoordinateSystemType()&&e(""),s.isEmpty()||s.getDimension()<2)return 0;if(t(s),s.getGeometryType()===i.enumEnvelope){const e=new a;return e.addEnvelope(s,!1),this.execute(e,n,o)}let m=s;s.getDescription().getAttributeCount()>1&&(m=s.clone(),m.dropAllAttributes());const l=(new _).execute(m,0,n.getTolerance(0),0,o);let p=null;const u=n.getGCS();u!==n&&(p=r(n,u));let c=(new h).execute(l,n,!1,o);return c.isEmpty()?0:(c===s&&(c=s.clone()),n.isPannable()?V(c,n,o):Z(c,n,u,p,o))}}function ae(){return{m_p_PCS:new I,m_factor:Number.NaN,setValues:_e,assign:re}}function _e(e,t){this.m_factor=e,this.m_p_PCS.assign(t)}function re(e){this.m_factor=e.m_factor,this.m_p_PCS.assign(e.m_p_PCS)}class he{constructor(e,t,i,s){this.m_ptStart=new T,this.m_ptEnd=new T,this.m_ptStart.assign(t),this.m_ptEnd.assign(i),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(e),this.m_e2=e,this.m_c1MinusE2=1-e;const n=Math.sin(s);let a;a=0===this.m_e2?2*n:n*(Y(this.m_e*n)+1/(1-this.m_e2*n*n)),this.m_baseA=a}setSegmentEndPoints(e,t){this.m_ptStart.assign(e),this.m_ptEnd.assign(t),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return e=>{const t=1-e,i=t*this.m_ptStart.x+e*this.m_ptEnd.x,s=t*this.m_ptStart.y+e*this.m_ptEnd.y,n=t*this.m_ptStart.z+e*this.m_ptEnd.z,a=i*i+s*s,_=n/Math.sqrt(n*n+this.m_c1MinusE2*this.m_c1MinusE2*a);let r;if(0===this.m_e2)r=2*_;else{r=_*(Y(this.m_e*_)+1/(1-this.m_e2*_*_))}return(this.m_deltaY*i-this.m_deltaX*s)/a*(r-this.m_baseA)}}}function oe(){return{e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN}}function me(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:le,changeSign:pe,assign:ue,clone:ce}}function le(e,t,i,s){const n=.5*e;this.sin_phi=Math.sin(e);const a=t*this.sin_phi,_=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(n+i),this.sin_half_phi_pz=Math.sin(n+s),this.sin_half_asin_e_sin_phi_pf=Math.sin(_+i),this.sin_half_asin_e_sin_phi_pz=Math.sin(_+s),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function pe(){this.sin_phi=-this.sin_phi;let e=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=e,e=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=e,e=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=e,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function ue(e){this.sin_phi=e.sin_phi,this.one_p_sin_phi=e.one_p_sin_phi,this.one_m_sin_phi=e.one_m_sin_phi,this.one_m_e_2_sin_2_phi=e.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=e.sin_half_phi_pf,this.sin_half_phi_pz=e.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=e.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=e.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=e.atanh_sin_phi,this.atanh_esin_phi=e.atanh_esin_phi,this.make_negative=e.make_negative}function ce(){return{...this}}class ge{constructor(t,i,s){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new G,this.m_scaleToDegrees=new G,this.m_progressTracker=s,n(4!==i),this.m_curveType=i,this.m_inputSR=t,t&&0!==t.getCoordinateSystemType()||e(""),this.m_inputGCS=t.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(e){let t,i=e.clone();if(i.dropAllAttributes(),e.hasNonLinearSegments()){i=(new _).execute(i,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)}if(this.m_inputSR.isPannable()){const e=new o;i.queryEnvelope(e);const t=this.m_inputSR.getPannableExtent();if(!t.containsEnvelope(e)){const s=t.getCenterX()-e.getCenterX(),n=new G;n.setShiftCoords(s,0),i.applyTransformation(n),e.move(s,0);const a=new k;t.queryIntervalX(a);const _=new k;e.queryIntervalX(_),i=a.contains(_)?P(i,this.m_inputSR):(new u).foldInto360RangeGeodetic(i,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(i=(new h).execute(i,this.m_inputSR,!1,this.m_progressTracker),t=i.createInstance(),S(this.m_transformPCS2GCS,i,t,this.m_progressTracker)||(t=(new u).execute(i,this.m_transformPCS2GCS,this.m_progressTracker))):t=(new h).execute(i,this.m_inputGCS,!1,this.m_progressTracker),t.isEmpty())return 0;if(1===this.m_curveType){const e=f();return this.m_inputGCS.querySpheroidData(e),this.m_a=e.majorSemiAxis,this.m_eSquared=e.e2,this.loxodromeArea(t)}const s=t.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),s.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const n=f();if(this.m_inputGCS.querySpheroidData(n),this.m_a=n.majorSemiAxis,this.m_b=n.minorSemiAxis,this.m_eSquared=n.e2,2===this.m_curveType)return this.executeClippedPolygonGreatEllipticArea(t);{const e={stack:[],error:void 0,hasError:!1};try{const i=A.unit(9101),s=this.m_inputGCS.getPECoordSys(),n=j(e,s.cloneAlterUnits(i),!1);let a,_,r=this.executeClippedPolygonGeodeticArea(t,n,0),h=0;do{h++,a=this.executeClippedPolygonGeodeticArea(t,n,h),_=Math.abs(a-r),r=a}while(Math.abs(a)>1&&_>1e-8*Math.abs(a)&&h<7);return a}catch(a){e.error=a,e.hasError=!0}finally{B(e)}}}executeClippedPolygonGeodeticArea(e,t,i){const s={stack:[],error:void 0,hasError:!1};try{const n=new o;e.queryEnvelope(n);const a=j(s,this.getEqualAreaPCSInstance(t,n),!1),_=e.clone();x(a,_);const r=50,h=_.getImpl().getAttributeStreamRef(0),m=e.getImpl().getAttributeStreamRef(0),l=j(s,new y,!1),p=j(s,new y,!1),u=40,c=[0,0],g=D(ae,u),d=O(u,-1),f=ae(),P=ae();let S,A;const M=a;let C=_.calculateArea2D();const T=new v(0),w=.5*Math.PI,q=1e-10*Math.abs(C)+1e-6,N=e.getPathCount();let b,$,z,G;const k=new I,F=new I,J=new I,Y=new I,U=new I,X=new I;let B,H;for($=e.getPathStart(0),b=0;b<N;b++,$=z)for(z=e.getPathEnd(b),h.queryPoint2D(z-1<<1,J),m.queryPoint2D(z-1<<1,k),Math.abs(k.y)>w&&(k.y=L(w,k.y)),G=$;G<z;G++,J.assign(Y),k.assign(F)){if(h.queryPoint2D(G<<1,Y),m.queryPoint2D(G<<1,F),Math.abs(F.y)>w&&(F.y=L(w,F.y)),B=I.distance(J,Y),B<r||0===k.y&&0===F.y)continue;R.geodeticDistance(this.m_a,this.m_eSquared,k.x,k.y,F.x,F.y,l,p,null,this.m_curveType);const e=l.val,t=p.val;for(f.setValues(0,J),P.setValues(1,Y),A=i,g[0].assign(P),d[0]=i,S=0;S>=0;){H=.5*(f.m_factor+P.m_factor),R.geodeticCoordinate(this.m_a,this.m_eSquared,k.x,k.y,e*H,t,l,p,this.m_curveType),U.x=l.val,U.y=p.val,c[0]=U.x,c[1]=U.y,E.geogToProj(M,1,c),X.x=c[0],X.y=c[1];const i=-X.offset(f.m_p_PCS,P.m_p_PCS),s=.5*i*I.distance(f.m_p_PCS,P.m_p_PCS);if(T.pe(s),Math.abs(s)>q||Math.abs(s)>0&&A>0)P.setValues(H,X),S++,g[S].assign(P),Math.abs(s)<=q?(A--,d[S-1]=A,d[S]=A):(A=d[S-1],d[S]=A);else{if(S<=0)break;f.assign(P),S--,P.assign(g[S]),A=d[S]}}}return C+=T.getResult(),Math.abs(C)}catch(n){s.error=n,s.hasError=!0}finally{B(s)}}executeClippedPolygonGreatEllipticArea(e){const t=[],i=[],s=new I,n=new I,a=M(1,this.m_eSquared,new I(0,.5*Math.PI)),_=new v(0),r=new v(0),h=new v(0),m=new T,l=new T,p=new o;e.queryLooseEnvelope(p);let u=0;p.containsCoords(p.xmin,0)||(u=Math.abs(p.ymin)<Math.abs(p.ymax)?p.ymin:p.ymax);const c=new he(this.m_eSquared,m,l,u),g=this.m_a*this.m_a,d=e.getImpl().querySegmentIterator();for(d.stripAttributes();d.nextPath();)for(;d.hasNextSegment();){const e=d.nextSegment();s.assign(e.getStartXY()),n.assign(e.getEndXY()),n.x-s.x>Math.PI?s.x+=2*Math.PI:n.x-s.x<-Math.PI&&(n.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(e,t,i);for(let i of t)m.assign(M(this.m_a,this.m_eSquared,i.getStartXY())),l.assign(M(this.m_a,this.m_eSquared,i.getEndXY())),c.setSegmentEndPoints(m,l),this.adaptiveIntegrationWithRomberg(c,_);for(let t of i){let e=t.getStartXY(),i=t.getEndXY(),s=u;e.y<0&&(i=F(e,e=i),e.y=-e.y,i.y=-i.y,s=-s);const n=M(1,this.m_eSquared,e),_=M(1,this.m_eSquared,i),o=Math.min(e.y,i.y),m=C(this.m_eSquared,e.x,i.x,s,o);r.pe(m);const l=Math.abs(C(this.m_eSquared,e.x,i.x,o,$)),p=new T;p.setSub(n,a);const c=new T;c.setSub(_,a);const d=new T;d.setCrossProductVector(p,c);let E=g*(l-.5*d.length());E=L(E,i.x-e.x),h.pe(E)}t.length=0,i.length=0}return h.getResult()+g*(.5*(1-this.m_eSquared)*_.getResult()+r.getResult())}getEqualAreaPCSInstance(e,t){const i=t.getCenterX(),s=0,n=0;let a,_;const r=t.height();let h,o;(h=t.ymin>45*Math.PI/180||t.ymax<45*-Math.PI/180)?a=L(.5*Math.PI,t.getCenterY()):(a=t.getCenterY(),_=t.ymin+r*(2/3));const m=g("EqualAreaPCS"),l=e.toString();return o=h?A.fromString(c.PE_TYPE_PROJCS,`PROJCS["${m}", ${l}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${s}],PARAMETER["False_Northing", ${n}],PARAMETER["Central_Meridian", ${i}], PARAMETER["Latitude_of_Origin", ${a}], UNIT["Meter",1.0]]`):A.fromString(c.PE_TYPE_PROJCS,`PROJCS["${m}", ${l}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", ${s}],PARAMETER["False_Northing", ${n}],PARAMETER["Central_Meridian", ${i}],PARAMETER["Standard_Parallel_1", ${_}],PARAMETER["Latitude_of_Origin", ${a}],UNIT["Meter",1.0]]`),o}splitSegmentCrossingItegralThreshold(e,t,i){const s=100,n=20,a=n*n,_=M(this.m_a,this.m_eSquared,new I(0,$)),r=M(this.m_a,this.m_eSquared,new I(0,-$)),h=this.splitSegmentPassingThroughPole(e);for(let o of h){const e=o.getStartXY(),h=o.getEndXY(),m=M(this.m_a,this.m_eSquared,e),l=M(this.m_a,this.m_eSquared,h),p=new I,u=new T;let c=T.sqrDistance(_,m),g=T.sqrDistance(m,l);if(c<=s){if(!(g>a)){i.push(new q({start:e,end:h}));continue}u.assign(l.sub(m)),u.normalizeThis(),u.assign(m.add(u.mul(n))),p.assign(w(this.m_a,this.m_eSquared,u)),i.push(new q({start:e,end:p})),e.assign(p)}if(m.assign(M(this.m_a,this.m_eSquared,e)),c=T.sqrDistance(_,l),g=T.sqrDistance(m,l),c<=s){if(!(g>a)){i.push(new q({start:e,end:h}));continue}u.assign(l.sub(m)),u.normalizeThis(),u.assign(l.sub(u.mul(n))),p.assign(w(this.m_a,this.m_eSquared,u)),i.push(new q({start:p,end:h})),h.assign(p)}if(m.assign(M(this.m_a,this.m_eSquared,e)),l.assign(M(this.m_a,this.m_eSquared,h)),c=T.sqrDistance(r,m),g=T.sqrDistance(m,l),c<=s){if(!(g>a)){i.push(new q({start:e,end:h}));continue}u.assign(l.sub(m)),u.normalizeThis(),u.assign(m.add(u.mul(n))),p.assign(w(this.m_a,this.m_eSquared,u)),i.push(new q({start:e,end:p})),e.assign(p)}if(m.assign(M(this.m_a,this.m_eSquared,e)),l.assign(M(this.m_a,this.m_eSquared,h)),c=T.sqrDistance(r,l),g=T.sqrDistance(m,l),c<=s){if(!(g>a)){i.push(new q({start:e,end:h}));continue}u.assign(l.sub(m)),u.normalizeThis(),u.assign(l.sub(u.mul(n))),p.assign(w(this.m_a,this.m_eSquared,u)),i.push(new q({start:p,end:h})),h.assign(p)}t.push(new q({start:e,end:h}))}}splitSegmentPassingThroughPole(e){const t={stack:[],error:void 0,hasError:!1};try{const i=[],s=new T,n=new T,a=new T,_=new I,r=20,h=3.124139361,o=10,m=e.getStartXY(),l=e.getEndXY(),p=j(t,new y,!1);if(R.geodeticDistance(this.m_a,this.m_eSquared,m.x,m.y,l.x,l.y,p,null,null,2),Math.abs(l.x-m.x)>h&&p.val>r){const e=new H(new I(0,90),m.divide(this.m_rpu),l.divide(this.m_rpu),this.m_inputGCS,2,2);let t=N(e.makeFunctor(),0,1,1e-10);if(t.second<=o&&t.first>0&&t.first<1)return s.assign(M(this.m_a,this.m_eSquared,m)),n.assign(M(this.m_a,this.m_eSquared,l)),J(s,n,t.first,a),_.assign(w(this.m_a,this.m_eSquared,a)),i.push(new q({start:m,end:_})),i.push(new q({start:_,end:l})),i;if(e.setPointDistFrom(new I(0,-90)),t=N(e.makeFunctor(),0,1,1e-10),t.second<=o&&t.first>0&&t.first<1)return s.assign(M(this.m_a,this.m_eSquared,m)),n.assign(M(this.m_a,this.m_eSquared,l)),J(s,n,t.first,a),_.assign(w(this.m_a,this.m_eSquared,a)),i.push(new q({start:m,end:_})),i.push(new q({start:_,end:l})),i}return i.push(new q({start:m,end:l})),i}catch(i){t.error=i,t.hasError=!0}finally{B(t)}}adaptiveIntegrationWithRomberg(e,t){const i=e.makeFunctor();let s=0,n=1,a=i(s),_=i(n);const r=1e-17,h=1e-14;let o=(s+n)/2,m=i(o),l=Math.abs(m-a),u=Math.abs(_-m),c=0;for(;c++<32&&(l/u<.1||u/l<.1);)l<u?(t.pe(p(5,s,o,h,r,i)),s=o,a=m):(t.pe(p(5,o,n,h,r,i)),n=o,_=m),o=(s+n)/2,m=Math.abs(i(o)),l=Math.abs(m-a),u=Math.abs(_-m);t.pe(p(5,s,n,h,r,i))}loxodromeAreaHemi(e,t,i,s,n){const a=i.clone(),_=n.clone();let r,h,o,m,l,p,u,c,g,d,E,f,P,S,A,x;return a.make_negative&&a.changeSign(),_.make_negative&&_.changeSign(),E=s-t,1===Math.abs(a.sin_phi)||1===Math.abs(_.sin_phi)?e.half_qp*E:a.sin_phi===_.sin_phi?(d=.5*e.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+Y(e.e*a.sin_phi))*E,d):(A=Math.log(_.sin_half_phi_pf*a.sin_half_phi_pz/(_.sin_half_phi_pz*a.sin_half_phi_pf)),x=Math.log(_.sin_half_asin_e_sin_phi_pf*a.sin_half_asin_e_sin_phi_pz/(_.sin_half_asin_e_sin_phi_pz*a.sin_half_asin_e_sin_phi_pf)),1===this.m_eSquared?(l=0,r=.5*(A+_.sin_phi/_.one_m_e_2_sin_2_phi-a.sin_phi/a.one_m_e_2_sin_2_phi),h=0):(l=-2*e.atanh_e_over_e*(Math.log(_.one_p_sin_phi/a.one_p_sin_phi)-e.e*x),r=(A-e.e*x)/e.one_m_e_2,h=(Math.log(_.one_m_e_2_sin_2_phi/a.one_m_e_2_sin_2_phi)+l/e.atanh_e_over_e)/e.one_m_e_2),o=-x*(a.atanh_esin_phi+_.atanh_esin_phi),m=1/a.one_m_e_2_sin_2_phi-1/_.one_m_e_2_sin_2_phi,p=U(_.one_m_sin_phi/e.one_p_e,e.e)-U(a.one_m_sin_phi/e.one_p_e,e.e),u=U(_.one_p_sin_phi/e.one_p_e,e.e)-U(a.one_p_sin_phi/e.one_p_e,e.e),c=U(a.one_m_sin_phi/-e.one_m_e,e.e)-U(_.one_m_sin_phi/-e.one_m_e,e.e),g=U(a.one_p_sin_phi/-e.one_m_e,e.e)-U(_.one_p_sin_phi/-e.one_m_e,e.e),d=.25/r*(h+o+m+l+.5*(p+u+c+g)),d+=e.half_qp,f=.5*e.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+Y(e.e*a.sin_phi)),P=.5*e.one_m_e_2*_.sin_phi*(1/_.one_m_e_2_sin_2_phi+Y(e.e*_.sin_phi)),P<f&&(S=f,f=P,P=S),d<f&&(d=f),d>P&&(d=P),d*=E,d)}loxodromeArea(e){const t=Math.PI/180;let i=0;const s=oe(),n=me(),a=me();s.e=Math.sqrt(this.m_eSquared),s.one_p_e=1+s.e,s.one_m_e=1-s.e,s.one_m_e_2=1-this.m_eSquared,s.atanh_e_over_e=Y(s.e),this.m_eSquared>=1?s.half_qp=1:s.half_qp=.5*(1+s.atanh_e_over_e*s.one_m_e_2),s.f=.25*Math.PI,s.z=.75*Math.PI,a.initialize(0,s.e,s.f,s.z);const _=e.getPathCount(),r=new I,h=new I,o=e.getImpl().getAttributeStreamRef(0);for(let m=0;m<_;m++){const _=e.getPathStart(m),l=e.getPathEnd(m);if(!(l-_<=1)){o.queryPoint2D(2*(l-1),r);for(let e=_;e<l;e++){o.queryPoint2D(2*e,h);const m=r.y*t,l=h.y*t;if(e===_?(n.initialize(m,s.e,s.f,s.z),n.make_negative=!1):n.assign(a),a.initialize(l,s.e,s.f,s.z),a.make_negative=!1,r.y*h.y<0){if(r.y>=90&&h.y<=-90||h.y>=90&&r.y<=-90)return Number.NaN;const e=me();e.initialize(0,s.e,s.f,s.z),e.make_negative=!1;const _=n.atanh_sin_phi-s.e*n.atanh_esin_phi,o=a.atanh_sin_phi-s.e*a.atanh_esin_phi,l=(o*r.x-_*h.x)/(o-_);m<0?(n.make_negative=!0,i-=this.loxodromeAreaHemi(s,r.x*t,n,l*t,e),n.make_negative=!1,i+=this.loxodromeAreaHemi(s,l*t,e,h.x*t,a)):(i+=this.loxodromeAreaHemi(s,r.x*t,n,l*t,e),a.make_negative=!0,i-=this.loxodromeAreaHemi(s,l*t,e,h.x*t,a),a.make_negative=!1)}else r.y>=0?i+=this.loxodromeAreaHemi(s,r.x*t,n,h.x*t,a):(n.make_negative=!0,a.make_negative=!0,i-=this.loxodromeAreaHemi(s,r.x*t,n,h.x*t,a),n.make_negative=!1,a.make_negative=!1);r.assign(h)}}}return this.m_a*i*this.m_a}calculate(e){if(e.isEmpty()||e.getDimension()<2)return 0;if(e.getGeometryType()===i.enumEnvelope){const t=new a;return t.addEnvelope(e,!1),this.calculate(t)}return this.m_inputSR!==this.m_inputGCS&&null===this.m_transformPCS2GCS&&(this.m_transformPCS2GCS=r(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(e)}}class de{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,i){return!1}canAccelerateGeometry(e){return!1}execute(e,i,s,n){if(t(e),4===s)return(new ne).execute(e,i,n);return new ge(i,s,n).calculate(e)}}export{de as OperatorGeodeticArea};
