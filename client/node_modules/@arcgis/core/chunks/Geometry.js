/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
function e(e){switch(e){case 1:return"Unknown error";case 2:return"Corrupted geometry";case 3:return"Empty geometry";case 4:return"Math singularity";case 5:return"Buffer is too small";case 6:return"Invalid shape type";case 7:return"Projection out of supported range";case 8:return"Non simple geometry";case 9:return"Cannot calculate geodesic";case 10:return"Notation conversion";case 11:return"Missing grid file";case 12:return"Invalid call";case 13:return"Internal error";case 14:return"Not implemented";case 15:return"IO error";case 16:return"Invalid 3D";case 17:return"An ambiguous geography edge with antipodal points";case 18:return"Geocentric coordinates require ellipsoidal height";case 19:return"Geography cannot be projected into a gnomonic plane or a result of an operation cannot fit into a gnomonic plane";case 20:return"Geometry is too large to be exported in to a given format";case 21:return"Operation is canceled by the user";default:return"unknown error"}}function n(e,n){try{if(!e)throw new Error(n)}catch(t){throw t}}class t extends Error{constructor(e,n){super(),this.m_AdditionalMessage=n,this.m_ErrorType=e}what(){return e(this.m_ErrorType)}additionalMessage(){return this.m_AdditionalMessage?this.m_AdditionalMessage:""}code(){return this.m_ErrorType}}class r extends t{constructor(e){super(2,e),this.name="corrupted geometry exception"}}class o extends t{constructor(e){super(3,e),this.name="empty gemetry exception"}}class i extends t{constructor(e){super(4,e),this.name="match singularity exception"}}class u extends t{constructor(e){super(8,e),this.name="non simple geometry exception"}}var a;!function(e){e[e.enumUnknown=0]="enumUnknown",e[e.enumPoint=513]="enumPoint",e[e.enumLine=5122]="enumLine",e[e.enumBezier=5123]="enumBezier",e[e.enumEllipticArc=5124]="enumEllipticArc",e[e.enumEnvelope=3077]="enumEnvelope",e[e.enumMultiPoint=8710]="enumMultiPoint",e[e.enumPolyline=25607]="enumPolyline",e[e.enumPolygon=27656]="enumPolygon",e[e.enumMultipatch=40969]="enumMultipatch",e[e.enumGeometryCollection=3594]="enumGeometryCollection",e[e.enumRationalBezier2=5134]="enumRationalBezier2",e[e.enumBezier2=5135]="enumBezier2",e[e.enumRationalBezier23d=5392]="enumRationalBezier23d",e[e.enumGreatArc3d=5393]="enumGreatArc3d"}(a||(a={}));const s=[0,0,1,1,1,2,0,1,2,3,-1,-1,-1,-1,1,1];function c(e){return s[15&e]}function m(e){return!!(512&e)}function l(e){return!!(1024&e)}function p(e){return!!(2048&e)}function f(e){return!!(4096&e)}function d(e){return!!(8192&e)}function y(e){return!!(16384&e)}function g(e){return!!(32768&e)}function h(e){const n=e.getGeometryType();return d(n)?e.getPointCount():e.isEmpty()?0:n===a.enumEnvelope?4:n===a.enumPoint?1:f(n)?2:void A("missing type")}function w(e){const n=e.getGeometryType();if(y(n))return e.hasNonLinearSegments();if(n===a.enumGeometryCollection){const n=e;for(let e=0,t=n.getGeometryCount();e<t;e++)if(w(n.getGeometry(e)))return!0;return!1}return!!f(n)&&n!==a.enumLine}function G(e){throw new r(e)}function x(e){const n=new Error(e);throw n.name="invalid argument exception",n}function E(e){const n=new i(e);throw n.name="invalid argument exception",n}function v(){x("Geometry type is not supported for 3D operations.")}function P(e){throw new t(12,e)}function B(e){throw new o(e)}function M(e){const n=new t(14,e);throw n.name="not implemented",n}function z(e){const n=new Error(e);throw n.name="out of range exception",n}function A(e){const n=new t(13,e);throw n.name="internal error",n}function C(e){const n=new Error(e);throw n.name="logic error exception",n}function b(e){throw new u(e)}function k(){M("operation does not support curves yet")}function T(e){e&&w(e)&&k()}function _(e){e&&g(e.getGeometryType())&&M("Unsupported geometry type.")}function I(e){e===a.enumGeometryCollection&&x("Geometry_collection instances are not supported in this operation")}function L(e){I(e.getGeometryType())}function N(e){x(`bad wkid: ${e}`)}function R(e){let n="bad wkt: ";n+=e,n+="...",x(n)}function U(e,n){e||x(n)}export{R as A,I as B,b as C,a as G,_ as a,m as b,f as c,M as d,A as e,d as f,n as g,w as h,y as i,G as j,T as k,p as l,g as m,l as n,P as o,z as p,E as q,B as r,C as s,x as t,v as u,h as v,U as w,c as x,L as y,N as z};
