/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{b as t,c as e}from"./tslib.es6.js";import{t as i,G as s,g as n,e as o,v as a,i as m}from"./Geometry.js";import{t as r,K as u,G as c,a0 as h,a1 as l,ad as _,an as p,ap as d,S as g,aq as x,ar as y,ac as P,e as S,as as D,N as G,w as f,a as v,at as T,H as b,ai as w,a2 as M}from"./QuadraticBezier.js";import{P as E,T as R,s as I,f as C,E as B,h as q}from"./Transformation2D.js";import{s as A,w as N,m as F}from"./Distance2DCalculator-BX0Ep7eP.js";import{O as X}from"./OperatorShapePreservingDensify.js";function Y(){return new r}class k{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(t,e,i){this.m_peR1=new h,this.m_peR2=new h,this.m_peR3=new h,void 0!==t?this.reset(t,e,i):this.reset(1,0,1)}reset(t,e,i){this.m_a=t,this.m_e2=e,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=i,this.m_unitToRad=.017453292519943295*i,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(t,e,i,s){const n=this.m_peR1,o=this.m_peR2,a=this.m_peR3;l.geodeticDistance(this.m_a,this.m_e2,t*this.m_unitToRad,e*this.m_unitToRad,i*this.m_unitToRad,s*this.m_unitToRad,a,n,o,0);const m=Math.cos(n.val),r=Math.cos(o.val+3.141592653589793),u=e*this.m_unitToRad,c=b.phiToEta(this.m_e2,u),h=Math.sin(n.val)*Math.cos(c);let _=e;if(m*r<0){const t=m<0?-1:1,e=Math.acos(Math.abs(h))*t;_=b.etaToPhi(this.m_e2,e)/this.m_unitToRad}let p=q((i-t)*this.m_unitToRad,2*Math.PI);Math.abs(p)>Math.PI&&(p=p>0?p-2*Math.PI:p+2*Math.PI),p/=this.m_unitToRad,i=t+p;const d=Y();return d.xmin=Math.min(t,i),d.xmax=Math.max(t,i),d.ymin=Math.min(e,s),d.ymin=Math.min(d.ymin,_),d.ymax=Math.max(e,s),d.ymax=Math.max(d.ymax,_),d}minDistanceGeodesic(t,e){const i=O(t),s=O(e);if(i&&s)return this.lowerDistanceGeodetic_(t.xmin,t.ymin,e.xmin,e.ymin);const n=this.normalizeGeodesic_(e,t);return U(t,n)?t.ymin>=n.ymax?this.minDistanceGeodesicUpDown_(t,n):n.ymin>=t.ymax?this.minDistanceGeodesicUpDown_(n,t):t.xmin>n.xmax?this.minDistanceGeodesicLeftRight_(n,t):this.minDistanceGeodesicLeftRight_(t,n):0}sqrMaxMinDistanceGeodesic(t,e){return n(0),0}maxDistanceGeodesic(t,e){return n(0),0}sqrMinDistance(t,e){return n(0),0}sqrMaxDistance(t,e){return n(0),0}sqrMaxMinDistance(t,e){return n(0),0}calculateMaxDim(t){return n(0),0}lowerDistanceGeodesic(t,e,i,s){return n(0),0}upperDistanceGeodesic(t,e,i,s){return n(0),0}normalizeGeodesic_(t,e){const i=t.clone(),s=t.clone();let n=V(i,e);if(0===n)return i;for(;s.xmax>e.xmin;){s.xmin-=this.m_u360,s.xmax-=this.m_u360;const t=V(s,e);if(t<n&&(i.assign(s),n=t,0===n))return i}for(s.assign(t);s.xmin<e.xmax;){s.xmin+=this.m_u360,s.xmax+=this.m_u360;const t=V(s,e);if(t<n&&(i.assign(s),n=t,0===n))return i}return i}lowerDistanceGeodetic_(t,e,i,s){const n=this.m_peR1;{const o=this.m_b*this.m_b/this.m_a,a=b.phiToPhig(this.m_e2,this.m_unitToRad*e),m=b.phiToPhig(this.m_e2,this.m_unitToRad*s);l.geodeticDistance(o,0,this.m_unitToRad*t,a,this.m_unitToRad*i,m,n,null,null,0)}return n.val}upperDistanceGeodetic_(t,e,i,s){return n(0),0}minDistanceGeodesicUpDown_(t,e){if(e.xmin<=t.xmin?e.xmax>=t.xmin:t.xmax>=e.xmin)return this.lowerDistanceGeodetic_(0,t.ymin,0,e.ymax);if(e.xmin>t.xmax){const i=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);if(e.xmax-t.xmin<this.m_u180)return i;const s=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);return Math.min(i,s)}{const i=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);if(t.xmax-e.xmin<this.m_u180)return i;const s=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);return Math.min(i,s)}}minDistanceGeodesicLeftRight_(t,e){let i=Math.abs(t.xmax-e.xmin);for(;i>this.m_u180;)i-=this.m_u360;let s=Math.abs(t.xmin-e.xmax);for(;s>this.m_u180;)s-=this.m_u360;return Math.abs(i)<=Math.abs(s)?this.minDistanceGeodesicLeftRightNormalized_(t,e):this.minDistanceGeodesicLeftRightNormalized_(e,t)}minDistanceGeodesicLeftRightNormalized_(t,e){let i,s;return i=this.lowerDistanceGeodetic_(t.xmax,t.ymin,e.xmin,e.ymin),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymin,e.xmin,e.ymin,e.ymax),i=Math.min(i,s)),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymin,t.xmax,t.ymin,t.ymax),i=Math.min(i,s)),s=this.lowerDistanceGeodetic_(t.xmax,t.ymax,e.xmin,e.ymax),i=Math.min(i,s),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymax,e.xmin,e.ymin,e.ymax),i=Math.min(i,s)),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(s=this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymax,t.xmax,t.ymin,t.ymax),i=Math.min(i,s)),i}normalizeDistance_(t){return n(0),0}lowerDistanceGeodeticSegMeridional_(t,e,i,s,n,o){let a=this.lowerDistanceGeodeticPtMeridional_(t,e,s,n,o);const m=this.lowerDistanceGeodeticPtMeridional_(t,i,s,n,o);let r=this.lowerDistanceGeodeticPtMeridional_(s,n,t,e,i);const u=this.lowerDistanceGeodeticPtMeridional_(s,o,t,e,i);return a=Math.min(a,m),r=Math.min(r,u),Math.min(a,r)}minDistanceGeodesicPointBox_(t,e,i){return n(0),0}lowerDistanceGeodeticPtMeridional_(t,e,i,s,n){const o=this.m_b*this.m_b/this.m_a,a=b.phiToPhig(this.m_e2,this.m_unitToRad*e),m=b.phiToPhig(this.m_e2,this.m_unitToRad*s),r=b.phiToPhig(this.m_e2,this.m_unitToRad*n),u=this.m_peR1,c=this.m_peR2;l.geodeticDistance(o,0,this.m_unitToRad*i,m,this.m_unitToRad*t,a,u,null,null,0),l.geodeticDistance(o,0,this.m_unitToRad*i,r,this.m_unitToRad*t,a,c,null,null,0);const h=_(1,0,new E(this.m_unitToRad*t,a)),d=_(1,0,new E(this.m_unitToRad*i,m)),g=_(1,0,new E(this.m_unitToRad*i,r));let x=new p;x.setCrossProductVector(d,g);const y=d.dotProduct(g);if(x.length()<1.568e-10)return y>=0?Math.min(u.val,c.val):0;x=x.getUnitVector();let P=new p;if(P.setCrossProductVector(x,h),P.length()<1.568e-10){return Math.min(u.val,c.val)-1e-5*o}P=P.getUnitVector();let S=h.sub(x.mul(h.dotProduct(x)));{const e=new p;e.setCrossProductVector(d,S);const i=new p;i.setCrossProductVector(S,g);let s=x.dotProduct(e)>0&&x.dotProduct(i)>0;if(s||(S.negateThis(),e.setCrossProductVector(d,S),i.setCrossProductVector(S,g),s=x.dotProduct(e)>0&&x.dotProduct(i)>0),s){S=S.getUnitVector();const e=w(1,0,S),i=this.m_peR3;l.geodeticDistance(o,0,this.m_unitToRad*t,a,e.x,e.y,i,null,null,0);const s=Math.min(u.val,c.val);return Math.min(s,i.val)}}return Math.min(u.val,c.val)}fixAngle(t){return n(0),0}moveCloser(t,e){return n(0),0}}function O(t){return t.xmin===t.xmax&&t.ymin===t.ymax}function U(t,e){return e.xmax<t.xmin||e.xmin>t.xmax||e.ymax<t.ymin||e.ymin>t.ymax}function V(t,e){let i,s=0;return i=t.xmin-e.xmax,i>s&&(s=i),i=e.xmin-t.xmax,i>s&&(s=i),s}class L{}function z(t){return{outPoint:void 0===t?new E:t.clone()}}function H(t,e){t.outPoint.assign(e.outPoint)}function j(){return new r}class K{constructor(t,e,i,s,n=0,o=4){this.m_ptDistFrom=new E,this.m_segStartPt=new E,this.m_segEndPt=new E,this.m_geodeticLength=new h,this.m_az12=new h,this.m_minGeodeticDist=new h,this.m_segStartPt3d=new p,this.m_segEndPt3d=new p,this.m_sr=s,this.m_distCurveType=n,this.m_segCurveType=o,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=2===this.m_sr.getCoordinateSystemType()&&this.m_sr.isPannable();const a=M();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.setPointDistFrom(t),this.setSegmentEndPoints(e,i)}setSegmentEndPoints(t,e){this.m_segStartPt.assign(t),this.m_segEndPt.assign(e),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),2===this.m_segCurveType&&(this.m_segStartPt3d.assign(_(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(_(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(t){this.m_ptDistFrom.assign(t),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(t){this.m_segCurveType=t}setDistanceCurveType(t){this.m_distCurveType=t}makeFunctor(){return i=>{let s;switch(this.m_segCurveType){case 0:case 1:case 3:{const o={stack:[],error:void 0,hasError:!1};try{const e=t(o,new h,!1),n=t(o,new h,!1);l.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*i,this.m_az12.val,e,n,this.m_segCurveType),s=new E(e.val,n.val);break}catch(n){o.error=n,o.hasError=!0}finally{e(o)}}case 2:{const t=p.lerp(this.m_segStartPt3d,this.m_segEndPt3d,i);s=w(this.m_a,this.m_eSquared,t);break}case 4:s=E.lerp(this.m_segStartPt,this.m_segEndPt,i),this.m_bIsPannablePcs&&(x(this.m_sr,0,[s],1),s.mulThis(this.m_rpu));break;default:o("Invalid curve type")}return l.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,s.x,s.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:l.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=E.distance(this.m_segStartPt,this.m_segEndPt);break;default:o("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}}function Q(){return new L}class J{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(t,e,i,s,n){this.m_boxGeomA=j(),this.m_boxGeomB=j(),this.m_envGeomA=new r,this.m_envGeomB=new r,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new R,this.m_scaleToDegrees=new R,this.m_inputSR=t,this.m_distCurveType=e,this.m_progressTracker=i,this.m_maxDistance=s,this.m_maxDeviation=n,this.m_inputGCS=t.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;const o=M();this.m_inputGCS.querySpheroidData(o),this.m_a=o.majorSemiAxis,this.m_eSquared=o.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new k(this.m_a,this.m_eSquared,1),4===this.m_distCurveType&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=2===this.m_inputSR.getCoordinateSystemType()&&this.m_inputSR.isPannable()}progress(t=!1){}calculate(t,e,i,s){const n=z(),o=z();if(t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(t,e,n,o))return i&&H(i,n),s&&H(s,o),0;const a=this.prepareGeometry(t);if(a.isEmpty())return Number.NaN;const m=this.prepareGeometry(e);if(m.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(a,m);const r=this._ExecuteBruteForce(a,m,n,o);return r>=this.m_maxDistance?Number.NaN:(i&&(this.prepareOutput(n),H(i,n)),s&&(this.prepareOutput(o),H(s,o)),r)}createDistanceFunctor(t,e,i){const s=new K(t,e,i,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||1===this.m_inputSR.getCoordinateSystemType()||s.setSegmentCurveType(2),s}_NormalizeAndProject(t){if(this.m_inputSR.isPannable()&&(t=(new u).foldInto360Range(t,this.m_inputSR)),2===this.m_inputSR.getCoordinateSystemType()){const e=c(this.m_inputSR,this.m_inputGCS,null);t=(new u).execute(t,e,this.m_progressTracker)}return t}_ExecuteBruteForce(t,e,n,o){switch(t.getGeometryType()){case s.enumPoint:return this.calculateDistanceGeodeticPointGeometry(t,e,n,o);case s.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(t,e,n,o);case s.enumPolyline:case s.enumPolygon:case s.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(t,e,n,o);default:i("")}}calculateDistanceGeodeticPointGeometry(t,e,n,o){switch(e.getGeometryType()){case s.enumPoint:return this.calculateDistanceGeodeticPointPoint(t,e,n,o);case s.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,n,o);case s.enumPolyline:case s.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(t,e,n,o);default:i("")}}calculateDistanceGeodeticPointPoint(i,s,n,o){const a={stack:[],error:void 0,hasError:!1};try{const e=i.getXY();e.scale(this.m_rpu);const m=s.getXY();m.scale(this.m_rpu),n.outPoint.assign(e),o.outPoint.assign(m);const r=t(a,new h,!1);return l.geodeticDistance(this.m_a,this.m_eSquared,e.x,e.y,m.x,m.y,r,null,null,this.m_distCurveType),r.val}catch(m){a.error=m,a.hasError=!0}finally{e(a)}}calculateDistanceGeodeticPointMultipoint(i,s,n,o){const a={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(i,s);const e=this.estimateMinimumDistance(n,o);let m=e<this.m_maxDistance?e:this.m_maxDistance;const r=i.getXY();r.scale(this.m_rpu),n.outPoint.assign(r);const u=_(this.m_a,this.m_eSquared,r),c=new E,d=s.getImpl(),g=t(a,new h,!1),x=d.getPointCount();for(let t=0;t<x;++t){d.queryXY(t,c),c.scale(this.m_rpu);const e=_(this.m_a,this.m_eSquared,c);if(!(p.distance(u,e)>m)&&(!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>m)&&(l.geodeticDistance(this.m_a,this.m_eSquared,r.x,r.y,c.x,c.y,g,null,null,this.m_distCurveType),g.val<m&&(m=g.val,o.outPoint=c,0===m))))return m}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(m){a.error=m,a.hasError=!0}finally{e(a)}}calculateDistanceGeodeticPointMultipath(i,s,o,a){const m={stack:[],error:void 0,hasError:!1};try{const e=new E,r=new E;e.assign(i.getXY()),r.assign(i.getXY()),o.outPoint.assign(r.mul(this.m_rpu)),this.m_bIsPannablePcs&&d(this.m_inputSR,[e],1,!1),this.computeEnvelopesAndBoxes(i,s);const u=this.estimateMinimumDistance(o,a);let c=u<this.m_maxDistance?u:this.m_maxDistance;const h=s.getImpl(),l=new E(0,0),_=new E(0,0),p=[1],g=this.canUseSpatialTree(i,s),x=Q();g&&this.buildSpatialTree(x,s);const y=j();y.setCoords({xmin:r.x,ymin:r.y,xmax:r.x,ymax:r.y});const P=t(m,this.createDistanceFunctor(r,l,_),!1),S=h.querySegmentIterator();if(S.stripAttributes(),g)n(0);else for(;S.nextPath();)for(;S.hasNextSegment();){const t=S.nextSegment(),i=this.findOrComputeBoxSegment(S.getStartPointIndex(),t,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(y,i)>c)continue;const s=this.calculateDistanceGeodeticPointSegment(e,r,t,p,P);if(s.second<c&&(this.updateOutputSegment(a,t,s.first),c=s.second,0===c))return 0}return c===this.m_maxDistance?Number.POSITIVE_INFINITY:c}catch(r){m.error=r,m.hasError=!0}finally{e(m)}}calculateDistanceGeodeticMultipointGeometry(t,e,n,o){switch(e.getGeometryType()){case s.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,o,n);case s.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(t,e,n,o);case s.enumPolyline:case s.enumPolygon:case s.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(t,e,n,o);default:i("")}}calculateDistanceGeodeticMultipointMultipoint(i,s,n,o){const a={stack:[],error:void 0,hasError:!1};try{const e=t(a,new h,!1);this.computeEnvelopesAndBoxes(i,s);const m=this.estimateMinimumDistance(n,o);let r=m<this.m_maxDistance?m:this.m_maxDistance;const u=new E,c=new E,d=i.getImpl(),g=s.getImpl(),x=j(),y=d.getPointCount(),P=g.getPointCount();for(let t=0;t<y;++t){if(u.assign(d.getXY(t)),x.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y}),this.m_envHelper.minDistanceGeodesic(x,this.m_boxGeomB)>r)continue;u.scale(this.m_rpu);const i=_(this.m_a,this.m_eSquared,u);for(let t=0;t<P;++t){c.assign(g.getXY(t)),c.scale(this.m_rpu);const s=_(this.m_a,this.m_eSquared,c);if(!(p.distance(i,s)>=r)&&(l.geodeticDistance(this.m_a,this.m_eSquared,u.x,u.y,c.x,c.y,e,null,null,this.m_distCurveType),e.val<r&&(n.outPoint.assign(u),o.outPoint.assign(c),r=e.val,0===r)))return r}}return r===this.m_maxDistance?Number.POSITIVE_INFINITY:r}catch(m){a.error=m,a.hasError=!0}finally{e(a)}}calculateDistanceGeodeticMultipointMultipath(i,s,o,a){const m={stack:[],error:void 0,hasError:!1};try{const e=s.getImpl().querySegmentIterator();e.stripAttributes(),this.computeEnvelopesAndBoxes(i,s);const r=this.estimateMinimumDistance(o,a);let u=r<this.m_maxDistance?r:this.m_maxDistance;const c=new E,h=new E(0,0),l=new E(0,0),_=new E(0,0),p=[0],g=j(),x=t(m,this.createDistanceFunctor(h,l,_),!1),y=Q(),P=this.canUseSpatialTree(i,s);P&&this.buildSpatialTree(y,s);const S=i.getPointCount();for(let t=0;t<S;++t)if(c.assign(i.getXY(t)),h.assign(i.getXY(t)),this.m_bIsPannablePcs&&d(this.m_inputSR,[c],1,!1),g.setCoords({xmin:h.x,ymin:h.y,xmax:h.x,ymax:h.y}),!(this.m_envHelper.minDistanceGeodesic(g,this.m_boxGeomB)>u))if(x.setPointDistFrom(h),P)n(0);else{for(;e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(this.m_envHelper.minDistanceGeodesic(g,this.findOrComputeBoxSegment(e.getStartPointIndex(),t,this.m_segmentBoxesB))>u)continue;const i=this.calculateDistanceGeodeticPointSegment(c,h,t,p,x);if(i.second<u&&(o.outPoint.assign(h.mul(this.m_rpu)),this.updateOutputSegment(a,t,i.first),u=i.second,0===u))return 0}e.resetToFirstPath()}return u===this.m_maxDistance?Number.POSITIVE_INFINITY:u}catch(r){m.error=r,m.hasError=!0}finally{e(m)}}calculateDistanceGeodeticMultipathGeometry(t,e,n,o){switch(e.getGeometryType()){case s.enumPoint:return this.calculateDistanceGeodeticPointMultipath(e,t,o,n);case s.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(e,t,o,n);case s.enumPolyline:case s.enumPolygon:case s.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(t,e,n,o);default:i("")}}calculateDistanceGeodeticMultipathMultipath(t,e,i,s){const n=[t],o=[e],a=this.swapGeometries(n,o),m=n[0],r=o[0];this.computeEnvelopesAndBoxes(n[0],o[0]);const u=this.estimateMinimumDistance(i,s),c=this.calculateDistanceGeodeticMultipathMultipath_(m,r,i,s,u);return a&&(s.outPoint=I(i.outPoint,i.outPoint=s.outPoint)),c}calculateDistanceGeodeticMultipathMultipath_(i,s,o,a,m=Number.MAX_VALUE){const r={stack:[],error:void 0,hasError:!1};try{let e=m;const u=new E(0,0),c=new E,h=new E(0,0),l=new E,_=new E(0,0),p=new E,d=new E,P=new E,S=[new E],D=[0],G=[0],f=j(),v=j(),T=t(r,this.createDistanceFunctor(_,u,h),!1),b=Q(),w=this.canUseSpatialTree(i,s);w&&this.buildSpatialTree(b,s);const M=s.querySegmentIterator();M.stripAttributes();const R=new g,I=A(i);for(let t=0;t<I.length;++t){const s=I[t];i.getSegmentBuffer(s,R,!0);const m=R.get();if(f.assign(this.findOrComputeBoxSegment(s,m,this.m_segmentBoxesA)),w)n(0);else{if(_.assign(m.getStartXY()),p.assign(m.getStartXY()),d.assign(m.getEndXY()),P.assign(m.getEndXY()),this.m_bIsPannablePcs&&(x(this.m_inputSR,0,[p],1),x(this.m_inputSR,0,[P],1)),this.m_envHelper.minDistanceGeodesic(f,this.m_boxGeomB)>e)continue;for(;M.nextPath();){for(;M.hasNextSegment();){const t=M.nextSegment();if(u.assign(t.getStartXY()),c.assign(t.getStartXY()),h.assign(t.getEndXY()),l.assign(t.getEndXY()),m.intersect(t,S,D,G,this.m_tolerance))return this.updateOutputSegment(o,m,D[0]),this.updateOutputSegment(a,t,G[0]),0;if(this.m_bIsPannablePcs&&(x(this.m_inputSR,0,[c],1),x(this.m_inputSR,0,[l],1)),v.assign(this.findOrComputeBoxPoint(M.getStartPointIndex(),c,l,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(f,v)>e)continue;T.setSegmentEndPoints(u,h),T.setPointDistFrom(p);let i=y(T.makeFunctor(),0,1,1e-10);if(i.second<e&&(o.outPoint.assign(p.mul(this.m_rpu)),this.updateOutputSegment(a,t,i.first),e=i.second,0===e))break;if(T.setPointDistFrom(P),i=y(T.makeFunctor(),0,1,1e-10),i.second<e&&(o.outPoint.assign(P.mul(this.m_rpu)),this.updateOutputSegment(a,t,i.first),e=i.second,0===e))break;if(T.setSegmentEndPoints(_,d),T.setPointDistFrom(c),i=y(T.makeFunctor(),0,1,1e-10),i.second<e&&(this.updateOutputSegment(o,m,i.first),a.outPoint.assign(c.mul(this.m_rpu)),e=i.second,0===e))break;if(T.setPointDistFrom(l),i=y(T.makeFunctor(),0,1,1e-10),i.second<e&&(this.updateOutputSegment(o,m,i.first),a.outPoint.assign(l.mul(this.m_rpu)),e=i.second,0===e))break}if(0===e)return 0}M.resetToFirstPath()}}return e===this.m_maxDistance?Number.POSITIVE_INFINITY:e}catch(u){r.error=u,r.hasError=!0}finally{e(r)}}calculateDistanceGeodeticPointSegment(t,e,i,s,n){const o=i.getStartXY(),a=i.getEndXY();return i.intersectPoint(t,s,this.m_tolerance)?C(s[0],0):(n.setPointDistFrom(e),n.setSegmentEndPoints(o,a),y(n.makeFunctor(),0,1,1e-10))}prepareGeometry(t){let e=t.clone();const i=t.getGeometryType();if(i===s.enumPoint||i===s.enumMultiPoint)return this._NormalizeAndProject(e);if(i===s.enumEnvelope&&(e=this.envelopeToPolygon(e)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(e,4);if(2===this.m_inputSR.getCoordinateSystemType()){if(e=P(e,this.m_inputSR,0,null),e.isEmpty())return e;e=(new X).execute(e,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);const t=this.m_inputSR.getSRToGCSTransform();return(new u).execute(e,t,this.m_progressTracker)}const n=new r;e.queryLooseEnvelope(n);const o=this.m_inputSR.getPannableExtent();if(n.ymin<o.ymin||n.ymax>o.ymax){const t=new r(n.xmin-1,o.ymin,n.xmax+1,o.ymax);if(e=(new S).execute(e,t,this.m_inputSR,this.m_progressTracker),e.isEmpty())return e}return n.width()>2*o.width()?(e=D(e,-2*o.width(),2*o.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker),e):e}prepareGeometryPannable(t,e){const i=new r;t.queryEnvelope(i);const s=this.m_inputSR.getPannableExtent();if(s.containsEnvelope(i))return t;const n=new B;s.queryIntervalX(n);const o=new B;return i.queryIntervalX(o),t=n.contains(o)?G(t,this.m_inputSR):(new u).foldInto360RangeGeodetic(t,this.m_inputSR,e)}prepareOutput(t){t.outPoint.scale(1/this.m_rpu),2===this.m_inputSR.getCoordinateSystemType()&&d(this.m_inputSR,[t.outPoint],1,!1)}updateOutputSegment(t,e,i){e.queryCoord2D(i,t.outPoint),this.m_bIsPannablePcs&&x(this.m_inputSR,0,[t.outPoint],1),t.outPoint.mulThis(this.m_rpu)}computeTolerance(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB);const i=new r(this.m_envGeomA);return i.mergeEnvelope2D(this.m_envGeomB),f(null,i)}envelopeToPolygon(t){const e=new v;return e.addEnvelope(t,!1),e}computeEnvelopesAndBoxes(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(t,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(e,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(t,e,i){switch(t.getGeometryType()){case s.enumPoint:return this.computeBoxPoint(t,e);case s.enumMultiPoint:return this.computeBoxMultiPoint(t,e);case s.enumPolyline:case s.enumPolygon:return this.computeBoxMultiPath(t,e,i);default:o("Invalid geometry type")}}computeBoxPoint(t,e){const i=t.getXY();e.length=1,e[0]=i.mul(this.m_rpu);const s=j();return s.setCoords({xmin:i.x,ymin:i.y,xmax:i.x,ymax:i.y}),s}computeBoxSegment(t){return n(0),{}}computeBoxMultiPoint(t,e){let i=!0;for(let n=0;n<t.getPointCount();++n){const s=t.getXY(n);if(i){e.length=4;for(let t=0;t<e.length;++t)e[t]=s.clone();i=!1}s.x<e[0].x&&e[0].assign(s),s.y>e[1].y&&e[1].assign(s),s.x>e[2].x&&e[2].assign(s),s.y<e[3].y&&e[3].assign(s)}for(let n=0;n<e.length;++n)e[n].mulThis(this.m_rpu);const s=j();return t.queryEnvelope(s),s}computeBoxMultiPath(t,e,i){let s=!0;const n=j();n.setEmpty();const o=t.querySegmentIterator();for(o.stripAttributes();o.nextPath();)for(;o.hasNextSegment();){const t=o.nextSegment(),a=t.getStartXY(),m=t.getEndXY();if(this.m_bIsPannablePcs&&(x(this.m_inputSR,0,[a],1),x(this.m_inputSR,0,[m],1)),s){e.length=4;for(let t=0;t<e.length;++t)e[t]=a.clone();s=!1}a.x<e[0].x&&e[0].assign(a),a.y>e[1].y&&e[1].assign(a),a.x>e[2].x&&e[2].assign(a),a.y<e[3].y&&e[3].assign(a),m.x<e[0].x&&e[0].assign(m),m.y>e[1].y&&e[1].assign(m),m.x>e[2].x&&e[2].assign(m),m.y<e[3].y&&e[3].assign(m);const r=this.findOrComputeBoxPoint(o.getStartPointIndex(),a,m,i);n.mergeEnvelope2D(r)}for(let a=0;a<e.length;++a)e[a].mulThis(this.m_rpu);return n}findOrComputeBoxSegment(t,e,i){if(!i.has(t)){let s=j();if(e.queryEnvelope(s),this.m_bIsPannablePcs){const t=E.construct(s.xmin,s.ymin),e=E.construct(s.xmax,s.ymax);x(this.m_inputSR,0,[t],1),x(this.m_inputSR,0,[e],1),s=this.m_envHelper.calculateBbox(t.x,t.y,e.x,e.y)}return i.set(t,s),s}return i.get(t)}findOrComputeBoxPoint(t,e,i,s){if(!s.has(t)){let n=j();return n.setCoords({xmin:e.x,ymin:e.y,xmax:i.x,ymax:i.y}),this.m_bIsPannablePcs&&(n=this.m_envHelper.calculateBbox(n.xmin,n.ymin,n.xmax,n.ymax)),s.set(t,n),n}return s.get(t)}checkPointInPolygon(t,e){return n(0),!1}estimateMinimumDistance(i,s){const n={stack:[],error:void 0,hasError:!1};try{const e=t=>_(this.m_a,this.m_eSquared,t),o=this.m_boundaryPtsA.map(e),a=this.m_boundaryPtsB.map(e);let m=Number.MAX_VALUE,r=0,u=0;for(let t=0;t<o.length;++t)for(let e=0;e<a.length;++e){const i=p.distance(o[t],a[e]);i<m&&(m=i,r=t,u=e)}i.outPoint.assign(this.m_boundaryPtsA[r]),s.outPoint.assign(this.m_boundaryPtsB[u]);const c=t(n,new h,!1);return l.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[r].x,this.m_boundaryPtsA[r].y,this.m_boundaryPtsB[u].x,this.m_boundaryPtsB[u].y,c,null,null,this.m_distCurveType),c.val}catch(o){n.error=o,n.hasError=!0}finally{e(n)}}swapGeometries(t,e){return a(t[0])>a(e[0])&&(e[0]=I(t[0],t[0]=e[0]),this.m_envGeomB=I(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(t,e){return!1}checkGeometriesIntersect(t,e,i,n){let o=t.getGeometryType(),a=e.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(o===s.enumPoint&&2===e.getDimension()){const s=[0],o=[t.getXY()];if(T(e,o,1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(o[0]),n.outPoint.assign(o[0]),!0}else if(a===s.enumPoint&&2===t.getDimension()){const s=[2],o=[e.getXY()];if(T(t,o,1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(o[0]),n.outPoint.assign(o[0]),!0}if(o===s.enumMultiPoint&&2===e.getDimension())return this.multipointIntersectsArea(t,e,i,n);if(a===s.enumMultiPoint&&2===t.getDimension())return this.multipointIntersectsArea(e,t,n,i);let r,u,c=t,h=e;if(o===s.enumEnvelope&&(r=this.envelopeToPolygon(t),c=r,o=s.enumPolygon),a===s.enumEnvelope&&(u=this.envelopeToPolygon(e),h=u,a=s.enumPolygon),m(o)&&m(a)){const t=c.querySegmentIterator(),e=h.querySegmentIterator(),s=F(),o=F();if(N(c,h,t,e,s,o))return i.outPoint.assign(s.outPoint),n.outPoint.assign(s.outPoint),!0}}return!1}multipointIntersectsArea(t,e,i,s){const n=t.getPointCount();for(let o=0;o<n;++o){const n=[2],a=t.getXY(o);if(T(e,[a],1,this.m_tolerance,n),0!==n[0])return i.outPoint.assign(a),s.outPoint.assign(a),!0}return!1}getNearestNeighbourVisitor(t,e,i,s,o,a,m){return n(0),{}}buildSpatialTree(t,e){n(0)}}export{J as G,K as a,z as m};
