/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{invert as e,translate as i}from"../core/libs/gl-matrix-2/math/mat4.js";import{create as t}from"../core/libs/gl-matrix-2/factories/mat4f64.js";import{n as o,t as r}from"./vec32.js";import{create as a}from"../core/libs/gl-matrix-2/factories/vec3f64.js";import{NormalFromDepth as h}from"../views/3d/webgl-engine/core/shaderLibrary/NormalFromDepth.glsl.js";import{ScreenSpacePass as l}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{ReadShadowMapPass as s}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{RgbaFloatEncoding as n}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{Float3PassUniform as d}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as g}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as c}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as p}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{Matrix4PassUniform as w}from"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js";import{ShaderBuilder as m}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as u}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{SnapshotSlot as f}from"../views/3d/webgl-engine/lib/ShadowMap.js";import{ReadShadowMapConfiguration as v}from"../views/3d/webgl-engine/shaders/ReadShadowMapConfiguration.js";const x=.025;function b(){const t=new m;t.include(s,y),t.include(l),t.include(h);const a=t.fragment;return a.include(n),a.uniforms.add(new u("defaultDepthTex",((e,i)=>i.shadowMap.getSnapshot(f.ExcludeHighlight))),new u("highlightDepthTex",((e,i)=>i.shadowMap.getSnapshot(f.Highlight))),new u("depthMap",((e,i)=>i.depth?.attachment)),new u("highlightTexture",(e=>e.highlight)),new g("uColor",(e=>e.shadowColor)),new c("opacity",(e=>e.shadowOpacity)),new c("occludedOpacity",(e=>e.occludedShadowOpacity)),new c("terminationFactor",(e=>e.opacityElevation*e.dayNightTerminator)),new d("lightingMainDirectionView",((e,i)=>o(S,r(S,i.lighting.mainLight.direction,i.camera.viewInverseTransposeMatrix)))),new w("inverseViewMatrix",((t,o)=>e(M,i(M,o.camera.viewMatrix,o.camera.center))))).main.add(p`
    ivec2 highlightTextureSize = textureSize(highlightTexture, 0);
    ivec2 highlightIUV = ivec2(uv * vec2(highlightTextureSize));
    vec4 highlightInfo = texelFetch(highlightTexture, highlightIUV, 0);

    fragColor = vec4(0.0);

    // Calculate bit mask to check if pixel is highlit unoccluded at any level
    int ored =
         (int(highlightInfo.r*255.0) << 0)
       | (int(highlightInfo.g*255.0) << 8)
       | (int(highlightInfo.b*255.0) << 16)
       | (int(highlightInfo.a*255.0) << 24);
    bool visiblyHighlighted = ((ored & ~(ored >> 1)) & (1+4+16+64)) != 0;
    if (visiblyHighlighted) {
      return;
    }

    // 1.0 is the clear value of depthMap, which means nothing has been drawn there and we should discard
    float depth = depthFromTexture(depthMap, uv);
    if (depth >= 1.0 || depth <= 0.0) {
      return;
    }

    float currentPixelDepth = linearizeDepth(depth);
    vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
    vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;

    mat4 shadowMatrix;
    float linearDepth = -currentPixelDepth;
    int i = chooseCascade(linearDepth, shadowMatrix);
    if (i >= numCascades) {
      return;
    }

    // vertex completely outside? -> no shadow
    vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);
    if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
      return;
    }

    ivec2 texSize = textureSize(highlightDepthTex, 0);
    ivec2 uvShadow = ivec2(cascadeCoordinates(i, texSize, lvpos) * vec2(texSize));

    float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);
    bool shadowHighlight = depthHighlight < lvpos.z;
    if (!shadowHighlight) {
      return;
    }

    float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);
    bool shadowDefault = depthDefault < lvpos.z;

    vec3 normal = normalFromDepth(depthMap, currentPixelPos.xyz, gl_FragCoord.xy, uv);
    bool shaded = dot(normal, lightingMainDirectionView) < ${p.float(x)};

    float fragOpacity = (shadowDefault || shaded) ? occludedOpacity : opacity;
    fragColor = vec4(uColor.rgb, uColor.a * fragOpacity * terminationFactor);
  `),t}const M=t(),S=a(),y=new v,D=Object.freeze(Object.defineProperty({__proto__:null,build:b},Symbol.toStringTag,{value:"Module"}));export{D as S,b};
