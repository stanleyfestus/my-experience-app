/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{ForwardLinearDepth as e}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{ShaderOutput as r}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as i}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as o}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ObjectAndLayerIdColor as a}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js";import{OutputHighlight as t}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{EvaluateAmbientLighting as n}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js";import{addMainLightDirection as s,addMainLightIntensity as l}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{NormalUtils as d}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{PBRMode as g}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapDraw as v}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as m}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{Water as c}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl.js";import{WaterDistortion as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl.js";import{alphaCutoff as u}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js";import{ColorConversion as w}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{addProjViewLocalOrigin as h,addCameraPosition as f}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float4PassUniform as b}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as y}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as j}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as L}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{VertexAttribute as C}from"../views/3d/webgl-engine/lib/VertexAttribute.js";import{outputColorHighlightOID as P}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";function O(O){const x=new L,{vertex:D,fragment:S}=x;h(D,O),x.include(o,O),x.attributes.add(C.POSITION,"vec3"),x.attributes.add(C.UV0,"vec2");const M=new b("waterColor",(e=>e.color));if(O.output===r.Color&&O.draped)return x.varyings.add("vpos","vec3"),D.uniforms.add(M),D.main.add(j`
      if (waterColor.a < ${j.float(u)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }

      vpos = position;
      gl_Position = transformPosition(proj, view, vpos);`),S.uniforms.add(M),S.main.add(j`fragColor = waterColor;`),x;switch(O.output===r.Color&&(x.include(d,O),x.include(e,O),x.varyings.add("vuv","vec2"),x.varyings.add("vpos","vec3"),x.varyings.add("vnormal","vec3"),x.varyings.add("vtbnMatrix","mat3"),O.terrainDepthTest&&x.varyings.add("depth","float"),D.uniforms.add(M),D.main.add(j`
      if (waterColor.a < ${j.float(u)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }

      vuv = uv0;
      vpos = position;

      vnormal = getLocalUp(vpos, localOrigin);
      vtbnMatrix = getTBNMatrix(vnormal);

      ${O.terrainDepthTest?"depth = (view * vec4(vpos, 1.0)).z;":""}

      gl_Position = transformPosition(proj, view, vpos);
      ${O.output===r.Color?"forwardLinearDepth();":""}`)),x.include(m,O),O.output){case r.Color:x.include(n,{pbrMode:g.Disabled,lightingSphericalHarmonicsOrder:2}),x.include(p),x.include(v,O),x.include(c,O),x.include(i,O),x.include(P,O),S.uniforms.add(M,new y("timeElapsed",(e=>e.timeElapsed)),D.uniforms.get("view"),D.uniforms.get("localOrigin")),f(S,O),S.include(w),s(S),l(S),S.main.add(j`
        discardBySlice(vpos);
        ${O.terrainDepthTest?"terrainDepthTest(depth);":""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - cameraPosition);
        float shadow = ${O.receiveShadows?j`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view * vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, mainLightDirection, waterColor.rgb, mainLightIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);

        // gamma correction
        fragColor = delinearizeGamma(final);
        outputColorHighlightOID(fragColor, vpos);`);break;case r.Normal:x.include(d,O),x.include(p,O),x.include(i,O),x.varyings.add("vpos","vec3"),x.varyings.add("vuv","vec2"),D.uniforms.add(M),D.main.add(j`
        if (waterColor.a < ${j.float(u)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        gl_Position = transformPosition(proj, view, vpos);`),S.uniforms.add(new y("timeElapsed",(e=>e.timeElapsed))),S.main.add(j`discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
fragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);`);break;case r.Highlight:x.include(t,O),x.varyings.add("vpos","vec3"),D.uniforms.add(M),D.main.add(j`
        if (waterColor.a < ${j.float(u)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);`),x.include(i,O),S.main.add(j`discardBySlice(vpos);
calculateOcclusionAndOutputHighlight();`);break;case r.ObjectAndLayerIdColor:x.include(a,O),x.varyings.add("vpos","vec3"),D.uniforms.add(M),D.main.add(j`
        if (waterColor.a < ${j.float(u)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
        forwardObjectAndLayerIdColor();`),x.include(i,O),S.main.add(j`discardBySlice(vpos);
outputObjectAndLayerIdColor();`)}return x}const x=Object.freeze(Object.defineProperty({__proto__:null,build:O},Symbol.toStringTag,{value:"Module"}));export{x as W,O as b};
