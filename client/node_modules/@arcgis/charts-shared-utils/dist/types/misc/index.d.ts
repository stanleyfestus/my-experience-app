import type { IField, WebChartStackedKinds, WebChartSeries, WebChart, WebChartDataItem, WebChartDataItemValue, LegendItemVisibility, WebMapWebChart, WebBoxPlot } from "@arcgis/charts-spec";
import { WebChartTypes, WebChartTimeIntervalUnits, OverlayTerms, WebChartSortOrderKinds } from "@arcgis/charts-spec";
import type { ChartElementLimit } from "../defaults/interfaces";
import { ChartSubType } from "./interfaces";
type WebChartType = typeof WebChartTypes.BarSeries | typeof WebChartTypes.BoxPlotSeries | typeof WebChartTypes.ComboLineAndBarSeries | typeof WebChartTypes.GaugeSeries | typeof WebChartTypes.HistogramSeries | typeof WebChartTypes.LineSeries | typeof WebChartTypes.PieSeries | typeof WebChartTypes.RadarSeries | typeof WebChartTypes.ScatterSeries;
type XYChartType = typeof WebChartTypes.BarSeries | typeof WebChartTypes.BoxPlotSeries | typeof WebChartTypes.ComboLineAndBarSeries | typeof WebChartTypes.HistogramSeries | typeof WebChartTypes.LineSeries | typeof WebChartTypes.RadarSeries | typeof WebChartTypes.ScatterSeries;
type SupportedChartType = typeof WebChartTypes.BarSeries | typeof WebChartTypes.BoxPlotSeries | typeof WebChartTypes.HistogramSeries | typeof WebChartTypes.LineSeries | typeof WebChartTypes.PieSeries | typeof WebChartTypes.RadarSeries | typeof WebChartTypes.ScatterSeries;
export type ChartTypes = Extract<WebChartTypes, WebChartType>;
export type XYChartTypes = Extract<WebChartTypes, XYChartType>;
export type SupportedCharts = Extract<ChartTypes, SupportedChartType>;
/**
 * Returns the color policy for the chart.  If it's not defined, `WebChartColoringPatterns.Single` will be used.
 * @param chartConfig the chart config.
 * @returns the color policy.
 */
export declare function getColorMatch(chartConfig?: WebMapWebChart): boolean;
/**
 * Getting the type of a chart or series. If the input parameters are incorrect (empty array of series, or a mix of unknown/unallowed series types) the function returns `undefined`.
 * To get the series type, a valid seriesIndex is required. Otherwise, the type of a chart is determined and returned.
 * @param chartSeries The array of chart's series
 * @param seriesIndex An index to get a specific series' type.  A valid index is required if the goal is to get the type of the series.
 */
export declare function getChartOrSeriesType(chartSeries: WebChartSeries[] | undefined, seriesIndex?: number): ChartTypes | undefined;
/**
 * Indicates whether or not the chart is rotated.
 * @param chartConfig the chart config.
 * @returns
 */
export declare function isChartRotated(chartConfig?: WebMapWebChart): boolean;
/**
 * Getting the list of series types from a series config array.
 * @param chartSeries The array of chart's series
 */
export declare function getSeriesTypes(chartSeries?: WebChartSeries[]): ChartTypes[];
/**
 * Returns the type of stacking (side-by-side, stacked...) to be used to display the chart.
 * For Line, Bar, Box-plot, and Radar chart, default option is 'sideBySide'
 * @param series
 */
export declare function getStackedType(config?: WebChart | WebMapWebChart): WebChartStackedKinds | undefined;
/**
 * Escapes any single quote in the input string with a single quote for SQL.
 * For example: Cote d'Ivoire -> Cote d''Ivoire
 * @param string input string to replace for any special characters.
 */
export declare function escapeSQLString(string: string): string;
/**
 * Normalizes a string by
 *   - trimming off white spaces
 *   - if the value is a string and keepSurroundingQuotes is not true: stripping ' (single inverted comma), if present on both sides
 *   - if escape is true (or undefined): escaping special characters like ", \, /.
 * E.g.:
 * "'alpha'" => "alpha"
 * "'alpha" => No change
 * "alpha'" => No change
 * "alp'ha'" => alp''ha
 * "  'alpha'" => "alpha"
 * "alp"\/ha" => "alp\"\\\/ha"
 * @param props.value The string to normalize
 * @param props.keepSurroundingQuotes Whether to keep the surrounding quotes; default is false
 * @param props.escape Whether to escape special characters; default is true
 */
export declare function normalizeString(props: {
    value: string;
    keepSurroundingQuotes?: boolean;
    escape?: boolean;
}): string;
/**
 * Indicates whether a bar, line or pie chart respects the number limit of elements (bars, markers or slices).
 * For bar chart, different limits are set according to the number of series.
 * For line chart, a limit on the number of series and the total number of markers are set.
 * For pie chart, a limit on the number of slices is set.
 * @param props.count Number total of elements on the chart
 * @param props.seriesCount Number of series on the chart
 * @param props.seriesType The series type
 * @param props.chartLimits The runtime chart limits
 */
export declare function isNumberOfElementsUnderLimit(props: {
    count: number;
    seriesCount: number;
    chartType?: WebChartTypes;
    chartLimits?: ChartElementLimit;
}): boolean;
/**
 * Returns the alias for the field name if it exists; otherwise return the field name itself.
 * @param fieldName The field name to look for in the field array
 * @param fields The list of fields containing all the information regarding the fields, including the alias
 */
export declare function getFieldAlias(fields: IField[] | undefined, fieldName: string): string;
/**
 * Return the field name for the field alias if it exists; otherwise return the field alias itself.
 * @param fieldAlias The field alias to look for in the field array
 * @param fields The list of fields containing all the information regarding the fields, including the alias
 */
export declare function getFieldNameFromFieldAlias(fields: IField[] | undefined, fieldAlias: string): string;
/**
 * Decides whether we can show the legend or not. If it returns `false`, then we should not show the legend even if `legend.visible` is `true`.
 * For Pie charts, hide the legend when there is only one slice.
 * @param chartSeries
 */
export declare function canShowLegend(chartSeries: WebChartSeries[]): boolean;
/**
 * Based on a provided list of supported chart types, this function returns a boolean indicating if the config
 * contains supported series. An extra test is done for the scatter plot, pie, and histogram series.
 * @param supportedChartTypes The list of supported chart types
 * @param config The chart's config
 */
export declare function isSupportedChart(supportedChartTypes: WebChartTypes[], config?: WebChart | WebMapWebChart): boolean;
/**
 * Indicates whether a string field is empty (different from undefined, null and empty string).
 * The value is stringified before being trimmed to debunk edge cases like when the value is a numeric value.
 * @param value The value to test
 * @returns `true` if empty, `false` otherwise
 */
export declare function isEmptyStringField(value: string | null | undefined): boolean;
/**
 * Indicates whether an object contains a property key from list of properties.
 * @param data the object to look into
 * @param propertyList the array of property keys to search the data if one of them is present.
 * @returns An object containing a boolean indicating the propertyList presence, and the property key that matched
 */
export declare function isPropertyKeyInData<T extends WebChartDataItem>(data: T, propertyList: string[]): {
    isInItem: boolean;
    expr?: string;
};
/**
 * Indicates whether an object contains the result of a calculated expression coming from a
 * query (similar to "EXPR_1").
 * @param dataItem the object to look into
 * @returns An object containing a boolean indicating the expression's presence, and the expression key that matched
 */
export declare function isQueryCalculatedExprInItem(dataItem: WebChartDataItem): {
    isInItem: boolean;
    expr?: string;
};
/**
 * Finds localized string for the given `WebChartTimeIntervalUnits` unit type.
 * @param unit
 * @param strings
 * @returns Localized unit type label
 */
export declare function getTimeIntervalUnitLabel(unit: WebChartTimeIntervalUnits, strings: {
    seconds: string;
    minutes: string;
    hours: string;
    days: string;
    weeks: string;
    months: string;
    years: string;
}): string;
/**
 * Returns the appropriate `index` to fetch the default color from `overlayRamp[]` array for a histogram overlay
 * @param overlayType
 */
export declare function getOverlayColorIndex(overlayType: OverlayTerms | undefined): number;
/**
 * Assigns visible property to a series or an overlay
 * @param props.config The config that gets updated for each series visibility
 * @param props.event The event that is currently being called
 */
export declare function updateSeriesVisibility(event: CustomEvent<LegendItemVisibility>, config?: WebBoxPlot | WebChart | WebMapWebChart): void;
/**
 * Sanitize an HTML string to prevent XSS attacks (https://owasp.org/www-community/attacks/xss/)
 * @param inputToSanitize The HTML string to sanitize
 */
export declare function sanitizeHTMLOutput(inputToSanitize: string): string;
/** .
 * Indicates if a provided number value is valid.
 * An invalid value is: undefined | NaN | Infinite | -Infinite | null
 * See for more details:
 *   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite
 *   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
 */
export declare function isValidNumber(value: WebChartDataItemValue): boolean;
/**
 * Updates the chart rotation for a given WebChart config.
 * Returns the updated config.
 * @param newRotation new rotation
 * @param config the chart config
 */
export declare function updateRotation<T extends WebBoxPlot | WebChart | WebMapWebChart>(newRotation: boolean, config?: T): T | undefined;
/**
 * Gets the sorting field or (sorting type for box-plot) and orderBy from an input string.
 * @param stringToParse The input string to parse, like `orderByField` of a query clause or `orderDataBy` property of a chart config.
 * @param useDefault If set to `false`, the default sort order will not be used.
 * @returns
 */
export declare function getOrderByComponents(stringToParse: string, useDefault?: boolean): {
    fieldToSort: string;
    orderBy?: WebChartSortOrderKinds;
};
/**
 * Determines if certain chart subtype is a split by chart.
 * @param chartSubType The chart subtype
 * @returns true if the chart subtype is a split by chart, false otherwise
 */
export declare function isSplitByChart(chartSubType: ChartSubType): boolean;
export {};
