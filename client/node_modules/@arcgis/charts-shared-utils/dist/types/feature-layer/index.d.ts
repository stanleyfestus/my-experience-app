import type { IFeatureLayer, IField, WebChart, WebChartDataFilters, WebChartQuery, WebChartSeriesType, SupportedLayer } from "@arcgis/charts-spec";
import { WebChartTypes } from "@arcgis/charts-spec";
import type FeatureLayer from "@arcgis/core/layers/FeatureLayer";
import type FeatureLayerView from "@arcgis/core/views/layers/FeatureLayerView";
import type Renderer from "@arcgis/core/renderers/Renderer";
import type { QueryObjectProps, RendererInfo, SubtypeInfo } from "./interfaces";
import { ChartSubType } from "../misc/interfaces";
import type SubtypeGroupLayer from "@arcgis/core/layers/SubtypeGroupLayer";
import type SubtypeSublayer from "@arcgis/core/layers/support/SubtypeSublayer";
export type QueryObject = FeatureLayerView | SupportedLayer | undefined;
/**
 * Returns the renderer type and the field and normalization field if applicable.
 * @param layerRenderer
 */
export declare function getRendererInfo(layerRenderer?: Renderer): RendererInfo;
/**
 * Function creating a FeatureLayer from a set of parameters.
 * It returns the created Feature Layer.
 * It is memoized (cached) to avoid multiple requests for a same feature layer.
 */
export declare const getFeatureLayer: (featureLayer: IFeatureLayer) => Promise<FeatureLayer>;
/**
 * Indicates whether the input object is an instance of `FeatureLayerView`.
 * @param queryObject
 */
export declare function isFeatureLayerView(queryObject: QueryObject): queryObject is FeatureLayerView;
/**
 * Indicates whether the input object is an instance of `FeatureLayer`.
 * @param queryObject
 */
export declare function isFeatureLayer(queryObject: QueryObject): queryObject is FeatureLayer;
/**
 * Indicates whether the input object is an instance of `SubtypeGroupLayer`.
 * @param queryObject
 */
export declare function isSubtypeGroupLayer(queryObject: QueryObject | SubtypeGroupLayer): queryObject is SubtypeGroupLayer;
/**
 * Indicates whether the input object is an instance of `SubtypeSublayer`.
 * @param queryObject
 */
export declare function isSubtypeSublayer(queryObject: QueryObject): queryObject is SubtypeSublayer;
/**
 * Returns a feature layer from a QueryObject instance.
 * It will use the QueryObject itself if it's a Feature Layer, or the `layer` property from it if it's a Feature Layer View.
 * @param queryObject
 */
export declare function getLayerFromQueryObject(queryObject: QueryObject): SupportedLayer;
/**
 * Returns the proper query object to use according to the situation.
 * If can return either a FeatureLayer or a FeatureLayerView (and possibly nothing)
 * @param props
 */
export declare function getQueryObject(props: QueryObjectProps): Promise<QueryObject>;
/**
 * Returns the main `Layer` instance associated with the layer being used.
 *
 * Only needed for the case where the layer is a `SubtypeSublayer`, in which case we use the parent layer which is a `SubtypeGroupLayer`.
 *
 * @param layer
 */
export declare function getMainLayer(layer: SupportedLayer): FeatureLayer | SubtypeGroupLayer;
export declare function getMainLayer(layer: SupportedLayer | undefined): FeatureLayer | SubtypeGroupLayer | undefined;
/**
 * Fetches all the fields info a feature layer.
 * @param queryObject
 * @param usePopupTemplateFieldsInfo whether to use the aliases from the popupTemplate
 */
export declare function fetchLayerFieldsInfo(queryObject: QueryObject, usePopupTemplateFieldsInfo?: boolean): Promise<IField[]>;
/**
 * Looks into a list of fields for one having a specific name, and returning it if found.
 * Returns nothing if the field is not found.
 * @param fields The list of fields containing all the information regarding the fields, including the name
 */
export declare function getFieldFromName(fieldName: string, fields?: IField[]): IField | undefined;
/**
 * Look for an OID field among a list of feature layer fields.
 * The function `find` used can return in theory an `undefined` value, but in our case we're sure to bring back
 * the field ID (every feature layer has one).
 * As a consequence the backup value returned if `oidField.name` is `undefined` doesn't matter because it will not happen.
 */
export declare function getObjectIdField(layerFieldsInfo: IField[]): string;
/**
 * Checks whether the given field has a valid numeric type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isNumericField(field: IField): boolean;
/**
 * Checks whether the given field has a valid date type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isDateField(field: IField): boolean;
/**
 * Checks whether the given field has a valid integer type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isIntegerField(field: IField): boolean;
/**
 * Returns list of date field names from an array of fields of type IField
 * @param fieldsInfo
 */
export declare function getLayerDateFields(fieldsInfo: IField[]): string[];
/**
 * Returns list of numeric field names from an array of fields of type IField
 * @param fieldsInfo
 */
export declare function getLayerNumericFields(fieldsInfo: IField[]): string[];
/**
 * Extract the field name from equality-where clauses like `field = 'some_value'`.
 * This field is actually stored in each series where clause.
 * TODO: do we want to enforce the test by seeing if the extracted field is part of the feature layer list of fields?
 * E.g.:
 * "field = 'some_value'" => "field"
 * "field > 'some_value'" => ""
 * @param where the where clause to extract the field from
 * @param normalize whether to normalize the extracted field; by default it's true
 */
export declare function getSplitByField(where: string | undefined, normalize?: boolean): string;
/**
 * Extract the value from equality-where clauses like `field = 'some_value'`.
 * Optionally normalize or escape single quotes in the returned value according to the `normalize` param value.
 * If normalize is undefined then normalize the returned value.
 * For string value, if normalize is set to false and escape is set to false or undefined, the value is returned as is.
 * @param props.where the where clause to extract the value from
 * @param props.normalize whether to normalize the extracted value; default is true
 * @param props.keepSurroundingQuotes whether to keep the surrounding quotes; default is false
 * @param props.escape whether to escape the extracted value; default is false
 */
export declare function getSplitByValue(props: {
    where: string | undefined;
    normalize?: boolean;
    keepSurroundingQuotes?: boolean;
    escape?: boolean;
}): number | string | null;
/**
 * Normalizes a where clause, by escaping the "'" character and other special characters if needed.
 * Ex:
 *   - where = "field = 5" => returns "field = 5"
 *   - where = "field = 'value'" => returns "field = 'value'"
 *   - where = "field = 'va'lue'" => returns "field = 'va''lue'"
 * @param props.where the where clause to normalize
 * @param props.normalize whether to normalize the where clause
 * @param props.escape whether to escape the where clause
 */
export declare function normalizeWhereClause(props: {
    where: string;
    normalize?: boolean;
    escape?: boolean;
}): string;
/**
 * Detects a where clause being always true, as in 1=1, 2 = 2, 'some_value'='some_value'
 * @param where
 */
export declare function isAbsoluteTruthWhereClause(where?: string): boolean;
/**
 * Gets the query type for box plot chart.
 * @param seriesConfig the box plot series config
 */
export declare function getBoxPlotChartSubType(seriesConfig: WebChartSeriesType[]): ChartSubType;
/**
 * Returns the type of query we're dealing with. The actual values are:
 * a. Simple (0): single query using an aggregation
 * b. NoAggregation (1): single or multiple queries not using any aggregation
 * c. SplitByFieldValues (2): multiple queries using a specific field as a split-by
 * d. SplitByNumericalFields (3): multiple queries using multiple numerical fields as a split-by
 * e. PieFromFields (4): single query using more than one statistics fields
 * f. For Box-plot: one of the 7 combinations.
 * @param series The config series. Refrain from using `[firstSeries]` in place of `config.series` to avoid incorrect result,
 * especially for box-plot, bar and line charts.
 */
export declare function getChartSubType(series?: WebChartSeriesType[]): ChartSubType;
/**
 * Retrieve subtype information from the query object.
 * @param queryObject The query object from which to retrieve the feature layer.
 * @returns subtype info like typeIdField and the subtypes, if defined; otherwise undefined.
 * //TODO: may need to revise regrading the typeIdField property (See https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/42555)
 */
export declare function getLayerSubtypeInfo(queryObject: QueryObject): SubtypeInfo | undefined;
/**
 * Get the field description if the field contains subtype or domain value.
 * This field description is mainly for displaying purpose (while its id is used in queries).
 * @param props.fieldName the name of the field
 * @param props.fieldValueToMatch the value to search for a match in the subtypes or domains; if the field contains subtype or domain it's likely the id.
 * @param props.subtypeInfo the subtype information, which includes typeIdField and types.
 * @param props.fieldList the list of fields
 * @returns The field description if available; otherwise undefined.
 */
export declare function getFieldDescription(props: {
    fieldName: string;
    fieldValueToMatch: number | string;
    subtypeInfo?: SubtypeInfo;
    fieldList?: IField[];
}): string | undefined;
/**
 * Returns feature layer field names used in its renderer.
 * @param {FeatureLayer} layer
 * @returns {Promise<string[]>}
 */
export declare function getRendererFieldNames(layer: SupportedLayer): Promise<string[]>;
/**
 * Returns a boolean to indicate if the feature layer is on standard feature data store or not.
 * https://doc.arcgis.com/en/arcgis-online/reference/faq.htm#anchor7
 * @param {FeatureLayer} layer
 * @returns {Promise<boolean>}
 */
export declare function isStandardLayer(layer: SupportedLayer): Promise<boolean>;
/**
 * Indicates whether the bar or line series is configured to use time binning.
 * @param props.seriesConfig The series configuration
 * @param props.xAxisValueFormatType The x-axis value format type
 * @param props.setTimeBinningInfoWhenNotProvided Boolean indicating whether we want to set the time binning info when not provided
 */
export declare function isSeriesUsingTimeBinning(props: {
    seriesConfig: WebChartSeriesType;
    xAxisValueFormatType?: WebChartTypes;
    setTimeBinningInfoWhenNotProvided?: boolean;
}): boolean;
/**
 * Finds the matching field name for a given layer based on the fieldToMatch parameter.
 * @param {QueryObject} queryObject
 * @param {string} fieldToMatch
 * @returns {Promise<string>}
 */
export declare function findMatchingLayerFieldName(queryObject: QueryObject, fieldToMatch: string): Promise<string>;
/**
 * Indicates whether a feature layer supports queries with a `distance` parameter
 * @param layer The layer to test
 * @returns A boolean
 */
export declare function doesLayerSupportQueryWithDistance(layer: SupportedLayer): boolean;
/**
 * Computes a feature layer capabilities regarding its spatial aggregation statistics.
 * Only considers the 'EnvelopeAggregate' for now.
 * @param layer The layer instance
 * @returns A sum up of the capabilities
 */
export declare function getLayerSpatialAggregationStatisticsCapabilities(layer: SupportedLayer): boolean;
/**
 * Builds a WebChartQuery based on information coming from the runtime filters (chart options), the config and the data source.
 * The filters by attributes from all sources are all combined together (using the AND operator).
 * Regarding the other filters (by geometry, gdb version and time extent) only one of each can be applied. The runtime
 * filters are chosen over the config filters.
 * @param props.queryObject The query object (feature layer or feature layer view)
 * @param props.chartConfig The chart's config
 * @param props.runtimeDataFilters The runtime data filters
 * @param props.ignoreViewExtent Whether to ignore the view extent
 */
export declare function buildQueryConfig(props: {
    queryObject?: QueryObject;
    chartConfig: WebChart;
    runtimeDataFilters?: WebChartDataFilters;
    ignoreViewExtent?: boolean;
}): WebChartQuery;
