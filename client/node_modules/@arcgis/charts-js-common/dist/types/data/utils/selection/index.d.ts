import type { QueryObject, ErrorStrings } from "@arcgis/charts-shared-utils";
import type { WebChart, WebChartDataItem, WebChartQuery, WebChartDataTypes } from "@arcgis/charts-spec";
import type { ChartOptions } from "../../../interfaces";
/**
 * Builds a where clause following the pattern `<OID field> in (<list_of_OIDs>)`
 * @param fieldOID
 * @param listOIDs
 */
export declare function joinOIDs(fieldOID: string, listOIDs?: number[]): string | undefined;
/**
 * Fetches data from a list of OIDs. If the chart is non aggregated we directly read the OIDs stored in the data context,
 * and if the chart is aggregated we perform queries to fetch the data.
 * @param props.chartData The data fetched by the last call to `getData()`
 * @param props.chartConfig The chart's config
 * @param props.queryConfig The query config
 * @param props.queryObject The query object (layer or feature layer view)
 * @param props.dataWasUpdated Whether the data was updated
 * @param props.currentSelectionOIDs The OIDs representing the selection currently active on the chart
 * @param props.options The runtime options
 * @param props.errorStrings The t9n error strings
 */
export declare function getSelectionItemsFromOIDs(props: {
    chartData?: WebChartDataTypes;
    chartConfig: WebChart;
    queryConfig?: WebChartQuery;
    queryObject: QueryObject;
    dataWasUpdated?: boolean;
    currentSelectionOIDs?: number[];
    options?: ChartOptions;
    errorStrings: ErrorStrings;
}): Promise<WebChartDataItem[] | undefined>;
/**
 * Fetches OIDs based on a where clause gathering information from multiples elements (markers, bars...)
 * TODO: add a threshold to limit the number of data items to bring back
 * @param props
 * @returns a list of OIDs matching the provided the where clause
 */
export declare function fetchOIDsFromWhereClause(props: {
    whereList: string[];
    queryObject: QueryObject;
    queryFilter?: string;
    queryConfig: WebChartQuery;
}): Promise<number[]>;
