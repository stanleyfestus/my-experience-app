import type { ChartElementLimit, SelectionIndexes } from "@arcgis/charts-shared-utils";
import type { WebChart, WebChartBin, WebChartDataItem, WebChartDataTypes, TimeIntervalInfo, WebChartSeriesType, WebGaugeChart, ValueConversion, WebBoxPlot, IExtent, WebChartDataItemValue } from "@arcgis/charts-spec";
import { WebChartDataTransformations } from "@arcgis/charts-spec";
import type { SortWebChartDataItemsProps, DataUpdateNeededDetails } from "./interfaces";
import type { ChartOptions } from "../../../interfaces";
/**
 * Merges an array of IExtent into one IExtent
 * @param extentList
 * @returns
 */
export declare function mergeExtents(extentList?: IExtent[]): IExtent | undefined;
/**
 * Checks in the data context if some extra values has been stored.
 * - `typeOrDomainIdValue` is used for when preferLabel is false
 * - `originalCategoryValue` is used for the non-aggregated bar charts in order to handle the duplicated
 *   category names. In that case the categories are replaced by a unique key, different from the original category name.
 * - `originalDateValue` is used for storing the original non formatted category when it's a date
 * - `defaultPieFromFieldsName` is used by pie chart from field.
 * @param props.value The default value
 * @param props.dataContext The data context
 * @param props.useRendererLabel Whether to use the renderer label
 * @param props.specificField A specific field to look for
 * @param props.preferLabel Whether to use field label instead of value
 * @param props.keepNullValues Whether to keep the null values
 */
export declare function getXAxisValueFromContext(props: {
    value: Date | number | string;
    dataContext?: WebChartDataItem;
    useRendererLabel?: boolean;
    specificField?: string;
    preferLabel?: boolean;
    keepNullValues?: boolean;
}): Date | number | string;
/**
 * Looks for the original x value in the data context. Chooses by order of priority:
 * - the type or domain id value
 * - the original category value
 * @param dataContext The data context
 */
export declare function getOriginalXValueFromContext(dataContext?: WebChartDataItem): WebChartDataItemValue | undefined;
/**
 * Sorting an array WebChartDataItem following the instructions defined in the props.
 *
 * @param props.arrayToSort The array to sort
 * @param props.sortingField The field to sort by
 * @param props.orderBy The order by
 * @param props.forceAscendingOrder Whether to force the ascending order
 * @param props.multiSeriesYField The multi series y field
 * @param props.isNonAggregated Whether the chart is non-aggregated
 * @param props.sortByCategory Whether to sort by category (the x-axis field)
 * @param props.chartType The chart type
 * @param props.chartSubType The chart sub type
 * @param props.preferLabel Whether to use data label instead of value
 * @param props.fieldList The layer field list
 */
export declare function sortWebChartDataItems(props: SortWebChartDataItemsProps): void;
/**
 * This function reassigns the category/field name and stat value to the series x and y, while deleting the
 * technical field used during the rendering for technical reasons.
 * @param modifiedData The data to revert
 * @param seriesConfig The series config
 */
export declare function revertPieFromFieldsProperties<T extends WebChartDataItem[] | WebChartDataTypes>(modifiedData: T, seriesConfig?: WebChart["series"]): T;
/**
 * This function reverts some changes done to process the chart's data set:
 * - removes the formatted dates used specifically for the queries
 * - switches back the values of the modified dates/categories to accommodate the rendering (axis labels, sort...)
 * @param data The data containing modified x values
 * @param seriesConfig The series config
 */
export declare function revertOriginalXValues<T extends WebChartDataItem[] | WebChartDataTypes>(data: T, seriesConfig?: WebChart["series"]): T;
/**
 * Removes some technical properties including color ones from a data item
 * @param dataItem The data item to sanitize
 * @returns The sanitized data item
 */
export declare function removeAdditionalStatisticsPerItem(dataItem: WebChartDataItem): WebChartDataItem;
/**
 * Before sending the event payload containing the data, we need to revert some changes done to sort the charts.
 * @param data The data set to modify
 * @param seriesConfig The series config
 * @returns The sanitized data
 */
export declare function removeAdditionalStatistics(data: WebChartDataTypes, seriesConfig: WebChartSeriesType[]): WebChartDataTypes;
/**
 * Sanitizes data by reverting technical changes made to the data set.
 * The point is to send meaningful data to the user through events or the `chartWillRender()` function.
 * @param props.data The data to sanitize
 * @param props.seriesConfig The series config
 */
export declare function sanitizeData(props: {
    data?: WebChartDataTypes;
    seriesConfig: WebChartSeriesType[];
}): WebChartDataTypes | undefined;
/**
 * A function to determine whether the scatter plot is aggregated.
 * It can use a map of statistics containing the number of points (computed from the data side) or
 * a data context object usually stored within each marker.
 * @param props
 */
export declare function isScatterPlotAggregated(props: {
    statsMap?: Map<string, number>;
    dataContext?: WebChartDataItem;
    chartLimits?: ChartElementLimit;
}): boolean;
/**
 * A function to determine whether a chart is aggregated.
 * Supports scatter plot, bar chart and pie chart. Defaults to true for the other types of chart.
 * @param props
 */
export declare function isChartAggregated(props: {
    dataContext?: WebChartBin | WebChartDataItem;
    chartConfig: WebChart;
    chartLimits?: ChartElementLimit;
}): boolean;
/**
 * Converts the field to have the transform functions applied in where clause.
 * Use by histogram.
 * @param xAxisField
 * @param type
 */
export declare function getTransformedQuery(xAxisField: string, type?: WebChartDataTransformations): string;
/**
 * Transform a date into a format that can be used for querying.
 * Ex:
 *   - 1629862814560 => "8/25/2021 3:40:14 AM"
 *   - new Date(2005, 5, 5, 5, 5, 5) => "6/5/2005 12:05:05 PM"
 * @param date
 * @returns
 */
export declare function transformDateToQueryFormat(date: Date | number): number | string;
/**
 * Construct an array of WebChartDataItem using every key/value pairs from the input data (of type WebChartDataItem).
 *
 * Currently only Pie chart uses this function.
 * @param data The data to convert
 * @param x The x field name
 * @param y The y field name
 */
export declare function convertMultipleNumericFieldsData(props: {
    dataToConvert: WebChartDataItem;
    x: string;
    y: string;
}): WebChartDataItem[];
/**
 * Compares two gauge configs and indicates whether the color type change
 * @param oldConfig The previous config
 * @param newConfig The updated config
 */
export declare function hasColorMatchChanged(oldConfig: WebChart, newConfig: WebChart): boolean;
/**
 * Compares the 'slices' array from the pie series, and indicates whether they are different.
 * Compare only the slices id and label to avoid false positives.
 * @param props.oldConfig The previous chart config
 * @param props.newConfig The newest chart config
 */
export declare function hasSlicesConfigChanged(props: {
    oldConfig: WebChart;
    newConfig: WebChart;
}): boolean;
/**
 * Compares the split by value for each series element in the box plot config and returns true if the series has different split by value between new and old box plot config, false otherwise.
 * @param oldSeries The former series config
 * @param newSeries The new series config
 */
export declare function hasSplitByValueChanged(oldSeries: WebChart["series"], newSeries: WebChart["series"]): boolean;
/**
 * Verify if the order of the numeric fields has changed
 * @param oldSeries - The previous series config
 * @param newSeries - The new series config
 */
export declare function hasNumericFieldsChanged(oldSeries: WebChart["series"], newSeries: WebChart["series"]): boolean;
/**
 * Function saying if a data update is needed. We compare different properties from the former config and the new one
 * in order to decide if the update is needed.
 * @param props
 */
export declare function isDataUpdateNeeded(props: {
    forceDataUpdate?: boolean;
    oldConfig: WebBoxPlot | WebChart;
    newConfig: WebBoxPlot | WebChart;
    options?: ChartOptions;
    formerFilterBySelection?: boolean;
    timeIntervalInfo?: TimeIntervalInfo;
    currentSelectionDataItems?: WebChartDataItem[];
    currentSelectionOIDs?: number[];
    currentSelectionIndexes?: SelectionIndexes;
}): {
    dataUpdateNeeded: boolean;
    updateNeededDetails: DataUpdateNeededDetails;
};
/**
 * Function used on line charts using time binning.
 * Indicates whether resetting the previously fetched binned data is necessary.
 * It is necessary when the time interval unit or any common data property changes.
 * @param dataUpdateNeededDetails
 */
export declare function isBinnedServerDataResetNeeded(dataUpdateNeededDetails: DataUpdateNeededDetails): boolean;
/**
 * Check if the Pie chart data has slices with all positive or all negative values.
 *
 * Note: Pie with the following character is supported:
 * - no slice with positive and no slice with negative values
 * - the slices can have 0, null, or undefined values
 *
 * @param data the data to check for positive and negative values
 * @param fieldToCheckForValue to field containing the values
 */
export declare function checkForSupportedPieChart(data: WebChartDataItem[], fieldToCheckForValue: string): boolean;
/**
 * Calculates the maximum number of features to fetch according to the runtime chart options 'chartLimits'.
 * For instance:
 * - on a pie chart, the limit is the maximum number of slices (`maxPieChartSliceCountTotal`)
 * - on a bar or line chart, the limits vary depending on number of series. Maximum number of series count is (`maxBarChartSeriesCount`) and (`maxLineChartSeriesCount`)
 * @param chartConfig The chart's config
 * @param chartLimits The runtime chart limits
 */
export declare function getMaximumNumberOfFeaturesToFetch(chartConfig: WebChart | WebGaugeChart, chartLimits?: ChartElementLimit): number | undefined;
/**
 * Apply a conversion (from a factor and an offset) to a numeric value.
 * The factor is applied first and then the offset (when both are provided).
 * @param value The value to convert
 * @param valueConversion The information regarding the conversion to apply
 * @returns The converted value, or the original value if the `valueConversion` is undefined or invalid
 */
export declare function applyValueConversion(value: number, valueConversion?: ValueConversion): number;
/**
 * Extract the value from the input string, without the %; valid percent value is between 0 - 100
 * it's safe that we extract upto 3 digits and not worry about having an invalid number like 100.5
 * @param inputValue input string
 * @returns
 */
export declare function extractPercentValue(inputValue: string): number | undefined;
