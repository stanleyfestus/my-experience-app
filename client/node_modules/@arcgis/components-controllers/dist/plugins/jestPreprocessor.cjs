"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/plugins/jestPreprocessor.ts
var jestPreprocessor_exports = {};
__export(jestPreprocessor_exports, {
  default: () => jestPreprocessor_default
});
module.exports = __toCommonJS(jestPreprocessor_exports);
var import_jest_preprocessor = __toESM(require("@stencil/core/testing/jest-preprocessor.js"), 1);
var import_node_fs = __toESM(require("fs"), 1);

// src/plugins/utils.ts
function removeMutableWarning(code) {
  const warning = "is immutable but was modified from within the component";
  const index = code.indexOf(warning);
  if (index === -1) {
    throw new Error(
      "Couldn't find check for mutable in Stencil's code. This may have happened if Stencil updated their source code in src/runtime/proxy-component.ts - this plugin needs to be updated to match new Stencil version"
    );
  }
  const warningStart = code.lastIndexOf("consoleDevWarn", index);
  const warningEnd = code.indexOf(");", warningStart) + ");".length;
  return code.slice(0, warningStart) + code.slice(warningEnd);
}

// src/plugins/jestPreprocessor.ts
var stencilJest = import_jest_preprocessor.default;
var jestPreprocessorCode = import_node_fs.default.readFileSync(__filename, "utf8");
var transformer = {
  ...stencilJest,
  getCacheKey: (sourceText, sourcePath, options) => `${stencilJest.getCacheKey?.(sourceText, sourcePath, options)}:${jestPreprocessorCode}`,
  process(sourceText, sourcePath, ...rest) {
    const shouldTransformCoreAdapter = sourcePath.endsWith("core-adapter/dist/index.cjs");
    const result = stencilJest.process(
      shouldTransformCoreAdapter ? transformCoreAdapter(sourceText) : sourceText,
      sourcePath,
      ...rest
    );
    const shouldTransformControllers = (sourcePath.endsWith(".ts") || sourcePath.endsWith(".tsx")) && sourceText.includes("@Component(");
    const shouldRemoveMutable = sourcePath.endsWith("@stencil/core/internal/testing/index.js");
    return {
      ...result,
      code: shouldTransformControllers ? transformControllers(result.code) : shouldRemoveMutable ? removeMutableWarning(result.code) : result.code
    };
  }
};
var jestPreprocessor_default = transformer;
var registerInstance = "__stencil_registerInstance(";
function transformControllers(code) {
  const lines = code.split("\n");
  const lastRequireLine = lines.findLastIndex((line) => line.includes('= require("')) + 1;
  const updated = [
    ...lines.slice(0, lastRequireLine),
    `const {forceUpdate} = require("@stencil/core/internal/testing");`,
    ...lines.slice(lastRequireLine)
  ].join("\n");
  return updated.replaceAll(
    registerInstance,
    `this.constructor.__registerControllers = ()=>hostRef.$cmpMeta$.$members$??{};${registerInstance}`
  ).replaceAll(/COMPILER_META[\s\S]*\};/gu, transformMeta).replaceAll("useControllerManager)(this)", "useControllerManager)(this,forceUpdate)");
}
var transformMeta = (meta) => meta.replaceAll(flagsRegex, "$<key>true");
var flags = [
  "hasLifecycle",
  "hasComponentWillLoadFn",
  "hasComponentDidLoadFn",
  "hasComponentWillUpdateFn",
  "hasComponentDidUpdateFn",
  "hasComponentWillRenderFn",
  "hasComponentDidRenderFn",
  "hasConnectedCallbackFn",
  "hasDisconnectedCallbackFn",
  "hasWatchCallback"
];
var flagsRegex = new RegExp(`(?<key>(?:${flags.join("|")})"?\\s*:\\s*)false`, "gu");
var transformCoreAdapter = (code) => `${code.replaceAll(reAsyncImport, "await jestTransformerLock(()=>$<import>)")}
${locker}`;
var reAsyncImport = /await (?<import>import\("[^"]+"\))/gu;
var locker = `var jestTransformerLock = (function () {
  var locks = new Set();
  function doLoad(load) {
    if (locks.size === 0) return load();
    else return Promise.all(locks).then(load);
  }
  return function lock(load) {
    var promise = doLoad(load).finally(() => locks.delete(promise));
    locks.add(promise);
    return promise;
  };
})();`;
