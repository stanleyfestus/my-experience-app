import {
  Controller,
  GenericController,
  bypassGetter,
  bypassReadOnly,
  bypassSetter,
  controllerSymbol,
  dynamicGetSet,
  getSet,
  isController,
  proxyExports,
  readonly,
  retrieveComponent,
  retrieveParentControllers,
  setAmbientComponent,
  setParentController,
  trackKey,
  trackPropKey,
  trackPropertyKey,
  useControllerManager,
  watch
} from "./chunk-HOKLTU7K.js";
import "./chunk-KU4RC64P.js";

// src/functional.ts
var makeController = (constructor) => proxy(void 0, constructor);
var makeGenericController = (constructor) => (component) => proxy(
  component,
  /**
   * GenericController is identical to Controller, in all except for typing.
   * So dying a type-cast here so as not to needlessly add one more object
   * to the prototype chain
   */
  constructor
);
var FunctionalController = class extends Controller {
  constructor(component, constructor) {
    super(component);
    const originalExports = this.exports;
    try {
      setAmbientComponent(this.component);
      const value = constructor(this.component, this);
      const constructorChangedExports = this.exports !== originalExports;
      if (value instanceof Promise) {
        if (!constructorChangedExports) {
          this.setProvisionalExports(value);
        }
        const resolved = value.then((result) => {
          this.exports = result;
          super.catchUpLifecycle();
        }).catch((error) => {
          this._ready.reject(error);
          console.error(error);
        });
        this.onLoad(async () => await resolved);
      } else {
        if (!constructorChangedExports || value !== void 0) {
          this.exports = value;
        }
        queueMicrotask(() => super.catchUpLifecycle());
      }
    } catch (error) {
      this._ready.reject(error);
      console.error(error);
    }
  }
  /** Noop - will be called in the constructor instead */
  catchUpLifecycle() {
    return;
  }
};
var proxy = proxyExports(FunctionalController);

// src/useWatchAttributes.ts
var useWatchAttributes = (attributes, callback) => new AttributeWatchController(attributes, callback);
var AttributeWatchController = class extends Controller {
  constructor(_attributes, _callback) {
    super();
    this._attributes = _attributes;
    this._callback = _callback;
    this._observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (_attributes.includes(mutation.attributeName)) {
          _callback(
            this.component.el.getAttribute(mutation.attributeName),
            mutation.oldValue,
            mutation.attributeName
          );
        }
      });
    });
  }
  handleConnected() {
    this._attributes.forEach((attribute) => {
      if (this.component.el.hasAttribute(attribute)) {
        this._callback(null, this.component.el.getAttribute(attribute), attribute);
      }
    });
    this._observer.observe(this.component.el, {
      attributes: true,
      attributeOldValue: true,
      attributeFilter: this._attributes
    });
  }
  handleDisconnected() {
    this._observer.disconnect();
  }
};

// src/load.ts
var load = makeController;

// src/toFunction.ts
var toFunction = (Class) => (...args) => {
  const ambientControllers = retrieveParentControllers();
  const instance = new Class(...args);
  setParentController(ambientControllers.at(-1));
  return instance;
};

// src/useMedia.ts
var useMedia = (query) => makeController((_component, controller) => {
  const media = globalThis.matchMedia(query);
  function changed() {
    controller.exports = media.matches;
  }
  changed();
  controller.onLifecycle(() => {
    media.addEventListener("change", changed);
    return () => media.removeEventListener("change", changed);
  });
  return controller.exports;
});

// src/useDirection.ts
import { getElementAttribute, observeAncestorsMutation } from "@arcgis/components-utils";
var defaultDirection = "ltr";
var useDirection = () => makeController((component, controller) => {
  controller.exports = defaultDirection;
  controller.onLifecycle(
    () => observeAncestorsMutation(component.el, ["dir"], () => {
      const dir = getElementAttribute(component.el, "dir", defaultDirection);
      controller.exports = dir === "rtl" ? "rtl" : "ltr";
    })
  );
  if (process.env.NODE_ENV !== "production") {
    trackKey(
      component,
      (resolved) => {
        if (resolved?.key === "dir") {
          throw new Error(
            `Do not assign this controller to a prop called \`dir\` as that will overwrite the \`dir\` attribute on the host element - component should not be setting the \`dir\` attribute on itself. Instead, assign this controller to a property called \`direction\`.`
          );
        }
      },
      controller.exports
    );
  }
  return controller.exports;
});

// src/useT9n.ts
import { getElementLocales, startLocaleObserver } from "@arcgis/components-utils";
var makeT9nController = (getAssetPath) => (options = {}) => (
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  makeController((component, controller) => {
    const componentWithOverrides = component;
    controller.onLifecycle(
      () => startLocaleObserver(
        component.el,
        getAssetPath("./assets"),
        ({ t9nLocale, t9nStrings, lang }) => {
          const withoutOverrides = {
            ...t9nStrings,
            _lang: lang,
            _t9nLocale: t9nLocale,
            _loading: false
          };
          controller.exports = withoutOverrides;
          const label = t9nStrings.componentLabel ?? t9nStrings.widgetLabel;
          if (typeof label === "string" && "label" in component && component.label == null) {
            component.label ?? (component.label = label);
          }
          applyOverrides(componentWithOverrides.messageOverrides);
        },
        options.name
      )
    );
    function applyOverrides(messageOverrides) {
      const currentValue = controller.exports;
      const rawMessages = currentValue._original ?? currentValue;
      const updated = deepMerge(rawMessages, messageOverrides);
      updated._original = rawMessages;
      controller.exports = updated;
    }
    if ("messageOverrides" in componentWithOverrides) {
      controller.onLifecycle(() => watch(componentWithOverrides, "messageOverrides", applyOverrides));
    }
    if (options.blocking) {
      return controller.ready;
    }
    const locale = getElementLocales(component.el);
    const pending = {
      _lang: locale.lang,
      _t9nLocale: locale.t9nLocale,
      _loading: true
    };
    return pending;
  })
);
function deepMerge(original, overwrites) {
  if (!overwrites) {
    return original;
  }
  const merged = { ...original };
  Object.entries(overwrites).forEach(([key, value]) => {
    if (typeof value === "object") {
      merged[key] = deepMerge(original[key], value);
    } else {
      merged[key] = value ?? original[key];
    }
  });
  return merged;
}

// src/usePropertyChange.ts
var usePropertyChange = (_component) => propertyChangeController;
var eventName = "arcgisPropertyChange";
var propertyChangeController = (...toWatch) => makeController((component, controller) => {
  const eventedComponent = component;
  let eventEmitter = eventedComponent[eventName];
  if (component.manager.isLit) {
    eventEmitter = component.constructor.createEvent(eventName, void 0, component);
    if (process.env.NODE_ENV !== "production") {
      if (typeof eventEmitter !== "object" || eventEmitter === null || !("emit" in eventEmitter) || typeof eventEmitter.emit !== "function") {
        throw new Error(`Expected to find createEvent static property on ArcGIS Lit's LitElement"`);
      }
    }
  }
  if (process.env.NODE_ENV !== "production") {
    if (typeof eventEmitter !== "object" || eventEmitter === null || !("emit" in eventEmitter) || typeof eventEmitter.emit !== "function") {
      throw new Error(
        `For consistency, usePropertyChange must be assigned to an arcgisPropertyChange property that has an @Event() decorator`
      );
    }
    const allProps = new Set(
      Object.entries(component.manager.internals.members).filter(([_name, [propType]]) => (propType & 31 /* Prop */) !== 0).map(([name]) => name)
    );
    toWatch.forEach((prop) => {
      if (!allProps.has(prop)) {
        throw new Error(
          prop in component ? `For usePropertyChange to emit event on "${prop}" property change, you should add @${component.manager.isLit ? "property" : "Prop"}() to ${prop} in ${component.el.tagName.toLowerCase()}` : `usePropertyChange can't emit event on "${prop}" property change as such property does not exist in ${component.el.tagName.toLowerCase()}`
        );
      }
    });
  }
  controller.onLoad(
    () => controller.onLifecycle(
      () => toWatch.map(
        (name) => (
          // Casting to 'el' to simplify dynamic prop name typing
          watch(component, name, () => eventEmitter.emit({ name }))
        )
      )
    )
  );
  if (process.env.NODE_ENV !== "production" && component.manager.isLit) {
    trackKey(
      component,
      (resolution) => {
        if (resolution === void 0 || resolution.isReactive || resolution.key !== eventName) {
          throw new Error(
            `For consistency, usePropertyChange must be assigned to an arcgisPropertyChange property and that property should not have @property() or @state() decorators: arcgisPropertyChange = usePropertyChange<this>()("prop1", "prop2");`
          );
        }
      },
      eventEmitter
    );
  }
  return eventEmitter;
});
export {
  Controller,
  GenericController,
  bypassGetter,
  bypassReadOnly,
  bypassSetter,
  controllerSymbol,
  dynamicGetSet,
  getSet,
  isController,
  load,
  makeController,
  makeGenericController,
  makeT9nController,
  proxyExports,
  readonly,
  retrieveComponent,
  toFunction,
  trackKey,
  trackPropKey,
  trackPropertyKey,
  useControllerManager,
  useDirection,
  useMedia,
  usePropertyChange,
  useWatchAttributes,
  watch
};
