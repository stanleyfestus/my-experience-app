import { B as BaseComponent, a as BaseController, T as TrackKeyResolution, C as ControllerHost, b as Controller, G as GenericControllerType, c as ControllerLifecycleMethods } from './Controller-bXH9rI0X.cjs';
export { e as ControllerManager, d as GenericController, i as LitElementPropertyDeclaration, g as LitElementWithChangedPropertiesMap, L as LitElementWithCreateEventFactory, h as LitEventEmitter, S as StencilLifecycles, U as Use, f as controllerSymbol, r as retrieveComponent, u as useControllerManager } from './Controller-bXH9rI0X.cjs';
import { GenericT9nStrings, LocaleObserver } from '@arcgis/components-utils';
import { EventEmitter } from '@stencil/core';
import 'lit';
import '@stencil/core/internal';

/**
 * A magical solution to finding out what property name a given controller
 * on a given object was assigned to. Note, this does not work for properties
 * that have \@Prop() or \@State() decorator - for those, use
 * manager.trackPropKey() instead.
 *
 * @example
 * function trackMe<T>(defaultValue:T, component:BaseComponent):T {
 *   component.manager.trackPropertyKey(component, (key)=>console.log(key), defaultValue);
 *   return defaultValue;
 * }
 *
 * class MyComponent extends BaseComponent {
 *   // Will console log "myProp"
 *   myProp = trackMe('a', this);
 * }
 *
 */
declare function trackPropertyKey<T>(object: BaseComponent | BaseController, onResolved: (key: string | undefined) => void, defaultValue: T): T;

/**
 * Like manager.trackPropertyKey(), but for props that have \@State() or \@Prop()
 * decorator
 *
 * @example
 * function trackMe() {
 *   const component = retrieveComponent();
 *   const defaultValue = 'some value';
 *   return trackPropKey(component, (key)=>console.log(key), defaultValue);
 * }
 *
 * class MyComponent extends BaseComponent {
 *   // Will console log "myProp"
 *   @Prop() myProp = trackMe();
 *
 *   // Will console log "myState"
 *   @State() myState = trackMe();
 * }
 */
declare function trackPropKey<T>(component: BaseComponent, onResolved: (key: string | undefined) => void, defaultValue: T): T;

/**
 * A combination of trackPropertyKey() and trackPropKey(). For usage when
 * you want to track a property, but don't know if it will be defined with the
 * \@Prop() decorator or not
 */
declare function trackKey<T>(hostsCandidates: (BaseComponent | BaseController)[] | BaseComponent | BaseController, onResolved: (resolution: TrackKeyResolution | undefined) => void, defaultValue: T): T;

/**
 * Controller is a function that takes a component instance and then can
 * export some values to the component, or hook into component's lifecycle
 *
 * See controllers documentation for many example controllers and their usages
 */
declare const makeController: <Exports>(constructor: (component: BaseComponent & ControllerHost, controller: Controller<Exports>) => Exports | Promise<Exports>) => Exports;
/**
 * If your controller requires some specific properties to be present on the
 * component, besides what's included in the BaseComponent, use
 * makeGenericController
 *
 * When using a controller created using makeGenericController(), consumer must
 * pass in "this" explicitly for proper type-checking. If controller was
 * created using makeController(), that is not necessary
 */
declare const makeGenericController: <Exports, Component = BaseComponent>(constructor: (component: BaseComponent & Component & ControllerHost, controller: GenericControllerType<Exports, Component>) => Exports | Promise<Exports>) => (component: BaseComponent & Component) => Exports;

/**
 * Make a @Prop() or @State() readonly (prevent overwriting default value).
 *
 * For internal properties, prefer TypeScript's "readonly" modifier instead.
 *
 * @example
 * ```ts
 * // Defining readonly prop
 * @Prop({ reflect: true }) prop = readonly('a');
 * ```
 *
 * @example
 * ```ts
 * // Overwriting readonly prop internally
 * bypassReadOnly(()=>{
 *   this.prop = 'b';
 * });
 * ```
 *
 */
declare function readonly<T>(value: T): T;
/**
 * Like bypassSetter(), but only bypasses readonly(), rather that
 * all setters set using getSet()
 */
declare function bypassReadOnly<T = void>(callback: () => T): T | void;

/**
 * Listen for any component's @State()/@Prop() change, and mutate it's
 * value before it is set.
 * This is necessary because Stencil's Compiler does not support get/set for
 * @State()/@Prop().
 * For private component properties, you should use regular get/set syntax.
 *
 * @example
 * ```tsx
 * @Prop() exampleProp = getSet(defaultValue,{get,set})
 * @Prop() someProp = getSet(
 *   undefined as string | undefined,
 *   {
 *     get: (value)=>value.trim(),
 *     set: (newValue,oldValue) => newValue.trim() ?? oldValue
 *   }
 * )
 * ```
 *
 * @remarks
 * Unlike a native get/set, the get function receives the current attribute
 * value, and can modify it before returning it (or can disregard the current
 * value and get it from elsewhere instead).
 * Similarly, setter is called with the new and old value, and is expected to
 * return the final new value (or return the old value to undo the change)
 */
declare function getSet<T>(
/**
 * Default value is used only if user did not set a value in the DOM before
 * component was loaded
 */
defaultValue: T, getSet: {
    get?(newValue: T, propertyName: string): T;
    set(newValue: T, oldValue: T, propertyName: string): T;
} | {
    get(newValue: T, propertyName: string): T;
    set?(newValue: T, oldValue: T, propertyName: string): T;
} | {
    get(newValue: T, propertyName: string): T;
    set: "ignore";
}): T;
/**
 * Like getSet(), but can be called on any component's
 * state/prop from anywhere, rather than just from the default value
 */
declare const dynamicGetSet: <Component extends BaseComponent, Property extends "componentDidLoad" | "componentDidUpdate" | "componentShouldUpdate" | "componentWillLoad" | "componentWillUpdate" | "connectedCallback" | "disconnectedCallback" | "autoDestroyDisabled" | "manager" | "el" | "destroy" | keyof Component>(component: Component, property: Property, getSet: {
    get?(newValue: (BaseComponent & Component)[Property], propertyName: Property): (BaseComponent & Component)[Property];
    set(newValue: (BaseComponent & Component)[Property], oldValue: (BaseComponent & Component)[Property], propertyName: Property): (BaseComponent & Component)[Property];
} | {
    get(newValue: (BaseComponent & Component)[Property], propertyName: Property): (BaseComponent & Component)[Property];
    set?(newValue: (BaseComponent & Component)[Property], oldValue: (BaseComponent & Component)[Property], propertyName: Property): (BaseComponent & Component)[Property];
}) => void;
/**
 * If you need to set a prop/state without triggering the custom setter you
 * defined with getSet()/dynamicGetSet()/readonly(), set the value inside
 * of this function
 *
 * @example
 * ```tsx
 * @Prop() readOnly = readOnly(true);
 *
 * someAction(): void {
 *   bypassSetter(()=>{
 *     this.readOnly = false;
 *   });
 * }
 * ```
 *
 */
declare function bypassSetter<T = void>(callback: () => T): T | void;
/**
 * Property reads inside of this function will bypass any custom getter you
 * may have, and read the value directly from what's stored in Stencil/Lit.
 *
 * This also bypasses reactiveUtils integration - reading a property inside of
 * bypassGetter won't make that property tracked.
 *
 * @example
 * ```tsx
 * reactiveUtils.watch(
 *   ()=>{
 *     bypassGetter(()=>{
 *       console.log(this.someProp);
 *     });
 *     return this.prop;
 *   },
 *   console.log
 * );
 * ```
 */
declare function bypassGetter<T = void>(callback: () => T): T | void;

/**
 * Dynamically set a watcher for any reactive property
 *
 * @example
 * ```ts
 * this.manager.onLifecycle(()=>
 *   watch(this, "myProp", (newValue,oldValue)=>console.log(newValue,oldValue))
 * )
 * ```
 *
 * @example
 * Note, if you are in Lit, you should prefer the willUpdate() lifecycle method
 * over watch(). willUpdate() is going to be more memory-efficient, and more
 * flexible (can watch multiple props at once or provide dynamic prop name)
 *
 * ```ts
 * willUpdate(changedProperties: PropertyValues<this>) {
 *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
 *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
 *   }
 * }
 * ```
 */
declare function watch<Component extends BaseComponent, Property extends keyof Component>(component: Component, property: Property, callback: (newValue: Component[Property], oldValue: Component[Property], property: Property) => void): () => void;

/**
 * Watch when given attributes change on the component element.
 *
 * @example
 * ```tsx
 * class MyComponent extends LitELement {
 *   _attributeWatch = useWatchAttributes(["aria-expanded"], (attribute, newValue, oldValue)=>{
 *     console.log(attribute, newValue, oldValue);
 *     // (optional) if you wish to trigger a re-render in response
 *     this.requestUpdate(attribute);
 *   });
 * }
 * ```
 *
 * @remarks
 * If some watched attribute is already present when the component is connected,
 * the callback will fire immediately.
 */
declare const useWatchAttributes: <T extends string>(attributes: readonly T[], callback: (newValue: string | null, oldValue: string | null, attribute: T) => void) => Controller;

/**
 * Load a value from a promise and provide it to the component
 *
 * @example
 * reactiveUtils = load(importCoreReactiveUtils);
 *
 * componentWillLoad() {
 *   this.reactiveUtils.when(...)
 * }
 */
declare const load: <T>(loader: () => Promise<T>) => T;

/**
 * If you wish to directly expose the "exports" property of your controller,
 * rather than the entire controller class, wrap your class definition in
 * "proxyExports".
 *
 * This is especially convenient when your exports is not an object, or it is a
 * dynamically created object, and so you don't want your Controller's methods
 * interfering with the keys on the exported value.
 *
 * "proxyExports" is the default behavior for all controllers declared using
 * the makeController()/makeGenericController() function
 *
 * @remarks
 * If using readonly(), and controller updates it's exports, the readonly prop
 * will still get updated.
 *
 * @remarks
 * (Advanced) If you wish to use proxyExports() in a class that does not
 * extend Controller class and does not have a useControllerManager(), then your
 * class must subclass a class with the following constructor:
 * `constructor() { setAmbientController(this); }`. This
 * is necessary for proxyExports() to receive a reference to your object
 * implicitly, and before any of your default values are assigned.
 */
declare const proxyExports: <Exports, const Parameters extends unknown[]>(Class: new (...args: Parameters) => ControllerLifecycleMethods & Pick<Controller<Exports>, "component" | "exports" | "watchExports">) => ((...args: Parameters) => Exports);

/**
 * A tiny helper for using a class-based controller as if it's a function.
 * Main advantage of this is that it's a bit shorter to type.
 *
 * This utility can be used for converting non-controller classes to functions
 * too
 */
declare const toFunction: <T, const P extends unknown[]>(Class: new (...args: P) => T) => ((...args: P) => T);

/**
 * A controller for determining if the document matches a provided media string.
 * If the media changes, the controller will update in real time and your
 * component will be re-rendered.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia
 *
 * @remarks
 * Most of the time, only CSS code needs to be aware of the media query. You can
 * use the following CSS to apply styles based on the media query:
 *
 * ```css
 * \@media (prefers-reduced-motion) {
 *   .animation {
 *     animation: none:
 *   }
 * }
 * ```
 *
 * The above is preferable as it is more performant and keeps styling-related
 * logic isolated to CSS files.
 *
 * ```tsx
 * prefersReducedMotion = useMedia('(prefers-reduced-motion)');
 *
 * render() {
 *   return prefersReducedMotion ? <calcite-loader /> : this.messages.loading;
 * }
 * ```
 *
 * @remarks
 * If you need to find out if component should be rendered in dark or light mode,
 * the calcite class names should take priority over the media query. Here is how
 * you can check in CSS if the component should be in dark mode:
 *
 * ```css
 * :host {
 *   --theme: white;
 * }
 * :host-context(.calcite-mode-dark) {
 *   --theme: black;
 * }
 * @media (prefers-color-scheme: dark) {
 *   :host-context(.calcite-mode-auto) {
 *     --theme: black;
 *   }
 * }
 * ```
 *
 * You might not even have to write a media query yourself as Calcite defines
 * a few CSS variables that will have correct value based on the theme:
 * https://github.com/Esri/calcite-colors/blob/c152fc963cd8ae76ba0e9c8a78afe1211a7b573d/dist/colors.scss#L503-L525
 *
 * It's ideal if only the CSS part of your component is aware of the current
 * theme. Determining correct theme though JavaScript, and listening to class
 * name changes on all ancestors of current element adds complexity and
 * performance concerns and should be avoided if possible. That is why, a
 * `useTheme()` controller is not provided, until it is absolutely necessary.
 *
 * See also https://github.com/Esri/calcite-colors
 *
 */
declare const useMedia: (query: string) => boolean;

type Direction = "ltr" | "rtl";
/**
 * Finds the closest "dir" attribute to current component and returns it's value.
 * Watches for changes to "dir" in real time and will re-render your component
 * if needed.
 *
 * @remarks
 * As much as possible, try to rely on
 * [CSS logical properties](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_logical_properties_and_values)
 * to streamline ltr/rtl handling.
 *
 *
 * In cases were more control is needed, use a selector like this in CSS:
 *
 * ```css
 * // Apply these styles if web component has an ancestor with dir="rtl"
 * :host-context([dir="rtl"]) {
 *   flex-direction: row-reverse;
 * }
 * ```
 *
 * Only in cases where the above is not sufficient and you need JavaScript to
 * be aware of ltr/rtl, use this controller.
 *
 * @remarks
 * Do not assign this controller to a prop called `dir` as that will overwrite
 * the `dir` attribute on the host element - component should not be setting
 * the `dir` attribute on itself. Instead, assign this controller to a property
 * called `direction`.
 *
 * @example
 * ```tsx
 * direction = useDirection()
 *
 * render() {
 *   return <calcite-button
 *     icon={this.direction === 'ltr' ? 'chevrons-left' : 'chevrons-right'}
 *     // Note: calcite provides a iconFlipRtl prop, so the above may not be necessary
 *   >
 *     {this.messages.open}
 *   </calcite-button>;
 * }
 * ```
 *
 */
declare const useDirection: () => Direction;

type Meta<T9nStrings extends GenericT9nStrings> = {
    _lang: LocaleObserver["lang"];
    _t9nLocale: LocaleObserver["t9nLocale"];
    _loading: boolean;
    /**
     * The "_overrides" property won't actually exist at runtime and exists only
     * to simplify typing like so:
     *
     * @example
     * ```ts
     * // Type of the messageOverrides is set automatically based on _overrides:
     *   @Prop() messageOverrides?: typeof this.messages._overrides;
     * ```
     */
    _overrides: DeepPartial<T9nStrings>;
    /**
     * If messageOverrides are in effect, this will contain original strings
     */
    _original?: T9nStrings;
};
type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
type Options = {
    readonly name?: string;
    /** @default false */
    readonly blocking?: boolean;
};
interface UseT9n {
    <Strings extends GenericT9nStrings>(options: Options & {
        readonly blocking: true;
    }): Meta<Strings> & Strings;
    <Strings extends GenericT9nStrings>(options?: Options & {
        readonly blocking?: false;
    }): Meta<Strings> & Partial<Strings>;
}
/**
 * Load component's localization strings.
 *
 * Note, to use correct asset path in each package using controllers, you need
 * to create a `useT9n` controller using the `makeT9nController` factory
 * function.
 *
 * @example
 * // Creating a `useT9n` controller
 * import { makeT9nController } from "@arcgis/components-controllers";
 * import { getAssetPath } from "@stencil/core";
 * const useT9n = makeT9nController(getAssetPath);
 *
 * @example
 * import type T9nStrings from "./assets/home/t9n/home.t9n.en.json";
 *
 * @Component({ tag: "arcgis-home", assetsDirs: ["assets"] })
 * export class Home {
 *   messages = useT9n<typeof T9nStrings>();
 * }
 *
 * @remarks
 * When using this controller, `@State()` is not needed as Controller will
 * trigger the update automatically when necessary.
 *
 * The strings are loaded async and might not be available by the time your
 * component renders. If you wish to delay render() until the strings are ready,
 * pass `true` as the first argument to `useT9n`.
 */
declare const makeT9nController: (getAssetPath: (path: string) => string) => UseT9n;

/**
 * Like Stencil's EventEmitter, but with disabled covariance check
 */
type CovariantEventEmitter<T> = {
    emit(data?: T): ReturnType<EventEmitter<T>["emit"]>;
};
/**
 * While we don't actually return CustomEvent<T>, claiming that we do simplifies
 * typing.
 *
 * See:
 * ```ts
 * handleClick(event: ArcgisCounter['arcgisClick']): void {
 * }
 * ```
 *
 * Without it, you would have to do:
 * ```ts
 * handleClick(event: ReturnType<ArcgisCounter['arcgisClick']['emit']>): void {
 * }
 * ```
 *
 * This is also used by ArcGIS Lit to more easily find all event properties
 */
type PropertyChangeController<Component extends BaseComponent> = <ToWatch extends keyof Component>(...toWatch: ToWatch[]) => CovariantEventEmitter<{
    name: ToWatch & string;
}> & CustomEvent<{
    name: ToWatch & string;
}>;
/**
 * Let user easily set watchers for component properties.
 * Unlike reactiveUtils, these watchers can be set from JSX.
 *
 * See example 10 in ./3.stencil.md for more documentation:
 * https://devtopia.esri.com/WebGIS/arcgis-web-components/blob/main/packages/support-packages/components-controllers/docs/3.stencil.tsx
 *
 * @example
 * // Using usePropertyChange in your component:
 * @Event() arcgisPropertyChange = usePropertyChange<this>()('prop1', 'prop2');
 *
 * @example
 * // Using a component that has arcgisPropertyChange event:
 * // in JSX:
 * <arcgis-compass
 *   onarcgisPropertyChange={({detail, target}) =>
 *     console.log(detail.name, target[detail.name])
 *   }
 * />
 *
 * // natively:
 * const compass = document.createElement("arcgis-compass");
 * compass.addEventListener("arcgisPropertyChange", ({detail, target}) => {
 *  console.log(detail.name, target[detail.name]);
 * });
 */
declare const usePropertyChange: <Component extends BaseComponent>(_component?: BaseComponent) => PropertyChangeController<Component>;

declare const isController: (value: unknown) => value is ControllerLifecycleMethods;

export { BaseComponent, BaseController, Controller, ControllerHost, ControllerLifecycleMethods, type CovariantEventEmitter, GenericControllerType, type UseT9n, bypassGetter, bypassReadOnly, bypassSetter, dynamicGetSet, getSet, isController, load, makeController, makeGenericController, makeT9nController, proxyExports, readonly, toFunction, trackKey, trackPropKey, trackPropertyKey, useDirection, useMedia, usePropertyChange, useWatchAttributes, watch };
