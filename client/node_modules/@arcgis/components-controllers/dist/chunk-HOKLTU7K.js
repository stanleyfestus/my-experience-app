import {
  getMemberType,
  parsePropertyValue,
  retrieveComponentMembers
} from "./chunk-KU4RC64P.js";

// src/types.ts
var controllerSymbol = Symbol.for("controller");

// package.json
var name = "@arcgis/components-controllers";

// src/utils.ts
var isController = (value) => typeof value === "object" && value !== null && (controllerSymbol in value || "hostConnected" in value || "hostDisconnected" in value || "hostUpdate" in value || "hostUpdated" in value);
var devOnlySetPersistentControllerData = process.env.NODE_ENV === "production" ? void 0 : (controller, data) => {
  const manager = controller.component.manager;
  const controllers = "_controllers" in manager ? manager._controllers : void 0;
  if (controllers === void 0) {
    return void 0;
  }
  const index = Array.from(controllers).indexOf(controller);
  if (index === -1) {
    return;
  }
  const devOnlyControllerData = Symbol.for(`${name}: devOnlyControllerData`);
  const el = controller.component.el;
  el[devOnlyControllerData] ?? (el[devOnlyControllerData] = {});
  el[devOnlyControllerData][index] = data;
};
var devOnlyGetPersistentControllerData = process.env.NODE_ENV === "production" ? void 0 : (controller) => {
  const manager = controller.component.manager;
  const controllers = "_controllers" in manager ? manager._controllers : void 0;
  if (controllers === void 0) {
    return void 0;
  }
  const index = Array.from(controllers).indexOf(controller);
  const devOnlyControllerData = Symbol.for(`${name}: devOnlyControllerData`);
  const el = controller.component.el;
  return el[devOnlyControllerData]?.[index];
};

// src/ControllerInternals.ts
var ambientComponent;
function setAmbientComponent(component) {
  if (ambientComponent === component) {
    return;
  }
  ambientComponent = component;
  queueMicrotask(() => {
    if (ambientComponent === component) {
      ambientComponent = void 0;
    }
  });
}
function retrieveComponent(name2) {
  if (process.env.NODE_ENV !== "production" && ambientComponent === void 0) {
    throw new Error(
      [
        `Unable to find out which component ${name2 || "this"} controller `,
        "belongs to. This might happen if you tried to create a controller ",
        "outside the component. If so, please wrap your controller ",
        "definition in an arrow function, ",
        "`const myController = ()=>makeController(...);` and call that",
        "function inside the component `my = myController();`, or ",
        "define your controller using makeGenericController/GenericController ",
        "instead.\n",
        "If you wish to use a controller inside an async controller, ",
        "make sure you are using controller.use.\n",
        "You might also have multiple instances of Controllers loaded"
      ].join("\n")
    );
  }
  return ambientComponent;
}
var ambientControllers = [];
function setParentController(controller) {
  if (controller === void 0) {
    ambientControllers = [];
    return;
  }
  const index = ambientControllers.indexOf(controller);
  ambientControllers = index === -1 ? [...ambientControllers, controller] : ambientControllers.slice(0, index + 1);
  queueMicrotask(() => {
    ambientControllers = [];
  });
}
function retrieveParentControllers() {
  return ambientControllers;
}
var ambientChildController;
function setAmbientChildController(controller) {
  if (ambientChildController === controller) {
    return;
  }
  ambientChildController = controller;
  queueMicrotask(() => {
    if (ambientChildController === controller) {
      ambientChildController = void 0;
    }
  });
}
function retrieveAmbientChildController() {
  const controller = ambientChildController;
  ambientChildController = void 0;
  return controller;
}
var use = async (value, watchExports) => {
  const controller = useRefSync(value);
  if (controller === void 0) {
    if (process.env.NODE_ENV !== "production" && typeof watchExports === "function") {
      throw new Error(
        `Unable to resolve a controller from the provided value, so can't watch it's exports. The value you passed is not a controller and not a controller exports. If your controller exports a literal value, try making your controller export an object instead`
      );
    }
    return value;
  }
  await controller.ready;
  if (typeof watchExports === "function") {
    if (process.env.NODE_ENV !== "production" && controller.watchExports === void 0) {
      throw new Error(`The controller must implement watchExports method to support watching exports`);
    }
    const unsubscribe = controller.watchExports(
      (exports) => watchExports(exports, unsubscribe)
    );
  }
  return controller.exports;
};
var useRef = async (value) => {
  const controller = useRefSync(value);
  if (process.env.NODE_ENV !== "production" && controller === void 0) {
    throw new Error(
      `Unable to resolve a controller from the provided value. The value you passed is not a controller and not a controller exports. If your controller exports a literal value, try making your controller export an object instead`
    );
  }
  await controller.ready;
  return controller;
};
var useRefSync = (value) => {
  const ambientChildController2 = retrieveAmbientChildController();
  if (ambientChildController2 !== void 0) {
    return ambientChildController2;
  }
  const component = retrieveComponent();
  const controller = component.manager.internals.resolveExports(value);
  if (controller !== void 0) {
    return controller;
  }
  if (isController(value)) {
    return value;
  }
  return void 0;
};
var shouldBypass = {
  setter: false,
  getter: false,
  readOnly: false
};
var elementToInstance = /* @__PURE__ */ new WeakMap();

// src/Controller.ts
import { Deferred, safeAsyncCall, safeCall } from "@arcgis/components-utils";
var _a;
_a = controllerSymbol;
var Controller = class {
  constructor(component) {
    this._callbacks = {
      hostConnected: [],
      hostDisconnected: [],
      hostLoad: [],
      hostLoaded: [],
      hostUpdate: [],
      hostUpdated: [],
      hostDestroy: [],
      hostLifecycle: []
    };
    this._ready = new Deferred();
    this._lifecycleCleanups = [];
    this.connectedCalled = false;
    this._loadCalled = false;
    this.loadedCalled = false;
    this[_a] = true;
    this.ready = this._ready.promise;
    /*
     * Setting default exports to "this" so that controllers that don't use
     * exports/proxyExports(), could still be used as if they did
     * (i.e with controller.use)
     */
    this._exports = makeProvisionalValue(this);
    this._exportWatchers = /* @__PURE__ */ new Set();
    const resolvedComponent = toControllerHost(component ?? retrieveComponent(new.target.name));
    if (process.env.NODE_ENV === "production") {
      this.component = resolvedComponent;
    } else {
      Object.defineProperty(this, "component", {
        writable: false,
        enumerable: false,
        configurable: true,
        value: resolvedComponent
      });
      if ("hostDestroy" in this) {
        this.component.manager.ensureHasDestroy?.();
      }
    }
    this.component.addController(this);
    setParentController(this);
    const manager = this.component.manager;
    const isInControllerManager = manager === void 0;
    if (!isInControllerManager) {
      queueMicrotask(() => this.catchUpLifecycle());
    }
  }
  /**
   * If controller is being added dynamically, after the component
   * construction, then trigger connected and load right away
   */
  catchUpLifecycle() {
    const { manager } = this.component;
    const connectedWillStillHappen = !manager.connectedCalled;
    if (!connectedWillStillHappen && !this.connectedCalled) {
      this.triggerConnected();
    }
    const loadWillStillHappen = !manager._loadCalled;
    if (loadWillStillHappen) {
      return;
    }
    this.triggerLoad().then(() => {
      const loadedWillStillHappen = !manager.loadedCalled;
      if (loadedWillStillHappen) {
        return;
      }
      this.triggerLoaded();
    }).catch(console.error);
  }
  get exports() {
    return this._exports;
  }
  /**
   * Set controller's exports property (for usage with proxyExports()) and mark
   * controller as ready (for usage in other controllers). Also, triggers
   * re-render of the component
   */
  set exports(exports) {
    const oldExports = this._exports;
    if (oldExports !== exports) {
      this._exports = exports;
      this._exportWatchers.forEach(safeCall);
      if (this.connectedCalled && this.assignedProperty !== false) {
        this.component.requestUpdate(this.assignedProperty, oldExports);
      }
    }
    this._ready.resolve(exports);
  }
  setProvisionalExports(exports) {
    this._exports = makeProvisionalValue(exports);
    this._exportWatchers.forEach(safeCall);
  }
  watchExports(callback) {
    const safeCallback = () => callback(this._exports);
    this._exportWatchers.add(safeCallback);
    return () => void this._exportWatchers.delete(safeCallback);
  }
  /**
   * A flexible utility for making sure a controller is loaded before it's used,
   * regardless of how or where a controller was defined:
   *
   * @example
   * makeGenericController(async (component, controller) => {
   *   // Await some controller from the component:
   *   await controller.use(component.someController);
   *   // Initialize new controllers
   *   await controller.use(load(importCoreReactiveUtils));
   *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
   *   await controller.use(someController(component));
   * });
   *
   * @remarks
   * If your controller is not async, and you are not creating it async, then
   * you are not required to use controller.use - you can use it directly.
   * Similarly, accessing controllers after componentWillLoad callback does not
   * require awaiting them as they are guaranteed to be loaded by then.
   */
  get use() {
    setAmbientComponent(this.component);
    return use;
  }
  /**
   * Just like controller.use, but returns the controller itself, rather than it's
   * exports
   *
   * Use cases:
   * - You have a controller and you want to make sure it's loaded before you
   *   try to use it
   * - Your controller is not using exports, so you wish to access some props on
   *   it directly
   * - You have a controller exports only, and you want to retrieve the
   *   controller itself. This is useful if you wish to call .watchExports() or
   *   some other method on the controller
   */
  get useRef() {
    setAmbientComponent(this.component);
    return useRef;
  }
  /**
   * Like useRef, but doesn't wait for the controller to get ready
   *
   * @internal
   */
  get useRefSync() {
    setAmbientComponent(this.component);
    return useRefSync;
  }
  controllerRemoved() {
    if (this.component.el.isConnected) {
      this.triggerDisconnected();
    }
    this.triggerDestroy();
  }
  // Register a lifecycle callback
  onConnected(callback) {
    this._callbacks.hostConnected.push(callback);
  }
  onDisconnected(callback) {
    this._callbacks.hostDisconnected.push(callback);
  }
  onLoad(callback) {
    this._callbacks.hostLoad.push(callback);
  }
  onLoaded(callback) {
    this._callbacks.hostLoaded.push(callback);
  }
  onUpdate(callback) {
    this._callbacks.hostUpdate.push(callback);
  }
  onUpdated(callback) {
    this._callbacks.hostUpdated.push(callback);
  }
  onDestroy(callback) {
    if (process.env.NODE_ENV !== "production") {
      this.component.manager.ensureHasDestroy?.();
    }
    this._callbacks.hostDestroy.push(callback);
  }
  onLifecycle(callback) {
    this._callbacks.hostLifecycle.push(callback);
    if (this.connectedCalled && this.component.el.isConnected) {
      this._callLifecycle(callback);
    }
  }
  // Call each lifecycle hook
  /** @internal */
  triggerConnected() {
    const genericController = this;
    if (genericController.hostConnected) {
      safeCall(genericController.hostConnected, genericController);
    }
    this._callbacks.hostConnected.forEach(safeCall);
    this.triggerLifecycle();
    this.connectedCalled = true;
  }
  /** @internal */
  triggerDisconnected() {
    const genericController = this;
    if (genericController.hostDisconnected) {
      safeCall(genericController.hostDisconnected, genericController);
    }
    this._callbacks.hostDisconnected.forEach(safeCall);
    this._lifecycleCleanups.forEach(safeCall);
    this._lifecycleCleanups = [];
  }
  /** @internal */
  async triggerLoad() {
    if (this._loadCalled) {
      return;
    }
    this._loadCalled = true;
    const genericController = this;
    if (genericController.hostLoad) {
      await safeAsyncCall(genericController.hostLoad, genericController);
    }
    if (this._callbacks.hostLoad.length > 0) {
      await Promise.allSettled(this._callbacks.hostLoad.map(safeAsyncCall));
    }
    this._ready.resolve(this._exports);
  }
  /** @internal */
  triggerLoaded() {
    if (this.loadedCalled) {
      return;
    }
    const genericController = this;
    if (genericController.hostLoaded) {
      safeCall(genericController.hostLoaded, genericController);
    }
    this._callbacks.hostLoaded.forEach(safeCall);
    this.loadedCalled = true;
  }
  /** @internal */
  triggerUpdate(changedProperties) {
    const genericController = this;
    if (genericController.hostUpdate) {
      safeCall(genericController.hostUpdate, genericController, changedProperties);
    }
    this._callbacks.hostUpdate.forEach(callUpdate, changedProperties);
  }
  /** @internal */
  triggerUpdated(changedProperties) {
    const genericController = this;
    if (genericController.hostUpdated) {
      safeCall(genericController.hostUpdated, genericController, changedProperties);
    }
    this._callbacks.hostUpdated.forEach(callUpdate, changedProperties);
  }
  /** @internal */
  triggerDestroy() {
    const genericController = this;
    if (genericController.hostDestroy) {
      safeCall(genericController.hostDestroy, genericController);
    }
    this._callbacks.hostDestroy.forEach(safeCall);
  }
  /** @internal */
  triggerLifecycle() {
    const genericController = this;
    if (genericController.hostLifecycle) {
      this._callLifecycle(() => genericController.hostLifecycle());
    }
    this._callbacks.hostLifecycle.forEach(this._callLifecycle, this);
  }
  _callLifecycle(callback) {
    setAmbientComponent(this.component);
    const cleanupRaw = safeCall(callback);
    const cleanup = Array.isArray(cleanupRaw) ? cleanupRaw : [cleanupRaw];
    cleanup.forEach((cleanup2) => {
      if (typeof cleanup2 === "function") {
        this._lifecycleCleanups.push(cleanup2);
      } else if (typeof cleanup2 === "object" && typeof cleanup2.remove === "function") {
        this._lifecycleCleanups.push(cleanup2.remove);
      }
    });
  }
};
function callUpdate(callback) {
  safeCall(callback, void 0, this);
}
var GenericController = Controller;
function makeProvisionalValue(base) {
  if (typeof base !== "object" && typeof base !== "function" || base === null) {
    return base;
  }
  const proxy = new Proxy(base, {
    get(target, prop, receiver) {
      if (cyclical.has(prop) && prop in target && target[prop] === proxy) {
        return void 0;
      }
      if (prop in target || prop in Promise.prototype || typeof prop === "symbol") {
        return typeof target === "function" ? target[prop] : Reflect.get(target, prop, receiver);
      }
      if (process.env.NODE_ENV !== "production") {
        if (process.env.NODE_ENV === "test" && (prop.startsWith("$$") || prop.startsWith("@@") || prop === "nodeType" || prop === "tagName" || prop === "toJSON" || prop === "hasAttribute")) {
          return;
        }
        console.error(
          `Trying to access "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`
        );
      }
      return void 0;
    },
    set: (target, prop, newValue, receiver) => {
      if (process.env.NODE_ENV !== "production") {
        console.error(`Trying to set "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`);
      }
      return Reflect.set(target, prop, newValue, receiver);
    }
  });
  return proxy;
}
var cyclical = /* @__PURE__ */ new Set(["exports", "_exports"]);
var accessBeforeLoad = process.env.NODE_ENV === "production" ? "" : [
  "This might be the case if you are trying to access an async controller in ",
  "connectedCallback(). Or, if you are using it inside of ",
  "componentWillLoad()/another controller without controller.use. Example correct ",
  "usage:\n",
  "makeController(async (component, controller)=>{ await controller.use(someOtherController); });"
].join("");
function toControllerHost(component) {
  if (process.env.NODE_ENV === "production") {
    return component;
  } else {
    if ("addController" in component) {
      return component;
    } else {
      throw new Error(
        "Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line"
      );
    }
  }
}

// src/trackPropertyKey.ts
import { safeCall as safeCall2 } from "@arcgis/components-utils";
function trackPropertyKey(object, onResolved, defaultValue) {
  const keys = Object.keys(object);
  const keyCount = keys.length;
  if (keyTrackMap === void 0) {
    queueMicrotask(keyTrackResolve);
  }
  keyTrackMap ?? (keyTrackMap = /* @__PURE__ */ new Map());
  let pendingTrackers = keyTrackMap.get(object);
  if (pendingTrackers === void 0) {
    pendingTrackers = { callbacks: [], keyCount };
    keyTrackMap.set(object, pendingTrackers);
  }
  if (pendingTrackers.keyCount !== keyCount) {
    pendingTrackers.callbacks.forEach((resolve) => resolve(keys));
    pendingTrackers.callbacks = [];
    pendingTrackers.keyCount = keyCount;
  }
  pendingTrackers.callbacks.push((keys2) => {
    const callback = (key2) => safeCall2(onResolved, null, key2);
    const key = keys2[keyCount];
    if (key === void 0) {
      callback(void 0);
    } else if (object[key] === defaultValue) {
      callback(key);
    } else {
      callback(void 0);
    }
  });
  return defaultValue;
}
var keyTrackMap = void 0;
function keyTrackResolve() {
  Array.from(keyTrackMap?.entries() ?? []).forEach(([object, { callbacks }]) => {
    const keys = Object.keys(object);
    callbacks.forEach((commit) => commit(keys));
  });
  keyTrackMap = void 0;
}

// src/useWatch.ts
import { safeCall as safeCall3 } from "@arcgis/components-utils";
function watch(component, property, callback) {
  var _a2;
  const genericProperty = property;
  if (process.env.NODE_ENV !== "production") {
    const type = getMemberType(component, genericProperty);
    if (type === void 0) {
      throw new Error(
        component.manager.isLit ? `Trying to watch a non-@property, non-@state property "${genericProperty}". Either convert it into a @state() to be able to use watch() on it, or use the get/set syntax` : `Trying to watch a non-@Prop, non-@State property "${genericProperty}". Convert it into a @State() or @Prop property if you need to use watch() on it`
      );
    }
  }
  const internals = component.manager.internals;
  (_a2 = internals.allWatchers)[genericProperty] ?? (_a2[genericProperty] = []);
  const watchers = internals.allWatchers[genericProperty];
  const genericCallback = callback;
  const safeCallback = (newValue, oldValue, propertyName) => safeCall3(genericCallback, null, newValue, oldValue, propertyName);
  watchers.push(safeCallback);
  return () => {
    const index = watchers.indexOf(safeCallback);
    if (index !== -1) {
      watchers.splice(index, 1);
    }
  };
}

// src/ControllerManager.ts
import { Deferred as Deferred2, safeAsyncCall as safeAsyncCall2, safeCall as safeCall4 } from "@arcgis/components-utils";

// src/ComponentInternals.ts
var ComponentInternals = class {
  constructor(component) {
    /**
     * When watchers are set, they are set into `allWatchers`. When watchers are
     * read in the setter, they are read from `enabledWatchers`.
     *
     * In Stencil, on connectedCallback(), controller manager does
     * `enabledWatchers=allWatchers`. Reasoning:
     * - This disables watchers until connected callback (matches behavior of
     *   Stencil's watchers)
     * - This removes the need for a check in the setter for whether the watchers
     *   were enabled already or not (as getters/setters are hot path, and should
     *   be streamlined)
     *
     * In Lit, we set enabledWatchers to allWatchers in the constructor.
     * Reasoning:
     * - While in Stencil all user provided properties are either set before the
     *   component constructor (this is possible since Stencil's props store is
     *   externalized) or after connectedCallback, in Lit the properties may be
     *   set by attributeChangedCallback before connectedCallback. Thus, we need
     *   to enable watchers even before connectedCallback.
     * - This means, that a watcher set for some prop before your component got
     *   a chance to set the default value will trigger the watcher when the
     *   default value is set - but, that is inline with Lit's willUpdate behavior
     *   of triggering for default values AND, the only way to set a watcher
     *   before default value is if you called watcher inside a controller. For
     *   now, there are no controllers written outside of arcgis-map-components
     *   package, so I was able to verify that this change would have no
     *   negative impact.
     *
     * In either way, I plan to remove watchers from controllers once Stencil
     * support is removed.
     */
    this.enabledWatchers = {};
    this.allWatchers = {};
    /**
     * "readOnly" is not enabled initially since we need to allow to set property
     * default values in the constructor.
     * For Stencil, readonly is enabled by the `readonly()` controller.
     * For Lit, we have the following logic:
     */
    this.enableReadonly = () => {
      this.enableReadonly = void 0;
      if (!this.component.manager.isLit) {
        return;
      }
      const internals = this.component.manager.internals;
      Object.entries(internals.members).forEach(([name2, [type]]) => {
        var _a2;
        const isReadOnly = type & 2048 /* ReadOnly */;
        if (isReadOnly) {
          (_a2 = internals.setters)[name2] ?? (_a2[name2] = []);
          internals.setters[name2].push(internals.readonlySetter);
        }
      });
    };
    this.trackedValue = nothing;
    this.keyTrackers = [];
    this.getters = {};
    this.setters = {};
    this.accessorGetter = {};
    this.accessorSetter = {};
    this.reactiveUtilsIntegrations = /* @__PURE__ */ new Set();
    this._exports = /* @__PURE__ */ new WeakMap();
    this.readonlySetter = (newValue, _oldValue, property) => {
      if (shouldBypass.readOnly) {
        return newValue;
      }
      throw new Error(
        `Cannot assign to read-only property "${property}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(
          newValue
        )}"`
      );
    };
    if (process.env.NODE_ENV === "production") {
      this.component = component;
    } else {
      Object.defineProperty(this, "component", {
        writable: false,
        enumerable: false,
        configurable: true,
        value: component
      });
    }
  }
  firePropTrackers(key, value) {
    const trackers = this.keyTrackers;
    this.trackedValue = nothing;
    this.keyTrackers = [];
    trackers.forEach((tracker) => tracker(key, value));
  }
  // REFACTOR: once Stencil is no longer supported, simplify this with Lit's getPropertyDescriptor(), or https://github.com/shoelace-style/shoelace/issues/1990
  /**
   * Configure a getter or setter for a given \@Prop/\@State
   *
   * Note, since props are defined on the prototype, they are shared between all
   * instances of a component. Thus, instead of passing a reference to the
   * getter/setter function, you should update the
   * ComponentInternals.getters/setters properties, and then call getSetProxy
   * to apply the changes to the prototype
   */
  getSetProxy(property) {
    const component = this.component;
    const classPrototype = component.constructor.prototype;
    this._getSetProxy(classPrototype, property, "class");
    if (component.manager.isLit) {
      return;
    }
    const htmlPrototype = component.el.constructor.prototype;
    if (classPrototype !== htmlPrototype) {
      this._getSetProxy(htmlPrototype, property, "html");
    }
  }
  _getSetProxy(prototype, name2, type) {
    const component = this.component;
    const propType = getMemberType(component, name2);
    let descriptor;
    do {
      descriptor = Object.getOwnPropertyDescriptor(prototype, name2);
    } while (!descriptor && (prototype = Object.getPrototypeOf(prototype)));
    if (process.env.NODE_ENV !== "production") {
      const tolerateNotFound = type === "html";
      if (descriptor?.set === void 0 || descriptor.get === void 0) {
        if (descriptor !== void 0 && "value" in descriptor) {
          throw new Error(
            `getSet() should only be used on @Prop/@property/@State/@state properties. For internal component properties, use regular get/set syntax. Tried to use it on "${name2}" in ${component.el.tagName}`
          );
        } else if (tolerateNotFound) {
          return;
        } else {
          throw new Error(`Unable to find "${name2}" property on the ${component.el.tagName} component`);
        }
      }
      if (propType === void 0) {
        throw new Error("Unable to retrieve prop type");
      }
    } else if (!descriptor) {
      return void 0;
    }
    const originalGet = descriptor.get;
    const originalSet = descriptor.set;
    const isGetterAlreadyOverwritten = customAccessor in originalGet;
    const isSetterAlreadyOverwritten = customAccessor in originalSet;
    if (isGetterAlreadyOverwritten && isSetterAlreadyOverwritten) {
      return;
    }
    const shouldOverwriteGet = !isGetterAlreadyOverwritten;
    const shouldOverwriteSet = !isSetterAlreadyOverwritten;
    const finalGetter = shouldOverwriteGet ? function getter() {
      let value = originalGet.call(this);
      const component2 = elementToInstance.get(this);
      if (shouldBypass.getter || component2 === void 0) {
        return value;
      }
      const internals = component2.manager.internals;
      value = internals.accessorGetter[name2](value, name2);
      const getters = internals.getters[name2] ?? emptyArray;
      for (let i = 0; i < getters.length; i++) {
        value = getters[i](value, name2);
      }
      return value;
    } : originalGet;
    const finalSetter = shouldOverwriteSet ? function setter(rawNewValue) {
      const oldValue = originalGet.call(this);
      const component2 = elementToInstance.get(this);
      if (component2 === void 0) {
        originalSet.call(this, rawNewValue);
        return;
      }
      let newValue = component2.manager.isLit ? (
        /*
         * Cast `null` to `undefined`. Reasons:
         * - component can declare properties simply using
         *   `@property() name?: string;` and get accurate typings,
         *   without being forced to use
         *   `@property() name?: string | Nil;`.
         * - simplifies checks in the code and thus reduces bugs
         */
        rawNewValue ?? void 0
      ) : parsePropertyValue(rawNewValue, propType);
      const internals = component2.manager.internals;
      if (newValue === oldValue) {
        originalSet.call(this, newValue);
      } else {
        const setters = shouldBypass.setter ? emptyArray : internals.setters[name2] ?? emptyArray;
        for (let i = 0; i < setters.length; i++) {
          newValue = setters[i](newValue, oldValue, name2);
          if (newValue === oldValue) {
            break;
          }
        }
        newValue = internals.accessorSetter[name2](newValue, oldValue, name2);
        originalSet.call(this, newValue);
        if (newValue !== oldValue) {
          internals.enabledWatchers[name2]?.forEach((watcher) => watcher(newValue, oldValue, name2));
        }
      }
      if (internals.keyTrackers.length > 0) {
        internals?.firePropTrackers(name2, rawNewValue);
      }
    } : originalSet;
    if (shouldOverwriteGet) {
      finalGetter[customAccessor] = true;
    }
    if (shouldOverwriteSet) {
      finalSetter[customAccessor] = true;
    }
    Object.defineProperty(prototype, name2, {
      ...descriptor,
      get: finalGetter,
      set: finalSetter
    });
  }
  /**
   * Associate an exports object with a controller for reverse lookup in
   * controller.use
   */
  markExports(controller, exports) {
    if (typeof exports === "object" && exports !== null || typeof exports === "function") {
      this._exports.set(exports, controller);
    }
  }
  resolveExports(exports) {
    if (typeof exports === "object" && exports !== null || typeof exports === "function") {
      return this._exports.get(exports);
    } else {
      return void 0;
    }
  }
};
var emptyArray = [];
var customAccessor = Symbol();
var nothing = process.env.NODE_ENV === "production" ? (
  // eslint-disable-next-line symbol-description
  Symbol()
) : Symbol.for(
  // Use Symbol.for in dev mode to make it easier to maintain state when doing HMR.
  `${name}: nothing`
);

// src/ControllerManager.ts
import { devToolsAwareTimeout } from "@arcgis/components-utils";
var useControllerManager = (component, forceUpdate) => new ControllerManager(component, forceUpdate);
var ControllerManager = class extends GenericController {
  constructor(component, forceUpdate) {
    if (process.env.NODE_ENV !== "production") {
      component.el.__component = component;
      ({});
    }
    const isLit = "addController" in component;
    const controllers = /* @__PURE__ */ new Set();
    function addController(controller) {
      controllers.add(controller);
      if (!(controllerSymbol in controller) && component.renderRoot && component.el.isConnected) {
        controller.hostConnected?.();
      }
    }
    function removeController(controller) {
      void controllers.delete(controller);
      controller.controllerRemoved?.();
    }
    const controllerHost = component;
    controllerHost.addController = addController;
    controllerHost.removeController = removeController;
    if (!isLit) {
      const update = forceUpdate ?? component.constructor.__forceUpdate;
      controllerHost.requestUpdate = () => update(component);
    }
    if (process.env.NODE_ENV !== "production") {
      const stencilToLitMapping = {
        componentDidLoad: "loaded",
        componentDidRender: "updated",
        componentDidUpdate: "updated",
        componentShouldUpdate: "shouldUpdate",
        componentWillLoad: "load",
        componentWillRender: "willUpdate",
        componentWillUpdate: "willUpdate"
      };
      Object.entries(stencilToLitMapping).forEach(([stencilMethod, litMethod]) => {
        if (isLit && stencilMethod in component) {
          throw new Error(
            `Unexpected ${stencilMethod}() in a Lit component ${component.el.tagName.toLowerCase()}. In Lit, you should use ${litMethod}() instead`
          );
        }
        if (!isLit && litMethod in component) {
          throw new Error(
            `Unexpected ${litMethod}() in a Stencil component ${component.el.tagName.toLowerCase()}. In Stencil, you should use ${litMethod}() instead`
          );
        }
      });
      if (isLit) {
        let i = 0;
        let isLitElementClass = false;
        for (let prototype = component; !isLitElementClass; i++) {
          if (prototype === null) {
            throw new Error("Expected controllers to be used in a LitElement class");
          }
          if (Object.hasOwn(prototype, "_load")) {
            isLitElementClass = true;
            break;
          }
          prototype = Object.getPrototypeOf(prototype);
        }
        if (i < 1) {
          throw new Error(
            "It looks like you are trying to call useControllerManager in a component that uses LitElement imported from 'lit'. useControllerManager should only be used in the LitElement coming from `@arcgis/lit`"
          );
        }
      }
    }
    super(component);
    /** @internal */
    this.internals = new ComponentInternals(this.component);
    this.destroyed = false;
    this._updatePromise = new Deferred2();
    this._originalLifecycles = {};
    this.isLit = isLit;
    this.component.manager = this;
    retrieveComponentMembers(component, isLit);
    this._controllers = controllers;
    this.exports = void 0;
    this.hasDestroy = autoDestroyDisabledPropName in this.component && typeof this.component.destroy === "function";
    this._bindLifecycleMethods();
    const internals = this.internals;
    Object.keys(internals.members).forEach((name2) => {
      internals.accessorGetter[name2] = defaultGetterSetter;
      internals.accessorSetter[name2] = defaultGetterSetter;
      internals.getSetProxy(name2);
    });
    if (isLit) {
      this.internals.enabledWatchers = this.internals.allWatchers;
    } else {
      Object.defineProperty(component, "updateComplete", {
        get: async () => await this._updatePromise.promise
      });
    }
    queueMicrotask(internals.enableReadonly);
    setParentController(void 0);
    setAmbientComponent(component);
    elementToInstance.set(component.el, component);
    elementToInstance.set(component, component);
  }
  _bindLifecycleMethods() {
    const component = this.component;
    const isLit = this.isLit;
    const isStencilDistBuild = component.el === component;
    this._originalLifecycles = {
      // These component's callbacks will be called by Lit, so we don't have to
      _connectedCallback: isLit || isStencilDistBuild ? void 0 : component.connectedCallback,
      _disconnectedCallback: isLit || isStencilDistBuild ? void 0 : component.disconnectedCallback,
      _load: isLit ? component.load : component.componentWillLoad,
      _loaded: isLit ? component.loaded : component.componentDidLoad,
      _willUpdate: isLit ? void 0 : component.componentWillUpdate,
      _updated: isLit ? void 0 : component.componentDidUpdate,
      _destroy: component.destroy
    };
    const hostConnected = this._connectedCallback.bind(this);
    const hostDisconnected = this._disconnectedCallback.bind(this);
    const hostUpdate = this._update.bind(this);
    const hostUpdated = this._updated.bind(this);
    if (isLit) {
      component.constructor.prototype.addController.call(component, {
        // Lit will call these callbacks
        hostConnected,
        hostDisconnected,
        hostUpdate,
        hostUpdated
      });
    } else {
      component.connectedCallback = hostConnected;
      component.disconnectedCallback = hostDisconnected;
      component.componentWillLoad = this._load.bind(this);
      component.componentDidLoad = this._loaded.bind(this);
      component.componentWillUpdate = hostUpdate;
      component.componentDidUpdate = hostUpdated;
    }
    if (this.hasDestroy) {
      component.destroy = this.destroy.bind(this);
    }
  }
  /**
   * Private because this is not supposed to be called by Component directly.
   * Instead, _bindLifecycleMethods will take care of that. Otherwise, you risk
   * calling lifecycle methods twice.
   *
   * @internal
   */
  _connectedCallback() {
    if (this.destroyed) {
      const tagName = this.component.el.tagName.toLowerCase();
      this.component.el.remove();
      throw new Error(
        `The ${tagName} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the ${autoDestroyDisabledPropName} prop.`
      );
    }
    if (this._autoDestroyTimeout !== void 0) {
      clearTimeout(this._autoDestroyTimeout);
    }
    const internals = this.internals;
    internals.enabledWatchers = internals.allWatchers;
    keyTrackResolve();
    internals.enableReadonly?.();
    this._controllers.forEach(callConnected);
    this._originalLifecycles._connectedCallback?.call(this.component);
    if (process.env.NODE_ENV !== "production") {
      devOnlySetPersistentControllerData?.(this, true);
    }
  }
  /** @internal */
  _disconnectedCallback() {
    if (this.destroyed) {
      return;
    }
    this._controllers.forEach(callDisconnected);
    this._originalLifecycles._disconnectedCallback?.call(this.component);
    if (this.hasDestroy) {
      this._setAutoDestroyTimeout();
    }
  }
  /** @internal */
  async _load() {
    const integrations = this.internals.reactiveUtilsIntegrations;
    if (integrations.size > 0) {
      for (const controller of integrations) {
        if ("triggerLoad" in controller) {
          await controller.triggerLoad();
        } else {
          await safeAsyncCall2(controller.hostLoad, controller);
        }
      }
    }
    await Promise.allSettled(Array.from(this._controllers, callLoad, integrations));
    await this._originalLifecycles._load?.call(this.component);
    if (this.hasDestroy) {
      watch(this.component, autoDestroyDisabledPropName, () => this._setAutoDestroyTimeout());
    }
  }
  /** @internal */
  _loaded() {
    this._controllers.forEach(callLoaded);
    this._originalLifecycles._loaded?.call(this.component);
  }
  _update() {
    const changedProperties = this.component.changedProperties;
    this._controllers.forEach(callUpdate2, changedProperties);
    this._originalLifecycles._willUpdate?.call(this.component);
  }
  _updated() {
    const maybeLitComponent = this.component;
    this._controllers.forEach(callUpdated, maybeLitComponent.changedProperties);
    this._originalLifecycles._updated?.call(this.component);
    if (this.isLit) {
      maybeLitComponent.changedProperties = /* @__PURE__ */ new Map();
    } else {
      const updatePromise = this._updatePromise;
      this._updatePromise = new Deferred2();
      updatePromise.resolve(true);
    }
  }
  async destroy() {
    if (process.env.NODE_ENV !== "production") {
      this.ensureHasDestroy?.();
    }
    if (this.destroyed) {
      return;
    }
    if (this.component.el.isConnected) {
      this.hasDestroy = false;
      try {
        this.component.el.remove();
      } finally {
        this.hasDestroy = true;
      }
    }
    this._autoDestroyTimeout = void 0;
    this.destroyed = true;
    this._controllers.forEach(callDestroy);
    this._controllers.clear();
    await this._originalLifecycles._destroy?.call(this.component);
  }
  _setAutoDestroyTimeout() {
    if (this._autoDestroyTimeout !== void 0) {
      clearTimeout(this._autoDestroyTimeout);
    }
    if (!this.component.el.isConnected && !this.component.autoDestroyDisabled) {
      const destroy = () => void this.destroy().catch(console.error);
      if (process.env.NODE_ENV !== "production" && autoDestroyOnDisconnectTimeout === 0) {
        queueMicrotask(destroy);
      } else {
        this._autoDestroyTimeout = devToolsAwareTimeout(destroy, autoDestroyOnDisconnectTimeout);
      }
    }
  }
};
if (process.env.NODE_ENV !== "production") {
  ControllerManager.prototype.ensureHasDestroy = function ensureHasDestroy() {
    if (!this.hasDestroy) {
      throw new Error(
        `
          If the component uses a controller that uses destroy() method, then the
          component must have the following properties:
          /**
           * If true, the component will not be destroyed automatically when it is
           * disconnected from the document. This is useful when you want to move the
           * component to a different place on the page, or temporary hide it. If this
           * is set, make sure to call the \`destroy\` method when you are done to prevent
           * memory leaks.
           */
          @Prop() ${autoDestroyDisabledPropName} = false;
          
          /** Permanently destroy the component */
          @Method()
          async destroy(): Promise<void> {
            await this.manager.destroy();
          }
          `.trim().split("\n").map((line) => line.trim()).join("\n")
      );
    }
  };
}
var autoDestroyDisabledPropName = "autoDestroyDisabled";
var autoDestroyOnDisconnectTimeout = 1e3;
var exportsForTests = process.env.NODE_ENV === "production" ? void 0 : {
  setAutoDestroyOnDisconnectTimeout: (timeout) => {
    autoDestroyOnDisconnectTimeout = timeout;
  }
};
var defaultGetterSetter = (value) => value;
function callConnected(controller) {
  if ("triggerConnected" in controller) {
    controller.triggerConnected();
  } else {
    safeCall4(controller.hostConnected, controller);
  }
}
function callDisconnected(controller) {
  if ("triggerDisconnected" in controller) {
    controller.triggerDisconnected();
  } else {
    safeCall4(controller.hostDisconnected, controller);
  }
}
async function callLoad(controller) {
  if (!this.has(controller)) {
    if ("triggerLoad" in controller) {
      await controller.triggerLoad();
    } else {
      await safeAsyncCall2(controller.hostLoad, controller);
    }
  }
}
function callLoaded(controller) {
  if ("triggerLoaded" in controller) {
    controller.triggerLoaded();
  } else {
    safeCall4(controller.hostLoaded, controller);
  }
}
function callUpdate2(controller) {
  if ("triggerUpdate" in controller) {
    controller.triggerUpdate(this);
  } else {
    safeCall4(controller.hostUpdate, controller, this);
  }
}
function callUpdated(controller) {
  if ("triggerUpdated" in controller) {
    controller.triggerUpdated(this);
  } else {
    safeCall4(controller.hostUpdated, controller, this);
  }
}
function callDestroy(controller) {
  if ("triggerDestroy" in controller) {
    controller.triggerDestroy();
  } else {
    safeCall4(controller.hostDestroy, controller);
  }
}

// src/trackPropKey.ts
import { safeCall as safeCall5 } from "@arcgis/components-utils";
function trackPropKey(component, onResolved, defaultValue) {
  const internals = component.manager.internals;
  if (internals.trackedValue !== nothing && internals.trackedValue !== defaultValue) {
    internals.firePropTrackers(void 0, void 0);
  }
  if (internals.keyTrackers.length === 0) {
    queueMicrotask(() => internals.firePropTrackers(void 0, void 0));
  }
  internals.trackedValue = defaultValue;
  internals.keyTrackers.push((key, value) => safeCall5(onResolved, void 0, defaultValue === value ? key : void 0));
  return defaultValue;
}

// src/trackKey.ts
function trackKey(hostsCandidates, onResolved, defaultValue) {
  const candidateHosts = Array.isArray(hostsCandidates) ? hostsCandidates : [hostsCandidates];
  let leftToResolve = candidateHosts.length + 1;
  const resolved = (resolution) => {
    leftToResolve -= 1;
    if (resolution !== void 0) {
      leftToResolve = 0;
    }
    if (leftToResolve === 0) {
      onResolved(resolution);
    }
  };
  candidateHosts.forEach(
    (host) => trackPropertyKey(
      host,
      (key) => resolved(
        key === void 0 ? void 0 : {
          key,
          host,
          isReactive: false
        }
      ),
      defaultValue
    )
  );
  const component = candidateHosts.find(
    (host) => "manager" in host && typeof host.manager === "object" && host.manager.component === host
  );
  if (component) {
    trackPropKey(
      component,
      (key) => resolved(
        key === void 0 ? void 0 : {
          key,
          host: component,
          isReactive: getMemberType(component, key) !== void 0
        }
      ),
      defaultValue
    );
  }
  return defaultValue;
}

// src/getSet.ts
function getSet(defaultValue, getSet2) {
  const component = retrieveComponent();
  return trackPropKey(
    component,
    (rawName) => {
      if (process.env.NODE_ENV !== "production" && rawName === void 0) {
        throw new Error(
          "Unable to resolve get/set's prop name. Make sure you are using it like @Prop() someProp = getSet(defaultValue,{get,set})"
        );
      }
      const name2 = rawName;
      const manager = component.manager;
      const genericComponent = component;
      const value = genericComponent[name2];
      const isStencilHotReload = process.env.NODE_ENV !== "production" && !manager.isLit && devOnlyGetPersistentControllerData?.(manager) === true;
      if (value != null && value !== defaultValue && typeof getSet2.set === "function" && !isStencilHotReload) {
        const newValue = getSet2.set(value, defaultValue, name2);
        if (newValue !== value) {
          if (manager.isLit) {
            genericComponent[name2] = newValue;
          } else {
            let firstConnected = true;
            manager.onConnected(() => {
              if (!firstConnected) {
                return;
              }
              firstConnected = true;
              bypassSetter(() => {
                genericComponent[name2] = newValue;
              });
            });
          }
        }
      }
      genericGetSet(component, name2, getSet2);
    },
    defaultValue
  );
}
var dynamicGetSet = (component, property, getSet2) => genericGetSet(component, property, getSet2);
function bypassSetter(callback) {
  shouldBypass.setter = true;
  try {
    return callback();
  } finally {
    shouldBypass.setter = false;
  }
}
function bypassGetter(callback) {
  shouldBypass.getter = true;
  try {
    return callback();
  } finally {
    shouldBypass.getter = false;
  }
}
function genericGetSet(component, property, getSet2) {
  var _a2, _b;
  const genericGetSet2 = getSet2;
  const internals = component.manager.internals;
  const get = typeof genericGetSet2.get === "function" ? genericGetSet2.get : void 0;
  if (get) {
    (_a2 = internals.getters)[property] ?? (_a2[property] = []);
    internals.getters[property].unshift(get);
  }
  const set = genericGetSet2.set === "ignore" ? ignoreSet : genericGetSet2.set;
  if (set) {
    (_b = internals.setters)[property] ?? (_b[property] = []);
    internals.setters[property].unshift(
      set
    );
  }
}
var ignoreSet = (_, value) => value;

// src/readonly.ts
function readonly(value) {
  const component = retrieveComponent();
  return getSet(value, { set: component.manager.internals.readonlySetter });
}
function bypassReadOnly(callback) {
  shouldBypass.readOnly = true;
  try {
    return callback();
  } finally {
    shouldBypass.readOnly = false;
  }
}

// src/proxyExports.ts
var proxyExports = (Class) => (...args) => {
  const ambientControllers2 = retrieveParentControllers();
  const instance = new Class(...args);
  const initialExports = instance.exports;
  setParentController(ambientControllers2.at(-1));
  const internals = instance.component.manager.internals;
  internals.markExports(instance, initialExports);
  instance.watchExports((exports) => internals.markExports(instance, exports));
  setAmbientChildController(instance);
  const hostCandidates = [instance.component, ...ambientControllers2].reverse();
  return trackKey(
    hostCandidates,
    (resolution) => resolution === void 0 ? void 0 : setProxy(instance, resolution, initialExports),
    initialExports
  );
};
function setProxy(controller, { host, key, isReactive: assignedToProp }, initialExports) {
  const genericHost = host;
  const controllerValueChanged = genericHost[key] !== controller.exports;
  const hostValueChanged = genericHost[key] !== initialExports;
  const controllerUpdatedExports = initialExports !== controller.exports;
  if (controllerValueChanged && !hostValueChanged && controllerUpdatedExports) {
    genericHost[key] = controller.exports;
  }
  const isProxyExportsOnComponent = host === controller.component;
  if (isProxyExportsOnComponent) {
    if (assignedToProp) {
      const internals = controller.component.manager.internals;
      if (hostValueChanged) {
        internals.markExports(controller, genericHost[key]);
      }
      watch(controller.component, key, (value) => {
        if (value !== controller.exports) {
          internals.markExports(controller, value);
        }
      });
    }
    controller.assignedProperty = assignedToProp ? void 0 : key;
  }
  controller.watchExports(() => {
    if (genericHost[key] === controller.exports) {
      return;
    }
    const manager = controller.component.manager;
    const isReadOnly = manager.internals.setters[key]?.includes(manager.internals.readonlySetter);
    if (isReadOnly) {
      bypassReadOnly(() => {
        genericHost[key] = controller.exports;
      });
    } else {
      genericHost[key] = controller.exports;
    }
  });
}

export {
  controllerSymbol,
  isController,
  devOnlySetPersistentControllerData,
  devOnlyGetPersistentControllerData,
  setAmbientComponent,
  retrieveComponent,
  setParentController,
  retrieveParentControllers,
  Controller,
  GenericController,
  trackPropertyKey,
  watch,
  useControllerManager,
  defaultGetterSetter,
  trackPropKey,
  trackKey,
  getSet,
  dynamicGetSet,
  bypassSetter,
  bypassGetter,
  readonly,
  bypassReadOnly,
  proxyExports
};
