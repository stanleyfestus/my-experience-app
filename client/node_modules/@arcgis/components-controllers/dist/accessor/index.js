import {
  Controller,
  GenericController,
  bypassGetter,
  bypassSetter,
  defaultGetterSetter,
  devOnlyGetPersistentControllerData,
  devOnlySetPersistentControllerData,
  proxyExports,
  retrieveComponent,
  trackKey,
  trackPropKey,
  trackPropertyKey
} from "../chunk-HOKLTU7K.js";
import "../chunk-KU4RC64P.js";

// src/accessor/utils.ts
import { importCoreReactiveUtils } from "@arcgis/core-adapter";
var reactiveUtils;
async function loadReactiveUtils() {
  reactiveUtils ?? (reactiveUtils = importCoreReactiveUtils());
  return await reactiveUtils;
}

// src/accessor/useAccessor.ts
import { camelToKebab, isNotUndefined } from "@arcgis/components-utils";

// src/accessor/reactiveUtilsIntegration.ts
import { importCoreAccessor, importCoreAccessorSupportDecorators } from "@arcgis/core-adapter";
function useReactiveUtilsIntegration() {
  const component = retrieveComponent();
  component.manager.internals.reactiveUtilsIntegrations.add(new ReactiveUtilsIntegration(component));
}
var accessorPromise = Promise.all([importCoreAccessor(), importCoreAccessorSupportDecorators()]);
var ReactiveUtilsIntegration = class extends Controller {
  async hostLoad() {
    const [Accessor, { subclass, property }] = await accessorPromise;
    class AccessorSubclass extends Accessor {
    }
    const getter = (_value, propertyName) => accessor[propertyName];
    function setter(newValue, _oldValue, propertyName) {
      if (accessor !== void 0) {
        accessor[propertyName] = newValue;
      }
      return newValue;
    }
    const component = this.component;
    const internals = component.manager.internals;
    const enabledMembers = [];
    bypassGetter(
      () => Object.keys(internals.members).forEach((name) => {
        const alreadyIntegrated = internals.accessorSetter[name] !== defaultGetterSetter;
        if (alreadyIntegrated) {
          return;
        }
        enabledMembers.push(name);
        internals.accessorGetter[name] = getter;
        internals.accessorSetter[name] = setter;
        property({
          value: component[name]
        })(AccessorSubclass.prototype, name);
      })
    );
    this._enabledMembers = enabledMembers;
    if (enabledMembers.length === 0) {
      return;
    }
    const Subclass = subclass(component.el.tagName)(AccessorSubclass);
    const accessor = new Subclass();
    this._instance = accessor;
  }
  controllerRemoved() {
    super.controllerRemoved();
    const internals = this.component.manager.internals;
    this._instance?.destroy();
    this._enabledMembers?.forEach((name) => {
      internals.accessorGetter[name] = defaultGetterSetter;
      internals.accessorSetter[name] = defaultGetterSetter;
    });
  }
};

// src/accessor/useAccessor.ts
var makeAccessorController = (loadAccessor, _options) => (component, options) => proxy(component, loadAccessor, options);
var AccessorController = class extends GenericController {
  constructor(component, _loadAccessor, _options) {
    super(component);
    this._loadAccessor = _loadAccessor;
    this._options = _options;
    // A mapping from bound component's "prop" name to Accessor instance's "property"
    this._watchedProperties = /* @__PURE__ */ new Map();
    this._isBinding = { value: true };
    this.setProvisionalExports(
      accessorSupport.makeGetterProxy(
        component,
        this._watchedProperties,
        this._isBinding,
        this.constructor.allowedPropNameMismatches
      )
    );
    const integrations = component.manager.internals.reactiveUtilsIntegrations;
    integrations.add(this);
    const reactiveUtilsIntegration = Array.from(integrations).find(
      (integration) => integration instanceof ReactiveUtilsIntegration
    );
    if (reactiveUtilsIntegration) {
      integrations.delete(reactiveUtilsIntegration);
    }
    integrations.add(reactiveUtilsIntegration ?? new ReactiveUtilsIntegration(this.component));
    trackPropKey(
      component,
      (resolved) => {
        if (resolved) {
          this._instancePropName = resolved;
        }
      },
      this.exports
    );
  }
  hostConnected() {
    this._isBinding.value = false;
  }
  async hostLoad() {
    this.reactiveUtils = await loadReactiveUtils();
    const component = this.component;
    const parameters = this._gatherParameters();
    const finalParameters = this._options?.editConstructorProperties?.call(component, parameters) ?? parameters;
    const awaitedParameters = finalParameters instanceof Promise ? await finalParameters : finalParameters;
    const genericComponent = component;
    const existingInstance = typeof this._instancePropName === "string" ? genericComponent[this._instancePropName] : void 0;
    const hasInstance = existingInstance != null && existingInstance !== this.exports;
    if (hasInstance) {
      this._instance = existingInstance;
      existingInstance.set(awaitedParameters);
    } else {
      this._instance = await this._createInstance(awaitedParameters);
    }
    if (component.manager.destroyed) {
      return;
    }
    accessorSupport.watchComponentUpdates(this, this._instance, this._watchedProperties);
    accessorSupport.watchAccessorUpdates(this, this._instance, this._watchedProperties);
    this.exports = this._instance;
  }
  _gatherParameters() {
    const data = Object.fromEntries(
      Array.from(
        this._watchedProperties,
        ([prop, property]) => [property, this.component[prop]]
      ).filter(([, value]) => value !== void 0)
    );
    const props = process.env.NODE_ENV === "production" ? data : filterWatchedProperties?.(this, data) ?? data;
    return props;
  }
  async _createInstance(parameters) {
    if (this._isAccessorConstructor(this._loadAccessor)) {
      return new this._loadAccessor(parameters);
    } else {
      return await this._loadAccessor(parameters);
    }
  }
  _isAccessorConstructor(loader) {
    return "prototype" in loader && "declaredClass" in loader.prototype;
  }
  hostDestroy() {
    if (this._instance) {
      this._instance.destroy();
    }
  }
  async reCreate() {
    this.hostDestroy();
    await this.hostLoad();
  }
};
var proxy = proxyExports(AccessorController);
var accessorSupport = {
  makeGetterProxy: (component, watchedProperties, isBinding, allowedPropNameMismatches) => new Proxy(
    {},
    {
      /*
       * Without this, makeProvisionalValue() will throw on accessing
       * non-existent prop
       */
      has: (target, prop) => typeof prop === "string" || prop in target,
      get: (target, prop) => {
        const value = Reflect.get(target, prop);
        if (typeof prop === "symbol" || prop in Promise.prototype) {
          return value;
        }
        const hasProp = prop in target;
        const doBinding = isBinding?.value ?? true;
        if (hasProp || !doBinding) {
          return value;
        }
        if (process.env.NODE_ENV !== "production" && watchedProperties.has(prop) && !component.manager.isLit) {
          throw new Error(
            `Tried to bind "${prop.toString()}" prop twice. This might also happen if you are trying to access the accessor instance before ${component.manager.isLit ? "load" : "componentWillLoad"}()`
          );
        }
        return trackKey(
          component,
          (resolved) => {
            if (process.env.NODE_ENV !== "production") {
              if (resolved === void 0) {
                if (component.manager.isLit) {
                  return;
                }
                throw new Error(
                  `Unable to resolve what property is "${prop.toString()}" being bound too. Check documentation for useAccessor to ensure proper usage. Make sure you are not trying to access the accessor instance before ${component.manager.isLit ? "load" : "componentWillLoad"}()`
                );
              }
              const isFlippingBoolean = resolved.key.toLowerCase().includes("disable");
              const collidesWithNativeProp = prop in HTMLElement.prototype;
              const collidesWithCustomProp = allowedPropNameMismatches?.has(prop) === true;
              if (resolved.key !== prop && !collidesWithNativeProp && !collidesWithCustomProp && !isFlippingBoolean) {
                throw new Error(
                  `Tried to bind "${resolved?.key}" property to "${prop.toString()}" - property names must match`
                );
              }
              if (!resolved.isReactive) {
                throw new Error(
                  component.manager.isLit ? `For two-way binding with Accessor to work, the property on your component must have @property() or @state() decorator. "${prop.toString()}" has neither` : `For two-way binding with Accessor to work, the property on your component must have @Prop() or @State() decorator. "${prop.toString()}" has neither`
                );
              }
            }
            if (resolved !== void 0) {
              watchedProperties.set(resolved.key, prop);
            }
          },
          value
        );
      }
    }
  ),
  // Update Accessor on component prop change
  watchComponentUpdates(controller, instance, watchedProperties) {
    function getter(_value, propName) {
      const propertyName = watchedProperties.get(propName);
      const value = instance[propertyName];
      const flipBoolean = typeof value === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
      return flipBoolean ? !value : value;
    }
    const setter = (newValue, _oldValue, propName) => {
      const propertyName = watchedProperties.get(propName);
      const value = instance[propertyName];
      const flipBoolean = typeof value === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
      const currentValue = flipBoolean ? !value : value;
      if (currentValue === newValue) {
        return newValue;
      }
      instance[propertyName] = flipBoolean ? !newValue : newValue;
      const finalValue = instance[propertyName];
      return flipBoolean ? !finalValue : finalValue;
    };
    const component = controller.component;
    const internals = component.manager.internals;
    watchedProperties.forEach((_propName, propertyName) => {
      internals.accessorGetter[propertyName] = getter;
      internals.accessorSetter[propertyName] = setter;
    });
  },
  // Update component on Accessor prop change
  watchAccessorUpdates(controller, instance, watchedProperties) {
    const { component } = controller;
    const genericComponent = component;
    const genericInstance = instance;
    const readonlyProps = findReadOnlyAccessorProps(instance);
    if (process.env.NODE_ENV !== "production") {
      setReadonlyProps?.(controller, readonlyProps);
    }
    bypassGetter(
      () => (
        // Careful: Map's forEach callback arguments are (value, key), not (key, value)
        watchedProperties.forEach((propertyName, propName) => {
          if (process.env.NODE_ENV !== "production" && !(propertyName in instance)) {
            throw new Error(`"${propertyName}" does not exist on the accessor instance`);
          }
          if (readonlyProps.has(propertyName)) {
            return;
          }
          const domValue = genericComponent[propName];
          const modelValue = genericInstance[propertyName];
          const flipBoolean = typeof domValue === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
          const resolvedDomValue = flipBoolean ? !domValue : domValue;
          if (resolvedDomValue != null && modelValue !== resolvedDomValue) {
            genericInstance[propertyName] = resolvedDomValue;
          }
        })
      )
    );
    controller.onLifecycle(() => {
      if (instance.destroyed) {
        return;
      }
      return Array.from(
        watchedProperties,
        ([propName, propertyName]) => controller.reactiveUtils.watch(
          () => genericInstance[propertyName],
          () => {
            const newValue = genericInstance[propertyName];
            const flipBoolean = typeof newValue === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
            const resolvedNewValue = flipBoolean ? !newValue : newValue;
            bypassSetter(() => {
              genericComponent[propName] = resolvedNewValue;
            });
          },
          { initial: true }
        )
      );
    });
  },
  // REFACTOR: remove this once Stencil is no longer supported
  reEmitAccessorEvents(controller, instance, reactiveUtils2, prefix) {
    const isEvented = "on" in instance && typeof instance.on === "function";
    if (!isEvented) {
      return;
    }
    const toListen = Object.entries(controller.component).map(([key, unknown]) => {
      const value = unknown;
      if (!key.startsWith(prefix) || key === prefix || typeof value !== "object" || value === null || !("emit" in value) || typeof value.emit !== "function") {
        return void 0;
      }
      const emit = value.emit;
      const trimmedEventName = key.slice(prefix.length);
      const camelCaseEventName = camelToKebab(trimmedEventName);
      const eventName = camelCaseEventName.toLowerCase();
      return [eventName, emit];
    }).filter(isNotUndefined);
    if (toListen.length === 0) {
      return;
    }
    const eventTarget = instance;
    const getEventTarget = () => eventTarget;
    controller.onLifecycle(() => {
      if (instance.destroyed) {
        return;
      }
      return toListen.map(([eventName, emit]) => reactiveUtils2.on(getEventTarget, eventName, emit));
    });
  },
  async reCreate(instance, component) {
    const accessorController = component.manager.useRefSync(instance);
    if (accessorController === void 0) {
      if (process.env.NODE_ENV !== "production") {
        console.error("Unable to resolve the useAccessor controller from the provided value");
      }
      return;
    }
    await accessorController.reCreate();
  }
};
function findReadOnlyAccessorProps(instance) {
  const accessor = instance;
  const properties = Object.entries(accessor.__accessor__?.metadata ?? {});
  return new Set(
    properties.filter(([_property, descriptor]) => descriptor?.readOnly === true).map(([property]) => property)
  );
}
var setReadonlyProps = process.env.NODE_ENV === "production" ? void 0 : (controller, properties) => {
  devOnlySetPersistentControllerData?.(controller, properties);
};
var filterWatchedProperties = process.env.NODE_ENV === "production" ? void 0 : (controller, data) => {
  const readonlyProperties = devOnlyGetPersistentControllerData?.(controller);
  if (readonlyProperties instanceof Set) {
    return Object.fromEntries(Object.entries(data).filter(([key]) => !readonlyProperties.has(key)));
  }
  return data;
};

// src/accessor/reEmitEvent.ts
function reEmitEvent(getEventedAccessor, eventName) {
  const component = retrieveComponent();
  if (process.env.NODE_ENV !== "production" && !component.manager.isLit) {
    throw new Error(
      "reEmitEvent is only supported in Lit components. Consult documentation for equivalent Stencil pattern."
    );
  }
  let emitter;
  const reactiveUtils2 = loadReactiveUtils();
  const manager = component.manager;
  manager.onLoaded(() => {
    void reactiveUtils2.then(
      (reactiveUtils3) => manager.onLifecycle(() => reactiveUtils3.on(getEventedAccessor, eventName, emitter.emit))
    );
  });
  return trackPropertyKey(
    component,
    (propertyKey) => {
      if (process.env.NODE_ENV !== "production" && propertyKey === void 0) {
        throw new Error(
          'Unable to resolve what property name reEmitEvent() was assigned to. Make sure you are using it like `arcgisGo = reEmitEvent<__esri.HomeViewModelGoEvent>(() => this.viewModel, "go");`'
        );
      }
      emitter = component.constructor.createEvent(
        eventName,
        void 0,
        component
      );
      if (process.env.NODE_ENV !== "production") {
        if (typeof emitter !== "object" || emitter === null || !("emit" in emitter) || typeof emitter.emit !== "function") {
          throw new Error(`Expected to find createEvent static property on ArcGIS Lit's LitElement`);
        }
      }
    },
    void 0
  );
}
export {
  AccessorController,
  accessorSupport,
  makeAccessorController,
  reEmitEvent,
  useReactiveUtilsIntegration
};
