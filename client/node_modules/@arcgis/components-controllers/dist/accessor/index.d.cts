import { d as GenericController, B as BaseComponent, b as Controller, h as LitEventEmitter } from '../Controller-bXH9rI0X.cjs';
import '@arcgis/components-utils';
import '@stencil/core';
import 'lit';
import '@stencil/core/internal';

/**
 * Do two-way binding between an instance of an Accessor and component's
 * properties
 */

type Requires<Props, Accessor extends __esri.Accessor> = BaseComponent & Pick<Accessor, keyof Accessor & keyof Props> & {
    reactiveUtils?: typeof __esri.reactiveUtils;
    autoDestroyDisabled: boolean;
    destroy: () => Promise<void>;
};
/**
 * Given an Accessor class, create a controller that will do two-way binding of
 * props between the component and the Accessor
 *
 * See 4.accessor.tsx for documentation & examples
 */
declare const makeAccessorController: <Props, Accessor extends __esri.Accessor, OmitProps extends string = never>(loadAccessor: ((props: Props) => Accessor | Promise<Accessor>) | (new (props: Props) => Accessor), _options?: {
    /**
     * Don't expose the following Widget's properties on the component.
     * You can also bind the property to \@State rather than \@Prop if you
     * wish to use it internally only:
     * @example
     * \@State() timeZone = this.widget.timeZone;
     */
    omitProps: OmitProps[];
}) => (component: Requires<Omit<Props, OmitProps>, Accessor>, options?: {
    editConstructorProperties(props: Props): Promise<Props> | Props;
}) => Accessor;
declare class AccessorController<Props, Accessor extends __esri.Accessor, ExtraRequires = Record<never, never>> extends GenericController<Accessor, ExtraRequires & Requires<Props, Accessor>> {
    private _loadAccessor;
    private _options?;
    reactiveUtils: __esri.reactiveUtils;
    protected _instance: Accessor;
    protected _watchedProperties: Map<string, string & keyof Props>;
    private _instancePropName;
    private _isBinding;
    /**
     * (development only) Allow these props to mismatch the name of the Accessor's property
     * to avoid collisions
     *
     * @internal
     */
    static allowedPropNameMismatches?: Set<string>;
    constructor(component: ExtraRequires & Requires<Props, Accessor>, _loadAccessor: ((props: Props) => Accessor | Promise<Accessor>) | (new (props: Props) => Accessor), _options?: {
        editConstructorProperties?(props: Props): Promise<Props> | Props;
    } | undefined);
    hostConnected(): void;
    hostLoad(): Promise<void>;
    private _gatherParameters;
    private _createInstance;
    private _isAccessorConstructor;
    hostDestroy(): void;
    reCreate(): Promise<void>;
}
declare const accessorSupport: {
    makeGetterProxy: (component: BaseComponent, watchedProperties: Map<string, string>, isBinding?: {
        value: boolean;
    }, allowedPropNameMismatches?: Set<string>) => unknown;
    watchComponentUpdates<T>(controller: Controller<T> & {
        reactiveUtils: __esri.reactiveUtils;
    }, instance: __esri.Accessor, watchedProperties: Map<string, string>): void;
    watchAccessorUpdates<T_1>(controller: Controller<T_1> & {
        reactiveUtils: __esri.reactiveUtils;
    }, instance: __esri.Accessor, watchedProperties: Map<string, string>): void;
    reEmitAccessorEvents<T_2>(controller: Controller<T_2>, instance: __esri.Accessor, reactiveUtils: __esri.reactiveUtils, prefix: string): void;
    reCreate(instance: __esri.Accessor, component: BaseComponent): Promise<void>;
};

/**
 * Re-emit an event from the accessor instance on the component
 *
 * @example
 * ```tsx
 * arcgisGo = reEmitEvent<__esri.HomeViewModelGoEvent>(() => this.viewModel, "go");
 * ```
 *
 * @remarks
 * `reEmitEvent()` only works in Lit. Consult documentation for equivalent
 * Stencil pattern.
 */
declare function reEmitEvent<T>(getEventedAccessor: () => __esri.Evented, eventName: string): CustomEvent<T> & LitEventEmitter<T>;

/**
 * If this controller is present on the component, reactiveUtils integration
 * will be enabled. With that, you can use reactiveUtils.watch() and other
 * methods to watch for changes on the component's Props and State.
 */
declare function useReactiveUtilsIntegration(): void;

export { AccessorController, accessorSupport, makeAccessorController, reEmitEvent, useReactiveUtilsIntegration };
