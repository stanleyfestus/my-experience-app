import { IHandle, Deferred } from '@arcgis/components-utils';
import { ComponentInterface } from '@stencil/core';
import { ReactiveController, PropertyValues, PropertyDeclaration, ReactiveControllerHost } from 'lit';
import { HostRef } from '@stencil/core/internal';

type TrackKeyResolution = {
    readonly key: string;
    readonly host: BaseComponent | BaseController;
    /**
     * True if property is decorated with `@State()` or `@Prop()` decorator
     */
    readonly isReactive: boolean;
};
/**
 * Like ControllerInternals, but specific to each instance of a component
 *
 * @internal
 */
declare class ComponentInternals {
    /**
     * When watchers are set, they are set into `allWatchers`. When watchers are
     * read in the setter, they are read from `enabledWatchers`.
     *
     * In Stencil, on connectedCallback(), controller manager does
     * `enabledWatchers=allWatchers`. Reasoning:
     * - This disables watchers until connected callback (matches behavior of
     *   Stencil's watchers)
     * - This removes the need for a check in the setter for whether the watchers
     *   were enabled already or not (as getters/setters are hot path, and should
     *   be streamlined)
     *
     * In Lit, we set enabledWatchers to allWatchers in the constructor.
     * Reasoning:
     * - While in Stencil all user provided properties are either set before the
     *   component constructor (this is possible since Stencil's props store is
     *   externalized) or after connectedCallback, in Lit the properties may be
     *   set by attributeChangedCallback before connectedCallback. Thus, we need
     *   to enable watchers even before connectedCallback.
     * - This means, that a watcher set for some prop before your component got
     *   a chance to set the default value will trigger the watcher when the
     *   default value is set - but, that is inline with Lit's willUpdate behavior
     *   of triggering for default values AND, the only way to set a watcher
     *   before default value is if you called watcher inside a controller. For
     *   now, there are no controllers written outside of arcgis-map-components
     *   package, so I was able to verify that this change would have no
     *   negative impact.
     *
     * In either way, I plan to remove watchers from controllers once Stencil
     * support is removed.
     */
    enabledWatchers: Watchers;
    allWatchers: Watchers;
    readonly component: BaseComponent & ControllerHost;
    /**
     * Do not use this directly as it may break on framework updates.
     * Instead, use helpers like getPropMembers() and getPropType()
     */
    members: HostRef["$cmpMeta$"]["$members$"];
    constructor(component: BaseComponent & ControllerHost);
    /**
     * "readOnly" is not enabled initially since we need to allow to set property
     * default values in the constructor.
     * For Stencil, readonly is enabled by the `readonly()` controller.
     * For Lit, we have the following logic:
     */
    enableReadonly: (() => void) | undefined;
    trackedValue: unknown;
    keyTrackers: ((key: string | undefined, value: unknown) => void)[];
    firePropTrackers(key: string | undefined, value: unknown): void;
    readonly getters: Record<string, ((value: unknown, propertyName: string) => unknown)[] | undefined>;
    readonly setters: Record<string, ((newValue: unknown, oldValue: unknown, propertyName: string) => unknown)[] | undefined>;
    readonly accessorGetter: Record<string, (value: unknown, propertyName: string) => unknown>;
    readonly accessorSetter: Record<string, (newValue: unknown, oldValue: unknown, propertyName: string) => unknown>;
    reactiveUtilsIntegrations: Set<BaseController | Controller<unknown>>;
    /**
     * Configure a getter or setter for a given \@Prop/\@State
     *
     * Note, since props are defined on the prototype, they are shared between all
     * instances of a component. Thus, instead of passing a reference to the
     * getter/setter function, you should update the
     * ComponentInternals.getters/setters properties, and then call getSetProxy
     * to apply the changes to the prototype
     */
    getSetProxy(property: string): void;
    private _getSetProxy;
    private _exports;
    /**
     * Associate an exports object with a controller for reverse lookup in
     * controller.use
     */
    markExports(controller: BaseController, exports: unknown): void;
    resolveExports(exports: unknown): BaseController | undefined;
    readonlySetter: <T>(newValue: T, _oldValue: T, property: string) => T;
}
type Watchers = Record<string, ((newValue: unknown, oldValue: unknown, propertyName: string) => void)[] | undefined>;

/**
 * Using "new ControllerManager(this)" inside a component causes this TypeScript
 * error:
 * 'manager' implicitly has type 'any' because it does not have a type
 * annotation and is referenced directly or indirectly in its own initializer.
 *
 * This function fixes that, and it's also a bit shorter to type
 */
declare const useControllerManager: (component: BaseComponent, forceUpdate?: (component: BaseComponent) => void) => ControllerManager;
/**
 * A manager for all other controllers. It finds all controllers on the
 * component, loads them, and forwards lifecycle events to them.
 */
declare class ControllerManager<Unused = never> extends GenericController<undefined> {
    private readonly _controllers;
    /** @internal */
    readonly internals: ComponentInternals;
    hasDestroy: boolean;
    destroyed: boolean;
    private _updatePromise;
    private _autoDestroyTimeout?;
    /**
     * If true, indicates that ControllerManager is running against a Lit component.
     * Otherwise, means we are running against a Stencil component.
     */
    readonly isLit: boolean;
    constructor(component: BaseComponent, forceUpdate?: (component: BaseComponent) => void);
    private _originalLifecycles;
    private _bindLifecycleMethods;
    /**
     * Throws an error if component does not implement destroy() lifecycle, but
     * tries to use it. This check is only present in development mode
     */
    ensureHasDestroy?: () => void;
    /**
     * Private because this is not supposed to be called by Component directly.
     * Instead, _bindLifecycleMethods will take care of that. Otherwise, you risk
     * calling lifecycle methods twice.
     *
     * @internal
     */
    _connectedCallback(): void;
    /** @internal */
    _disconnectedCallback(): void;
    /** @internal */
    _load(): Promise<void>;
    /** @internal */
    _loaded(): void;
    private _update;
    private _updated;
    destroy(): Promise<void>;
    private _setAutoDestroyTimeout;
}

/**
 * Explicitly picking rather than extending everything because the interface
 * has "[memberName: string]: any;", which ruins type-safety of components
 */
type StencilLifecycles = Pick<ComponentInterface, "componentDidLoad" | "componentDidUpdate" | "componentShouldUpdate" | "componentWillLoad" | "componentWillUpdate" | "connectedCallback" | "disconnectedCallback">;
/**
 * Properties required on all components that use a controller
 *
 * @remarks
 * Do not use this type in Lit. Use `LitElement` instead
 */
type BaseComponent = StencilLifecycles & {
    manager: ControllerManager;
    el: HTMLElement;
    autoDestroyDisabled?: boolean;
    destroy?: () => Promise<void>;
};
/**
 * Helper utility to get component type from a controller. Can be used in
 * "implements"
 * @example
 * const useHomeViewModel = makeViewModelController(newWidgetsHomeHomeViewModel);
 * export class Home implements Use<typeof useHomeViewModel> {
 * // No need for "implements BaseComponent" as that's already included in
 * // every controller
 *
 * @remarks
 * TypeScript detects errors even without Use<typeof useHomeViewModel>, but Use
 * makes errors display in a more readable format
 */
type Use<Callback extends (component: any) => unknown> = Parameters<Callback>[0];
/**
 * Base API for a controller. Compatible with both Lit's Reactive controllers
 * and Stencil's lifecycle
 */
type ControllerLifecycleMethods = {
    readonly hostConnected?: ReactiveController["hostConnected"];
    readonly hostDisconnected?: ReactiveController["hostDisconnected"];
    readonly hostLoad?: ComponentInterface["componentWillLoad"];
    readonly hostLoaded?: ComponentInterface["componentDidLoad"];
    /**
     * Called during the client-side host update, just before the host calls
     * its own update.
     *
     * Code in `update()` can depend on the DOM as it is not called in
     * server-side rendering.
     *
     * @remarks
     * The changedProperties parameter will only be present in Lit, not in Stencil
     */
    readonly hostUpdate?: (changedProperties: PropertyValues) => void;
    /**
     * Called after a host update, just before the host calls firstUpdated and
     * updated. It is not called in server-side rendering.
     *
     * @remarks
     * The changedProperties parameter will only be present in Lit, not in Stencil
     */
    readonly hostUpdated?: (changedProperties: PropertyValues) => void;
    /**
     * Called when the component is finally being destroyed (rather than
     * temporary disconnected from the DOM)
     */
    readonly hostDestroy?: () => void;
    /**
     * lifecycle() is a convenience higher-level callback that:
     * - calls the provided callback right away the first time if
     *   connectedCallback has already happened once
     *   - otherwise, calls it on connectedCallback
     * - calls the callback on each future connectedCallback
     * - if you returned a function, or an object like {remove:()=>void}, that
     *   function will be called on the next disconnectedCallback
     *
     * This is a bit like useEffect(callback, []) in React
     */
    readonly hostLifecycle?: () => (() => void)[] | IHandle | IHandle[] | (() => void) | undefined | void;
    /**
     * Called after component.removeComponent(controller) was called on this
     * controller
     */
    readonly controllerRemoved?: () => void;
};
/**
 * Controller host interface, compatible with both Lit's Reactive controllers
 * and Stencil's lifecycle.
 * These members are added to the component instance by ControllerManager.
 */
type ControllerHost = {
    /**
     * Adds a controller to the host, which connects the controller's lifecycle
     * methods to the host's lifecycle.
     */
    addController(controller: BaseController): void;
    addController(controller: ReactiveController): void;
    /**
     * Removes a controller from the host.
     */
    /**
     * Removes a controller from the host.
     */
    removeController(controller: BaseController): void;
    removeController(controller: ReactiveController): void;
    /**
     * Requests a host update which is processed asynchronously. The update can
     * be waited on via the `updateComplete` property.
     *
     * @remarks
     * In Stencil:
     * This method will re-render your component. All passed parameters are ignored
     *
     * In Lit:
     * It is recommended to provide the property name describing what property
     * triggered the update - property name will be provided to the willUpdate()
     * lifecycle hook, giving it the ability to react to the change.
     *
     * @see https://lit.dev/docs/api/ReactiveElement/#ReactiveElement.requestUpdate
     */
    requestUpdate: (name?: PropertyKey, oldValue?: unknown, options?: PropertyDeclaration) => void;
    readonly updateComplete: ReactiveControllerHost["updateComplete"];
};
/**
 * A symbol is used to mark providers/controllers on a component instance.
 * This helps to distinguish them from regular properties.
 */
declare const controllerSymbol: unique symbol;
/**
 * Adding an optional symbol to satisfy TypeScript
 * "type Controller has no properties in common with BaseController"
 */
type BaseController = ControllerLifecycleMethods & {
    readonly [controllerSymbol]?: true;
};
/**
 * `@arcgis/lit`'s LitElement should have a createEvent static property. That
 * will be used by controllers when they wish to emit an event on the component.
 *
 * The controllers package can not import `createEvent()` directly from
 * `@arcgis/lit` as controllers package needs to support both Stencil and Lit,
 * so should not have a direct dependency on Lit.
 */
type LitElementWithCreateEventFactory = {
    createEvent: CreateEventFactory;
};
/**
 * A reference to Lit's map of changed properties that triggered the update
 */
type LitElementWithChangedPropertiesMap = {
    changedProperties: PropertyValues;
};
type CreateEventFactory = <T>(eventName?: string, options?: EventInit, component?: BaseComponent) => CustomEvent<T> & LitEventEmitter<T>;
type LitEventEmitter<T = undefined> = undefined extends T ? {
    emit(): CustomEvent<undefined>;
} : {
    emit(payload: T): CustomEvent<T>;
};
/**
 * Property declaration with additional `reaDonly` option (handled by Controllers)
 */
type LitElementPropertyDeclaration = PropertyDeclaration & {
    /**
     * Declare a property that can't be modified by the developer.
     *
     * @example
     * ```ts
     * \@property({ readOnly: true })
     * myReadonlyProp = 'initialValue';
     * ```
     *
     * @example
     * Inside the component code, you can overwrite the readOnly property like so:
     * ```ts
     * bypassReadOnly(() => {
     *  this.myReadonlyProp = 'newValue';
     * });
     * ```
     *
     * @example
     * Alternatively, you can declare a readOnly prop like so:
     *
     * ```ts
     * \@property()
     * get myReadonlyProp(): string {
     *   return 'someValue';
     * }
     * ```
     */
    readonly readOnly?: boolean;
};

/**
 * A bundle of small behind-the-scenes utils that improve DX for controllers,
 * powering features like implicit component reference passing and
 * proxyExports()
 */

declare function retrieveComponent(name?: string): BaseComponent;
/**
 * The type definition has to be duplicated due to this TypeScript error:
 * "'use' is referenced directly or indirectly in its own type annotation."
 */
declare const use: <Value>(value: Value, watchExports?: (value: NotNever<InferController<Value>>, unsubscribe: () => void) => void) => Promise<NotNever<InferController<Value>>>;
declare const useRef: <Value>(value: Value) => Promise<InferController<Value>>;
declare const useRefSync: <Value>(value: Value) => InferController<Value> | undefined;
/**
 * If passed value is a controller, then return it. Otherwise, assume it's a
 * proxyExports() result and wrap it into a controller
 *
 * Note, this won't type correctly if a proxyExports() controller is exporting a
 * non-proxyExports() controller
 */
type InferController<ControllerOrExports> = ControllerOrExports extends BaseController ? ControllerOrExports & {
    exports?: unknown;
    ready?: Promise<void>;
    watchExports?: Controller["watchExports"];
} : Controller<ControllerOrExports>;
/**
 * If controller never sets it's exports, then it's default exports is "this".
 * This allows usage of controller.use with controllers that don't have exports
 */
type NotNever<T extends {
    exports?: any;
}> = T extends {
    exports: never;
} ? T : T["exports"];

/**
 * Base class for Controllers defined using a class rather than a function.
 * Defining controller using makeController() function is more succinct for smaller
 * controllers. For controllers that need to declare several methods, or need
 * more flexibility, this class may be used
 *
 * See ./examples.tsx for many example controllers and their usages.
 */
declare abstract class Controller<Exports = never> implements BaseController {
    protected _callbacks: {
        readonly [KEY in keyof Omit<ControllerLifecycleMethods, "controllerRemoved">]-?: NonNullable<ControllerLifecycleMethods[KEY]>[];
    };
    protected _ready: Deferred<Exports>;
    private _lifecycleCleanups;
    /** @internal */
    assignedProperty?: string | false;
    connectedCalled: boolean;
    protected _loadCalled: boolean;
    loadedCalled: boolean;
    readonly [controllerSymbol] = true;
    component: BaseComponent & ControllerHost;
    ready: Promise<Exports>;
    constructor(component?: BaseComponent);
    /**
     * If controller is being added dynamically, after the component
     * construction, then trigger connected and load right away
     */
    catchUpLifecycle(): void;
    private _exports;
    get exports(): Exports;
    /**
     * Set controller's exports property (for usage with proxyExports()) and mark
     * controller as ready (for usage in other controllers). Also, triggers
     * re-render of the component
     */
    set exports(exports: Exports);
    /**
     * If controller needs to await a promise before it's exports are fully ready
     * but it wishes to make some limited exports available before then,
     * this method can be used.
     *
     * This is useful for permitting a limited usage of the controller in default
     * values of properties or in component constructor.
     *
     * In order to help detect bugs, trying to access a prop on the exports value
     * that does not exist will throw an error (in development only). This is
     * useful to detect usages of controller that forgot to await it's exports.
     * (the "value in this.myController" check won't cause an exception though)
     */
    setProvisionalExports(exports: Exports): void;
    setProvisionalExports(exports: Exports extends object ? Partial<Exports> : Exports): void;
    setProvisionalExports<Props extends keyof Exports>(exports: Pick<Exports, Props>): void;
    private _exportWatchers;
    watchExports(callback: (exports: Exports) => void): () => void;
    /**
     * A flexible utility for making sure a controller is loaded before it's used,
     * regardless of how or where a controller was defined:
     *
     * @example
     * makeGenericController(async (component, controller) => {
     *   // Await some controller from the component:
     *   await controller.use(component.someController);
     *   // Initialize new controllers
     *   await controller.use(load(importCoreReactiveUtils));
     *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
     *   await controller.use(someController(component));
     * });
     *
     * @remarks
     * If your controller is not async, and you are not creating it async, then
     * you are not required to use controller.use - you can use it directly.
     * Similarly, accessing controllers after componentWillLoad callback does not
     * require awaiting them as they are guaranteed to be loaded by then.
     */
    get use(): typeof use;
    /**
     * Just like controller.use, but returns the controller itself, rather than it's
     * exports
     *
     * Use cases:
     * - You have a controller and you want to make sure it's loaded before you
     *   try to use it
     * - Your controller is not using exports, so you wish to access some props on
     *   it directly
     * - You have a controller exports only, and you want to retrieve the
     *   controller itself. This is useful if you wish to call .watchExports() or
     *   some other method on the controller
     */
    get useRef(): typeof useRef;
    /**
     * Like useRef, but doesn't wait for the controller to get ready
     *
     * @internal
     */
    get useRefSync(): typeof useRefSync;
    controllerRemoved(): void;
    onConnected(callback: NonNullable<ControllerLifecycleMethods["hostConnected"]>): void;
    onDisconnected(callback: NonNullable<ControllerLifecycleMethods["hostDisconnected"]>): void;
    onLoad(callback: NonNullable<ControllerLifecycleMethods["hostLoad"]>): void;
    onLoaded(callback: NonNullable<ControllerLifecycleMethods["hostLoaded"]>): void;
    onUpdate(callback: NonNullable<ControllerLifecycleMethods["hostUpdate"]>): void;
    onUpdated(callback: NonNullable<ControllerLifecycleMethods["hostUpdated"]>): void;
    onDestroy(callback: NonNullable<ControllerLifecycleMethods["hostDestroy"]>): void;
    onLifecycle(callback: NonNullable<ControllerLifecycleMethods["hostLifecycle"]>): void;
    /** @internal */
    triggerConnected(): void;
    /** @internal */
    triggerDisconnected(): void;
    /** @internal */
    triggerLoad(): Promise<void>;
    /** @internal */
    triggerLoaded(): void;
    /** @internal */
    triggerUpdate(changedProperties: PropertyValues): void;
    /** @internal */
    triggerUpdated(changedProperties: PropertyValues): void;
    /** @internal */
    triggerDestroy(): void;
    /** @internal */
    triggerLifecycle(): void;
    private _callLifecycle;
}
declare abstract class GenericControllerType<Exports, Requires = BaseComponent> extends Controller<Exports> {
    component: BaseComponent & ControllerHost & Requires;
    constructor(component: BaseComponent & Requires);
}
/**
 * If your controller requires some specific properties to be present on the
 * component, besides what's included in the BaseComponent, use
 * GenericController over the usual Controller. Use the 2nd generic argument
 * on this class for specifying what properties your controller expects on the
 * component
 *
 * When using a controller created using GenericController, consumer must
 * pass in "this" explicitly to the constructor. If controller was
 * created using Controller, that is not necessary
 *
 * @remarks
 * GenericController class is identical to Controller class in all but typing.
 * That is why, at runtime GenericController is actually equal to Controller
 * class.
 * You can use GenericControllerType type if you wish to reference generic
 * controller instance type.
 */
declare const GenericController: typeof GenericControllerType;

export { type BaseComponent as B, type ControllerHost as C, GenericControllerType as G, type LitElementWithCreateEventFactory as L, type StencilLifecycles as S, type TrackKeyResolution as T, type Use as U, type BaseController as a, Controller as b, type ControllerLifecycleMethods as c, GenericController as d, ControllerManager as e, controllerSymbol as f, type LitElementWithChangedPropertiesMap as g, type LitEventEmitter as h, type LitElementPropertyDeclaration as i, retrieveComponent as r, useControllerManager as u };
