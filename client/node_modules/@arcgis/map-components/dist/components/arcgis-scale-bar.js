/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.0-next.58
 */
import { proxyCustomElement, HTMLElement, createEvent, forceUpdate, h } from '@stencil/core/internal/client';
import { g as globalCss } from './globalCss.js';
import { u as useT9n, m as makeViewModelController } from './useViewModel.js';
import { h as importCoreReactiveUtils, a1 as importIntl, a2 as importApplicationsComponentsGetDefaultUnits, p as classes, a3 as newWidgetsScaleBarScaleBarViewModel } from './index2.js';
import { l as load } from './index3.js';
import { u as useControllerManager, g as getSet } from './index4.js';

const base = "esri-scale-bar";
const css = {
    base,
    labelContainer: `${base}__label-container`,
    rulerLabelContainer: `${base}__label-container--ruler`,
    lineLabelContainer: `${base}__label-container--line`,
    topLabelContainer: `${base}__label-container--top`,
    bottomLabelContainer: `${base}__label-container--bottom`,
    label: `${base}__label`,
    line: `${base}__line`,
    topLine: `${base}__line--top`,
    bottomLine: `${base}__line--bottom`,
    ruler: `${base}__ruler`,
    rulerBlock: `${base}__ruler-block`,
    barContainer: `${base}__bar-container`,
    rulerBarContainer: `${base}__bar-container--ruler`,
    lineBarContainer: `${base}__bar-container--line`,
};

function createScreenPoint(x = 0, y = 0) {
    return { x, y };
}

const useScaleBarViewModel = makeViewModelController(newWidgetsScaleBarScaleBarViewModel);
const __cmpMeta = [0,"arcgis-scale-bar",{"autoDestroyDisabled":[1028,"auto-destroy-disabled"],"icon":[1537],"label":[1025],"position":[1537],"referenceElement":[1025,"reference-element"],"barStyle":[1025,"bar-style"],"unit":[1025],"destroy":[64]}];
const ArcgisScaleBar$1 = /*@__PURE__*/ proxyCustomElement(class ArcgisScaleBar extends HTMLElement {
    connectedCallback() { this.manager._connectedCallback(); }
    disconnectedCallback() { this.manager._disconnectedCallback(); }
    constructor() {
        super();
        this.__registerHost();
this.constructor.__registerControllers = ()=>__cmpMeta[2]??{};
        this.arcgisReady = createEvent(this, "arcgisReady", 7);
        //--------------------------------------------------------------------------
        //
        //  Controllers
        //
        //--------------------------------------------------------------------------
        this.manager = useControllerManager(this,forceUpdate);
        this.messages = useT9n();
        this.reactiveUtils = load(importCoreReactiveUtils);
        this.intlUtils = load(importIntl);
        this.unitUtils = load(importApplicationsComponentsGetDefaultUnits);
        this.viewModel = useScaleBarViewModel(this);
        this._scaleComputedFrom = createScreenPoint();
        this.autoDestroyDisabled = false;
        this.icon = "actual-size";
        this.label = undefined;
        this.position = "top-left";
        this.referenceElement = undefined;
        this.barStyle = "line";
        this.unit = getSet(undefined, {
            set: (unit) => unit ?? this._defaultUnit,
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentDidLoad() {
        this._defaultUnit = this.unitUtils.getDefaultUnitForView(this.viewModel.view);
        if (!this.unit) {
            this.unit = this._defaultUnit;
        }
        this.manager.onLifecycle(() => this.reactiveUtils.watch(() => {
            const view = this.viewModel.view;
            return [view?.stationary, view?.center, view?.scale, view?.zoom];
        }, ([stationary]) => {
            if (stationary) {
                forceUpdate(this);
            }
        }));
    }
    /** Permanently destroy the component */
    async destroy() {
        await this.manager.destroy();
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    componentDidRender() {
        this._handleRootCreateOrUpdate();
    }
    render() {
        const isDisabled = this.viewModel.state === "disabled";
        const baseClasses = {
            [globalCss.disabled]: isDisabled,
        };
        let metricScaleBar;
        let imperialScaleBar;
        if (!isDisabled) {
            const { unit, barStyle } = this;
            const useImperial = unit === "imperial" || unit === "dual";
            const useMetric = unit === "metric" || unit === "dual";
            const baseLengthInPixels = 100;
            const effectiveStyle = unit === "dual" ? "line" : barStyle;
            if (useImperial) {
                const imperialScale = this.viewModel.getScaleBarProperties(baseLengthInPixels, "imperial");
                if (imperialScale) {
                    imperialScaleBar =
                        effectiveStyle === "ruler" ? this._renderRuler(imperialScale) : this._renderLine(imperialScale, "bottom");
                }
            }
            if (useMetric) {
                const metricScale = this.viewModel.getScaleBarProperties(baseLengthInPixels, "metric");
                if (metricScale) {
                    metricScaleBar =
                        effectiveStyle === "ruler" ? this._renderRuler(metricScale) : this._renderLine(metricScale, "top");
                }
            }
        }
        return (h("div", { key: '8224f987c000c7263570091b725bad517f11bbf3', ref: (element) => (element ? this._handleRootCreateOrUpdate() : undefined), class: classes(css.base, globalCss.widget, baseClasses) }, metricScaleBar, imperialScaleBar));
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    _renderRuler(scaleBarProps) {
        const { length, unit, value } = scaleBarProps;
        const pixels = Math.round(length);
        const label = this._formatDistance(value, unit);
        return (h("div", { class: classes(css.barContainer, css.rulerBarContainer) }, h("div", { class: css.ruler, style: { width: `${pixels}px` } }, h("div", { class: css.rulerBlock }), h("div", { class: css.rulerBlock }), h("div", { class: css.rulerBlock }), h("div", { class: css.rulerBlock })), h("div", { class: classes(css.labelContainer, css.rulerLabelContainer) }, h("div", { class: css.label }, "0"), h("div", { class: css.label }, label))));
    }
    _renderLine(scaleBarProps, labelPosition) {
        const { length, unit, value } = scaleBarProps;
        const pixels = Math.round(length);
        const label = this._formatDistance(value, unit);
        const labelContainerClasses = {
            [css.topLabelContainer]: labelPosition === "top",
            [css.bottomLabelContainer]: labelPosition === "bottom",
        };
        const distance = (h("div", { class: classes(css.labelContainer, css.lineLabelContainer, labelContainerClasses) }, h("div", { class: css.label }, label)));
        const lineClasses = {
            [css.topLine]: labelPosition === "top",
            [css.bottomLine]: labelPosition === "bottom",
        };
        const line = h("div", { class: classes(css.line, lineClasses), style: { width: `${pixels}px` } });
        return h("div", { class: classes(css.barContainer, css.lineBarContainer) }, [line, distance]);
    }
    _handleRootCreateOrUpdate() {
        if (!this.viewModel) {
            return;
        }
        const scaleComputedFrom = this._scaleComputedFrom;
        const rect = this.el.getBoundingClientRect();
        const x = rect.left + window.pageXOffset;
        const y = rect.top + window.pageYOffset;
        const futureScreenPoint = createScreenPoint(x, y);
        const referenceScreenPointChanged = futureScreenPoint.x !== scaleComputedFrom.x || futureScreenPoint.y !== scaleComputedFrom.y;
        if (referenceScreenPointChanged) {
            this._scaleComputedFrom = futureScreenPoint;
        }
    }
    _formatDistance(value, unit) {
        return this.intlUtils.formatNumber(value, {
            style: "unit",
            unit,
            unitDisplay: "short",
        });
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return this; }
}, __cmpMeta);
function defineCustomElement$1() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-scale-bar"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-scale-bar":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcgisScaleBar$1);
            }
            break;
    } });
}
defineCustomElement$1();

const ArcgisScaleBar = ArcgisScaleBar$1;
const defineCustomElement = defineCustomElement$1;

export { ArcgisScaleBar, defineCustomElement };
