/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.0-next.58
 */
import { p as proxyExports, A as AccessorController, a as accessorSupport, w as watch, t as trackPropKey } from './index4.js';
import { a as attachToParent } from './component-utils.js';

// FEATURE: if inside of arcgis-expand/arcgis-placement, sync autoDestroyDisabled prop with that of Expand
/**
 * A controller for a wrapped JS API Widget
 * - loads the widget
 * - initializes the widget with the component's properties
 * - does two-way binding between widget and component properties
 * - re-emits the widgets's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://qawebgis.esri.com/arcgis-components/?path=/docs/references-arcgis-lit-transition-from-widgets--docs#usewidget-controller
 */
const makeWidgetController = (loadWidget, _options) => (component, options) => proxy(component, loadWidget, options);
class WidgetController extends AccessorController {
    constructor(component, _loadAccessor, 
    // Disable covariance check
    // eslint-disable-next-line @typescript-eslint/method-signature-style
    _options) {
        super(component, _loadAccessor, _options);
        this._watchedViewModelProperties = new Map();
        this._watchedVisibleElementsProperties = {};
        this._isBindingViewModel = { value: true };
        Object.defineProperty(this.exports, "viewModel", {
            value: accessorSupport.makeGetterProxy(component, this._watchedViewModelProperties, this._isBindingViewModel),
        });
        Object.defineProperty(this.exports, "visibleElements", {
            value: this._makeVisibleElementsBinder(),
        });
    }
    hostConnected() {
        super.hostConnected();
        /*
         * We are done binding props to properties - any accesses after this should
         * be treated as normal property accesses
         */
        this._isBindingViewModel.value = false;
        // If this is not the first connect, check if parent changed
        if (this.component.manager.loadedCalled) {
            attachToParent(this.component);
        }
    }
    async hostLoad() {
        /*
         * "viewModel" property might not have a @State(), so two-way binding might
         * not work (and probably one way is fine)
         */
        this._watchedProperties.delete("viewModel");
        await super.hostLoad();
        if (this.component.manager.destroyed) {
            return;
        }
        this._watchMetaProperties();
        accessorSupport.reEmitAccessorEvents(this, this._instance, this.reactiveUtils, "widget");
        // Do one way watching for viewModel property
        this.onLifecycle(() => this.reactiveUtils.watch(() => this._instance.viewModel, (newViewModel) => {
            this.component.viewModel = newViewModel;
        }, { initial: true }));
        const viewModel = this._instance.viewModel;
        if (typeof viewModel === "object") {
            accessorSupport.reEmitAccessorEvents(this, viewModel, this.reactiveUtils, "viewModel");
            accessorSupport.watchComponentUpdates(this, viewModel, this._watchedViewModelProperties);
            accessorSupport.watchAccessorUpdates(this, viewModel, this._watchedViewModelProperties);
        }
        const visibleElements = Object.entries(this._watchedVisibleElementsProperties);
        if (visibleElements.length > 0) {
            this.onLifecycle(() => visibleElements.map(([prop, propertyChain]) => {
                let base = this._instance.visibleElements ?? {};
                let defaultVisible = undefined;
                for (const key of propertyChain.slice(0, -1)) {
                    if (typeof base[key] === "object" && base[key] !== null) {
                        base = base[key];
                    }
                    else {
                        defaultVisible = Boolean(base[key]);
                        break;
                    }
                }
                if (defaultVisible === undefined) {
                    defaultVisible = Boolean(base[propertyChain.slice(-1)[0]] ?? true);
                }
                prop.startsWith("hide") ? !defaultVisible : defaultVisible;
                const hideShowInName = prop.startsWith("hide") || prop.startsWith("show");
                const shouldFlip = hideShowInName ? prop.startsWith("hide") : defaultVisible;
                const genericComponent = this.component;
                if (typeof genericComponent[prop] === "boolean") {
                    this._updateWidgetVisibleElement(propertyChain, genericComponent[prop], shouldFlip);
                }
                else {
                    genericComponent[prop] = false;
                }
                return watch(this.component, prop, (rawVisible) => this._updateWidgetVisibleElement(propertyChain, rawVisible, shouldFlip));
            }));
        }
    }
    _updateWidgetVisibleElement(propertyChain, propValue, shouldFlip) {
        let base = this._instance.visibleElements ?? {};
        for (const key of propertyChain.slice(0, -1)) {
            if (typeof base[key] !== "object" || base[key] === null) {
                base[key] = {};
            }
            base = base[key];
        }
        const visible = Boolean(shouldFlip ? !propValue : propValue);
        base[propertyChain.at(-1)] = visible;
    }
    hostLoaded() {
        const { el } = this.component;
        /*
         * On hot reloading, new this.component instance is created (so properties
         * on it are reset) but this.component.el instance is preserved (so
         * properties on it are preserved). Since childElem is re-parented on 1st
         * hostLoad(), for it to be accessible on the 2nd hostLoad() (hot reload),
         * we have to store it's reference on the el, rather than component
         */
        el.childElem ?? (el.childElem = document.createElement("div"));
        this._instance.container = el.childElem;
        let arcgisReadyEmitted = false;
        // Check if view was already provided by the user
        const currentView = this.component.el.view;
        // Define the "view" property to allow component usage with MapView/SceneView
        Object.defineProperty(this.component.el, "view", {
            get: () => this._instance.view ?? this._instance.viewModel?.view,
            set: (view) => {
                if (!("view" in this._instance) && typeof this._instance.viewModel === "object") {
                    this._instance.viewModel.view = view;
                }
                else {
                    this._instance.view = view;
                }
                if (!("map" in this._instance) && typeof this._instance.viewModel === "object") {
                    this._instance.viewModel.map = view.map;
                }
                else {
                    this._instance.map = view.map;
                }
                this._watchViewDestroy();
                // Only emit arcgisReady if view is not nullish
                if (view && !arcgisReadyEmitted) {
                    arcgisReadyEmitted = true;
                    this.component.arcgisReady.emit();
                }
            },
            configurable: true,
            enumerable: true,
        });
        if (currentView) {
            this._instance.view = currentView;
        }
        if (this.component.el.isConnected) {
            attachToParent(this.component);
            this._watchViewDestroy();
        }
    }
    hostDisconnected() {
        // If view is already destroyed, view.ui might be undefined
        if (typeof this.component.el.childElem === "object") {
            this.component.el.view?.ui?.remove(this.component.el.childElem);
        }
    }
    hostDestroy() {
        super.hostDestroy();
        this._watchViewDestroyHandle?.remove();
    }
    _watchMetaProperties() {
        watch(this.component, "position", (position) => {
            if (this.component.el.childElem != null && typeof position === "string") {
                attachToParent(this.component);
            }
        });
        watch(this.component, "referenceElement", () => attachToParent(this.component));
    }
    _makeVisibleElementsBinder() {
        return new Proxy({}, {
            has: (target, prop) => typeof prop === "string" || Reflect.has(target, prop),
            get: (target, prop) => {
                // Possibly called by the JS engine
                if (typeof prop === "symbol" || prop in Promise.prototype) {
                    return Reflect.get(target, prop);
                }
                const propertyChain = [prop];
                const proxy = this._makeRecursiveProxy(propertyChain);
                return trackPropKey(this.component, (rawResolvedKey) => {
                    const resolvedKey = rawResolvedKey;
                    this.component[resolvedKey] = false;
                    this._watchedVisibleElementsProperties[resolvedKey] = propertyChain;
                }, proxy);
            },
        });
    }
    _makeRecursiveProxy(propertyChain) {
        const chain = new Proxy({}, {
            get: (target, prop) => {
                const value = Reflect.get(target, prop);
                // Possibly called by the JS engine
                if (typeof prop === "symbol" || prop in Promise.prototype) {
                    return value;
                }
                propertyChain.push(prop);
                return chain;
            },
        });
        return chain;
    }
    /**
     * Destroy the component if view gets destroyed. Note, that when view is
     * destroyed, component disconnect is triggered, which will destroy the
     * component in 1s but that can be too late, because in the meanwhile,
     * a watcher on the widget/viewModel instance may get triggered, and throw
     * an error if it's not able to access this.view.map or etc
     * (happens in VersionManagementViewModel for example).
     * We can't check for this in disconnectedCallback though as even though
     * view.destroy() does trigger disconnect on all map-components, the
     * view.destroyed is not yet set to true when disconnect is triggered.
     */
    _watchViewDestroy() {
        this._watchViewDestroyHandle?.remove();
        this._watchViewDestroyHandle = this.reactiveUtils.when(() => this.component.el.view?.destroyed === true, () => void this.component.destroy().catch(console.error), { sync: true });
    }
}
const proxy = proxyExports(WidgetController);

export { makeWidgetController as m };
