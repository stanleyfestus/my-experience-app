/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.0-next.58
 */
import { proxyCustomElement, HTMLElement, createEvent, forceUpdate, h } from '@stencil/core/internal/client';
import { l as load } from './index3.js';
import { u as useControllerManager, r as readonly, g as getSet, a as accessorSupport, m as makeAccessorController } from './index4.js';
import { h as importCoreReactiveUtils, a5 as newWebScene, a6 as newViewsSceneView } from './index2.js';
import { p as parseCenter, c as isNotSameCamera, e as isNotSameEnvironment, b as isNotSameViewpoint } from './component-utils.js';

const sceneCss = ".arcgis-scene{padding:0;margin:0;height:100%;width:100%}";
const ArcgisSceneStyle0 = sceneCss;

const useWebScene = makeAccessorController(newWebScene);
const useSceneView = makeAccessorController(newViewsSceneView);
const __cmpMeta = [0,"arcgis-scene",{"autoDestroyDisabled":[1028,"auto-destroy-disabled"],"view":[1040],"map":[1040],"allLayerViews":[1040],"alphaCompositingEnabled":[1028,"alpha-compositing-enabled"],"analyses":[1040],"basemapView":[1040],"basemap":[1025],"camera":[1040],"center":[1025],"clippingArea":[1040],"constraints":[1040],"environment":[1040],"extent":[1040],"fatalError":[1040],"floors":[1040],"gamepad":[1040],"graphics":[1040],"ground":[1040],"groundView":[1040],"highlightOptions":[1040],"interacting":[1028],"itemId":[1537,"item-id"],"layerViews":[1040],"magnifier":[1040],"navigating":[1028],"navigation":[1040],"padding":[1040],"performanceInfo":[1040],"popup":[1040],"popupDisabled":[1028,"popup-disabled"],"qualityProfile":[1025,"quality-profile"],"ready":[1028],"resolution":[1026],"scale":[1026],"spatialReference":[1040],"stationary":[1028],"suspended":[1540],"theme":[1040],"timeExtent":[1040],"toMap":[1040],"toScreen":[1040],"updating":[1540],"viewingMode":[1025,"viewing-mode"],"viewpoint":[1040],"zoom":[1026],"addLayer":[64],"addLayers":[64],"closePopup":[64],"destroy":[64],"goTo":[64],"hitTest":[64],"openPopup":[64],"takeScreenshot":[64],"tryFatalErrorRecovery":[64],"whenAnalysisView":[64],"whenLayerView":[64]}];
const ArcgisScene$1 = /*@__PURE__*/ proxyCustomElement(class ArcgisScene extends HTMLElement {
    connectedCallback() { this.manager._connectedCallback(); }
    disconnectedCallback() { this.manager._disconnectedCallback(); }
    constructor() {
        super();
        this.__registerHost();
this.constructor.__registerControllers = ()=>__cmpMeta[2]??{};
        this.arcgisViewReadyChange = createEvent(this, "arcgisViewReadyChange", 7);
        this.arcgisViewChange = createEvent(this, "arcgisViewChange", 7);
        this.arcgisViewClick = createEvent(this, "arcgisViewClick", 7);
        this.arcgisViewDoubleClick = createEvent(this, "arcgisViewDoubleClick", 7);
        this.arcgisViewDrag = createEvent(this, "arcgisViewDrag", 7);
        this.arcgisViewHold = createEvent(this, "arcgisViewHold", 7);
        this.arcgisViewImmediateClick = createEvent(this, "arcgisViewImmediateClick", 7);
        this.arcgisViewImmediateDoubleClick = createEvent(this, "arcgisViewImmediateDoubleClick", 7);
        this.arcgisViewKeyDown = createEvent(this, "arcgisViewKeyDown", 7);
        this.arcgisViewKeyUp = createEvent(this, "arcgisViewKeyUp", 7);
        this.arcgisViewLayerviewCreate = createEvent(this, "arcgisViewLayerviewCreate", 7);
        this.arcgisViewLayerviewCreateError = createEvent(this, "arcgisViewLayerviewCreateError", 7);
        this.arcgisViewLayerviewDestroy = createEvent(this, "arcgisViewLayerviewDestroy", 7);
        this.arcgisViewMouseWheel = createEvent(this, "arcgisViewMouseWheel", 7);
        this.arcgisViewPointerDown = createEvent(this, "arcgisViewPointerDown", 7);
        this.arcgisViewPointerEnter = createEvent(this, "arcgisViewPointerEnter", 7);
        this.arcgisViewPointerLeave = createEvent(this, "arcgisViewPointerLeave", 7);
        this.arcgisViewPointerMove = createEvent(this, "arcgisViewPointerMove", 7);
        this.arcgisViewPointerUp = createEvent(this, "arcgisViewPointerUp", 7);
        this.manager = useControllerManager(this,forceUpdate);
        this.reactiveUtils = load(importCoreReactiveUtils);
        /**
         * This WebMap will be created only if user did not provide a map. Otherwise,
         * it will be equal to this.view.map
         */
        this._map = useWebScene(this, { editConstructorProperties: this._editMapProperties });
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this._setChildElement = (el) => {
            this.el.childElem = el;
        };
        this.autoDestroyDisabled = false;
        this.view = readonly(useSceneView(this, { editConstructorProperties: this._editViewProperties }));
        this.map = this.view.map;
        this.allLayerViews = this.view.allLayerViews;
        this.alphaCompositingEnabled = this.view.alphaCompositingEnabled;
        this.analyses = this.view.analyses;
        this.basemapView = this.view.basemapView;
        this.basemap = this._map.basemap;
        this.camera = getSet(undefined, {
            get: () => this.view.camera,
            set: (newValue, oldValue) => {
                this.view.camera = isNotSameCamera(oldValue, newValue) ? newValue : oldValue;
                return this.view.camera;
            },
        });
        this.center = getSet(undefined, {
            get: (value) => this.view.center ?? value,
            set: (newValue) => {
                const parsed = parseCenter(newValue, this.ready ? this.view : undefined);
                if (!this.ready) {
                    return parsed;
                }
                this.view.center = parsed;
                return this.view.center;
            },
        });
        this.clippingArea = getSet(this.view.clippingArea, {
            set: (newValue, oldValue) => (oldValue?.equals(newValue) ? oldValue : newValue),
        });
        this.constraints = this.view.constraints;
        this.environment = getSet(this.view.environment, {
            set: (newValue, oldValue) => (isNotSameEnvironment(oldValue, newValue) ? newValue : oldValue),
        });
        this.extent = getSet(undefined, {
            get: (extent) => this.view.extent ?? extent,
            set: (newValue, oldValue) => {
                if (!this.view.ready) {
                    return newValue;
                }
                if (newValue && !oldValue?.equals(newValue)) {
                    this.view.extent = newValue;
                }
                return this.view.extent;
            },
        });
        this.fatalError = this.view.fatalError;
        this.floors = this.view.floors;
        this.gamepad = getSet(undefined, {
            get: () => (this.ready ? this.view.input.gamepad : undefined),
            set: "ignore",
        });
        this.graphics = this.view.graphics;
        this.ground = this._map.ground;
        this.groundView = this.view.groundView;
        this.highlightOptions = this.view.highlightOptions;
        this.interacting = getSet(false, {
            get: () => this.view.interacting,
            set: "ignore",
        });
        this.itemId = getSet(undefined, {
            get: (value) => this._map.portalItem?.id ?? value,
            set: (newValue) => {
                // SceneView does not react to WebScene.portalItem change, so we have to recreate it
                if (this.ready) {
                    accessorSupport
                        .reCreate(this._map, this)
                        .then(() => {
                        this.view.map = this._map;
                    })
                        .catch(console.error);
                }
                return newValue;
            },
        });
        this.layerViews = this.view.layerViews;
        this.magnifier = this.view.magnifier;
        this.navigating = getSet(false, {
            get: () => this.view.navigating,
            set: "ignore",
        });
        this.navigation = this.view.navigation;
        this.padding = this.view.padding;
        this.performanceInfo = getSet(undefined, {
            get: () => this.view.performanceInfo,
            set: "ignore",
        });
        this.popup = this.view.popup;
        this.popupDisabled = this.view.popupEnabled;
        this.qualityProfile = this.view.qualityProfile;
        this.ready = this.view.ready;
        this.resolution = getSet(undefined, {
            get: () => this.view.resolution,
            set: "ignore",
        });
        this.scale = getSet(undefined, {
            get: (scale) => this.view.scale ?? scale,
            set: (newValue) => {
                if (this.ready) {
                    this.view.scale = newValue;
                }
                return newValue;
            },
        });
        this.spatialReference = getSet(this.view.spatialReference, {
            set: (newValue, oldValue) => (oldValue?.equals(newValue) ? oldValue : newValue),
        });
        this.stationary = getSet(true, {
            get: () => this.view.stationary,
            set: "ignore",
        });
        this.suspended = this.view.suspended;
        this.theme = this.view.theme;
        this.timeExtent = this.view.timeExtent;
        this.toMap = readonly((...args) => this.view.toMap(...args));
        this.toScreen = readonly((...args) => this.view.toScreen(...args));
        this.updating = this.view.updating;
        this.viewingMode = this.view.viewingMode;
        this.viewpoint = getSet(undefined, {
            get: () => this.view.viewpoint,
            set: (newValue, oldValue) => (isNotSameViewpoint(oldValue, newValue) ? newValue : oldValue),
        });
        this.zoom = getSet(undefined, {
            get: (zoom) => this.view.zoom ?? zoom,
            set: (newValue) => {
                if (this.ready) {
                    this.view.zoom = newValue;
                }
                return newValue;
            },
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Adds a layer to the map layers collection.
     */
    async addLayer(layer, index) {
        this.map?.add(layer, index);
    }
    /**
     * Adds a layer or array of layers to the map layers collection.
     */
    async addLayers(layers, index) {
        this.map?.addMany(layers, index);
    }
    /**
     * Closes the popup.
     */
    async closePopup() {
        this.view?.closePopup();
    }
    /**
     * Destroys the view, and any associated resources, including its map, popup, and UI elements.
     */
    async destroy() {
        await this.manager.destroy();
    }
    /**
     * Sets the view to a given target.
     */
    async goTo(target, options) {
        return (await this.view?.goTo(target, options));
    }
    /**
     * Returns hit test results from each layer that intersects the specified screen coordinates.
     */
    async hitTest(screenPoint, options) {
        return await this.view?.hitTest(screenPoint, options);
    }
    /**
     * Opens the popup at the given location with content defined either explicitly with content or driven
     * from the PopupTemplate of input features.
     */
    async openPopup(options) {
        await this.view?.openPopup(options);
    }
    /**
     * Create a screenshot of the current view.
     */
    async takeScreenshot(options) {
        return await this.view?.takeScreenshot(options);
    }
    /**
     * Call this method to clear any fatal errors resulting from a lost WebGL context.
     */
    async tryFatalErrorRecovery() {
        this.view?.tryFatalErrorRecovery();
    }
    async whenAnalysisView(analysis) {
        return await this.view?.whenAnalysisView(analysis);
    }
    /**
     * Gets the LayerView created on the view for the given layer.
     */
    async whenLayerView(layer) {
        return await this.view?.whenLayerView(layer);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentDidLoad() {
        var _a;
        (_a = this.view).container ?? (_a.container = this.el.childElem);
        const { watch } = this.reactiveUtils;
        this.manager.onLifecycle(() => [
            watch(() => this.view.stationary, () => {
                this.arcgisViewChange.emit();
            }, { initial: true }),
            watch(() => this.view.ready, () => this.arcgisViewReadyChange.emit(), { initial: this.view.ready }),
        ]);
        accessorSupport.reEmitAccessorEvents(this.manager, this.view, this.reactiveUtils, "arcgisView");
    }
    render() {
        return h("div", { key: '3954f72b45b30eabbb33ec2fd96000d72ec862b9', class: "arcgis-scene", ref: this._setChildElement });
    }
    _editMapProperties(mapProperties) {
        // If user provided a map, use that. Otherwise, a WebScene will be created by usWebScene
        if (this.map) {
            this._map = this.map;
        }
        if (this.itemId) {
            mapProperties.portalItem = { id: this.itemId };
        }
        else if (!this.basemap) {
            mapProperties.basemap = "topo-vector";
        }
        // See https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/1244#issuecomment-4922799
        const { basemap, ...rest } = mapProperties;
        if (!basemap) {
            mapProperties = rest;
        }
        return mapProperties;
    }
    _editViewProperties(properties) {
        // Don't overwrite UI if a custom one was already provided
        if (!this.view.ui) {
            properties.ui = {
                components: ["attribution"],
            };
        }
        // If user did not provide a map, use the WebScene we created
        properties.map ?? (properties.map = this._map);
        /*
         * The following properties are not two-way bound like others as they change
         * too often. Instead, they are assigned to getters to always get freshest
         * value without triggering re-render. But that means, useAccessor is not
         * aware of these properties, so we have to pass them manually here:
         */
        const center = parseCenter(this.center, undefined);
        if (center) {
            properties.center = center;
        }
        if (this.viewpoint) {
            properties.viewpoint = this.viewpoint;
        }
        if (this.scale !== undefined) {
            properties.scale = this.scale;
        }
        if (this.extent) {
            properties.extent = this.extent;
        }
        if (this.camera) {
            properties.camera = this.camera;
        }
        if (this.zoom !== undefined) {
            properties.zoom = this.zoom;
        }
        return properties;
    }
    get el() { return this; }
    static get style() { return ArcgisSceneStyle0; }
}, __cmpMeta);
function defineCustomElement$1() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-scene"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-scene":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcgisScene$1);
            }
            break;
    } });
}
defineCustomElement$1();

const ArcgisScene = ArcgisScene$1;
const defineCustomElement = defineCustomElement$1;

export { ArcgisScene, defineCustomElement };
