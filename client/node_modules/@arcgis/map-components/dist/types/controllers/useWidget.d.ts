import type { BaseComponent, CovariantEventEmitter, LitEventEmitter } from "@arcgis/components-controllers";
import { AccessorController } from "@arcgis/components-controllers/dist/accessor";
import type { Nil } from "@arcgis/components-utils";
import type { EventEmitter } from "../stencil-public-runtime";
import type ArcgisMap from "@arcgis/core/Map";
import type { ArcGISMapView, ArcGISSceneView } from "../components/types";
import type { ArcgisReferenceElement } from "../utils/component-utils";
type Requires<Props, Widget extends WidgetInstance> = BaseComponent & Pick<Widget, keyof Props & keyof Widget> & Uses<Widget>;
type WidgetInstance = __esri.Widget & {
    state?: string;
    viewModel?: __esri.Accessor & {
        state?: string;
        view?: ArcGISMapView | ArcGISSceneView | Nil;
        map?: ArcgisMap | Nil;
    };
    view?: ArcGISMapView | ArcGISSceneView | Nil;
    map?: ArcgisMap | Nil;
    visibleElements?: Record<never, unknown>;
};
type Uses<Widget extends WidgetInstance> = {
    reactiveUtils?: typeof __esri.reactiveUtils;
    state?: Exclude<Widget["viewModel"], Nil>["state"] | Widget["state"];
    viewModel?: Widget["viewModel"];
    icon: Nil | string;
    label: Nil | string;
    referenceElement: ArcgisReferenceElement | Nil | string;
    position: __esri.UIPosition;
    arcgisReady: EventEmitter<never> | LitEventEmitter;
    arcgisPropertyChange: CovariantEventEmitter<{
        name: string;
    }> | undefined;
    el: HTMLElement & {
        childElem?: HTMLElement & {
            ownedBy?: HTMLElement;
        };
        view?: ArcGISMapView | ArcGISSceneView | Nil;
    };
    autoDestroyDisabled: boolean;
    destroy: () => Promise<void>;
};
/**
 * A controller for a wrapped JS API Widget
 * - loads the widget
 * - initializes the widget with the component's properties
 * - does two-way binding between widget and component properties
 * - re-emits the widgets's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://qawebgis.esri.com/arcgis-components/?path=/docs/references-arcgis-lit-transition-from-widgets--docs#usewidget-controller
 */
export declare const makeWidgetController: <Props, Widget extends WidgetInstance, OmitProps extends string = never>(loadWidget: (props: Props) => Promise<Widget>, _options?: {
    /**
     * Don't expose the following Widget's properties on the component.
     * You can also bind the property to \@State rather than \@Prop if you
     * wish to use it internally only:
     * @example
     * \@State() timeZone = this.widget.timeZone;
     */
    omitProps: OmitProps[];
}) => (component: Requires<Omit<Props, OmitProps | "container" | "id" | "view" | "visible" | "visibleElements">, Widget>, options?: {
    editConstructorProperties(props: Props): Promise<Props> | Props;
}) => Widget;
export declare class WidgetController<Props, Widget extends WidgetInstance> extends AccessorController<Props, Widget, Uses<Widget>> {
    private _watchedViewModelProperties;
    private _watchedVisibleElementsProperties;
    private _isBindingViewModel;
    constructor(component: Requires<Props, Widget> & Uses<Widget>, _loadAccessor: (props: Props) => Promise<Widget>, _options?: {
        editConstructorProperties?(props: Props): Promise<Props> | Props;
    });
    hostConnected(): void;
    hostLoad(): Promise<void>;
    _updateWidgetVisibleElement(propertyChain: readonly string[], propValue: unknown, shouldFlip: boolean): void;
    hostLoaded(): void;
    hostDisconnected(): void;
    hostDestroy(): void;
    private _watchMetaProperties;
    private _makeVisibleElementsBinder;
    private _makeRecursiveProxy;
    /**
     * Destroy the component if view gets destroyed. Note, that when view is
     * destroyed, component disconnect is triggered, which will destroy the
     * component in 1s but that can be too late, because in the meanwhile,
     * a watcher on the widget/viewModel instance may get triggered, and throw
     * an error if it's not able to access this.view.map or etc
     * (happens in VersionManagementViewModel for example).
     * We can't check for this in disconnectedCallback though as even though
     * view.destroy() does trigger disconnect on all map-components, the
     * view.destroyed is not yet set to true when disconnect is triggered.
     */
    private _watchViewDestroy;
    private _watchViewDestroyHandle?;
}
export {};
