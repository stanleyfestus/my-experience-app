import type { BaseComponent, CovariantEventEmitter, LitEventEmitter } from "@arcgis/components-controllers";
import { AccessorController } from "@arcgis/components-controllers/dist/accessor";
import type { Nil } from "@arcgis/components-utils";
import type { EventEmitter } from "../stencil-public-runtime";
import type { ArcGISMapView, ArcGISSceneView } from "../components/types";
import type ArcgisMap from "@arcgis/core/Map";
import type { ArcgisReferenceElement } from "../utils/component-utils";
type Requires<Props, ViewModel extends ViewModelInstance> = BaseComponent & Pick<ViewModel, keyof Props & keyof ViewModel> & Uses<ViewModel>;
type ViewModelInstance = __esri.Accessor & Partial<__esri.Evented> & {
    state?: string;
    view?: ArcGISMapView | ArcGISSceneView | undefined;
    map?: ArcgisMap | Nil;
};
type Uses<ViewModel extends ViewModelInstance> = {
    reactiveUtils?: typeof __esri.reactiveUtils;
    state?: ViewModel["state"];
    icon: Nil | string;
    label: Nil | string;
    referenceElement: ArcgisReferenceElement | Nil | string;
    arcgisReady: EventEmitter<never> | LitEventEmitter;
    position: __esri.UIPosition;
    arcgisPropertyChange: CovariantEventEmitter<{
        name: string;
    }> | undefined;
    el: HTMLElement & {
        childElem?: HTMLElement & {
            ownedBy?: HTMLElement;
        };
        view?: ArcGISMapView | ArcGISSceneView | undefined;
    };
    autoDestroyDisabled: boolean;
    destroy: () => Promise<void>;
};
/**
 * A controller for a mapping component that:
 * - loads the viewModel
 * - initializes the viewModel with the component's properties
 * - does two-way binding between view model and component properties
 * - re-emits the viewModel's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://qawebgis.esri.com/arcgis-components/?path=/docs/references-arcgis-lit-transition-from-widgets--docs#useviewmodel-controller
 */
export declare const makeViewModelController: <Props, ViewModel extends ViewModelInstance, OmitProps extends string = never>(loadViewModel: (props: Omit<Props, "view">) => Promise<ViewModel>, _options?: {
    /**
     * Don't expose the following ViewModels's properties on the component.
     * You can also bind the property to \@State rather than \@Prop if you
     * wish to use it internally only:
     * @example
     * \@State() timeZone = this.viewModel.timeZone;
     */
    omitProps: OmitProps[];
}) => (component: Requires<Omit<Props, OmitProps>, ViewModel>, options?: {
    editConstructorProperties(props: Props): Promise<Props> | Props;
}) => ViewModel;
export declare class ViewModelController<Props, ViewModel extends ViewModelInstance> extends AccessorController<Props, ViewModel, Uses<ViewModel>> {
    hostConnected(): void;
    hostLoad(): Promise<void>;
    hostLoaded(): void;
    hostDisconnected(): void;
    hostDestroy(): void;
    private _watchMetaProperties;
    /**
     * Destroy the component if view gets destroyed. Note, that when view is
     * destroyed, component disconnect is triggered, which will destroy the
     * component in 1s but that can be too late, because in the meanwhile,
     * a watcher on the widget/viewModel instance may get triggered, and throw
     * an error if it's not able to access this.view.map or etc
     * (happens in VersionManagementViewModel for example).
     * We can't check for this in disconnectedCallback though as, if the entire
     * component tree is removed, the disconnect for the component will be
     * triggered before that of arcgis-map, so the view might not be destroyed
     * yet at that point.
     */
    private _watchViewDestroy;
    private _watchViewDestroyHandle?;
}
export {};
