/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.0-next.58
 */
import{i as t,a as i,D as s,b as o,d as n,c as e,e as h,f as r,h as c}from"./p-3c121fb0.js";var a,u=(t,i)=>t.manager.internals.members?.[i]?.[0],d=Symbol.for("controller");function f(t){a!==t&&(a=t,queueMicrotask((()=>{a===t&&(a=void 0)})))}function l(){return a}var y,p=[];function v(t){if(void 0===t)return void(p=[]);const i=p.indexOf(t);p=-1===i?[...p,t]:p.slice(0,i+1),queueMicrotask((()=>{p=[]}))}var g,w=async(t,i)=>{const s=m(t);if(void 0===s)return t;if(await s.ready,"function"==typeof i){const t=s.watchExports((s=>i(s,t)))}return s.exports},b=async t=>{const i=m(t);return await i.ready,i},m=t=>{const i=function(){const t=y;return y=void 0,t}();if(void 0!==i)return i;const s=l().manager.internals.resolveExports(t);return void 0!==s?s:(t=>"object"==typeof t&&null!==t&&(d in t||"hostConnected"in t||"hostDisconnected"in t||"hostUpdate"in t||"hostUpdated"in t))(t)?t:void 0},j={setter:!1,getter:!1,readOnly:!1},k=new WeakMap;g=d;var C=class{constructor(t){this._callbacks={hostConnected:[],hostDisconnected:[],hostLoad:[],hostLoaded:[],hostUpdate:[],hostUpdated:[],hostDestroy:[],hostLifecycle:[]},this._ready=new s,this._lifecycleCleanups=[],this.connectedCalled=!1,this._loadCalled=!1,this.loadedCalled=!1,this[g]=!0,this.ready=this._ready.promise,this._exports=L(this),this._exportWatchers=new Set;const i=t??l();this.component=i,this.component.addController(this),v(this),void 0===this.component.manager||queueMicrotask((()=>this.catchUpLifecycle()))}catchUpLifecycle(){const{manager:t}=this.component;!t.connectedCalled||this.connectedCalled||this.triggerConnected(),!t._loadCalled||this.triggerLoad().then((()=>{!t.loadedCalled||this.triggerLoaded()})).catch(console.error)}get exports(){return this._exports}set exports(t){const s=this._exports;s!==t&&(this._exports=t,this._exportWatchers.forEach(i),this.connectedCalled&&!1!==this.assignedProperty&&this.component.requestUpdate(this.assignedProperty,s)),this._ready.resolve(t)}setProvisionalExports(t){this._exports=L(t),this._exportWatchers.forEach(i)}watchExports(t){const i=()=>t(this._exports);return this._exportWatchers.add(i),()=>{this._exportWatchers.delete(i)}}get use(){return f(this.component),w}get useRef(){return f(this.component),b}get useRefSync(){return f(this.component),m}controllerRemoved(){this.component.el.isConnected&&this.triggerDisconnected(),this.triggerDestroy()}onConnected(t){this._callbacks.hostConnected.push(t)}onDisconnected(t){this._callbacks.hostDisconnected.push(t)}onLoad(t){this._callbacks.hostLoad.push(t)}onLoaded(t){this._callbacks.hostLoaded.push(t)}onUpdate(t){this._callbacks.hostUpdate.push(t)}onUpdated(t){this._callbacks.hostUpdated.push(t)}onDestroy(t){this._callbacks.hostDestroy.push(t)}onLifecycle(t){this._callbacks.hostLifecycle.push(t),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(t)}triggerConnected(){const t=this;t.hostConnected&&i(t.hostConnected,t),this._callbacks.hostConnected.forEach(i),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){const t=this;t.hostDisconnected&&i(t.hostDisconnected,t),this._callbacks.hostDisconnected.forEach(i),this._lifecycleCleanups.forEach(i),this._lifecycleCleanups=[]}async triggerLoad(){if(this._loadCalled)return;this._loadCalled=!0;const t=this;t.hostLoad&&await o(t.hostLoad,t),this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(o)),this._ready.resolve(this._exports)}triggerLoaded(){if(this.loadedCalled)return;const t=this;t.hostLoaded&&i(t.hostLoaded,t),this._callbacks.hostLoaded.forEach(i),this.loadedCalled=!0}triggerUpdate(t){const s=this;s.hostUpdate&&i(s.hostUpdate,s,t),this._callbacks.hostUpdate.forEach(_,t)}triggerUpdated(t){const s=this;s.hostUpdated&&i(s.hostUpdated,s,t),this._callbacks.hostUpdated.forEach(_,t)}triggerDestroy(){const t=this;t.hostDestroy&&i(t.hostDestroy,t),this._callbacks.hostDestroy.forEach(i)}triggerLifecycle(){const t=this;t.hostLifecycle&&this._callLifecycle((()=>t.hostLifecycle())),this._callbacks.hostLifecycle.forEach(this._callLifecycle,this)}_callLifecycle(t){f(this.component);const s=i(t);(Array.isArray(s)?s:[s]).forEach((t=>{"function"==typeof t?this._lifecycleCleanups.push(t):"object"==typeof t&&"function"==typeof t.remove&&this._lifecycleCleanups.push(t.remove)}))}};function _(t){i(t,void 0,this)}var x=C;function L(t){if("object"!=typeof t&&"function"!=typeof t||null===t)return t;const i=new Proxy(t,{get(t,s,o){if(!O.has(s)||!(s in t)||t[s]!==i)return s in t||s in Promise.prototype||"symbol"==typeof s?"function"==typeof t?t[s]:Reflect.get(t,s,o):void 0},set:(t,i,s,o)=>Reflect.set(t,i,s,o)});return i}var O=new Set(["exports","_exports"]),U=void 0;function D(){Array.from(U?.entries()??[]).forEach((([t,{callbacks:i}])=>{const s=Object.keys(t);i.forEach((t=>t(s)))})),U=void 0}function P(t,s,o){var n;const e=s,h=t.manager.internals;(n=h.allWatchers)[e]??(n[e]=[]);const r=h.allWatchers[e],c=o,a=(t,s,o)=>i(c,null,t,s,o);return r.push(a),()=>{const t=r.indexOf(a);-1!==t&&r.splice(t,1)}}var A=class{constructor(t){this.enabledWatchers={},this.allWatchers={},this.enableReadonly=()=>{if(this.enableReadonly=void 0,!this.component.manager.isLit)return;const t=this.component.manager.internals;Object.entries(t.members).forEach((([i,[s]])=>{var o;2048&s&&((o=t.setters)[i]??(o[i]=[]),t.setters[i].push(t.readonlySetter))}))},this.trackedValue=R,this.keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this.reactiveUtilsIntegrations=new Set,this._exports=new WeakMap,this.readonlySetter=(t,i,s)=>{if(j.readOnly)return t;throw new Error(`Cannot assign to read-only property "${s}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(t)}"`)},this.component=t}firePropTrackers(t,i){const s=this.keyTrackers;this.trackedValue=R,this.keyTrackers=[],s.forEach((s=>s(t,i)))}getSetProxy(t){const i=this.component,s=i.constructor.prototype;if(this._getSetProxy(s,t,"class"),i.manager.isLit)return;const o=i.el.constructor.prototype;s!==o&&this._getSetProxy(o,t,"html")}_getSetProxy(t,i,s){const o=u(this.component,i);let n;do{n=Object.getOwnPropertyDescriptor(t,i)}while(!n&&(t=Object.getPrototypeOf(t)));if(!n)return;const e=n.get,h=n.set,r=S in e,c=S in h;if(r&&c)return;const a=!r,d=!c,f=a?function(){let t=e.call(this);const s=k.get(this);if(j.getter||void 0===s)return t;const o=s.manager.internals;t=o.accessorGetter[i](t,i);const n=o.getters[i]??M;for(let s=0;s<n.length;s++)t=n[s](t,i);return t}:e,l=d?function(t){const s=e.call(this),n=k.get(this);if(void 0===n)return void h.call(this,t);let r=n.manager.isLit?t??void 0:function(t,i=8){return null==t||"object"==typeof t||"function"==typeof t?t:4&i?"false"!==t&&(""===t||!!t):2&i?Number.parseFloat(t):1&i?String(t):t}(t,o);const c=n.manager.internals;if(r===s)h.call(this,r);else{const t=j.setter?M:c.setters[i]??M;for(let o=0;o<t.length&&(r=t[o](r,s,i),r!==s);o++);r=c.accessorSetter[i](r,s,i),h.call(this,r),r!==s&&c.enabledWatchers[i]?.forEach((t=>t(r,s,i)))}c.keyTrackers.length>0&&c?.firePropTrackers(i,t)}:h;a&&(f[S]=!0),d&&(l[S]=!0),Object.defineProperty(t,i,{...n,get:f,set:l})}markExports(t,i){("object"==typeof i&&null!==i||"function"==typeof i)&&this._exports.set(i,t)}resolveExports(t){return"object"==typeof t&&null!==t||"function"==typeof t?this._exports.get(t):void 0}},M=[],S=Symbol(),R=Symbol(),E=(t,i)=>new q(t,i),q=class extends x{constructor(i,o){const n="addController"in i,e=new Set,h=i;if(h.addController=function(t){e.add(t),!(d in t)&&i.renderRoot&&i.el.isConnected&&t.hostConnected?.()},h.removeController=function(t){e.delete(t),t.controllerRemoved?.()},!n){const t=o??i.constructor.__forceUpdate;h.requestUpdate=()=>t(i)}super(i),this.internals=new A(this.component),this.destroyed=!1,this._updatePromise=new s,this._originalLifecycles={},this.isLit=n,this.component.manager=this,function(i,s){if(s)i.manager.internals.members=Object.fromEntries(Array.from(i.constructor.elementProperties,(([t,i])=>i.noAccessor?void 0:[t,[(i.readOnly?2048:0)|(i.state?32:16)]])).filter(t));else{const t=i.constructor,s=t.__registerControllers?.(i)??void 0;if(t.__registerControllers=void 0,"object"!=typeof s)throw new Error("Failed to retrieve component meta");i.manager.internals.members=Object.fromEntries(Object.entries(s).filter((([t,[i]])=>!!(63&i))))}}(i,n),this._controllers=e,this.exports=void 0,this.hasDestroy=T in this.component&&"function"==typeof this.component.destroy,this._bindLifecycleMethods();const r=this.internals;Object.keys(r.members).forEach((t=>{r.accessorGetter[t]=I,r.accessorSetter[t]=I,r.getSetProxy(t)})),n?this.internals.enabledWatchers=this.internals.allWatchers:Object.defineProperty(i,"updateComplete",{get:async()=>await this._updatePromise.promise}),queueMicrotask(r.enableReadonly),v(void 0),f(i),k.set(i.el,i),k.set(i,i)}_bindLifecycleMethods(){const t=this.component,i=this.isLit,s=t.el===t;this._originalLifecycles={_connectedCallback:i||s?void 0:t.connectedCallback,_disconnectedCallback:i||s?void 0:t.disconnectedCallback,_load:i?t.load:t.componentWillLoad,_loaded:i?t.loaded:t.componentDidLoad,_willUpdate:i?void 0:t.componentWillUpdate,_updated:i?void 0:t.componentDidUpdate,_destroy:t.destroy};const o=this._connectedCallback.bind(this),n=this._disconnectedCallback.bind(this),e=this._update.bind(this),h=this._updated.bind(this);i?t.constructor.prototype.addController.call(t,{hostConnected:o,hostDisconnected:n,hostUpdate:e,hostUpdated:h}):(t.connectedCallback=o,t.disconnectedCallback=n,t.componentWillLoad=this._load.bind(this),t.componentDidLoad=this._loaded.bind(this),t.componentWillUpdate=e,t.componentDidUpdate=h),this.hasDestroy&&(t.destroy=this.destroy.bind(this))}_connectedCallback(){if(this.destroyed){const t=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error(`The ${t} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the ${T} prop.`)}void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout);const t=this.internals;t.enabledWatchers=t.allWatchers,D(),t.enableReadonly?.(),this._controllers.forEach(W),this._originalLifecycles._connectedCallback?.call(this.component)}_disconnectedCallback(){this.destroyed||(this._controllers.forEach(F),this._originalLifecycles._disconnectedCallback?.call(this.component),this.hasDestroy&&this._setAutoDestroyTimeout())}async _load(){const t=this.internals.reactiveUtilsIntegrations;if(t.size>0)for(const i of t)"triggerLoad"in i?await i.triggerLoad():await o(i.hostLoad,i);await Promise.allSettled(Array.from(this._controllers,G,t)),await(this._originalLifecycles._load?.call(this.component)),this.hasDestroy&&P(this.component,T,(()=>this._setAutoDestroyTimeout()))}_loaded(){this._controllers.forEach(N),this._originalLifecycles._loaded?.call(this.component)}_update(){this._controllers.forEach(z,this.component.changedProperties),this._originalLifecycles._willUpdate?.call(this.component)}_updated(){const t=this.component;if(this._controllers.forEach(B,t.changedProperties),this._originalLifecycles._updated?.call(this.component),this.isLit)t.changedProperties=new Map;else{const t=this._updatePromise;this._updatePromise=new s,t.resolve(!0)}}async destroy(){if(!this.destroyed){if(this.component.el.isConnected){this.hasDestroy=!1;try{this.component.el.remove()}finally{this.hasDestroy=!0}}this._autoDestroyTimeout=void 0,this.destroyed=!0,this._controllers.forEach(H),this._controllers.clear(),await(this._originalLifecycles._destroy?.call(this.component))}}_setAutoDestroyTimeout(){void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout),this.component.el.isConnected||this.component.autoDestroyDisabled||(this._autoDestroyTimeout=n((()=>{this.destroy().catch(console.error)}),$))}},T="autoDestroyDisabled",$=1e3,I=t=>t;function W(t){"triggerConnected"in t?t.triggerConnected():i(t.hostConnected,t)}function F(t){"triggerDisconnected"in t?t.triggerDisconnected():i(t.hostDisconnected,t)}async function G(t){this.has(t)||("triggerLoad"in t?await t.triggerLoad():await o(t.hostLoad,t))}function N(t){"triggerLoaded"in t?t.triggerLoaded():i(t.hostLoaded,t)}function z(t){"triggerUpdate"in t?t.triggerUpdate(this):i(t.hostUpdate,t,this)}function B(t){"triggerUpdated"in t?t.triggerUpdated(this):i(t.hostUpdated,t,this)}function H(t){"triggerDestroy"in t?t.triggerDestroy():i(t.hostDestroy,t)}function J(t,s,o){const n=t.manager.internals;return n.trackedValue!==R&&n.trackedValue!==o&&n.firePropTrackers(void 0,void 0),0===n.keyTrackers.length&&queueMicrotask((()=>n.firePropTrackers(void 0,void 0))),n.trackedValue=o,n.keyTrackers.push(((t,n)=>i(s,void 0,o===n?t:void 0))),o}function K(t,s,o){const n=Array.isArray(t)?t:[t];let e=n.length+1;const h=t=>{e-=1,void 0!==t&&(e=0),0===e&&s(t)};n.forEach((t=>function(t,s,o){const n=Object.keys(t),e=n.length;void 0===U&&queueMicrotask(D),U??(U=new Map);let h=U.get(t);return void 0===h&&(h={callbacks:[],keyCount:e},U.set(t,h)),h.keyCount!==e&&(h.callbacks.forEach((t=>t(n))),h.callbacks=[],h.keyCount=e),h.callbacks.push((n=>{const h=n[e];i(s,null,void 0===h?void 0:t[h]===o?h:void 0)})),o}(t,(i=>h(void 0===i?void 0:{key:i,host:t,isReactive:!1})),o)));const r=n.find((t=>"manager"in t&&"object"==typeof t.manager&&t.manager.component===t));return r&&J(r,(t=>h(void 0===t?void 0:{key:t,host:r,isReactive:void 0!==u(r,t)})),o),o}function Q(t,i){const s=l();return J(s,(o=>{const n=o,e=s.manager,h=s,r=h[n];if(null!=r&&r!==t&&"function"==typeof i.set){const s=i.set(r,t,n);if(s!==r)if(e.isLit)h[n]=s;else{let t=!0;e.onConnected((()=>{t&&(t=!0,V((()=>{h[n]=s})))}))}}!function(t,i,s){var o,n;const e=s,h=t.manager.internals,r="function"==typeof e.get?e.get:void 0;r&&((o=h.getters)[i]??(o[i]=[]),h.getters[i].unshift(r));const c="ignore"===e.set?Y:e.set;c&&((n=h.setters)[i]??(n[i]=[]),h.setters[i].unshift(c))}(s,n,i)}),t)}function V(t){j.setter=!0;try{return t()}finally{j.setter=!1}}function X(t){j.getter=!0;try{return t()}finally{j.getter=!1}}var Y=(t,i)=>i;function Z(t){return Q(t,{set:l().manager.internals.readonlySetter})}var tt,it=t=>(...i)=>{const s=p,o=new t(...i),n=o.exports;v(s.at(-1));const e=o.component.manager.internals;var h;return e.markExports(o,n),o.watchExports((t=>e.markExports(o,t))),y!==(h=o)&&(y=h,queueMicrotask((()=>{y===h&&(y=void 0)}))),K([o.component,...s].reverse(),(t=>void 0===t?void 0:function(t,{host:i,key:s,isReactive:o},n){const e=i,h=e[s]!==n;e[s]!==t.exports&&!h&&n!==t.exports&&(e[s]=t.exports);if(i===t.component){if(o){const i=t.component.manager.internals;h&&i.markExports(t,e[s]),P(t.component,s,(s=>{s!==t.exports&&i.markExports(t,s)}))}t.assignedProperty=o?void 0:s}t.watchExports((()=>{if(e[s]===t.exports)return;const i=t.component.manager,o=i.internals.setters[s]?.includes(i.internals.readonlySetter);o?function(){j.readOnly=!0;try{return void(e[s]=t.exports)}finally{j.readOnly=!1}}():e[s]=t.exports}))}(o,t,n)),n)},st=Promise.all([e(),h()]),ot=class extends C{async hostLoad(){const[t,{subclass:i,property:s}]=await st;class o extends t{}const n=(t,i)=>a[i];function e(t,i,s){return void 0!==a&&(a[s]=t),t}const h=this.component,r=h.manager.internals,c=[];if(X((()=>Object.keys(r.members).forEach((t=>{r.accessorSetter[t]!==I||(c.push(t),r.accessorGetter[t]=n,r.accessorSetter[t]=e,s({value:h[t]})(o.prototype,t))})))),this._enabledMembers=c,0===c.length)return;const a=new(i(h.el.tagName)(o));this._instance=a}controllerRemoved(){super.controllerRemoved();const t=this.component.manager.internals;this._instance?.destroy(),this._enabledMembers?.forEach((i=>{t.accessorGetter[i]=I,t.accessorSetter[i]=I}))}},nt=t=>(i,s)=>ht(i,t,s),et=class extends x{constructor(t,i,s){super(t),this._loadAccessor=i,this._options=s,this._watchedProperties=new Map,this._isBinding={value:!0},this.setProvisionalExports(rt.makeGetterProxy(t,this._watchedProperties,this._isBinding,this.constructor.allowedPropNameMismatches));const o=t.manager.internals.reactiveUtilsIntegrations;o.add(this);const n=Array.from(o).find((t=>t instanceof ot));n&&o.delete(n),o.add(n??new ot(this.component)),J(t,(t=>{t&&(this._instancePropName=t)}),this.exports)}hostConnected(){this._isBinding.value=!1}async hostLoad(){this.reactiveUtils=await async function(){return tt??(tt=c()),await tt}();const t=this.component,i=this._gatherParameters(),s=this._options?.editConstructorProperties?.call(t,i)??i,o=s instanceof Promise?await s:s,n="string"==typeof this._instancePropName?t[this._instancePropName]:void 0;null!=n&&n!==this.exports?(this._instance=n,n.set(o)):this._instance=await this._createInstance(o),t.manager.destroyed||(rt.watchComponentUpdates(this,this._instance,this._watchedProperties),rt.watchAccessorUpdates(this,this._instance,this._watchedProperties),this.exports=this._instance)}_gatherParameters(){return Object.fromEntries(Array.from(this._watchedProperties,(([t,i])=>[i,this.component[t]])).filter((([,t])=>void 0!==t)))}async _createInstance(t){return this._isAccessorConstructor(this._loadAccessor)?new this._loadAccessor(t):await this._loadAccessor(t)}_isAccessorConstructor(t){return"prototype"in t&&"declaredClass"in t.prototype}hostDestroy(){this._instance&&this._instance.destroy()}async reCreate(){this.hostDestroy(),await this.hostLoad()}},ht=it(et),rt={makeGetterProxy:(t,i,s)=>new Proxy({},{has:(t,i)=>"string"==typeof i||i in t,get:(o,n)=>{const e=Reflect.get(o,n);return"symbol"==typeof n||n in Promise.prototype||n in o||!(s?.value??1)?e:K(t,(t=>{void 0!==t&&i.set(t.key,n)}),e)}}),watchComponentUpdates(t,i,s){function o(t,o){const n=s.get(o),e=i[n];return"boolean"==typeof e&&n!==o&&o.toLowerCase().includes("disable")?!e:e}const n=(t,o,n)=>{const e=s.get(n),h=i[e],r="boolean"==typeof h&&e!==n&&n.toLowerCase().includes("disable");if((r?!h:h)===t)return t;i[e]=r?!t:t;const c=i[e];return r?!c:c},e=t.component.manager.internals;s.forEach(((t,i)=>{e.accessorGetter[i]=o,e.accessorSetter[i]=n}))},watchAccessorUpdates(t,i,s){const{component:o}=t,n=o,e=i,h=function(t){const i=t,s=Object.entries(i.__accessor__?.metadata??{});return new Set(s.filter((([t,i])=>!0===i?.readOnly)).map((([t])=>t)))}(i);X((()=>s.forEach(((t,i)=>{if(h.has(t))return;const s=n[i],o=e[t],r="boolean"==typeof s&&t!==i&&i.toLowerCase().includes("disable")?!s:s;null!=r&&o!==r&&(e[t]=r)})))),t.onLifecycle((()=>{if(!i.destroyed)return Array.from(s,(([i,s])=>t.reactiveUtils.watch((()=>e[s]),(()=>{const t=e[s],o="boolean"==typeof t&&s!==i&&i.toLowerCase().includes("disable")?!t:t;V((()=>{n[i]=o}))}),{initial:!0})))}))},reEmitAccessorEvents(i,s,o,n){if(!("on"in s)||"function"!=typeof s.on)return;const e=Object.entries(i.component).map((([t,i])=>{const s=i;if(!t.startsWith(n)||t===n||"object"!=typeof s||null===s||!("emit"in s)||"function"!=typeof s.emit)return;const o=s.emit,e=t.slice(n.length);return[r(e).toLowerCase(),o]})).filter(t);if(0===e.length)return;const h=s,c=()=>h;i.onLifecycle((()=>{if(!s.destroyed)return e.map((([t,i])=>o.on(c,t,i)))}))},async reCreate(t,i){const s=i.manager.useRefSync(t);void 0!==s&&await s.reCreate()}};export{et as A,C,rt as a,Q as g,nt as m,it as p,Z as r,f as s,J as t,E as u,P as w}