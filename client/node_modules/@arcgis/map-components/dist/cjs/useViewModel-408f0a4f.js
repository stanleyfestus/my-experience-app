/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.0-next.58
 */
'use strict';

const index = require('./index-fbb18e12.js');
const index$1 = require('./index-80ecaa0e.js');
const index$2 = require('./index-bb8f4b21.js');
const componentUtils = require('./component-utils-b8b66725.js');

const useT9n = index.makeT9nController(index$1.getAssetPath);

/**
 * A controller for a mapping component that:
 * - loads the viewModel
 * - initializes the viewModel with the component's properties
 * - does two-way binding between view model and component properties
 * - re-emits the viewModel's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://qawebgis.esri.com/arcgis-components/?path=/docs/references-arcgis-lit-transition-from-widgets--docs#useviewmodel-controller
 */
const makeViewModelController = (loadViewModel, _options) => (component, options) => proxy(component, loadViewModel, options);
// REFACTOR: extract common logic into IntegrationController???
class ViewModelController extends index$2.AccessorController {
    hostConnected() {
        // If this is not the first connect, check if parent changed
        if (this.component.manager.loadedCalled) {
            componentUtils.attachToParent(this.component);
        }
    }
    async hostLoad() {
        await super.hostLoad();
        if (this.component.manager.destroyed) {
            return;
        }
        this._watchMetaProperties();
        index$2.accessorSupport.reEmitAccessorEvents(this, this._instance, this.reactiveUtils, "viewModel");
    }
    hostLoaded() {
        const { el } = this.component;
        const childNode = el.shadowRoot?.firstElementChild ?? el.firstElementChild ?? undefined;
        /*
         * On hot reloading, new this.component instance is created (so properties
         * on it are reset) but this.component.el instance is preserved (so
         * properties on it are preserved). Since childElem is re-parented on 1st
         * hostLoad(), for it to be accessible on the 2nd hostLoad() (hot reload),
         * we have to store it's reference on the el, rather than component
         */
        el.childElem = childNode ?? el.childElem;
        let arcgisReadyEmitted = false;
        // Check if view was already provided by the user
        const currentView = this.component.el.view;
        // Define the "view" property to allow component usage with MapView/SceneView
        Object.defineProperty(this.component.el, "view", {
            get: () => this._instance.view,
            set: (view) => {
                const oldView = this.component.el.view;
                const coreView = view;
                this._instance.view = coreView;
                this._instance.map = coreView?.map;
                this._watchViewDestroy();
                this.component.requestUpdate("view", oldView);
                // Only emit arcgisReady if view is not nullish
                if (view && !arcgisReadyEmitted) {
                    arcgisReadyEmitted = true;
                    this.component.arcgisReady.emit();
                }
            },
            configurable: true,
            enumerable: true,
        });
        if (currentView) {
            this._instance.view = currentView;
        }
        if (this.component.el.isConnected) {
            componentUtils.attachToParent(this.component);
            this._watchViewDestroy();
        }
    }
    hostDisconnected() {
        // If view is already destroyed, view.ui might be undefined
        if (typeof this.component.el.childElem === "object") {
            this.component.el.view?.ui?.remove(this.component.el.childElem);
        }
    }
    hostDestroy() {
        super.hostDestroy();
        this._watchViewDestroyHandle?.remove();
    }
    _watchMetaProperties() {
        index$2.watch(this.component, "position", (position) => {
            if (this.component.el.childElem != null && typeof position === "string") {
                componentUtils.attachToParent(this.component);
            }
        });
        index$2.watch(this.component, "referenceElement", () => componentUtils.attachToParent(this.component));
    }
    /**
     * Destroy the component if view gets destroyed. Note, that when view is
     * destroyed, component disconnect is triggered, which will destroy the
     * component in 1s but that can be too late, because in the meanwhile,
     * a watcher on the widget/viewModel instance may get triggered, and throw
     * an error if it's not able to access this.view.map or etc
     * (happens in VersionManagementViewModel for example).
     * We can't check for this in disconnectedCallback though as, if the entire
     * component tree is removed, the disconnect for the component will be
     * triggered before that of arcgis-map, so the view might not be destroyed
     * yet at that point.
     */
    _watchViewDestroy() {
        this._watchViewDestroyHandle?.remove();
        this._watchViewDestroyHandle = this.reactiveUtils.when(() => this.component.el.view?.destroyed === true, () => void this.component.destroy().catch(console.error), { sync: true });
    }
}
const proxy = index$2.proxyExports(ViewModelController);

exports.makeViewModelController = makeViewModelController;
exports.useT9n = useT9n;
