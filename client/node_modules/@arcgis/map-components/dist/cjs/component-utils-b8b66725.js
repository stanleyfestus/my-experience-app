/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.0-next.58
 */
'use strict';

//--------------------------------------------------------------------------
//
//  Public Methods
//
//--------------------------------------------------------------------------
/** @deprecated Use this.manager.onLifecycle() instead */
function addHandles(element, handle) {
    if (Array.isArray(handle)) {
        element._watchHandles = [...element._watchHandles, ...handle];
    }
    else {
        element._watchHandles.push(handle);
    }
}
/**
 * Find applicable arcgis-map, arcgis-scene, arcgis-expand or arcgis-placement
 * for the current component and attach to it
 *
 * @remarks
 * If the view property was set by the user directly (for backwards
 * comparability with MapView/SceneView), attachToParent() will return undefined
 * as attachToParent() is looking for component parents only.
 * If the view property was provided, the developer takes over the
 * responsibility of calling view.ui.add()
 */
function attachToParent(component) {
    if (component.el.childElem) {
        component.el.childElem.ownedBy = component.el;
    }
    const parent = findClosestParent(component);
    if (!parent) {
        const referenceElement = resolveReferenceElement(component.referenceElement);
        if (!referenceElement) {
            appendToContainer(component);
            return undefined;
        }
        attachToView(referenceElement, component, true);
        return referenceElement;
    }
    if (ignoreParentChange(parent, component.el.parent)) {
        return parent;
    }
    component.el.parent = parent;
    if (parent.tagName.toLowerCase() === "arcgis-expand") {
        attachToExpand(parent, component);
    }
    else if (parent.tagName.toLowerCase() === "arcgis-placement") {
        attachToPlacement(parent, component);
    }
    else {
        attachToView(parent, component, false);
    }
    return parent;
}
function findClosestParent({ el }) {
    for (let element = el.parentElement; element; element = element?.parentElement ?? null) {
        if (possibleParents.has(element.tagName.toLowerCase())) {
            return element;
        }
        /*
         * The expand's and placement's childElem will have an ownedBy property to
         * help findParent() detect if it belongs to expand, even after expand
         * moved it's childElem to be under view.ui's control
         */
        if ("ownedBy" in element &&
            element.ownedBy instanceof HTMLElement &&
            possibleParents.has(element.ownedBy.tagName.toLowerCase())) {
            return element.ownedBy;
        }
    }
    return undefined;
}
const possibleParents = new Set(["arcgis-map", "arcgis-scene", "arcgis-expand", "arcgis-placement"]);
/**
 * attachToParent() may be called redundantly (i.e when expand sets the
 * position prop on a component). Ignore the attachToParent() calls if the
 * parent is the same element, UNLESS the parent is a map/scene (as in that
 * case position change is meaningful)
 */
function ignoreParentChange(newParent, oldParent) {
    if (newParent !== oldParent) {
        return false;
    }
    const tagName = newParent.tagName.toLowerCase();
    return tagName === "arcgis-expand" || tagName === "arcgis-placement";
}
/** Call callback once component emits "arcgisReady" and has view property set */
function awaitReady(element, callback, eventName = "arcgisReady") {
    const maybeHasView = element;
    if (typeof maybeHasView.view?.ready === "boolean") {
        callback(maybeHasView.view);
    }
    else {
        element.addEventListener(eventName, (event) => (event.target === element ? awaitReady(element, callback, eventName) : undefined), { once: true });
    }
}
const attachToExpand = (expandRef, component) => awaitReady(expandRef, (view) => {
    if (component.el.childElem && typeof expandRef.content === "object") {
        expandRef.content?.append(component.el.childElem);
    }
    expandRef.expandIcon = component.icon || component.widget?.icon || expandRef.expandIcon;
    /**
     * Even though component-utils don't read the value of component's
     * position once component is in expand/placement, setting the position
     * here anyway is a good ideas as the component may use it's position
     * to inform rtl or styling.
     * FEATURE: when expand's/placement's position changes, update component too
     */
    component.position = expandRef.position;
    // Set the view property last since it will fire arcgisReady event
    component.el.view = view;
});
const attachToPlacement = (placementRef, component) => awaitReady(placementRef, (view) => {
    if (component.el.childElem) {
        component.el.append(component.el.childElem);
    }
    component.position = placementRef.position;
    // Set the view property last since it will fire arcgisReady event
    component.el.view = view;
});
const attachToView = (referenceElement, component, referenceElementProvided) => awaitReady(referenceElement, (view) => {
    /*
     * If referenceElement was provided, it means the component is outside the
     * view, thus we should not call addToViewUi()
     */
    if (referenceElementProvided) {
        appendToContainer(component);
    }
    else if (component.el.childElem) {
        addToViewUi(referenceElement, component);
    }
    // Set the view property last since it will fire arcgisReady event
    component.el.view = view;
}, "arcgisViewReadyChange");
function addToViewUi(referenceElement, component) {
    // REFACTOR: rename childElem to childElement
    const el = component.el.childElem ?? component.el;
    const childElements = [...referenceElement.children];
    const childrenPositions = {};
    /*
     * This logic is done for each component because if a component is dynamically
     * added, would need to redo anyway.
     */
    for (const child of childElements) {
        const position = child.getAttribute("position") ?? "manual";
        childrenPositions[position] ?? (childrenPositions[position] = []);
        childrenPositions[position].push({ child, position, index: childElements.indexOf(child) });
    }
    /*
     * If component.el is not actually inside of arcgis-map (has
     * referenceElement), index will be -1. In that case view.ui will simply add
     * it as last
     */
    const index = childrenPositions[component.position ?? "manual"]?.findIndex(({ child }) => child === component.el);
    // Remove it first in case it is already present
    referenceElement.view.ui.remove(el);
    referenceElement.view.ui.add(el, { position: component.position, index });
}
/**
 * Defines a view prop on the component's el and emits arcgisReady once that
 * prop is set by attachToParent()
 *
 * @deprecated Use useWidget or useViewModel instead
 */
function defineViewProperty(component) {
    let arcgisReadyEmitted = false;
    let view = component.el.view;
    const originalAccessor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(component.el), "view") ?? {
        get: () => view,
        set: (newView) => (view = newView),
    };
    // Define the "view" property for compatibility with JS API
    Object.defineProperty(component.el, "view", {
        get: originalAccessor.get.bind(component),
        set: (newView) => {
            originalAccessor.set.call(component, newView);
            if (newView && !arcgisReadyEmitted) {
                arcgisReadyEmitted = true;
                component.arcgisReady.emit();
            }
        },
        configurable: true,
        enumerable: true,
    });
    if (view) {
        component.el.view = view;
    }
}
function isNullOrEmptyString(value) {
    return value === undefined || value === null || value === "";
}
function isNotSameCamera(camera, camera2) {
    return (camera2 === undefined ||
        camera?.position !== camera2.position ||
        camera?.heading !== camera2.heading ||
        camera?.tilt !== camera2.tilt);
}
function isNotSameEnvironment(environment, environment2) {
    return (environment2 === undefined ||
        environment2?.atmosphereEnabled !== environment?.atmosphereEnabled ||
        (environment2?.lighting).date !== (environment?.lighting).date ||
        (environment2?.lighting).directShadowsEnabled !==
            (environment?.lighting).directShadowsEnabled ||
        (environment2?.lighting).cameraTrackingEnabled !==
            (environment?.lighting).cameraTrackingEnabled ||
        (environment2?.lighting).date !== (environment?.lighting).date ||
        (environment2?.lighting).displayUTCOffset !==
            (environment?.lighting).displayUTCOffset);
}
function isNotSameViewpoint(viewpoint, viewpoint2) {
    return (viewpoint2 === undefined ||
        viewpoint?.targetGeometry !== viewpoint2?.targetGeometry ||
        viewpoint?.rotation !== viewpoint2?.rotation ||
        viewpoint?.scale !== viewpoint2?.scale);
}
function parseCenter(newValue, view) {
    if (typeof newValue === "string") {
        const center = newValue.split(",").map(Number);
        if (center[0] !== view?.center.longitude && center[1] !== view?.center.latitude) {
            return center;
        }
    }
    else if (Array.isArray(newValue)) {
        if (newValue[0] !== view?.center.longitude && newValue[1] !== view?.center.latitude) {
            return newValue;
        }
    }
    else if (newValue && !view?.center.equals(newValue)) {
        return newValue;
    }
    return undefined;
}
/** @deprecated Use useWidget or useViewModel instead */
async function referenceElementHelper(component, refElement) {
    if (refElement == null) {
        return;
    }
    else if (typeof refElement === "string") {
        component.el.view = await updateForView(refElement);
    }
    else if (component.widget) {
        component.el.view = refElement.view;
    }
}
/** @deprecated Use useWidget or useViewModel instead */
async function updateForView(referenceElement) {
    const viewRef = resolveReferenceElement(referenceElement);
    return await new Promise((resolve) => {
        if (typeof viewRef?.view?.ready === "boolean") {
            resolve(viewRef.view);
        }
        else if (viewRef) {
            viewRef.addEventListener("arcgisViewReadyChange", () => resolve(viewRef.view), { once: true });
        }
    });
}
//--------------------------------------------------------------------------
//
//  Private Methods
//
//--------------------------------------------------------------------------
function appendToContainer(component) {
    /**
     * Most of the time, this will do nothing as childElem is initially
     * already inside of el. However, if component was inside the map before
     * and now was moved outside the map, this code will correctly re-attach
     * childElem to el.
     */
    if (component.el.childElem) {
        const container = component.el.shadowRoot ?? component.el;
        container.append(component.el.childElem);
    }
}
function resolveReferenceElement(referenceElement) {
    if (typeof referenceElement !== "string") {
        return referenceElement ?? undefined;
    }
    const isComplexSelector = referenceElement.includes("#") || referenceElement.includes(".") || referenceElement.includes("[");
    const resolved = (isComplexSelector ? undefined : document.querySelector(`#${referenceElement}`)) ??
        document.querySelector(referenceElement);
    return resolved ?? undefined;
}

exports.addHandles = addHandles;
exports.attachToParent = attachToParent;
exports.defineViewProperty = defineViewProperty;
exports.isNotSameCamera = isNotSameCamera;
exports.isNotSameEnvironment = isNotSameEnvironment;
exports.isNotSameViewpoint = isNotSameViewpoint;
exports.isNullOrEmptyString = isNullOrEmptyString;
exports.parseCenter = parseCenter;
exports.referenceElementHelper = referenceElementHelper;
