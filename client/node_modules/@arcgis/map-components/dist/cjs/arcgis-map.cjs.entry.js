/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.0-next.58
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-80ecaa0e.js');
const index$2 = require('./index-fbb18e12.js');
const index$1 = require('./index-bb8f4b21.js');
const index$3 = require('./index-87ff723d.js');
const componentUtils = require('./component-utils-b8b66725.js');

const mapCss = ".arcgis-map{padding:0;margin:0;height:100%;width:100%}";
const ArcgisMapStyle0 = mapCss;

const useWebMap = index$1.makeAccessorController(index$3.newWebMap);
const useMapView = index$1.makeAccessorController(index$3.newViewsMapView);
const ArcgisMap = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisViewReadyChange = index.createEvent(this, "arcgisViewReadyChange", 7);
        this.arcgisViewChange = index.createEvent(this, "arcgisViewChange", 7);
        this.arcgisViewClick = index.createEvent(this, "arcgisViewClick", 7);
        this.arcgisViewDoubleClick = index.createEvent(this, "arcgisViewDoubleClick", 7);
        this.arcgisViewDrag = index.createEvent(this, "arcgisViewDrag", 7);
        this.arcgisViewHold = index.createEvent(this, "arcgisViewHold", 7);
        this.arcgisViewImmediateClick = index.createEvent(this, "arcgisViewImmediateClick", 7);
        this.arcgisViewImmediateDoubleClick = index.createEvent(this, "arcgisViewImmediateDoubleClick", 7);
        this.arcgisViewKeyDown = index.createEvent(this, "arcgisViewKeyDown", 7);
        this.arcgisViewKeyUp = index.createEvent(this, "arcgisViewKeyUp", 7);
        this.arcgisViewLayerviewCreate = index.createEvent(this, "arcgisViewLayerviewCreate", 7);
        this.arcgisViewLayerviewCreateError = index.createEvent(this, "arcgisViewLayerviewCreateError", 7);
        this.arcgisViewLayerviewDestroy = index.createEvent(this, "arcgisViewLayerviewDestroy", 7);
        this.arcgisViewMouseWheel = index.createEvent(this, "arcgisViewMouseWheel", 7);
        this.arcgisViewPointerDown = index.createEvent(this, "arcgisViewPointerDown", 7);
        this.arcgisViewPointerEnter = index.createEvent(this, "arcgisViewPointerEnter", 7);
        this.arcgisViewPointerLeave = index.createEvent(this, "arcgisViewPointerLeave", 7);
        this.arcgisViewPointerMove = index.createEvent(this, "arcgisViewPointerMove", 7);
        this.arcgisViewPointerUp = index.createEvent(this, "arcgisViewPointerUp", 7);
        this.manager = index$1.useControllerManager(this);
        this.reactiveUtils = index$2.load(index$3.importCoreReactiveUtils);
        /**
         * This WebMap will be created only if user did not provide a map. Otherwise,
         * it will be equal to this.view.map
         */
        this._map = useWebMap(this, { editConstructorProperties: this._editMapProperties });
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this._setChildElement = (el) => {
            this.el.childElem = el;
        };
        this.autoDestroyDisabled = false;
        this.view = index$1.readonly(useMapView(this, { editConstructorProperties: this._editViewProperties }));
        this.map = this.view.map;
        this.allLayerViews = this.view.allLayerViews;
        this.background = this.view.background;
        this.basemapView = this.view.basemapView;
        this.basemap = this._map.basemap;
        this.center = index$1.getSet(undefined, {
            get: (value) => this.view.center ?? value,
            set: (newValue) => {
                const parsed = componentUtils.parseCenter(newValue, this.ready ? this.view : undefined);
                if (!this.ready) {
                    return parsed;
                }
                this.view.center = parsed;
                return this.view.center;
            },
        });
        this.constraints = this.view.constraints;
        this.extent = index$1.getSet(undefined, {
            get: (extent) => this.view.extent ?? extent,
            set: (newValue, oldValue) => {
                if (!this.view.ready) {
                    return newValue;
                }
                if (newValue && !oldValue?.equals(newValue)) {
                    this.view.extent = newValue;
                }
                return this.view.extent;
            },
        });
        this.fatalError = this.view.fatalError;
        this.floors = this.view.floors;
        this.gamepad = index$1.getSet(undefined, {
            get: () => (this.ready ? this.view.input.gamepad : undefined),
            set: "ignore",
        });
        this.graphics = this.view.graphics;
        this.ground = this._map.ground;
        this.interacting = index$1.getSet(false, {
            get: () => this.view.interacting,
            set: "ignore",
        });
        this.itemId = index$1.getSet(undefined, {
            get: (value) => this._map.portalItem?.id ?? value,
            set: (newValue) => {
                // MapView does not react to WebMap.portalItem change, so we have to recreate it
                if (this.ready) {
                    index$1.accessorSupport
                        .reCreate(this._map, this)
                        .then(() => {
                        this.view.map = this._map;
                    })
                        .catch(console.error);
                }
                return newValue;
            },
        });
        this.layerViews = this.view.layerViews;
        this.magnifier = this.view.magnifier;
        this.navigating = index$1.getSet(false, {
            get: () => this.view.navigating,
            set: "ignore",
        });
        this.navigation = this.view.navigation;
        this.padding = this.view.padding;
        this.popup = this.view.popup;
        this.popupDisabled = this.view.popupEnabled;
        this.ready = this.view.ready;
        this.resizeAlign = this.view.resizeAlign;
        this.resolution = this.view.resolution;
        this.rotation = this.view.rotation;
        this.scale = index$1.getSet(undefined, {
            get: (scale) => this.view.scale ?? scale,
            set: (newValue) => {
                if (this.ready) {
                    this.view.scale = newValue;
                }
                return newValue;
            },
        });
        this.spatialReference = index$1.getSet(this.view.spatialReference, {
            set: (newValue, oldValue) => (oldValue?.equals(newValue) ? oldValue : newValue),
        });
        this.stationary = index$1.getSet(true, {
            get: () => this.view.stationary,
            set: "ignore",
        });
        this.suspended = this.view.suspended;
        this.theme = this.view.theme;
        this.timeExtent = this.view.timeExtent;
        this.timeZone = this.view.timeZone;
        this.toMap = index$1.readonly((...args) => this.view.toMap(...args));
        this.toScreen = index$1.readonly((...args) => this.view.toScreen(...args));
        this.updating = this.view.updating;
        this.viewpoint = index$1.getSet(undefined, {
            get: () => this.view.viewpoint,
            set: (newValue, oldValue) => (componentUtils.isNotSameViewpoint(oldValue, newValue) ? newValue : oldValue),
        });
        this.zoom = index$1.getSet(undefined, {
            get: (zoom) => this.view.zoom ?? zoom,
            set: (newValue) => {
                if (this.ready) {
                    this.view.zoom = newValue;
                }
                return newValue;
            },
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Adds a layer to the map layers collection.
     */
    async addLayer(layer, index) {
        this.map?.add(layer, index);
    }
    /**
     * Adds a layer or array of layers to the map layers collection.
     */
    async addLayers(layers, index) {
        this.map?.addMany(layers, index);
    }
    /**
     * Closes the popup.
     */
    async closePopup() {
        this.view?.closePopup();
    }
    /**
     * Destroys the view, and any associated resources, including its map, popup, and UI elements.
     */
    async destroy() {
        await this.manager.destroy();
    }
    /**
     * Sets the view to a given target.
     */
    async goTo(target, options) {
        return (await this.view?.goTo(target, options));
    }
    /**
     * Returns hit test results from each layer that intersects the specified screen coordinates.
     */
    async hitTest(screenPoint, options) {
        return await this.view?.hitTest(screenPoint, options);
    }
    /**
     * Opens the popup at the given location with content defined either explicitly with content or driven
     * from the PopupTemplate of input features.
     */
    async openPopup(options) {
        await this.view?.openPopup(options);
    }
    /**
     * Create a screenshot of the current view.
     */
    async takeScreenshot(options) {
        return await this.view?.takeScreenshot(options);
    }
    /**
     * Call this method to clear any fatal errors resulting from a lost WebGL context.
     */
    async tryFatalErrorRecovery() {
        this.view?.tryFatalErrorRecovery();
    }
    /**
     * Gets the LayerView created on the view for the given layer.
     */
    async whenLayerView(layer) {
        return await this.view?.whenLayerView(layer);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentDidLoad() {
        var _a;
        (_a = this.view).container ?? (_a.container = this.el.childElem);
        const { watch } = this.reactiveUtils;
        this.manager.onLifecycle(() => [
            watch(() => this.view.stationary, () => {
                this.arcgisViewChange.emit();
            }, { initial: true }),
            watch(() => this.view.ready, () => this.arcgisViewReadyChange.emit(), { initial: this.view.ready }),
        ]);
        index$1.accessorSupport.reEmitAccessorEvents(this.manager, this.view, this.reactiveUtils, "arcgisView");
    }
    render() {
        return index.h("div", { key: 'a1234ec352a45db78f83d92985c3bd30ed3ffa16', class: "arcgis-map", ref: this._setChildElement });
    }
    _editMapProperties(mapProperties) {
        // If user provided a map, use that. Otherwise, a WebMap will be created by useWebMap
        if (this.map) {
            this._map = this.map;
        }
        if (this.itemId) {
            mapProperties.portalItem = { id: this.itemId };
        }
        else if (!this.basemap) {
            mapProperties.basemap = "topo-vector";
        }
        // See https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/1244#issuecomment-4922799
        const { basemap, ...rest } = mapProperties;
        if (!basemap) {
            mapProperties = rest;
        }
        const { ground, ...rest2 } = mapProperties;
        if (!ground) {
            mapProperties = rest2;
        }
        return mapProperties;
    }
    _editViewProperties(properties) {
        // Don't overwrite UI if a custom one was already provided
        if (!this.view.ui) {
            properties.ui = {
                components: ["attribution"],
            };
        }
        // If user did not provide a map, use the WebMap we created
        properties.map ?? (properties.map = this._map);
        /*
         * The following properties are not two-way bound like others as they change
         * too often. Instead, they are assigned to getters to always get freshest
         * value without triggering re-render. But that means, useAccessor is not
         * aware of these properties, so we have to pass them manually here:
         */
        const center = componentUtils.parseCenter(this.center, undefined);
        if (center) {
            properties.center = center;
        }
        if (this.viewpoint) {
            properties.viewpoint = this.viewpoint;
        }
        if (this.scale !== undefined) {
            properties.scale = this.scale;
        }
        if (this.extent) {
            properties.extent = this.extent;
        }
        if (this.zoom !== undefined) {
            properties.zoom = this.zoom;
        }
        return properties;
    }
    get el() { return index.getElement(this); }
};
ArcgisMap.style = ArcgisMapStyle0;

exports.arcgis_map = ArcgisMap;
